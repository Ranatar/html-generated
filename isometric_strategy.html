<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ò–∑–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è –°—Ç—Ä–∞—Ç–µ–≥–∏—è</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0e1a;
            font-family: 'JetBrains Mono', monospace;
            color: #00ff41;
            overflow: hidden;
            height: 100vh;
        }
        
        #game-container {
            display: flex;
            height: 100vh;
        }
        
        #canvas-area {
            flex: 1;
            position: relative;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1e2a 100%);
        }
        
        #game-canvas {
            display: block;
            image-rendering: pixelated;
            cursor: crosshair;
        }
        
        #ui-panel {
            width: 320px;
            background: rgba(10, 14, 26, 0.95);
            border-left: 2px solid #00ff41;
            padding: 20px;
            overflow-y: auto;
            box-shadow: -10px 0 30px rgba(0, 255, 65, 0.1);
        }
        
        .panel-section {
            margin-bottom: 20px;
            border: 1px solid #00ff41;
            padding: 15px;
            background: rgba(0, 255, 65, 0.03);
        }
        
        .panel-title {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #00ff41;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }
        
        .resource-display {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
            color: #7fff7f;
        }
        
        .resource-label {
            color: #00ff41;
        }
        
        .unit-info {
            padding: 10px;
            background: rgba(0, 255, 65, 0.05);
            border-left: 3px solid #00ff41;
            margin: 10px 0;
        }
        
        .unit-name {
            font-weight: bold;
            color: #00ff41;
            margin-bottom: 5px;
        }
        
        .unit-stats {
            font-size: 12px;
            color: #7fff7f;
            line-height: 1.6;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        button {
            background: rgba(0, 255, 65, 0.1);
            border: 2px solid #00ff41;
            color: #00ff41;
            padding: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }
        
        button:hover:not(:disabled) {
            background: rgba(0, 255, 65, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.4);
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .build-menu {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .build-btn {
            padding: 8px;
            font-size: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .build-icon {
            font-size: 20px;
        }
        
        .build-cost {
            font-size: 9px;
            color: #7fff7f;
        }
        
        #minimap {
            width: 100%;
            height: 200px;
            border: 2px solid #00ff41;
            margin-top: 15px;
            background: #000;
            image-rendering: pixelated;
        }
        
        .race-indicator {
            display: inline-block;
            padding: 3px 8px;
            background: rgba(0, 255, 65, 0.2);
            border-radius: 3px;
            font-size: 11px;
            margin-left: 10px;
        }
        
        .health-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 0, 0, 0.3);
            border: 1px solid #00ff41;
            margin: 5px 0;
            position: relative;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #00ff00);
            transition: width 0.3s;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .selected-indicator {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="canvas-area">
            <canvas id="game-canvas"></canvas>
        </div>
        <div id="ui-panel">
            <div class="panel-section">
                <div class="panel-title">üó∫ Terrain Info</div>
                <div id="terrain-info">
                    <p style="color: #7fff7f; font-size: 12px;">–ù–∞–≤–µ–¥–∏—Ç–µ –Ω–∞ –∫–ª–µ—Ç–∫—É</p>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">‚öî Resources</div>
                <div class="resource-display">
                    <span class="resource-label">ü™ô Gold:</span>
                    <span id="gold-amount">500</span>
                </div>
                <div class="resource-display">
                    <span class="resource-label">üå≤ Wood:</span>
                    <span id="wood-amount">300</span>
                </div>
                <div class="resource-display">
                    <span class="resource-label">üë• Supply:</span>
                    <span id="supply-amount">0/50</span>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üìã Selection</div>
                <div id="selection-info">
                    <p style="color: #7fff7f; font-size: 12px;">–í—ã–±–µ—Ä–∏—Ç–µ —é–Ω–∏—Ç –∏–ª–∏ –∑–¥–∞–Ω–∏–µ</p>
                </div>
            </div>
            
            <div class="panel-section" id="actions-panel" style="display: none;">
                <div class="panel-title">‚ö° Actions</div>
                <div id="action-buttons-container"></div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üèó Build</div>
                <div class="build-menu" id="build-menu">
                    <!-- –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ –∏–∑ JS -->
                </div>
            </div>
            
            <canvas id="minimap"></canvas>
            
            <div class="panel-section" style="margin-top: 15px; font-size: 10px; color: #7fff7f; line-height: 1.6;">
                <div class="panel-title" style="font-size: 9px;">‚å® Controls</div>
                <div style="margin: 5px 0;"><strong>–õ–ö–ú</strong> - –í—ã–±–æ—Ä</div>
                <div style="margin: 5px 0;"><strong>–ü–ö–ú</strong> - –ü—Ä–∏–∫–∞–∑/–ê—Ç–∞–∫–∞</div>
                <div style="margin: 5px 0;"><strong>–ö–æ–ª–µ—Å–æ</strong> - –î–≤–∏–∂–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã</div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // –ö–û–ù–°–¢–ê–ù–¢–´ –ò –ù–ê–°–¢–†–û–ô–ö–ò
        // ============================================================================
        
        const TILE_WIDTH = 64;
        const TILE_HEIGHT = 32;
        const MAP_WIDTH = 30;
        const MAP_HEIGHT = 30;
        
        const RACES = {
            HUMAN: 'human',
            ORC: 'orc'
        };
        
        const UNIT_TYPES = {
            // ===== –õ–Æ–î–ò =====
            // –†–∞–±–æ—á–∏–µ –∏ –±–∞–∑–æ–≤—ã–µ —é–Ω–∏—Ç—ã
            PEASANT: {
                name: '–ö—Ä–µ—Å—Ç—å—è–Ω–∏–Ω',
                icon: 'üë§',
                race: RACES.HUMAN,
                hp: 50,
                damage: 5,
                range: 1,
                speed: 2,
                cost: { gold: 50, wood: 0 },
                supply: 1,
                canBuild: true,
                canGather: true,
                carryCapacity: 10,
                trainTime: 5000
            },
            FOOTMAN: {
                name: '–í–æ–∏–Ω',
                icon: '‚öî',
                race: RACES.HUMAN,
                hp: 100,
                damage: 15,
                range: 1,
                speed: 3,
                cost: { gold: 100, wood: 20 },
                supply: 2,
                trainTime: 8000
            },
            ARCHER: {
                name: '–õ—É—á–Ω–∏–∫',
                icon: 'üèπ',
                race: RACES.HUMAN,
                hp: 60,
                damage: 12,
                range: 5,
                speed: 3,
                cost: { gold: 90, wood: 30 },
                supply: 2,
                trainTime: 10000
            },
            
            // –≠–ª–∏—Ç–Ω—ã–µ —é–Ω–∏—Ç—ã
            KNIGHT: {
                name: '–†—ã—Ü–∞—Ä—å',
                icon: 'üê¥',
                race: RACES.HUMAN,
                hp: 150,
                damage: 25,
                range: 1,
                speed: 5,
                cost: { gold: 200, wood: 50 },
                supply: 3,
                trainTime: 12000,
                ability: {
                    name: '–†—ã–≤–æ–∫',
                    icon: 'üí®',
                    cooldown: 10000,
                    range: 0,
                    effect: 'speed_boost',
                    value: 3,
                    duration: 5000
                }
            },
            CROSSBOWMAN: {
                name: '–ê—Ä–±–∞–ª–µ—Ç—á–∏–∫',
                icon: 'üéØ',
                race: RACES.HUMAN,
                hp: 70,
                damage: 20,
                range: 6,
                speed: 2.5,
                cost: { gold: 130, wood: 60 },
                supply: 2,
                trainTime: 11000
            },
            
            // –ú–∞–≥–∏—á–µ—Å–∫–∏–µ —é–Ω–∏—Ç—ã
            MAGE: {
                name: '–ú–∞–≥',
                icon: 'üßô',
                race: RACES.HUMAN,
                hp: 70,
                damage: 20,
                range: 4,
                speed: 2,
                cost: { gold: 150, wood: 50 },
                supply: 3,
                ability: {
                    name: '–û–≥–Ω–µ–Ω–Ω—ã–π —à–∞—Ä',
                    icon: 'üî•',
                    cooldown: 5000,
                    range: 5,
                    effect: 'damage',
                    value: 50
                },
                trainTime: 15000
            },
            PRIEST: {
                name: '–ñ—Ä–µ—Ü',
                icon: '‚õ™',
                race: RACES.HUMAN,
                hp: 60,
                damage: 8,
                range: 4,
                speed: 2,
                cost: { gold: 140, wood: 40 },
                supply: 2,
                ability: {
                    name: '–ú–∞—Å—Å–æ–≤–æ–µ –∏—Å—Ü–µ–ª–µ–Ω–∏–µ',
                    icon: '‚ú®',
                    cooldown: 12000,
                    range: 4,
                    effect: 'mass_heal',
                    value: 30
                },
                trainTime: 14000
            },
            ARCHMAGE: {
                name: '–ê—Ä—Ö–∏–º–∞–≥',
                icon: 'üßù',
                race: RACES.HUMAN,
                hp: 90,
                damage: 35,
                range: 5,
                speed: 2,
                cost: { gold: 300, wood: 100 },
                supply: 4,
                ability: {
                    name: '–ú–µ—Ç–µ–æ—Ä',
                    icon: '‚òÑ',
                    cooldown: 20000,
                    range: 6,
                    effect: 'aoe_damage',
                    value: 80,
                    radius: 2
                },
                trainTime: 25000
            },
            
            // –û—Å–∞–¥–Ω—ã–µ –æ—Ä—É–¥–∏—è
            CATAPULT: {
                name: '–ö–∞—Ç–∞–ø—É–ª—å—Ç–∞',
                icon: 'üé™',
                race: RACES.HUMAN,
                hp: 80,
                damage: 50,
                range: 7,
                speed: 1,
                cost: { gold: 250, wood: 100 },
                supply: 4,
                trainTime: 18000
            },
            
            // –õ–µ—Ç–∞—é—â–∏–µ —é–Ω–∏—Ç—ã
            GRIFFIN: {
                name: '–ì—Ä–∏—Ñ–æ–Ω',
                icon: 'ü¶Ö',
                race: RACES.HUMAN,
                hp: 120,
                damage: 22,
                range: 1,
                speed: 6,
                cost: { gold: 220, wood: 80 },
                supply: 3,
                trainTime: 16000,
                flying: true
            },
            
            // –ì–µ—Ä–æ–∏
            PALADIN: {
                name: '–ü–∞–ª–∞–¥–∏–Ω',
                icon: 'üëº',
                race: RACES.HUMAN,
                hp: 250,
                damage: 40,
                range: 1,
                speed: 3.5,
                cost: { gold: 500, wood: 150 },
                supply: 5,
                ability: {
                    name: '–ë–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —â–∏—Ç',
                    icon: 'üõ°',
                    cooldown: 30000,
                    range: 0,
                    effect: 'invulnerable',
                    value: 1,
                    duration: 3000
                },
                trainTime: 30000,
                hero: true
            },
            
            // ===== –û–†–ö–ò =====
            // –†–∞–±–æ—á–∏–µ –∏ –±–∞–∑–æ–≤—ã–µ —é–Ω–∏—Ç—ã
            PEON: {
                name: '–ü–µ–æ–Ω',
                icon: 'üßü',
                race: RACES.ORC,
                hp: 60,
                damage: 7,
                range: 1,
                speed: 2,
                cost: { gold: 50, wood: 0 },
                supply: 1,
                canBuild: true,
                canGather: true,
                carryCapacity: 10,
                trainTime: 5000
            },
            GRUNT: {
                name: 'Grunt',
                icon: '‚öî',
                race: RACES.ORC,
                hp: 120,
                damage: 18,
                range: 1,
                speed: 3,
                cost: { gold: 100, wood: 20 },
                supply: 2,
                trainTime: 8000
            },
            RAIDER: {
                name: '–†–µ–π–¥–µ—Ä',
                icon: 'ü™ì',
                race: RACES.ORC,
                hp: 80,
                damage: 16,
                range: 1,
                speed: 4,
                cost: { gold: 110, wood: 30 },
                supply: 2,
                trainTime: 10000
            },
            HEADHUNTER: {
                name: '–û—Ö–æ—Ç–Ω–∏–∫ –∑–∞ –≥–æ–ª–æ–≤–∞–º–∏',
                icon: 'üó°',
                race: RACES.ORC,
                hp: 65,
                damage: 14,
                range: 5,
                speed: 3,
                cost: { gold: 95, wood: 35 },
                supply: 2,
                trainTime: 10000
            },
            
            // –≠–ª–∏—Ç–Ω—ã–µ —é–Ω–∏—Ç—ã
            TAUREN: {
                name: '–¢–∞—É—Ä–µ–Ω',
                icon: 'üêÇ',
                race: RACES.ORC,
                hp: 200,
                damage: 30,
                range: 1,
                speed: 2.5,
                cost: { gold: 220, wood: 80 },
                supply: 4,
                ability: {
                    name: '–¢–æ–ø–æ—Ç',
                    icon: 'üí•',
                    cooldown: 15000,
                    range: 2,
                    effect: 'stun',
                    value: 2000
                },
                trainTime: 16000
            },
            BERSERKER: {
                name: '–ë–µ—Ä—Å–µ—Ä–∫',
                icon: 'üò°',
                race: RACES.ORC,
                hp: 110,
                damage: 35,
                range: 1,
                speed: 4,
                cost: { gold: 180, wood: 60 },
                supply: 3,
                ability: {
                    name: '–Ø—Ä–æ—Å—Ç—å',
                    icon: 'üî¥',
                    cooldown: 20000,
                    range: 0,
                    effect: 'damage_boost',
                    value: 20,
                    duration: 8000
                },
                trainTime: 14000
            },
            
            // –ú–∞–≥–∏—á–µ—Å–∫–∏–µ —é–Ω–∏—Ç—ã
            SHAMAN: {
                name: '–®–∞–º–∞–Ω',
                icon: 'üîÆ',
                race: RACES.ORC,
                hp: 65,
                damage: 18,
                range: 4,
                speed: 2,
                cost: { gold: 150, wood: 50 },
                supply: 3,
                ability: {
                    name: '–ò—Å—Ü–µ–ª–µ–Ω–∏–µ',
                    icon: 'üíö',
                    cooldown: 8000,
                    range: 3,
                    effect: 'heal',
                    value: 40
                },
                trainTime: 15000
            },
            WITCH_DOCTOR: {
                name: '–ó–Ω–∞—Ö–∞—Ä—å',
                icon: 'üßô‚Äç‚ôÇÔ∏è',
                race: RACES.ORC,
                hp: 70,
                damage: 22,
                range: 4,
                speed: 2,
                cost: { gold: 160, wood: 70 },
                supply: 3,
                ability: {
                    name: '–ü—Ä–æ–∫–ª—è—Ç–∏–µ',
                    icon: '‚ò†',
                    cooldown: 10000,
                    range: 5,
                    effect: 'weaken',
                    value: 10,
                    duration: 10000
                },
                trainTime: 16000
            },
            WARLOCK: {
                name: '–ß–µ—Ä–Ω–æ–∫–Ω–∏–∂–Ω–∏–∫',
                icon: 'üëπ',
                race: RACES.ORC,
                hp: 85,
                damage: 30,
                range: 5,
                speed: 2,
                cost: { gold: 280, wood: 90 },
                supply: 4,
                ability: {
                    name: '–ü—Ä–∏–∑—ã–≤ –¥–µ–º–æ–Ω–∞',
                    icon: 'üëø',
                    cooldown: 25000,
                    range: 3,
                    effect: 'summon',
                    value: 1
                },
                trainTime: 22000
            },
            
            // –û—Å–∞–¥–Ω—ã–µ –æ—Ä—É–¥–∏—è
            DEMOLISHER: {
                name: '–†–∞–∑—Ä—É—à–∏—Ç–µ–ª—å',
                icon: 'üé°',
                race: RACES.ORC,
                hp: 90,
                damage: 55,
                range: 7,
                speed: 1.5,
                cost: { gold: 260, wood: 110 },
                supply: 4,
                trainTime: 18000
            },
            
            // –õ–µ—Ç–∞—é—â–∏–µ —é–Ω–∏—Ç—ã
            WYVERN: {
                name: '–í–∏–≤–µ—Ä–Ω–∞',
                icon: 'üêâ',
                race: RACES.ORC,
                hp: 130,
                damage: 24,
                range: 1,
                speed: 6,
                cost: { gold: 230, wood: 90 },
                supply: 3,
                ability: {
                    name: '–Ø–¥–æ–≤–∏—Ç–æ–µ –¥—ã—Ö–∞–Ω–∏–µ',
                    icon: 'üü¢',
                    cooldown: 12000,
                    range: 4,
                    effect: 'poison',
                    value: 5,
                    duration: 10000
                },
                trainTime: 17000,
                flying: true
            },
            
            // –ì–µ—Ä–æ–∏
            BLADEMASTER: {
                name: '–ú–∞—Å—Ç–µ—Ä –∫–ª–∏–Ω–∫–∞',
                icon: '‚ö°',
                race: RACES.ORC,
                hp: 230,
                damage: 45,
                range: 1,
                speed: 4.5,
                cost: { gold: 500, wood: 150 },
                supply: 5,
                ability: {
                    name: '–ó–µ—Ä–∫–∞–ª—å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ',
                    icon: 'üë•',
                    cooldown: 30000,
                    range: 0,
                    effect: 'mirror_image',
                    value: 2
                },
                trainTime: 30000,
                hero: true
            }
        };
        
        const BUILDING_TYPES = {
            // ===== –õ–Æ–î–ò =====
            TOWN_HALL: {
                name: '–†–∞—Ç—É—à–∞',
                icon: '‚õ™',
                race: RACES.HUMAN,
                hp: 500,
                width: 3,
                height: 3,
                cost: { gold: 0, wood: 0 },
                trains: ['PEASANT'],
                provides: 10,
                buildTime: 0,
                researches: [
                    { name: '–£—Å–∏–ª–µ–Ω–Ω–∞—è –¥–æ–±—ã—á–∞', icon: '‚õè', cost: { gold: 100, wood: 50 }, effect: 'carry_capacity', value: 5, time: 12000 }
                ]
            },
            FARM: {
                name: '–§–µ—Ä–º–∞',
                icon: 'üè†',
                race: RACES.HUMAN,
                hp: 150,
                width: 2,
                height: 2,
                cost: { gold: 80, wood: 20 },
                provides: 5,
                buildTime: 10000
            },
            BARRACKS: {
                name: '–ö–∞–∑–∞—Ä–º–∞',
                icon: '‚öí',
                race: RACES.HUMAN,
                hp: 300,
                width: 2,
                height: 2,
                cost: { gold: 150, wood: 50 },
                trains: ['FOOTMAN', 'ARCHER', 'CROSSBOWMAN'],
                researches: [
                    { name: '–£–ª—É—á—à–µ–Ω–∏–µ –æ—Ä—É–∂–∏—è I', icon: '‚öî', cost: { gold: 100, wood: 50 }, effect: 'damage', value: 2, time: 15000 },
                    { name: '–£–ª—É—á—à–µ–Ω–∏–µ –±—Ä–æ–Ω–∏ I', icon: 'üõ°', cost: { gold: 150, wood: 50 }, effect: 'armor', value: 1, time: 20000 },
                    { name: '–°—Ç—Ä–æ–µ–≤–∞—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞', icon: 'üéØ', cost: { gold: 120, wood: 60 }, effect: 'range', value: 1, time: 18000 }
                ],
                buildTime: 15000
            },
            BLACKSMITH: {
                name: '–ö—É–∑–Ω–∏—Ü–∞',
                icon: 'üî®',
                race: RACES.HUMAN,
                hp: 250,
                width: 2,
                height: 2,
                cost: { gold: 120, wood: 60 },
                researches: [
                    { name: '–£–ª—É—á—à–µ–Ω–∏–µ –æ—Ä—É–∂–∏—è II', icon: '‚öî', cost: { gold: 200, wood: 100 }, effect: 'damage', value: 3, time: 25000 },
                    { name: '–£–ª—É—á—à–µ–Ω–∏–µ –±—Ä–æ–Ω–∏ II', icon: 'üõ°', cost: { gold: 250, wood: 100 }, effect: 'armor', value: 2, time: 30000 },
                    { name: '–°—Ç–∞–ª—å–Ω–æ–µ –æ—Ä—É–∂–∏–µ', icon: 'üó°', cost: { gold: 300, wood: 150 }, effect: 'damage', value: 5, time: 40000 }
                ],
                buildTime: 18000
            },
            STABLES: {
                name: '–ö–æ–Ω—é—à–Ω—è',
                icon: 'üèá',
                race: RACES.HUMAN,
                hp: 280,
                width: 2,
                height: 2,
                cost: { gold: 180, wood: 70 },
                trains: ['KNIGHT'],
                researches: [
                    { name: '–†–∞–∑–≤–µ–¥–µ–Ω–∏–µ –∫–æ–Ω–µ–π', icon: 'üêé', cost: { gold: 150, wood: 80 }, effect: 'speed', value: 1, time: 20000 }
                ],
                buildTime: 20000
            },
            ARCANE_TOWER: {
                name: '–ë–∞—à–Ω—è –ú–∞–≥–æ–≤',
                icon: 'üóº',
                race: RACES.HUMAN,
                hp: 250,
                width: 2,
                height: 2,
                cost: { gold: 200, wood: 80 },
                trains: ['MAGE', 'PRIEST', 'ARCHMAGE'],
                researches: [
                    { name: '–ú–∏—Å—Ç–∏—Ü–∏–∑–º', icon: '‚ú®', cost: { gold: 180, wood: 90 }, effect: 'ability_power', value: 10, time: 22000 },
                    { name: '–†–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è –º–∞–Ω—ã', icon: 'üíô', cost: { gold: 200, wood: 100 }, effect: 'cooldown', value: -2000, time: 25000 }
                ],
                buildTime: 20000
            },
            WORKSHOP: {
                name: '–ú–∞—Å—Ç–µ—Ä—Å–∫–∞—è',
                icon: 'üè≠',
                race: RACES.HUMAN,
                hp: 300,
                width: 2,
                height: 2,
                cost: { gold: 220, wood: 100 },
                trains: ['CATAPULT'],
                researches: [
                    { name: '–£–ª—É—á—à–µ–Ω–Ω—ã–µ –±–∞–ª–∞–Ω—Å–∏—Ä—ã', icon: '‚öô', cost: { gold: 200, wood: 120 }, effect: 'siege_damage', value: 15, time: 30000 }
                ],
                buildTime: 25000
            },
            AVIARY: {
                name: '–í–æ–ª—å–µ—Ä –≥—Ä–∏—Ñ–æ–Ω–æ–≤',
                icon: 'üèî',
                race: RACES.HUMAN,
                hp: 260,
                width: 2,
                height: 2,
                cost: { gold: 250, wood: 120 },
                trains: ['GRIFFIN'],
                researches: [
                    { name: '–ú–∞–Ω–µ–≤—Ä—ã –≤ –≤–æ–∑–¥—É—Ö–µ', icon: 'üå™', cost: { gold: 180, wood: 100 }, effect: 'flying_speed', value: 1.5, time: 20000 }
                ],
                buildTime: 22000
            },
            CASTLE: {
                name: '–ó–∞–º–æ–∫',
                icon: 'üè∞',
                race: RACES.HUMAN,
                hp: 600,
                width: 3,
                height: 3,
                cost: { gold: 400, wood: 200 },
                trains: ['PALADIN'],
                provides: 15,
                researches: [
                    { name: '–ö–æ—Ä–æ–ª–µ–≤—Å–∫–∞—è –≥–≤–∞—Ä–¥–∏—è', icon: 'üëë', cost: { gold: 300, wood: 150 }, effect: 'elite_damage', value: 8, time: 35000 }
                ],
                buildTime: 40000
            },
            GUARD_TOWER: {
                name: '–°—Ç–æ—Ä–æ–∂–µ–≤–∞—è –±–∞—à–Ω—è',
                icon: 'üóø',
                race: RACES.HUMAN,
                hp: 200,
                width: 1,
                height: 1,
                cost: { gold: 100, wood: 50 },
                damage: 10,
                range: 6,
                buildTime: 12000,
                isDefense: true
            },
            CANNON_TOWER: {
                name: '–ü—É—à–µ—á–Ω–∞—è –±–∞—à–Ω—è',
                icon: 'üéÜ',
                race: RACES.HUMAN,
                hp: 250,
                width: 1,
                height: 1,
                cost: { gold: 180, wood: 80 },
                damage: 30,
                range: 7,
                buildTime: 18000,
                isDefense: true
            },
            
            // ===== –û–†–ö–ò =====
            GREAT_HALL: {
                name: '–ë–æ–ª—å—à–æ–π –ó–∞–ª',
                icon: '‚õ∫',
                race: RACES.ORC,
                hp: 550,
                width: 3,
                height: 3,
                cost: { gold: 0, wood: 0 },
                trains: ['PEON'],
                provides: 10,
                buildTime: 0,
                researches: [
                    { name: '–£—Å–∏–ª–µ–Ω–Ω–∞—è –¥–æ–±—ã—á–∞', icon: '‚õè', cost: { gold: 100, wood: 50 }, effect: 'carry_capacity', value: 5, time: 12000 }
                ]
            },
            PIG_FARM: {
                name: '–°–≤–∏–Ω–æ—Ñ–µ—Ä–º–∞',
                icon: 'üèï',
                race: RACES.ORC,
                hp: 180,
                width: 2,
                height: 2,
                cost: { gold: 80, wood: 20 },
                provides: 5,
                buildTime: 10000
            },
            ORC_BARRACKS: {
                name: '–ö–∞–∑–∞—Ä–º–∞',
                icon: '‚öî',
                race: RACES.ORC,
                hp: 320,
                width: 2,
                height: 2,
                cost: { gold: 150, wood: 50 },
                trains: ['GRUNT', 'RAIDER', 'HEADHUNTER', 'BERSERKER'],
                researches: [
                    { name: '–£–ª—É—á—à–µ–Ω–∏–µ –æ—Ä—É–∂–∏—è I', icon: '‚öî', cost: { gold: 100, wood: 50 }, effect: 'damage', value: 2, time: 15000 },
                    { name: '–£–ª—É—á—à–µ–Ω–∏–µ –±—Ä–æ–Ω–∏ I', icon: 'üõ°', cost: { gold: 150, wood: 50 }, effect: 'armor', value: 1, time: 20000 },
                    { name: '–ë–æ–µ–≤–æ–µ –±–µ–∑—É–º–∏–µ', icon: 'üí¢', cost: { gold: 140, wood: 70 }, effect: 'attack_speed', value: 10, time: 18000 }
                ],
                buildTime: 15000
            },
            WAR_MILL: {
                name: '–í–æ–µ–Ω–Ω–∞—è –º–µ–ª—å–Ω–∏—Ü–∞',
                icon: '‚öí',
                race: RACES.ORC,
                hp: 260,
                width: 2,
                height: 2,
                cost: { gold: 120, wood: 60 },
                researches: [
                    { name: '–£–ª—É—á—à–µ–Ω–∏–µ –æ—Ä—É–∂–∏—è II', icon: '‚öî', cost: { gold: 200, wood: 100 }, effect: 'damage', value: 3, time: 25000 },
                    { name: '–£–ª—É—á—à–µ–Ω–∏–µ –±—Ä–æ–Ω–∏ II', icon: 'üõ°', cost: { gold: 250, wood: 100 }, effect: 'armor', value: 2, time: 30000 },
                    { name: '–ó–∞—Ç–æ—á–∫–∞ –∫–ª–∏–Ω–∫–æ–≤', icon: 'üî™', cost: { gold: 300, wood: 150 }, effect: 'damage', value: 5, time: 40000 }
                ],
                buildTime: 18000
            },
            TAUREN_TOTEM: {
                name: '–¢–æ—Ç–µ–º —Ç–∞—É—Ä–µ–Ω–æ–≤',
                icon: 'üóø',
                race: RACES.ORC,
                hp: 290,
                width: 2,
                height: 2,
                cost: { gold: 190, wood: 80 },
                trains: ['TAUREN'],
                researches: [
                    { name: '–°–∏–ª–∞ –∑–µ–º–ª–∏', icon: 'üåç', cost: { gold: 160, wood: 90 }, effect: 'hp', value: 50, time: 20000 }
                ],
                buildTime: 22000
            },
            SPIRIT_LODGE: {
                name: '–•–∏–∂–∏–Ω–∞ –î—É—Ö–æ–≤',
                icon: 'üõñ',
                race: RACES.ORC,
                hp: 270,
                width: 2,
                height: 2,
                cost: { gold: 200, wood: 80 },
                trains: ['SHAMAN', 'WITCH_DOCTOR', 'WARLOCK'],
                researches: [
                    { name: '–î—É—Ö–æ–≤–Ω–∞—è —Å–∏–ª–∞', icon: 'üëª', cost: { gold: 180, wood: 90 }, effect: 'ability_power', value: 10, time: 22000 },
                    { name: '–ó–µ–ª—å—è –ø—Ä–µ–¥–∫–æ–≤', icon: 'üß™', cost: { gold: 200, wood: 100 }, effect: 'cooldown', value: -2000, time: 25000 }
                ],
                buildTime: 20000
            },
            GOBLIN_FOUNDRY: {
                name: '–ì–æ–±–ª–∏–Ω—Å–∫–∞—è –ª–∏—Ç–µ–π–Ω–∞—è',
                icon: '‚öô',
                race: RACES.ORC,
                hp: 310,
                width: 2,
                height: 2,
                cost: { gold: 220, wood: 100 },
                trains: ['DEMOLISHER'],
                researches: [
                    { name: '–ù–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã–µ –±–æ–µ–ø—Ä–∏–ø–∞—Å—ã', icon: 'üí£', cost: { gold: 200, wood: 120 }, effect: 'siege_damage', value: 20, time: 30000 }
                ],
                buildTime: 25000
            },
            WYVERN_ROOST: {
                name: '–ì–Ω–µ–∑–¥–æ –≤–∏–≤–µ—Ä–Ω',
                icon: '‚õ∞',
                race: RACES.ORC,
                hp: 270,
                width: 2,
                height: 2,
                cost: { gold: 250, wood: 120 },
                trains: ['WYVERN'],
                researches: [
                    { name: '–£–∫—Ä–µ–ø–ª–µ–Ω–Ω–∞—è —á–µ—à—É—è', icon: 'üê≤', cost: { gold: 180, wood: 100 }, effect: 'flying_armor', value: 2, time: 20000 }
                ],
                buildTime: 22000
            },
            FORTRESS: {
                name: '–ö—Ä–µ–ø–æ—Å—Ç—å',
                icon: 'üèØ',
                race: RACES.ORC,
                hp: 650,
                width: 3,
                height: 3,
                cost: { gold: 400, wood: 200 },
                trains: ['BLADEMASTER'],
                provides: 15,
                researches: [
                    { name: '–ü—É—Ç—å –≤–æ–∏–Ω–∞', icon: '‚ö°', cost: { gold: 300, wood: 150 }, effect: 'elite_damage', value: 8, time: 35000 }
                ],
                buildTime: 40000
            },
            WATCH_TOWER: {
                name: '–î–æ–∑–æ—Ä–Ω–∞—è –±–∞—à–Ω—è',
                icon: 'üóº',
                race: RACES.ORC,
                hp: 220,
                width: 1,
                height: 1,
                cost: { gold: 100, wood: 50 },
                damage: 12,
                range: 6,
                buildTime: 12000,
                isDefense: true
            },
            SPIKE_TOWER: {
                name: '–®–∏–ø–æ–≤–∞–Ω–Ω–∞—è –±–∞—à–Ω—è',
                icon: 'üåµ',
                race: RACES.ORC,
                hp: 260,
                width: 1,
                height: 1,
                cost: { gold: 180, wood: 80 },
                damage: 35,
                range: 5,
                buildTime: 18000,
                isDefense: true
            }
        };
        
        const TERRAIN_TYPES = {
            GRASS: { char: '‚ñì', color: '#2d5016', passable: true },
            FOREST: { char: '‚ô†', color: '#1a3d0a', passable: true, resource: 'wood', amount: 500 },
            GOLD: { char: '‚óÜ', color: '#ffd700', passable: true, resource: 'gold', amount: 1000 },
            WATER: { char: '‚âà', color: '#1e40af', passable: false },
            MOUNTAIN: { char: '‚ñ≤', color: '#4a5568', passable: false },
            DEPLETED: { char: '‚ñë', color: '#3d4d26', passable: true }
        };
        
        // ============================================================================
        // –ò–ì–†–û–í–û–ï –°–û–°–¢–û–Ø–ù–ò–ï
        // ============================================================================
        
        class GameState {
            constructor() {
                this.resourceTiles = new Map(); // –°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Map
                this.map = this.generateMap(); // –ü–æ—Ç–æ–º –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–∞—Ä—Ç—É
                this.units = [];
                this.buildings = [];
                this.selectedUnits = [];
                this.selectedBuilding = null;
                this.player = {
                    race: RACES.HUMAN,
                    gold: 500,
                    wood: 300,
                    supply: 0,
                    maxSupply: 10,
                    researches: new Set()
                };
                this.enemy = {
                    race: RACES.ORC,
                    gold: 500,
                    wood: 300,
                    supply: 0,
                    maxSupply: 10,
                    researches: new Set()
                };
                this.camera = { x: 0, y: 0 };
                this.buildMode = null;
                this.time = 0;
                this.gameOver = false;
                this.victory = false;
                this.messages = [];
                
                this.initializeStartingUnits();
                this.showMessage('‚öî –ë–∏—Ç–≤–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è! –£–Ω–∏—á—Ç–æ–∂—å—Ç–µ –≤—Ä–∞–∂–µ—Å–∫—É—é –±–∞–∑—É!');
            }
            
            showMessage(text, duration = 5000) {
                this.messages.push({ text, time: this.time, duration });
            }
            
            generateMap() {
                const map = [];
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    map[y] = [];
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        const noise = Math.random();
                        if (noise > 0.9) {
                            map[y][x] = TERRAIN_TYPES.FOREST;
                            this.resourceTiles.set(`${x},${y}`, TERRAIN_TYPES.FOREST.amount);
                        } else if (noise > 0.85 && (x < 5 || x > MAP_WIDTH - 6 || y < 5 || y > MAP_HEIGHT - 6)) {
                            map[y][x] = TERRAIN_TYPES.GOLD;
                            this.resourceTiles.set(`${x},${y}`, TERRAIN_TYPES.GOLD.amount);
                        } else if (noise < 0.05) {
                            map[y][x] = TERRAIN_TYPES.WATER;
                        } else if (noise < 0.08) {
                            map[y][x] = TERRAIN_TYPES.MOUNTAIN;
                        } else {
                            map[y][x] = TERRAIN_TYPES.GRASS;
                        }
                    }
                }
                return map;
            }
            
            initializeStartingUnits() {
                // –ò–≥—Ä–æ–∫ (–≤–Ω–∏–∑—É —Å–ª–µ–≤–∞)
                const playerTownHall = new Building(3, 3, 'TOWN_HALL', true);
                this.buildings.push(playerTownHall);
                this.player.maxSupply += BUILDING_TYPES['TOWN_HALL'].provides || 0;
                
                this.units.push(new Unit(2, 5, 'PEASANT', true));
                this.units.push(new Unit(3, 6, 'PEASANT', true));
                this.units.push(new Unit(4, 5, 'PEASANT', true));
                
                // –í—Ä–∞–≥ (–≤–≤–µ—Ä—Ö—É —Å–ø—Ä–∞–≤–∞)
                const enemyGreatHall = new Building(MAP_WIDTH - 6, MAP_HEIGHT - 6, 'GREAT_HALL', false);
                this.buildings.push(enemyGreatHall);
                this.enemy.maxSupply += BUILDING_TYPES['GREAT_HALL'].provides || 0;
                
                this.units.push(new Unit(MAP_WIDTH - 5, MAP_HEIGHT - 4, 'PEON', false));
                this.units.push(new Unit(MAP_WIDTH - 6, MAP_HEIGHT - 3, 'PEON', false));
                this.units.push(new Unit(MAP_WIDTH - 4, MAP_HEIGHT - 4, 'PEON', false));
            }
            
            update(deltaTime) {
                if (this.gameOver) return;
                
                this.time += deltaTime;
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —é–Ω–∏—Ç–æ–≤
                this.units.forEach(unit => unit.update(deltaTime, this));
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–¥–∞–Ω–∏–π
                this.buildings.forEach(building => building.update(deltaTime, this));
                
                // –ò–ò –≤—Ä–∞–≥–∞ - –≤—ã–∑—ã–≤–∞–µ–º —á–∞—â–µ –¥–ª—è –±–æ–ª–µ–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è
                if (Math.random() < 0.005) {
                    this.enemyAI();
                }
                
                // –í—Ä–∞–≥ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–±–∏—Ä–∞–µ—Ç —Ä–µ—Å—É—Ä—Å—ã
                if (Math.random() < 0.01) {
                    this.enemyGatherResources();
                }
                
                // –í—Ä–∞–≥ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –∞—Ç–∞–∫—É–µ—Ç
                if (Math.random() < 0.002 && this.time > 30000) {
                    this.enemyAttack();
                }
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –º—ë—Ä—Ç–≤—ã—Ö —é–Ω–∏—Ç–æ–≤
                this.units = this.units.filter(unit => {
                    if (unit.hp <= 0) {
                        const owner = unit.isPlayer ? this.player : this.enemy;
                        owner.supply -= UNIT_TYPES[unit.type].supply || 0;
                        return false;
                    }
                    return true;
                });
                
                // –£–¥–∞–ª–µ–Ω–∏–µ —Ä–∞–∑—Ä—É—à–µ–Ω–Ω—ã—Ö –∑–¥–∞–Ω–∏–π
                this.buildings = this.buildings.filter(building => {
                    if (building.hp <= 0) {
                        const owner = building.isPlayer ? this.player : this.enemy;
                        const provides = BUILDING_TYPES[building.type].provides || 0;
                        owner.maxSupply -= provides;
                        
                        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è –≥–ª–∞–≤–Ω–æ–≥–æ –∑–¥–∞–Ω–∏—è
                        if (building.type === 'TOWN_HALL' && building.isPlayer) {
                            this.gameOver = true;
                            this.victory = false;
                            this.showMessage('üíÄ –ü–û–†–ê–ñ–ï–ù–ò–ï! –í–∞—à–∞ –†–∞—Ç—É—à–∞ —Ä–∞–∑—Ä—É—à–µ–Ω–∞!', 999999);
                        } else if (building.type === 'GREAT_HALL' && !building.isPlayer) {
                            this.gameOver = true;
                            this.victory = true;
                            this.showMessage('üëë –ü–û–ë–ï–î–ê! –í—Ä–∞–∂–µ—Å–∫–∏–π –ë–æ–ª—å—à–æ–π –ó–∞–ª —É–Ω–∏—á—Ç–æ–∂–µ–Ω!', 999999);
                        }
                        
                        return false;
                    }
                    return true;
                });
                
                // –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
                this.messages = this.messages.filter(msg => 
                    this.time - msg.time < msg.duration
                );
            }
            
            enemyAI() {
                const enemyPeons = this.units.filter(u => u.type === 'PEON' && !u.isPlayer);
                const enemyBuildings = this.buildings.filter(b => !b.isPlayer);
                
                // –í—Ä–∞–≥ —Å—Ç—Ä–æ–∏—Ç —Ñ–µ—Ä–º—ã –µ—Å–ª–∏ –Ω—É–∂–µ–Ω supply
                if (this.enemy.supply >= this.enemy.maxSupply - 3 && this.enemy.gold >= 80) {
                    const freePeon = enemyPeons.find(p => !p.buildingTarget && !p.gatherTarget && !p.carrying);
                    
                    if (freePeon) {
                        const x = MAP_WIDTH - 10 + Math.floor(Math.random() * 5);
                        const y = MAP_HEIGHT - 10 + Math.floor(Math.random() * 5);
                        
                        if (this.canPlaceBuilding(x, y, 'PIG_FARM')) {
                            const cost = BUILDING_TYPES['PIG_FARM'].cost;
                            this.enemy.gold -= cost.gold;
                            this.enemy.wood -= cost.wood;
                            const buildTime = BUILDING_TYPES['PIG_FARM'].buildTime;
                            const newBuilding = new Building(x, y, 'PIG_FARM', false, buildTime);
                            this.buildings.push(newBuilding);
                            this.enemy.maxSupply += BUILDING_TYPES['PIG_FARM'].provides || 0;
                            
                            freePeon.buildingTarget = newBuilding;
                            freePeon.moveTo(x, y, this);
                        }
                    }
                }
                
                // –í—Ä–∞–≥ —Å—Ç—Ä–æ–∏—Ç –±–æ–µ–≤—ã–µ –∑–¥–∞–Ω–∏—è
                if (this.enemy.gold >= 150 && enemyBuildings.length < 8) {
                    const freePeon = enemyPeons.find(p => !p.buildingTarget && !p.gatherTarget && !p.carrying);
                    
                    if (freePeon) {
                        const buildingTypes = ['ORC_BARRACKS', 'SPIRIT_LODGE'];
                        const type = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                        const x = MAP_WIDTH - 10 + Math.floor(Math.random() * 5);
                        const y = MAP_HEIGHT - 10 + Math.floor(Math.random() * 5);
                        
                        if (this.canPlaceBuilding(x, y, type)) {
                            const cost = BUILDING_TYPES[type].cost;
                            this.enemy.gold -= cost.gold;
                            this.enemy.wood -= cost.wood;
                            const buildTime = BUILDING_TYPES[type].buildTime;
                            const newBuilding = new Building(x, y, type, false, buildTime);
                            this.buildings.push(newBuilding);
                            this.enemy.maxSupply += BUILDING_TYPES[type].provides || 0;
                            
                            freePeon.buildingTarget = newBuilding;
                            freePeon.moveTo(x, y, this);
                        }
                    }
                }
                
                // –í—Ä–∞–≥ —Å–æ–∑–¥–∞—ë—Ç —é–Ω–∏—Ç–æ–≤ –±–æ–ª–µ–µ –∞–∫—Ç–∏–≤–Ω–æ
                const greatHall = enemyBuildings.find(b => b.type === 'GREAT_HALL' && !b.isUnderConstruction);
                if (greatHall && this.enemy.supply < this.enemy.maxSupply) {
                    // –°–æ–∑–¥–∞—ë–º –ø–µ–æ–Ω–æ–≤ –µ—Å–ª–∏ –∏—Ö –º–∞–ª–æ
                    if (enemyPeons.length < 5 && this.enemy.gold >= 50) {
                        this.enemy.gold -= 50;
                        greatHall.trainUnit('PEON');
                        return;
                    }
                    
                    // –°–æ–∑–¥–∞—ë–º –±–æ–µ–≤—ã–µ —é–Ω–∏—Ç—ã
                    if (this.enemy.gold >= 100) {
                        const unitTypes = ['GRUNT', 'RAIDER', 'SHAMAN'];
                        const type = unitTypes[Math.floor(Math.random() * unitTypes.length)];
                        const cost = UNIT_TYPES[type].cost;
                        
                        if (this.enemy.gold >= cost.gold && this.enemy.wood >= cost.wood) {
                            this.enemy.gold -= cost.gold;
                            this.enemy.wood -= cost.wood;
                            greatHall.trainUnit(type);
                        }
                    }
                }
            }
            
            enemyGatherResources() {
                const enemyPeons = this.units.filter(u => 
                    u.type === 'PEON' && 
                    !u.isPlayer && 
                    !u.gatherTarget && 
                    !u.carrying &&
                    !u.buildingTarget &&
                    u.path.length === 0
                );
                
                enemyPeons.forEach(peon => {
                    // –ò—â–µ–º –±–ª–∏–∂–∞–π—à–∏–π —Ä–µ—Å—É—Ä—Å
                    let nearestResource = null;
                    let minDist = Infinity;
                    
                    for (let y = MAP_HEIGHT - 15; y < MAP_HEIGHT; y++) {
                        for (let x = MAP_WIDTH - 15; x < MAP_WIDTH; x++) {
                            if (x >= 0 && y >= 0 && x < MAP_WIDTH && y < MAP_HEIGHT) {
                                const terrain = this.map[y][x];
                                if (terrain === TERRAIN_TYPES.GOLD || terrain === TERRAIN_TYPES.FOREST) {
                                    const dx = x - peon.x;
                                    const dy = y - peon.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (dist < minDist) {
                                        minDist = dist;
                                        nearestResource = { 
                                            x, 
                                            y, 
                                            type: terrain === TERRAIN_TYPES.GOLD ? 'GOLD' : 'FOREST' 
                                        };
                                    }
                                }
                            }
                        }
                    }
                    
                    if (nearestResource) {
                        peon.gatherTarget = nearestResource;
                        peon.autoGather = true; // –í–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ—Å–±–æ—Ä
                    }
                });
            }
            
            enemyAttack() {
                const enemyUnits = this.units.filter(u => 
                    !u.isPlayer && 
                    u.type !== 'PEON' &&
                    !u.target
                );
                
                // –ï—Å–ª–∏ —É –≤—Ä–∞–≥–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞—Ä–º–∏–∏ - –∞—Ç–∞–∫—É–µ–º
                if (enemyUnits.length >= 5) {
                    const playerBuildings = this.buildings.filter(b => b.isPlayer);
                    if (playerBuildings.length > 0) {
                        // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç - –≥–ª–∞–≤–Ω–æ–µ –∑–¥–∞–Ω–∏–µ
                        const townHall = playerBuildings.find(b => b.type === 'TOWN_HALL');
                        const target = townHall || playerBuildings[Math.floor(Math.random() * playerBuildings.length)];
                        
                        enemyUnits.forEach(unit => {
                            unit.moveTo(target.x + 1, target.y + 1, this);
                            unit.attackBuilding = target; // –ù–æ–≤–æ–µ –ø–æ–ª–µ –¥–ª—è –∞—Ç–∞–∫–∏ –∑–¥–∞–Ω–∏–π
                        });
                        
                        this.showMessage('‚ö† –í—Ä–∞–≥ –∞—Ç–∞–∫—É–µ—Ç –≤–∞—à–∏ –∑–¥–∞–Ω–∏—è!');
                    }
                }
            }
            
            canPlaceBuilding(x, y, buildingType) {
                const building = BUILDING_TYPES[buildingType];
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü –∫–∞—Ä—Ç—ã
                if (x < 0 || y < 0 || x + building.width > MAP_WIDTH || y + building.height > MAP_HEIGHT) {
                    return false;
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–Ω—è—Ç–æ—Å—Ç–∏ –∫–ª–µ—Ç–æ–∫
                for (let dy = 0; dy < building.height; dy++) {
                    for (let dx = 0; dx < building.width; dx++) {
                        const terrain = this.map[y + dy][x + dx];
                        if (!terrain.passable) {
                            return false;
                        }
                        
                        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥—Ä—É–≥–∏—Ö –∑–¥–∞–Ω–∏–π
                        if (this.buildings.some(b => 
                            x + dx >= b.x && x + dx < b.x + BUILDING_TYPES[b.type].width &&
                            y + dy >= b.y && y + dy < b.y + BUILDING_TYPES[b.type].height
                        )) {
                            return false;
                        }
                    }
                }
                
                return true;
            }
        }
        
        // ============================================================================
        // –ö–õ–ê–°–°–´ –ò–ì–†–û–í–´–• –û–ë–™–ï–ö–¢–û–í
        // ============================================================================
        
        class Unit {
            constructor(x, y, type, isPlayer) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.isPlayer = isPlayer;
                const stats = UNIT_TYPES[type];
                this.maxHp = stats.hp;
                this.hp = stats.hp;
                this.target = null;
                this.attackBuilding = null;
                this.path = [];
                this.attackCooldown = 0;
                this.gatherTarget = null;
                this.gatherCooldown = 0;
                this.carrying = null;
                this.carryAmount = 0;
                this.abilityCooldown = 0;
                this.autoGather = false; // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å–±–æ—Ä
                this.autoAttack = false; // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∞—Ç–∞–∫–∞
                this.buildingTarget = null; // –ó–¥–∞–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Å—Ç—Ä–æ–∏—Ç
                this.buildProgress = 0; // –ü—Ä–æ–≥—Ä–µ—Å—Å —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
            }
            
            update(deltaTime, gameState) {
                // –°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ –∑–¥–∞–Ω–∏—è
                if (this.buildingTarget && this.buildingTarget.isUnderConstruction) {
                    const dx = this.buildingTarget.x - this.x;
                    const dy = this.buildingTarget.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist <= 2) {
                        this.buildingTarget.buildProgress += deltaTime;
                        
                        if (this.buildingTarget.buildProgress >= this.buildingTarget.buildTime) {
                            this.buildingTarget.isUnderConstruction = false;
                            this.buildingTarget = null;
                            gameState.showMessage('‚úì –°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!', 2000);
                        }
                    } else {
                        // –î–≤–∏–∂–µ–Ω–∏–µ –∫ –∑–¥–∞–Ω–∏—é
                        const speed = UNIT_TYPES[this.type].speed * deltaTime * 0.001;
                        this.x += (dx / dist) * speed;
                        this.y += (dy / dist) * speed;
                    }
                    return; // –í–æ –≤—Ä–µ–º—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ –Ω–µ –¥–µ–ª–∞–µ–º –Ω–∏—á–µ–≥–æ –¥—Ä—É–≥–æ–≥–æ
                }
                
                // –î–≤–∏–∂–µ–Ω–∏–µ –ø–æ –ø—É—Ç–∏
                if (this.path.length > 0 && !this.target && !this.attackBuilding) {
                    const next = this.path[0];
                    const dx = next.x - this.x;
                    const dy = next.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 0.1) {
                        this.path.shift();
                    } else {
                        const speed = UNIT_TYPES[this.type].speed * deltaTime * 0.001;
                        this.x += (dx / dist) * speed;
                        this.y += (dy / dist) * speed;
                    }
                }
                
                // –ê–≤—Ç–æ–∞—Ç–∞–∫–∞ –¥–ª—è –≤—Ä–∞–≥–æ–≤ –∏ –¥–ª—è —é–Ω–∏—Ç–æ–≤ —Å autoAttack
                if (!this.target && !this.attackBuilding && ((!this.isPlayer && this.type !== 'PEON') || this.autoAttack)) {
                    const nearestEnemy = this.findNearestEnemy(gameState);
                    if (nearestEnemy) {
                        this.target = nearestEnemy;
                    }
                }
                
                // –ê—Ç–∞–∫–∞ —é–Ω–∏—Ç–æ–≤
                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const range = UNIT_TYPES[this.type].range;
                    
                    if (dist <= range) {
                        this.attackCooldown -= deltaTime;
                        if (this.attackCooldown <= 0) {
                            this.target.hp -= UNIT_TYPES[this.type].damage;
                            this.attackCooldown = 1000;
                            
                            // –ö–æ–Ω—Ç—Ä–∞—Ç–∞–∫–∞ - –µ—Å–ª–∏ –∞—Ç–∞–∫–æ–≤–∞–Ω, –∞—Ç–∞–∫–æ–≤–∞—Ç—å –≤ –æ—Ç–≤–µ—Ç
                            if (!this.target.target && this.target.isPlayer !== this.isPlayer) {
                                this.target.target = this;
                                this.target.autoAttack = true;
                            }
                            
                            if (this.target.hp <= 0) {
                                this.target = null;
                                // –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø–æ–∏—Å–∫ –≤—Ä–∞–≥–æ–≤ –µ—Å–ª–∏ autoAttack
                                if (this.autoAttack) {
                                    const nextEnemy = this.findNearestEnemy(gameState);
                                    if (nextEnemy) {
                                        this.target = nextEnemy;
                                    }
                                }
                            }
                        }
                    } else {
                        // –î–≤–∏–∂–µ–Ω–∏–µ –∫ —Ü–µ–ª–∏
                        const speed = UNIT_TYPES[this.type].speed * deltaTime * 0.001;
                        this.x += (dx / dist) * speed;
                        this.y += (dy / dist) * speed;
                    }
                }
                
                // –ê—Ç–∞–∫–∞ –∑–¥–∞–Ω–∏–π
                if (this.attackBuilding && this.attackBuilding.hp > 0) {
                    const dx = this.attackBuilding.x - this.x;
                    const dy = this.attackBuilding.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const range = UNIT_TYPES[this.type].range;
                    
                    if (dist <= range + 2) {
                        this.attackCooldown -= deltaTime;
                        if (this.attackCooldown <= 0) {
                            this.attackBuilding.hp -= UNIT_TYPES[this.type].damage;
                            this.attackCooldown = 1000;
                            
                            if (this.attackBuilding.hp <= 0) {
                                this.attackBuilding = null;
                            }
                        }
                    } else {
                        // –î–≤–∏–∂–µ–Ω–∏–µ –∫ –∑–¥–∞–Ω–∏—é
                        const speed = UNIT_TYPES[this.type].speed * deltaTime * 0.001;
                        this.x += (dx / dist) * speed;
                        this.y += (dy / dist) * speed;
                    }
                } else {
                    this.attackBuilding = null;
                }
                
                // –°–±–æ—Ä —Ä–µ—Å—É—Ä—Å–æ–≤ —Å –∏—Å—Ç–æ—â–µ–Ω–∏–µ–º
                if (this.gatherTarget && UNIT_TYPES[this.type].canGather && !this.carrying) {
                    const dx = this.gatherTarget.x - this.x;
                    const dy = this.gatherTarget.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist <= 1) {
                        this.gatherCooldown -= deltaTime;
                        if (this.gatherCooldown <= 0) {
                            const tileKey = `${this.gatherTarget.x},${this.gatherTarget.y}`;
                            const remainingResource = gameState.resourceTiles.get(tileKey) || 0;
                            
                            if (remainingResource > 0) {
                                const capacity = UNIT_TYPES[this.type].carryCapacity || 10;
                                const gathered = Math.min(capacity, remainingResource);
                                
                                this.carrying = this.gatherTarget.type;
                                this.carryAmount = gathered;
                                gameState.resourceTiles.set(tileKey, remainingResource - gathered);
                                
                                // –ò—Å—Ç–æ—â–µ–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–∞
                                if (remainingResource - gathered <= 0) {
                                    gameState.map[this.gatherTarget.y][this.gatherTarget.x] = TERRAIN_TYPES.DEPLETED;
                                    if (!this.autoGather) {
                                        this.gatherTarget = null;
                                    }
                                }
                                
                                this.gatherCooldown = 2000;
                                
                                // –í–æ–∑–≤—Ä–∞—Ç –≤ –±–∞–∑—É
                                const base = gameState.buildings.find(b => 
                                    b.isPlayer === this.isPlayer && 
                                    (b.type === 'TOWN_HALL' || b.type === 'GREAT_HALL')
                                );
                                
                                if (base) {
                                    this.moveTo(base.x + 1, base.y + 1, gameState);
                                }
                            } else {
                                this.gatherTarget = null;
                                this.autoGather = false;
                            }
                        }
                    } else {
                        const speed = UNIT_TYPES[this.type].speed * deltaTime * 0.001;
                        this.x += (dx / dist) * speed;
                        this.y += (dy / dist) * speed;
                    }
                }
                
                // –°–¥–∞—á–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
                if (this.carrying && this.carryAmount > 0) {
                    const base = gameState.buildings.find(b => 
                        b.isPlayer === this.isPlayer && 
                        (b.type === 'TOWN_HALL' || b.type === 'GREAT_HALL') &&
                        Math.abs(b.x - this.x) < 2 && Math.abs(b.y - this.y) < 2
                    );
                    
                    if (base) {
                        const owner = this.isPlayer ? gameState.player : gameState.enemy;
                        if (this.carrying === 'GOLD') {
                            owner.gold += this.carryAmount;
                        } else if (this.carrying === 'FOREST') {
                            owner.wood += this.carryAmount;
                        }
                        this.carrying = null;
                        this.carryAmount = 0;
                        
                        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–±–æ—Ä—É –µ—Å–ª–∏ autoGather
                        if (this.autoGather && this.gatherTarget) {
                            this.moveTo(this.gatherTarget.x, this.gatherTarget.y, gameState);
                        } else {
                            this.gatherTarget = null;
                            this.autoGather = false;
                        }
                    }
                }
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—É–ª–¥–∞—É–Ω–∞ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
                if (this.abilityCooldown > 0) {
                    this.abilityCooldown -= deltaTime;
                }
            }
            
            findNearestEnemy(gameState) {
                let nearest = null;
                let minDist = Infinity;
                
                const enemies = gameState.units.filter(u => u.isPlayer !== this.isPlayer);
                enemies.forEach(enemy => {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < minDist && dist < 10) {
                        minDist = dist;
                        nearest = enemy;
                    }
                });
                
                return nearest;
            }
            
            moveTo(targetX, targetY, gameState) {
                this.path = this.findPath(targetX, targetY, gameState);
                this.target = null;
                this.attackBuilding = null;
                // –ù–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º gatherTarget –µ—Å–ª–∏ –Ω–µ—Å—ë–º —Ä–µ—Å—É—Ä—Å—ã –∏–ª–∏ autoGather –∞–∫—Ç–∏–≤–µ–Ω
                if (!this.carrying && !this.autoGather) {
                    this.gatherTarget = null;
                }
            }
            
            findPath(targetX, targetY, gameState) {
                // –ü—Ä–æ—Å—Ç–æ–π A* pathfinding
                const start = { x: Math.floor(this.x), y: Math.floor(this.y) };
                const goal = { x: Math.floor(targetX), y: Math.floor(targetY) };
                
                const openSet = [start];
                const cameFrom = new Map();
                const gScore = new Map();
                const fScore = new Map();
                
                const key = (x, y) => `${x},${y}`;
                
                gScore.set(key(start.x, start.y), 0);
                fScore.set(key(start.x, start.y), this.heuristic(start, goal));
                
                while (openSet.length > 0) {
                    // –ù–∞—Ö–æ–¥–∏–º —É–∑–µ–ª —Å –Ω–∞–∏–º–µ–Ω—å—à–∏–º fScore
                    let current = openSet[0];
                    let currentKey = key(current.x, current.y);
                    let lowestF = fScore.get(currentKey);
                    
                    for (let i = 1; i < openSet.length; i++) {
                        const nodeKey = key(openSet[i].x, openSet[i].y);
                        const f = fScore.get(nodeKey);
                        if (f < lowestF) {
                            current = openSet[i];
                            currentKey = nodeKey;
                            lowestF = f;
                        }
                    }
                    
                    if (current.x === goal.x && current.y === goal.y) {
                        return this.reconstructPath(cameFrom, current);
                    }
                    
                    openSet.splice(openSet.indexOf(current), 1);
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å–µ–¥–µ–π
                    const neighbors = [
                        { x: current.x + 1, y: current.y },
                        { x: current.x - 1, y: current.y },
                        { x: current.x, y: current.y + 1 },
                        { x: current.x, y: current.y - 1 }
                    ];
                    
                    for (const neighbor of neighbors) {
                        if (neighbor.x < 0 || neighbor.y < 0 || 
                            neighbor.x >= MAP_WIDTH || neighbor.y >= MAP_HEIGHT) {
                            continue;
                        }
                        
                        const terrain = gameState.map[neighbor.y][neighbor.x];
                        if (!terrain.passable) {
                            continue;
                        }
                        
                        const neighborKey = key(neighbor.x, neighbor.y);
                        const tentativeG = gScore.get(currentKey) + 1;
                        
                        if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
                            cameFrom.set(neighborKey, current);
                            gScore.set(neighborKey, tentativeG);
                            fScore.set(neighborKey, tentativeG + this.heuristic(neighbor, goal));
                            
                            if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
                                openSet.push(neighbor);
                            }
                        }
                    }
                    
                    if (openSet.length > 100) break; // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∞–Ω–∏–π
                }
                
                return [];
            }
            
            heuristic(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }
            
            reconstructPath(cameFrom, current) {
                const path = [current];
                const key = (x, y) => `${x},${y}`;
                
                while (cameFrom.has(key(current.x, current.y))) {
                    current = cameFrom.get(key(current.x, current.y));
                    path.unshift(current);
                }
                
                return path;
            }
        }
        
        class Building {
            constructor(x, y, type, isPlayer, buildTime = 0) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.isPlayer = isPlayer;
                const stats = BUILDING_TYPES[type];
                this.maxHp = stats.hp;
                this.hp = buildTime > 0 ? 1 : stats.hp; // –í–æ –≤—Ä–µ–º—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ HP
                this.trainingQueue = [];
                this.trainingProgress = 0;
                this.currentTraining = null;
                this.researchQueue = [];
                this.researchProgress = 0;
                this.currentResearch = null;
                this.isUnderConstruction = buildTime > 0;
                this.buildTime = buildTime;
                this.buildProgress = 0;
            }
            
            update(deltaTime, gameState) {
                // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ –∑–¥–∞–Ω–∏—è
                if (this.isUnderConstruction) {
                    // HP —Ä–∞—Å—Ç—ë—Ç –ø–æ –º–µ—Ä–µ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
                    const progress = this.buildProgress / this.buildTime;
                    this.hp = Math.max(1, Math.floor(this.maxHp * progress));
                    return; // –í–æ –≤—Ä–µ–º—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ –Ω–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏–º —é–Ω–∏—Ç–æ–≤
                }
                
                // –ü—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–æ —é–Ω–∏—Ç–æ–≤
                if (this.currentTraining) {
                    this.trainingProgress += deltaTime;
                    
                    if (this.trainingProgress >= UNIT_TYPES[this.currentTraining].trainTime) {
                        // –°–æ–∑–¥–∞—ë–º —é–Ω–∏—Ç–∞
                        const owner = this.isPlayer ? gameState.player : gameState.enemy;
                        owner.supply += UNIT_TYPES[this.currentTraining].supply;
                        gameState.units.push(new Unit(this.x + 1, this.y + 1, this.currentTraining, this.isPlayer));
                        
                        this.currentTraining = null;
                        this.trainingProgress = 0;
                        
                        // –ë–µ—Ä—ë–º —Å–ª–µ–¥—É—é—â–µ–≥–æ –∏–∑ –æ—á–µ—Ä–µ–¥–∏
                        if (this.trainingQueue.length > 0) {
                            this.currentTraining = this.trainingQueue.shift();
                        }
                    }
                } else if (this.trainingQueue.length > 0) {
                    this.currentTraining = this.trainingQueue.shift();
                    this.trainingProgress = 0;
                }
                
                // –ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è
                if (this.currentResearch !== null) {
                    this.researchProgress += deltaTime;
                    const stats = BUILDING_TYPES[this.type];
                    const research = stats.researches[this.currentResearch];
                    
                    if (this.researchProgress >= research.time) {
                        // –ó–∞–≤–µ—Ä—à–∞–µ–º –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ
                        const owner = this.isPlayer ? gameState.player : gameState.enemy;
                        const researchKey = `${this.type}_${this.currentResearch}`;
                        owner.researches.add(researchKey);
                        
                        // –ü—Ä–∏–º–µ–Ω—è–µ–º —É–ª—É—á—à–µ–Ω–∏–µ
                        gameState.units.filter(u => u.isPlayer === this.isPlayer).forEach(unit => {
                            if (research.effect === 'damage') {
                                UNIT_TYPES[unit.type].damage += research.value;
                            } else if (research.effect === 'armor') {
                                unit.maxHp += research.value * 10;
                                unit.hp += research.value * 10;
                            }
                        });
                        
                        gameState.showMessage(`‚úì –ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ: ${research.name}`, 3000);
                        
                        this.currentResearch = null;
                        this.researchProgress = 0;
                    }
                }
            }
            
            trainUnit(unitType) {
                this.trainingQueue.push(unitType);
            }
            
            startResearch(researchIdx) {
                this.currentResearch = researchIdx;
                this.researchProgress = 0;
            }
        }
        
        // ============================================================================
        // –†–ï–ù–î–ï–†–ò–ù–ì
        // ============================================================================
        
        class Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }
            
            resize() {
                this.canvas.width = this.canvas.parentElement.clientWidth;
                this.canvas.height = this.canvas.parentElement.clientHeight;
            }
            
            worldToScreen(x, y, gameState) {
                const isoX = (x - y) * (TILE_WIDTH / 2);
                const isoY = (x + y) * (TILE_HEIGHT / 2);
                
                return {
                    x: isoX + this.canvas.width / 2 - gameState.camera.x,
                    y: isoY + 100 - gameState.camera.y
                };
            }
            
            screenToWorld(screenX, screenY, gameState) {
                const adjustedX = screenX - this.canvas.width / 2 + gameState.camera.x;
                const adjustedY = screenY - 100 + gameState.camera.y;
                
                const worldX = (adjustedX / (TILE_WIDTH / 2) + adjustedY / (TILE_HEIGHT / 2)) / 2;
                const worldY = (adjustedY / (TILE_HEIGHT / 2) - adjustedX / (TILE_WIDTH / 2)) / 2;
                
                return { x: worldX, y: worldY };
            }
            
            render(gameState) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // –†–∏—Å—É–µ–º terrain
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        this.drawTile(x, y, gameState.map[y][x], gameState);
                    }
                }
                
                // –†–∏—Å—É–µ–º –∑–¥–∞–Ω–∏—è
                gameState.buildings.forEach(building => {
                    this.drawBuilding(building, gameState);
                });
                
                // –†–∏—Å—É–µ–º —é–Ω–∏—Ç–æ–≤
                gameState.units.forEach(unit => {
                    this.drawUnit(unit, gameState);
                });
                
                // –†–∏—Å—É–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
                if (gameState.buildMode) {
                    this.drawBuildPreview(gameState);
                }
                
                // –†–∏—Å—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
                this.drawMessages(gameState);
            }
            
            drawMessages(gameState) {
                gameState.messages.forEach((msg, index) => {
                    const alpha = Math.min(1, (msg.time + msg.duration - gameState.time) / 1000);
                    
                    this.ctx.fillStyle = `rgba(0, 255, 65, ${alpha})`;
                    this.ctx.font = 'bold 18px JetBrains Mono';
                    this.ctx.textAlign = 'center';
                    this.ctx.strokeStyle = `rgba(0, 0, 0, ${alpha})`;
                    this.ctx.lineWidth = 3;
                    
                    const y = 50 + index * 30;
                    this.ctx.strokeText(msg.text, this.canvas.width / 2, y);
                    this.ctx.fillText(msg.text, this.canvas.width / 2, y);
                });
            }
            
            drawTile(x, y, terrain, gameState) {
                const screen = this.worldToScreen(x, y, gameState);
                
                // –†–∏—Å—É–µ–º —Ä–æ–º–±
                this.ctx.fillStyle = terrain.color;
                this.ctx.beginPath();
                this.ctx.moveTo(screen.x, screen.y);
                this.ctx.lineTo(screen.x + TILE_WIDTH / 2, screen.y + TILE_HEIGHT / 2);
                this.ctx.lineTo(screen.x, screen.y + TILE_HEIGHT);
                this.ctx.lineTo(screen.x - TILE_WIDTH / 2, screen.y + TILE_HEIGHT / 2);
                this.ctx.closePath();
                this.ctx.fill();
                
                // –†–∏—Å—É–µ–º —Å–∏–º–≤–æ–ª
                this.ctx.fillStyle = '#000';
                this.ctx.font = '16px JetBrains Mono';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(terrain.char, screen.x, screen.y + TILE_HEIGHT / 2);
                
                // –†–∏—Å—É–µ–º —Å—á—ë—Ç—á–∏–∫ —Ä–µ—Å—É—Ä—Å–æ–≤
                if (terrain.resource) {
                    const tileKey = `${x},${y}`;
                    const remaining = gameState.resourceTiles.get(tileKey) || 0;
                    
                    if (remaining > 0) {
                        this.ctx.fillStyle = terrain.resource === 'gold' ? '#ffd700' : '#8b4513';
                        this.ctx.font = '9px JetBrains Mono';
                        this.ctx.fillText(remaining, screen.x, screen.y + TILE_HEIGHT / 2 + 12);
                    }
                }
            }
            
            drawUnit(unit, gameState) {
                const screen = this.worldToScreen(unit.x, unit.y, gameState);
                const stats = UNIT_TYPES[unit.type];
                
                // –¢–µ–Ω—å
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.beginPath();
                this.ctx.ellipse(screen.x, screen.y + 25, 18, 6, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // –§–æ–Ω —é–Ω–∏—Ç–∞ (–∫–æ–º–∞–Ω–¥–∞)
                this.ctx.fillStyle = unit.isPlayer ? 'rgba(0, 255, 65, 0.3)' : 'rgba(255, 68, 68, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(screen.x, screen.y, 22, 0, Math.PI * 2);
                this.ctx.fill();
                
                // –û–±–≤–æ–¥–∫–∞ –∏–∫–æ–Ω–∫–∏ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞
                this.ctx.strokeStyle = unit.isPlayer ? '#00ff41' : '#ff4444';
                this.ctx.lineWidth = 3;
                this.ctx.font = '28px JetBrains Mono';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.strokeText(stats.icon, screen.x, screen.y);
                
                // –ò–∫–æ–Ω–∫–∞ —é–Ω–∏—Ç–∞
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillText(stats.icon, screen.x, screen.y);
                
                // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–Ω–æ—Å–∏–º—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
                if (unit.carrying && unit.carryAmount > 0) {
                    const resourceIcon = unit.carrying === 'GOLD' ? 'üí∞' : 'ü™µ';
                    this.ctx.font = '16px JetBrains Mono';
                    this.ctx.fillText(resourceIcon, screen.x + 20, screen.y - 20);
                    
                    // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ—Å—É—Ä—Å–∞
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.fillText(unit.carryAmount, screen.x + 20, screen.y - 5);
                }
                
                // HP bar —Å –æ–±–≤–æ–¥–∫–æ–π
                const barWidth = 35;
                const barHeight = 5;
                const hpPercent = unit.hp / unit.maxHp;
                
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(screen.x - barWidth / 2, screen.y - 25, barWidth, barHeight);
                
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(screen.x - barWidth / 2, screen.y - 25, barWidth, barHeight);
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillRect(screen.x - barWidth / 2, screen.y - 25, barWidth * hpPercent, barHeight);
                
                // –í—ã–¥–µ–ª–µ–Ω–∏–µ
                if (gameState.selectedUnits.includes(unit)) {
                    this.ctx.strokeStyle = '#ffff00';
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.arc(screen.x, screen.y, 25, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }
            
            drawBuilding(building, gameState) {
                const screen = this.worldToScreen(building.x, building.y, gameState);
                const stats = BUILDING_TYPES[building.type];
                
                // –û—Å–Ω–æ–≤–∞–Ω–∏–µ –∑–¥–∞–Ω–∏—è
                const width = stats.width * TILE_WIDTH / 2;
                const height = stats.height * TILE_HEIGHT / 2;
                
                // –¢–µ–Ω—å –∑–¥–∞–Ω–∏—è
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                this.ctx.fillRect(screen.x - width / 2 + 5, screen.y - height / 2 + 5, width, height);
                
                // –§–æ–Ω –∑–¥–∞–Ω–∏—è (–∫–æ–º–∞–Ω–¥–∞) - –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π –µ—Å–ª–∏ —Å—Ç—Ä–æ–∏—Ç—Å—è
                const alpha = building.isUnderConstruction ? 0.1 : 0.2;
                this.ctx.fillStyle = building.isPlayer ? `rgba(0, 255, 65, ${alpha})` : `rgba(255, 68, 68, ${alpha})`;
                this.ctx.fillRect(screen.x - width / 2, screen.y - height / 2, width, height);
                
                // –ì—Ä–∞–Ω–∏—Ü–∞ –∑–¥–∞–Ω–∏—è
                this.ctx.strokeStyle = building.isPlayer ? '#00ff41' : '#ff4444';
                this.ctx.lineWidth = building.isUnderConstruction ? 1 : 2;
                this.ctx.setLineDash(building.isUnderConstruction ? [5, 5] : []);
                this.ctx.strokeRect(screen.x - width / 2, screen.y - height / 2, width, height);
                this.ctx.setLineDash([]);
                
                // –û–±–≤–æ–¥–∫–∞ –∏–∫–æ–Ω–∫–∏ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞
                this.ctx.strokeStyle = building.isPlayer ? '#00ff41' : '#ff4444';
                this.ctx.lineWidth = 4;
                this.ctx.font = '42px JetBrains Mono';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.strokeText(stats.icon, screen.x, screen.y + 10);
                
                // –ò–∫–æ–Ω–∫–∞ –∑–¥–∞–Ω–∏—è - –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è –µ—Å–ª–∏ —Å—Ç—Ä–æ–∏—Ç—Å—è
                this.ctx.globalAlpha = building.isUnderConstruction ? 0.5 : 1.0;
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillText(stats.icon, screen.x, screen.y + 10);
                this.ctx.globalAlpha = 1.0;
                
                // –ü—Ä–æ–≥—Ä–µ—Å—Å —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
                if (building.isUnderConstruction) {
                    const progress = building.buildProgress / building.buildTime;
                    const barWidth = width;
                    const barHeight = 10;
                    
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(screen.x - barWidth / 2, screen.y + height / 2 + 5, barWidth, barHeight);
                    
                    this.ctx.fillStyle = '#ffaa00';
                    this.ctx.fillRect(screen.x - barWidth / 2, screen.y + height / 2 + 5, barWidth * progress, barHeight);
                    
                    this.ctx.strokeStyle = '#000000';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(screen.x - barWidth / 2, screen.y + height / 2 + 5, barWidth, barHeight);
                    
                    // –¢–µ–∫—Å—Ç –ø—Ä–æ—Ü–µ–Ω—Ç–∞
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '10px JetBrains Mono';
                    this.ctx.fillText(`${Math.floor(progress * 100)}%`, screen.x, screen.y + height / 2 + 10);
                }
                
                // HP bar —Å –æ–±–≤–æ–¥–∫–æ–π (—Ç–æ–ª—å–∫–æ –¥–ª—è –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö –∑–¥–∞–Ω–∏–π)
                if (!building.isUnderConstruction) {
                    const barWidth = width;
                    const barHeight = 8;
                    const hpPercent = building.hp / building.maxHp;
                    
                    this.ctx.strokeStyle = '#000000';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(screen.x - barWidth / 2, screen.y - height / 2 - 12, barWidth, barHeight);
                    
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.fillRect(screen.x - barWidth / 2, screen.y - height / 2 - 12, barWidth, barHeight);
                    this.ctx.fillStyle = '#00ff00';
                    this.ctx.fillRect(screen.x - barWidth / 2, screen.y - height / 2 - 12, barWidth * hpPercent, barHeight);
                }
                
                // –í—ã–¥–µ–ª–µ–Ω–∏–µ
                if (gameState.selectedBuilding === building) {
                    this.ctx.strokeStyle = '#ffff00';
                    this.ctx.lineWidth = 4;
                    this.ctx.setLineDash([8, 8]);
                    this.ctx.strokeRect(screen.x - width / 2 - 4, screen.y - height / 2 - 4, width + 8, height + 8);
                    this.ctx.setLineDash([]);
                }
            }
            
            drawBuildPreview(gameState) {
                const mouseWorld = this.screenToWorld(input.mouseX, input.mouseY, gameState);
                const gridX = Math.floor(mouseWorld.x);
                const gridY = Math.floor(mouseWorld.y);
                const screen = this.worldToScreen(gridX, gridY, gameState);
                
                const building = BUILDING_TYPES[gameState.buildMode];
                const canPlace = gameState.canPlaceBuilding(gridX, gridY, gameState.buildMode);
                
                this.ctx.fillStyle = canPlace ? 'rgba(0, 255, 65, 0.3)' : 'rgba(255, 0, 0, 0.3)';
                const width = building.width * TILE_WIDTH / 2;
                const height = building.height * TILE_HEIGHT / 2;
                this.ctx.fillRect(screen.x - width / 2, screen.y - height / 2, width, height);
                
                this.ctx.font = '36px JetBrains Mono';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(building.icon, screen.x, screen.y + 10);
            }
        }
        
        // ============================================================================
        // –í–í–û–î
        // ============================================================================
        
        class InputHandler {
            constructor(canvas) {
                this.canvas = canvas;
                this.mouseX = 0;
                this.mouseY = 0;
                this.isDragging = false;
                this.dragStartX = 0;
                this.dragStartY = 0;
                
                canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouseX = e.clientX - rect.left;
                this.mouseY = e.clientY - rect.top;
                
                if (this.isDragging) {
                    gameState.camera.x -= (e.clientX - this.dragStartX);
                    gameState.camera.y -= (e.clientY - this.dragStartY);
                    this.dragStartX = e.clientX;
                    this.dragStartY = e.clientY;
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–∞–π–ª–µ
                this.updateTerrainInfo();
            }
            
            updateTerrainInfo() {
                const worldPos = renderer.screenToWorld(this.mouseX, this.mouseY, gameState);
                const gridX = Math.floor(worldPos.x);
                const gridY = Math.floor(worldPos.y);
                
                if (gridX >= 0 && gridY >= 0 && gridX < MAP_WIDTH && gridY < MAP_HEIGHT) {
                    const terrain = gameState.map[gridY][gridX];
                    const terrainInfo = document.getElementById('terrain-info');
                    
                    let terrainName = '';
                    let terrainDesc = '';
                    
                    if (terrain === TERRAIN_TYPES.GRASS) {
                        terrainName = '‚ñì –¢—Ä–∞–≤–∞';
                        terrainDesc = '–û–±—ã—á–Ω–∞—è –∑–µ–º–ª—è';
                    } else if (terrain === TERRAIN_TYPES.FOREST) {
                        terrainName = '‚ô† –õ–µ—Å';
                        const tileKey = `${gridX},${gridY}`;
                        const remaining = gameState.resourceTiles.get(tileKey) || 0;
                        terrainDesc = `–î—Ä–µ–≤–µ—Å–∏–Ω–∞: ${remaining}`;
                    } else if (terrain === TERRAIN_TYPES.GOLD) {
                        terrainName = '‚óÜ –ó–æ–ª–æ—Ç–æ';
                        const tileKey = `${gridX},${gridY}`;
                        const remaining = gameState.resourceTiles.get(tileKey) || 0;
                        terrainDesc = `–ó–æ–ª–æ—Ç–æ: ${remaining}`;
                    } else if (terrain === TERRAIN_TYPES.WATER) {
                        terrainName = '‚âà –í–æ–¥–∞';
                        terrainDesc = '–ù–µ–ø—Ä–æ—Ö–æ–¥–∏–º–æ';
                    } else if (terrain === TERRAIN_TYPES.MOUNTAIN) {
                        terrainName = '‚ñ≤ –ì–æ—Ä—ã';
                        terrainDesc = '–ù–µ–ø—Ä–æ—Ö–æ–¥–∏–º–æ';
                    } else if (terrain === TERRAIN_TYPES.DEPLETED) {
                        terrainName = '‚ñë –ò—Å—Ç–æ—â–µ–Ω–æ';
                        terrainDesc = '–†–µ—Å—É—Ä—Å –∏—Å—á–µ—Ä–ø–∞–Ω';
                    }
                    
                    terrainInfo.innerHTML = `
                        <div style="color: #00ff41; font-weight: bold; margin-bottom: 5px;">${terrainName}</div>
                        <div style="color: #7fff7f; font-size: 11px;">${terrainDesc}</div>
                        <div style="color: #7fff7f; font-size: 11px; margin-top: 5px;">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: ${gridX}, ${gridY}</div>
                    `;
                }
            }
            
            handleMouseDown(e) {
                if (e.button === 1) { // –°—Ä–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞ (–∫–æ–ª–µ—Å–æ)
                    this.isDragging = true;
                    this.dragStartX = e.clientX;
                    this.dragStartY = e.clientY;
                    e.preventDefault();
                }
            }
            
            handleMouseUp(e) {
                if (e.button === 1) {
                    this.isDragging = false;
                    return;
                }
                
                const worldPos = renderer.screenToWorld(this.mouseX, this.mouseY, gameState);
                
                if (gameState.buildMode) {
                    this.handleBuildClick(worldPos);
                } else if (e.button === 0) { // –õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞
                    this.handleLeftClick(worldPos);
                } else if (e.button === 2) { // –ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞
                    this.handleRightClick(worldPos);
                }
            }
            
            handleLeftClick(worldPos) {
                const clickedUnit = gameState.units.find(u => 
                    Math.abs(u.x - worldPos.x) < 0.5 && 
                    Math.abs(u.y - worldPos.y) < 0.5
                );
                
                if (clickedUnit && clickedUnit.isPlayer) {
                    gameState.selectedUnits = [clickedUnit];
                    gameState.selectedBuilding = null;
                    updateUI();
                    return;
                }
                
                const clickedBuilding = gameState.buildings.find(b => {
                    const stats = BUILDING_TYPES[b.type];
                    return worldPos.x >= b.x && worldPos.x < b.x + stats.width &&
                           worldPos.y >= b.y && worldPos.y < b.y + stats.height;
                });
                
                if (clickedBuilding && clickedBuilding.isPlayer) {
                    gameState.selectedUnits = [];
                    gameState.selectedBuilding = clickedBuilding;
                    updateUI();
                    return;
                }
                
                gameState.selectedUnits = [];
                gameState.selectedBuilding = null;
                updateUI();
            }
            
            handleRightClick(worldPos) {
                if (gameState.selectedUnits.length > 0) {
                    const gridX = Math.floor(worldPos.x);
                    const gridY = Math.floor(worldPos.y);
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∏–∫ –ø–æ –≤—Ä–∞–∂–µ—Å–∫–æ–º—É —é–Ω–∏—Ç—É
                    const enemy = gameState.units.find(u => 
                        !u.isPlayer &&
                        Math.abs(u.x - worldPos.x) < 0.5 && 
                        Math.abs(u.y - worldPos.y) < 0.5
                    );
                    
                    if (enemy) {
                        gameState.selectedUnits.forEach(unit => {
                            unit.target = enemy;
                            unit.path = [];
                            unit.autoAttack = true; // –í–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ–∞—Ç–∞–∫—É
                        });
                        return;
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∏–∫ –ø–æ –≤—Ä–∞–∂–µ—Å–∫–æ–º—É –∑–¥–∞–Ω–∏—é
                    const enemyBuilding = gameState.buildings.find(b => {
                        const stats = BUILDING_TYPES[b.type];
                        return !b.isPlayer &&
                               worldPos.x >= b.x && worldPos.x < b.x + stats.width &&
                               worldPos.y >= b.y && worldPos.y < b.y + stats.height;
                    });
                    
                    if (enemyBuilding) {
                        gameState.selectedUnits.forEach(unit => {
                            unit.attackBuilding = enemyBuilding;
                            unit.moveTo(enemyBuilding.x + 1, enemyBuilding.y + 1, gameState);
                        });
                        return;
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∏–∫ –ø–æ —Ä–µ—Å—É—Ä—Å–∞–º
                    if (gridX >= 0 && gridY >= 0 && gridX < MAP_WIDTH && gridY < MAP_HEIGHT) {
                        const terrain = gameState.map[gridY][gridX];
                        
                        if ((terrain === TERRAIN_TYPES.GOLD || terrain === TERRAIN_TYPES.FOREST) &&
                            gameState.selectedUnits.some(u => UNIT_TYPES[u.type].canGather)) {
                            gameState.selectedUnits.forEach(unit => {
                                if (UNIT_TYPES[unit.type].canGather) {
                                    unit.gatherTarget = { x: gridX, y: gridY, type: terrain === TERRAIN_TYPES.GOLD ? 'GOLD' : 'FOREST' };
                                    unit.target = null;
                                    unit.autoGather = true; // –í–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ—Å–±–æ—Ä
                                }
                            });
                            return;
                        }
                    }
                    
                    // –û–±—ã—á–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
                    gameState.selectedUnits.forEach(unit => {
                        unit.moveTo(gridX, gridY, gameState);
                        unit.autoAttack = false; // –í—ã–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ–∞—Ç–∞–∫—É –ø—Ä–∏ –æ–±—ã—á–Ω–æ–º –¥–≤–∏–∂–µ–Ω–∏–∏
                    });
                }
            }
            
            handleBuildClick(worldPos) {
                const gridX = Math.floor(worldPos.x);
                const gridY = Math.floor(worldPos.y);
                
                if (gameState.canPlaceBuilding(gridX, gridY, gameState.buildMode)) {
                    const cost = BUILDING_TYPES[gameState.buildMode].cost;
                    
                    if (gameState.player.gold >= cost.gold && gameState.player.wood >= cost.wood) {
                        // –°–ø–∏—Å—ã–≤–∞–µ–º —Ä–µ—Å—É—Ä—Å—ã
                        gameState.player.gold -= cost.gold;
                        gameState.player.wood -= cost.wood;
                        
                        // –°–æ–∑–¥–∞—ë–º –∑–¥–∞–Ω–∏–µ –≤ —Å—Ç–∞–¥–∏–∏ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
                        const buildTime = BUILDING_TYPES[gameState.buildMode].buildTime;
                        const newBuilding = new Building(gridX, gridY, gameState.buildMode, true, buildTime);
                        gameState.buildings.push(newBuilding);
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º supply –µ—Å–ª–∏ –µ—Å—Ç—å
                        gameState.player.maxSupply += BUILDING_TYPES[gameState.buildMode].provides || 0;
                        
                        // –ù–∞–∑–Ω–∞—á–∞–µ–º –∫—Ä–µ—Å—Ç—å—è–Ω–∏–Ω–∞ —Å—Ç—Ä–æ–∏—Ç—å
                        if (gameState.selectedUnits.length > 0) {
                            const builder = gameState.selectedUnits[0];
                            builder.buildingTarget = newBuilding;
                            builder.moveTo(gridX, gridY, gameState);
                        }
                        
                        gameState.buildMode = null;
                        updateUI();
                    }
                }
            }
        }
        
        // ============================================================================
        // UI
        // ============================================================================
        
        function updateUI() {
            document.getElementById('gold-amount').textContent = gameState.player.gold;
            document.getElementById('wood-amount').textContent = gameState.player.wood;
            document.getElementById('supply-amount').textContent = 
                `${gameState.player.supply}/${gameState.player.maxSupply}`;
            
            const selectionInfo = document.getElementById('selection-info');
            const actionsPanel = document.getElementById('actions-panel');
            const actionsContainer = document.getElementById('action-buttons-container');
            
            if (gameState.selectedUnits.length > 0) {
                const unit = gameState.selectedUnits[0];
                const stats = UNIT_TYPES[unit.type];
                
                let statusText = '';
                if (unit.buildingTarget) {
                    const progress = Math.floor((unit.buildingTarget.buildProgress / unit.buildingTarget.buildTime) * 100);
                    statusText = `<br>üî® –°—Ç—Ä–æ–∏—Ç: ${progress}%`;
                } else if (unit.autoGather) {
                    statusText = `<br>‚õè –ê–≤—Ç–æ—Å–±–æ—Ä –∞–∫—Ç–∏–≤–µ–Ω`;
                } else if (unit.autoAttack) {
                    statusText = `<br>‚öî –ê–≤—Ç–æ–∞—Ç–∞–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞`;
                }
                
                selectionInfo.innerHTML = `
                    <div class="unit-info">
                        <div class="unit-name">${stats.icon} ${stats.name}</div>
                        <div class="health-bar">
                            <div class="health-fill" style="width: ${(unit.hp / unit.maxHp) * 100}%"></div>
                        </div>
                        <div class="unit-stats">
                            HP: ${Math.floor(unit.hp)}/${unit.maxHp}<br>
                            –£—Ä–æ–Ω: ${stats.damage}<br>
                            –î–∞–ª—å–Ω–æ—Å—Ç—å: ${stats.range}<br>
                            –°–∫–æ—Ä–æ—Å—Ç—å: ${stats.speed}
                            ${unit.carrying ? `<br>–ù–µ—Å—ë—Ç: ${unit.carrying === 'GOLD' ? 'üí∞' : 'ü™µ'} ${unit.carryAmount}` : ''}
                            ${statusText}
                        </div>
                    </div>
                `;
                
                actionsPanel.style.display = 'block';
                let buttons = `
                    <button onclick="stopUnit()">‚è∏ –°—Ç–æ–ø</button>
                    <button onclick="patrolUnit()">üîÑ –ü–∞—Ç—Ä—É–ª—å</button>
                `;
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –µ—Å–ª–∏ –µ—Å—Ç—å
                if (stats.ability) {
                    const canUse = unit.abilityCooldown <= 0;
                    const cooldownText = canUse ? '' : `(${Math.ceil(unit.abilityCooldown / 1000)}s)`;
                    buttons += `
                        <button onclick="useAbility()" ${!canUse ? 'disabled' : ''}>
                            ${stats.ability.icon} ${stats.ability.name} ${cooldownText}
                        </button>
                    `;
                }
                
                actionsContainer.innerHTML = buttons;
            } else if (gameState.selectedBuilding) {
                const building = gameState.selectedBuilding;
                const stats = BUILDING_TYPES[building.type];
                
                let statusText = '';
                if (building.isUnderConstruction) {
                    const progress = Math.floor((building.buildProgress / building.buildTime) * 100);
                    statusText = `<br>üî® –°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ: ${progress}%`;
                } else if (building.currentTraining) {
                    const progress = Math.floor((building.trainingProgress / UNIT_TYPES[building.currentTraining].trainTime) * 100);
                    statusText = `<br>‚è≥ –û–±—É—á–µ–Ω–∏–µ ${UNIT_TYPES[building.currentTraining].icon}: ${progress}%`;
                } else if (building.currentResearch !== null) {
                    const research = stats.researches[building.currentResearch];
                    const progress = Math.floor((building.researchProgress / research.time) * 100);
                    statusText = `<br>üî¨ ${research.icon} ${research.name}: ${progress}%`;
                }
                
                if (building.trainingQueue.length > 0) {
                    statusText += `<br>üìã –í –æ—á–µ—Ä–µ–¥–∏: ${building.trainingQueue.length}`;
                }
                
                selectionInfo.innerHTML = `
                    <div class="unit-info">
                        <div class="unit-name">${stats.icon} ${stats.name}</div>
                        <div class="health-bar">
                            <div class="health-fill" style="width: ${(building.hp / building.maxHp) * 100}%"></div>
                        </div>
                        <div class="unit-stats">
                            HP: ${Math.floor(building.hp)}/${building.maxHp}
                            ${statusText}
                        </div>
                    </div>
                `;
                
                if ((stats.trains || stats.researches) && !building.isUnderConstruction) {
                    actionsPanel.style.display = 'block';
                    let buttons = '';
                    
                    // –ö–Ω–æ–ø–∫–∏ —Å–æ–∑–¥–∞–Ω–∏—è —é–Ω–∏—Ç–æ–≤
                    if (stats.trains) {
                        buttons += stats.trains.map(unitType => {
                            const unitStats = UNIT_TYPES[unitType];
                            const canAfford = gameState.player.gold >= unitStats.cost.gold && 
                                            gameState.player.wood >= unitStats.cost.wood &&
                                            gameState.player.supply + unitStats.supply <= gameState.player.maxSupply;
                            
                            return `
                                <button onclick="trainUnit('${unitType}')" ${!canAfford ? 'disabled' : ''}>
                                    <div class="build-icon">${unitStats.icon}</div>
                                    <div>${unitStats.name}</div>
                                    <div class="build-cost">üí∞${unitStats.cost.gold} üå≤${unitStats.cost.wood}</div>
                                </button>
                            `;
                        }).join('');
                    }
                    
                    // –ö–Ω–æ–ø–∫–∏ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–π
                    if (stats.researches) {
                        buttons += stats.researches.map((research, idx) => {
                            const researchKey = `${building.type}_${idx}`;
                            const isResearched = gameState.player.researches.has(researchKey);
                            const isResearching = building.currentResearch === idx;
                            const canAfford = !isResearched && !isResearching &&
                                            building.currentResearch === null &&
                                            gameState.player.gold >= research.cost.gold && 
                                            gameState.player.wood >= research.cost.wood;
                            
                            return `
                                <button onclick="doResearch(${idx})" ${!canAfford || isResearched || isResearching ? 'disabled' : ''}>
                                    <div class="build-icon">${research.icon}</div>
                                    <div style="font-size: 9px;">${research.name}</div>
                                    <div class="build-cost">${isResearched ? '‚úì' : isResearching ? '...' : `üí∞${research.cost.gold} üå≤${research.cost.wood}`}</div>
                                </button>
                            `;
                        }).join('');
                    }
                    
                    actionsContainer.innerHTML = buttons;
                } else {
                    actionsPanel.style.display = 'none';
                }
            } else {
                selectionInfo.innerHTML = '<p style="color: #7fff7f; font-size: 12px;">–í—ã–±–µ—Ä–∏—Ç–µ —é–Ω–∏—Ç –∏–ª–∏ –∑–¥–∞–Ω–∏–µ</p>';
                actionsPanel.style.display = 'none';
            }
            
            updateBuildMenu();
        }
        
        function updateBuildMenu() {
            const buildMenu = document.getElementById('build-menu');
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω –∫—Ä–µ—Å—Ç—å—è–Ω–∏–Ω –∏–ª–∏ –ø–µ–æ–Ω
            const hasBuilder = gameState.selectedUnits.length > 0 && 
                              UNIT_TYPES[gameState.selectedUnits[0].type].canBuild;
            
            if (!hasBuilder) {
                buildMenu.innerHTML = '<p style="color: #7fff7f; font-size: 11px; text-align: center; grid-column: 1/-1;">–í—ã–±–µ—Ä–∏—Ç–µ –∫—Ä–µ—Å—Ç—å—è–Ω–∏–Ω–∞ –∏–ª–∏ –ø–µ–æ–Ω–∞</p>';
                return;
            }
            
            const playerRace = gameState.player.race;
            
            const buildings = Object.entries(BUILDING_TYPES).filter(([key, stats]) => 
                stats.race === playerRace && stats.cost.gold > 0
            );
            
            buildMenu.innerHTML = buildings.map(([key, stats]) => {
                const canAfford = gameState.player.gold >= stats.cost.gold && 
                                gameState.player.wood >= stats.cost.wood;
                
                return `
                    <button class="build-btn" onclick="startBuild('${key}')" ${!canAfford ? 'disabled' : ''}>
                        <div class="build-icon">${stats.icon}</div>
                        <div style="font-size: 9px;">${stats.name}</div>
                        <div class="build-cost">üí∞${stats.cost.gold} üå≤${stats.cost.wood}</div>
                    </button>
                `;
            }).join('');
        }
        
        function startBuild(buildingType) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—ã–±—Ä–∞–Ω –∫—Ä–µ—Å—Ç—å—è–Ω–∏–Ω –∏–ª–∏ –ø–µ–æ–Ω
            if (gameState.selectedUnits.length === 0) return;
            
            const unit = gameState.selectedUnits[0];
            const stats = UNIT_TYPES[unit.type];
            
            if (!stats.canBuild) {
                gameState.showMessage('‚ö† –¢–æ–ª—å–∫–æ –∫—Ä–µ—Å—Ç—å—è–Ω–µ –∏ –ø–µ–æ–Ω—ã –º–æ–≥—É—Ç —Å—Ç—Ä–æ–∏—Ç—å!', 2000);
                return;
            }
            
            gameState.buildMode = buildingType;
        }
        
        function trainUnit(unitType) {
            if (!gameState.selectedBuilding) return;
            
            const unitStats = UNIT_TYPES[unitType];
            const cost = unitStats.cost;
            
            if (gameState.player.gold >= cost.gold && 
                gameState.player.wood >= cost.wood &&
                gameState.player.supply + unitStats.supply <= gameState.player.maxSupply) {
                
                gameState.player.gold -= cost.gold;
                gameState.player.wood -= cost.wood;
                
                const building = gameState.selectedBuilding;
                building.trainUnit(unitType);
                
                gameState.showMessage(`‚è≥ –û–±—É—á–µ–Ω–∏–µ ${unitStats.name}...`, 2000);
                updateUI();
            }
        }
        
        function stopUnit() {
            gameState.selectedUnits.forEach(unit => {
                unit.path = [];
                unit.target = null;
                unit.attackBuilding = null;
                unit.gatherTarget = null;
                unit.autoGather = false;
                unit.autoAttack = false;
                unit.buildingTarget = null;
            });
        }
        
        function patrolUnit() {
            // –ü—Ä–æ—Å—Ç–æ–π –ø–∞—Ç—Ä—É–ª—å - –¥–≤–∏–∂–µ–Ω–∏–µ –≤ —Å–ª—É—á–∞–π–Ω—É—é —Ç–æ—á–∫—É
            gameState.selectedUnits.forEach(unit => {
                const x = Math.floor(Math.random() * MAP_WIDTH);
                const y = Math.floor(Math.random() * MAP_HEIGHT);
                unit.moveTo(x, y, gameState);
            });
        }
        
        function useAbility() {
            if (gameState.selectedUnits.length === 0) return;
            
            const unit = gameState.selectedUnits[0];
            const stats = UNIT_TYPES[unit.type];
            
            if (!stats.ability || unit.abilityCooldown > 0) return;
            
            const ability = stats.ability;
            
            if (ability.effect === 'damage') {
                // –ü—Ä—è–º–æ–π —É—Ä–æ–Ω –æ–¥–Ω–æ–π —Ü–µ–ª–∏
                const enemies = gameState.units.filter(u => 
                    u.isPlayer !== unit.isPlayer &&
                    Math.abs(u.x - unit.x) <= ability.range &&
                    Math.abs(u.y - unit.y) <= ability.range
                );
                
                if (enemies.length > 0) {
                    enemies[0].hp -= ability.value;
                    unit.abilityCooldown = ability.cooldown;
                    gameState.showMessage(`${stats.icon} –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ${ability.icon}!`, 2000);
                    updateUI();
                }
            } else if (ability.effect === 'aoe_damage') {
                // –ê–û–ï —É—Ä–æ–Ω
                const enemies = gameState.units.filter(u => 
                    u.isPlayer !== unit.isPlayer &&
                    Math.abs(u.x - unit.x) <= ability.range &&
                    Math.abs(u.y - unit.y) <= ability.range
                );
                
                if (enemies.length > 0) {
                    enemies.forEach(enemy => {
                        enemy.hp -= ability.value;
                    });
                    unit.abilityCooldown = ability.cooldown;
                    gameState.showMessage(`${stats.icon} –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ${ability.icon}! –ê–û–ï —É—Ä–æ–Ω!`, 2000);
                    updateUI();
                }
            } else if (ability.effect === 'heal') {
                // –õ–µ—á–µ–Ω–∏–µ –æ–¥–Ω–æ–π —Ü–µ–ª–∏
                const allies = gameState.units.filter(u => 
                    u.isPlayer === unit.isPlayer &&
                    u.hp < u.maxHp &&
                    Math.abs(u.x - unit.x) <= ability.range &&
                    Math.abs(u.y - unit.y) <= ability.range
                );
                
                if (allies.length > 0) {
                    allies[0].hp = Math.min(allies[0].maxHp, allies[0].hp + ability.value);
                    unit.abilityCooldown = ability.cooldown;
                    gameState.showMessage(`${stats.icon} –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ${ability.icon}!`, 2000);
                    updateUI();
                }
            } else if (ability.effect === 'mass_heal') {
                // –ú–∞—Å—Å–æ–≤–æ–µ –ª–µ—á–µ–Ω–∏–µ
                const allies = gameState.units.filter(u => 
                    u.isPlayer === unit.isPlayer &&
                    u.hp < u.maxHp &&
                    Math.abs(u.x - unit.x) <= ability.range &&
                    Math.abs(u.y - unit.y) <= ability.range
                );
                
                if (allies.length > 0) {
                    allies.forEach(ally => {
                        ally.hp = Math.min(ally.maxHp, ally.hp + ability.value);
                    });
                    unit.abilityCooldown = ability.cooldown;
                    gameState.showMessage(`${stats.icon} –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ${ability.icon}! –ú–∞—Å—Å–æ–≤–æ–µ –ª–µ—á–µ–Ω–∏–µ!`, 2000);
                    updateUI();
                }
            } else if (ability.effect === 'speed_boost' || ability.effect === 'damage_boost') {
                // –ë–∞—Ñ—Ñ—ã - –≤—Ä–µ–º–µ–Ω–Ω–æ —É–≤–µ–ª–∏—á–∏–≤–∞—é—Ç —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
                unit.abilityCooldown = ability.cooldown;
                unit.buffDuration = ability.duration;
                unit.buffType = ability.effect;
                unit.buffValue = ability.value;
                gameState.showMessage(`${stats.icon} –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ${ability.icon}!`, 2000);
                updateUI();
            } else if (ability.effect === 'summon') {
                // –ü—Ä–∏–∑—ã–≤ —é–Ω–∏—Ç–∞
                const summonType = unit.isPlayer ? 'FOOTMAN' : 'GRUNT'; // –ü—Ä–æ—Å—Ç–æ–π —é–Ω–∏—Ç
                gameState.units.push(new Unit(unit.x + 1, unit.y, summonType, unit.isPlayer));
                unit.abilityCooldown = ability.cooldown;
                gameState.showMessage(`${stats.icon} –ø—Ä–∏–∑—ã–≤–∞–µ—Ç —Å—É—â–µ—Å—Ç–≤–æ!`, 2000);
                updateUI();
            }
        }
        
        function doResearch(researchIdx) {
            if (!gameState.selectedBuilding) return;
            
            const building = gameState.selectedBuilding;
            const stats = BUILDING_TYPES[building.type];
            
            if (!stats.researches || researchIdx >= stats.researches.length) return;
            
            const research = stats.researches[researchIdx];
            const researchKey = `${building.type}_${researchIdx}`;
            
            if (gameState.player.researches.has(researchKey)) return;
            if (building.currentResearch !== null) return; // –£–∂–µ –∏—Å—Å–ª–µ–¥—É–µ–º —á—Ç–æ-—Ç–æ
            
            if (gameState.player.gold >= research.cost.gold && 
                gameState.player.wood >= research.cost.wood) {
                
                gameState.player.gold -= research.cost.gold;
                gameState.player.wood -= research.cost.wood;
                
                building.startResearch(researchIdx);
                
                gameState.showMessage(`üî¨ –ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ: ${research.name}...`, 2000);
                updateUI();
            }
        }
        
        // ============================================================================
        // –ú–ò–ù–ò–ö–ê–†–¢–ê
        // ============================================================================
        
        function renderMinimap() {
            const minimap = document.getElementById('minimap');
            const ctx = minimap.getContext('2d');
            
            const scaleX = minimap.width / MAP_WIDTH;
            const scaleY = minimap.height / MAP_HEIGHT;
            
            ctx.clearRect(0, 0, minimap.width, minimap.height);
            
            // –†–∏—Å—É–µ–º terrain
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    ctx.fillStyle = gameState.map[y][x].color;
                    ctx.fillRect(x * scaleX, y * scaleY, scaleX, scaleY);
                }
            }
            
            // –†–∏—Å—É–µ–º –∑–¥–∞–Ω–∏—è
            gameState.buildings.forEach(b => {
                ctx.fillStyle = b.isPlayer ? '#00ff41' : '#ff4444';
                ctx.fillRect(b.x * scaleX, b.y * scaleY, scaleX * 2, scaleY * 2);
            });
            
            // –†–∏—Å—É–µ–º —é–Ω–∏—Ç–æ–≤
            gameState.units.forEach(u => {
                ctx.fillStyle = u.isPlayer ? '#7fff7f' : '#ff8888';
                ctx.fillRect(u.x * scaleX - 1, u.y * scaleY - 1, 2, 2);
            });
        }
        
        // ============================================================================
        // –ò–ì–†–û–í–û–ô –¶–ò–ö–õ
        // ============================================================================
        
        let gameState, renderer, input;
        let lastTime = 0;
        
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            gameState.update(deltaTime);
            renderer.render(gameState);
            renderMinimap();
            
            requestAnimationFrame(gameLoop);
        }
        
        function init() {
            const canvas = document.getElementById('game-canvas');
            gameState = new GameState();
            renderer = new Renderer(canvas);
            input = new InputHandler(canvas);
            
            updateUI();
            requestAnimationFrame(gameLoop);
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>