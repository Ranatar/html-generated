<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Философские основания эстетики комплексного переменного</title>
    <style>
        :root {
            --primary-bg: #080822;
            --text-color: #f0f0f0;
            --accent-color: #aa64f8;
            --secondary-accent: #0bd9d9;
            --tertiary-accent: #ff6b6b;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: var(--primary-bg);
            color: var(--text-color);
            font-family: 'Helvetica Neue', Arial, sans-serif;
            overflow-x: hidden;
            transition: background-color 1.5s;
        }
        
        #main-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.8;
            transition: opacity 1s;
        }
        
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 20%, rgba(8,8,34,0.7) 70%);
            z-index: 0;
            pointer-events: none;
        }
        
        .container {
            position: relative;
            z-index: 1;
            max-width: 100%;
            margin: 0 auto;
            overflow-x: hidden;
        }
        
        header {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 0 2rem;
        }
        
        h1 {
            font-size: 3.5rem;
            margin-bottom: 1.5rem;
            color: var(--text-color);
            text-shadow: 0 0 15px var(--accent-color), 0 0 30px rgba(170, 100, 248, 0.5);
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 1.5s forwards 0.5s;
        }
        
        .subtitle {
            font-size: 1.5rem;
            max-width: 800px;
            margin-bottom: 2rem;
            line-height: 1.6;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 1.5s forwards 1s;
        }
        
        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .scroll-indicator {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            animation: fadeIn 1.5s forwards 2s;
        }
        
        .scroll-indicator p {
            margin-bottom: 0.5rem;
        }
        
        .scroll-indicator .arrow {
            width: 20px;
            height: 20px;
            border-right: 3px solid var(--text-color);
            border-bottom: 3px solid var(--text-color);
            transform: rotate(45deg);
            animation: bounce 2s infinite;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0) rotate(45deg);
            }
            40% {
                transform: translateY(-10px) rotate(45deg);
            }
            60% {
                transform: translateY(-5px) rotate(45deg);
            }
        }
        
        section {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 4rem 2rem;
            position: relative;
            overflow: hidden;
        }
        
        .section-content {
            max-width: 800px;
            margin: 0 auto;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 1s, transform 1s;
        }
        
        .section-content.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        h2 {
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
            color: var(--accent-color);
        }
        
        p {
            font-size: 1.1rem;
            line-height: 1.7;
            margin-bottom: 1.5rem;
        }
        
        .interactive-element {
            margin: 2rem 0;
            padding: 1rem;
            border-radius: 10px;
            background-color: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .interactive-element:hover {
            background-color: rgba(255, 255, 255, 0.1);
            transform: translateY(-5px);
        }
        
        .interactive-canvas {
            width: 100%;
            height: 300px;
            border-radius: 8px;
            margin: 1rem 0;
        }
        
        .function-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 1rem 0;
            flex-wrap: wrap;
        }
        
        .control-button {
            padding: 0.5rem 1rem;
            border: none;
            background-color: var(--accent-color);
            color: white;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .control-button:hover {
            background-color: #8840e2;
            transform: scale(1.05);
        }
        
        .dual-pane {
            display: flex;
            gap: 2rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }
        
        .dual-pane > div {
            flex: 1 1 300px;
        }
        
        #function-explorer {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background-color: rgba(10, 10, 40, 0.9);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(170, 100, 248, 0.5);
        }
        
        #function-explorer:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(170, 100, 248, 0.8);
        }
        
        #function-explorer-icon {
            width: 30px;
            height: 30px;
            fill: var(--accent-color);
        }
        
        #function-panel {
            position: fixed;
            bottom: -400px;
            right: 2rem;
            width: 320px;
            height: 380px;
            background-color: rgba(15, 15, 50, 0.95);
            border-radius: 15px;
            padding: 1.5rem;
            transition: bottom 0.5s cubic-bezier(0.17, 0.67, 0.83, 0.67);
            z-index: 99;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        #function-panel.open {
            bottom: 2rem;
        }
        
        #panel-canvas {
            width: 100%;
            height: 200px;
            border-radius: 8px;
            margin-bottom: 1rem;
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .slider-control {
            margin: 1rem 0;
        }
        
        .slider-control label {
            display: block;
            margin-bottom: 0.5rem;
        }
        
        .slider-control input {
            width: 100%;
        }
        
        #panel-function-select {
            width: 100%;
            padding: 0.5rem;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            border: none;
            border-radius: 5px;
            margin-bottom: 1rem;
        }
        
        #panel-function-select option {
            background-color: #151540;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        
        .modal.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .modal-content {
            background-color: var(--primary-bg);
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 2rem;
            border-radius: 10px;
            position: relative;
        }
        
        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-color);
            cursor: pointer;
        }
        
        #concept-map {
            position: fixed;
            top: 2rem;
            left: 2rem;
            cursor: pointer;
            z-index: 100;
            width: 50px;
            height: 50px;
            background-color: rgba(10, 10, 40, 0.9);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(11, 217, 217, 0.5);
        }
        
        #concept-map:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(11, 217, 217, 0.8);
        }
        
        #concept-map-icon {
            width: 25px;
            height: 25px;
            fill: var(--secondary-accent);
        }
        
        #concept-modal {
            background-color: rgba(8, 8, 34, 0.95);
        }
        
        #concept-canvas {
            width: 100%;
            height: 500px;
            margin-top: 1rem;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            
            .subtitle {
                font-size: 1.2rem;
            }
            
            h2 {
                font-size: 2rem;
            }
            
            #function-panel {
                width: 90%;
                right: 5%;
            }
            
            .dual-pane {
                flex-direction: column;
            }
        }
        
        /* Transition styles */
        .fade-transition {
            transition: opacity 1s, transform 1s;
        }
        
        .parallel-section {
            display: flex;
            position: relative;
            min-height: 100vh;
        }
        
        .half-section {
            flex: 1;
            padding: 4rem 2rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .half-section.text {
            background-color: rgba(8, 8, 34, 0.7);
        }
        
        .visual-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        @media (max-width: 1024px) {
            .parallel-section {
                flex-direction: column;
            }
            
            .half-section {
                width: 100%;
            }
            
            .half-section.visual {
                height: 50vh;
            }
            
            .control-button.active {
                background-color: #8840e2;
                transform: scale(1.05);
                box-shadow: 0 0 10px rgba(170, 100, 248, 0.8);
            }
            
        }
    </style>
</head>
<body>
    <canvas id="main-canvas"></canvas>
    <div id="overlay"></div>
    
    <div id="concept-map">
        <svg id="concept-map-icon" viewBox="0 0 24 24">
            <path d="M3,3H21V21H3V3M7,7V9H9V7H7M11,7V9H13V7H11M15,7V9H17V7H15M7,11V13H9V11H7M11,11V13H13V11H11M15,11V13H17V11H15M7,15V17H9V15H7M11,15V17H13V15H11M15,15V17H17V15H15Z" />
        </svg>
    </div>
    
    <div id="function-explorer">
        <svg id="function-explorer-icon" viewBox="0 0 24 24">
            <path d="M18.7,12.4C18.9,12.3 19.1,12.2 19.3,12.2C20.4,12.2 21.5,13 21.5,14C21.5,15 20.4,15.8 19.3,15.8C18.2,15.8 17.1,15 17.1,14C17.1,13.8 17.2,13.5 17.2,13.3L15.8,12.5C15.7,12.8 15.5,13.1 15.3,13.3L16.6,16C16.8,16 17,16 17.2,16C18.3,16 19.4,16.8 19.4,17.8C19.4,18.8 18.3,19.6 17.2,19.6C16.1,19.6 15,18.8 15,17.8C15,17.7 15,17.5 15.1,17.4L13.8,14.7C13.5,14.9 13.1,15 12.7,15C12.4,15 12.1,14.9 11.8,14.8L10.3,16.5C10.4,16.6 10.4,16.8 10.4,17C10.4,17.9 9.3,18.7 8.1,18.7C7,18.7 5.8,18 5.8,17C5.8,16 6.9,15.2 8.1,15.2C8.3,15.2 8.6,15.3 8.8,15.3L10.3,13.6C10.1,13.4 9.9,13 9.8,12.7L6.6,13.2C6.4,14 5.5,14.7 4.5,14.7C3.4,14.7 2.5,13.9 2.5,12.9C2.5,11.9 3.4,11.1 4.5,11.1C5.1,11.1 5.8,11.4 6.2,11.9L9.4,11.4C9.5,10.7 10.1,10 11,10C11.7,10 12.3,10.5 12.6,11.1L14.5,10.5C14.5,10.3 14.5,10.2 14.5,10C14.5,9 15.6,8.2 16.7,8.2C17.8,8.2 18.9,9 18.9,10C18.9,11 17.8,11.8 16.7,11.8C16.3,11.8 15.9,11.7 15.6,11.5L13.6,12.2C13.6,12.3 13.6,12.5 13.6,12.6C13.6,12.9 13.5,13.1 13.4,13.3L18.7,12.4Z" />
        </svg>
    </div>
    
    <div id="function-panel">
        <h3>Исследователь функций</h3>
        <select id="panel-function-select">
            <option value="mandelbrot">Множество Мандельброта</option>
            <option value="julia">Множество Жюлиа</option>
            <option value="exponential">Экспонента (e^z)</option>
            <option value="power">Степенная функция (z^n)</option>
            <option value="rational">Рациональная функция (1/z)</option>
            <option value="logarithm">Логарифм (ln z)</option>
            <option value="sine">Синус (sin z)</option>
        </select>
        <canvas id="panel-canvas"></canvas>
        <div class="slider-control">
            <label id="param-label">Параметр: <span id="param-value">0</span></label>
            <input type="range" id="param-slider" min="-2" max="2" step="0.01" value="0">
        </div>
        <div class="slider-control">
            <label id="zoom-label">Масштаб: <span id="zoom-value">1</span></label>
            <input type="range" id="zoom-slider" min="0.5" max="5" step="0.1" value="1">
        </div>
    </div>
    
    <div class="modal" id="concept-modal">
        <div class="modal-content">
            <button class="close-modal">&times;</button>
            <h2>Карта концепций эстетики комплексного переменного</h2>
            <p>Это интерактивная карта философских концепций, связанных с эстетикой визуализации функций комплексного переменного. Каждый узел представляет основное понятие, а связи между ними отражают философские отношения.</p>
            <canvas id="concept-canvas"></canvas>
        </div>
    </div>
    
    <div class="container">
        <header>
            <h1>Философские основания эстетики комплексного переменного</h1>
            <p class="subtitle">На границе между математической абстракцией и чувственным восприятием рождается особая эстетика, имеющая глубокие философские основания</p>
            <div class="scroll-indicator">
                <p>Прокрутите вниз для исследования</p>
                <div class="arrow"></div>
            </div>
        </header>
        
        <section id="ontology">
            <div class="section-content">
                <h2>Онтология эстетического</h2>
                <p>Визуализация комплексных функций открывает фундаментальный онтологический вопрос об источнике их эстетических качеств. В этой сфере сталкиваются три философские перспективы: платоническая, конструктивистская и структуралистская.</p>
                
                <div class="interactive-element" id="ontology-interactive">
                    <h3>Три онтологические перспективы</h3>
                    <canvas class="interactive-canvas" id="ontology-canvas"></canvas>
                    <div class="function-controls">
                        <button class="control-button" data-perspective="platonic">Платоническая</button>
                        <button class="control-button" data-perspective="constructivist">Конструктивистская</button>
                        <button class="control-button" data-perspective="structuralist">Структуралистская</button>
                    </div>
                </div>
                
                <p>Платоническая традиция рассматривает красоту визуализаций как проявление идеальной математической структуры, как "сияние истины". Конструктивистский подход утверждает, что эстетические качества создаются в процессе визуализации и восприятия, будучи культурно обусловленными. Структуралистская перспектива сосредотачивается на отношениях и структурах как источнике эстетического опыта.</p>
            </div>
        </section>
        
        <section id="epistemology">
            <div class="section-content">
                <h2>Эпистемология эстетического восприятия</h2>
                <p>Эстетическое восприятие визуализированных комплексных функций играет особую эпистемическую роль в математическом познании. Как отмечал Анри Пуанкаре, математическая интуиция часто имеет эстетический характер: "Эстетические чувства играют роль сита, благодаря которому мы удерживаем именно те комбинации, которые могут привести нас к цели".</p>
                
                <div class="dual-pane">
                    <div>
                        <p>Визуализация комплексных функций, делая абстрактные математические структуры эстетически воспринимаемыми, создаёт уникальную эпистемическую ситуацию, в которой математическое понимание достигается через эстетическое созерцание.</p>
                        <p>История комплексного анализа знает примеры, когда визуальное представление приводило к математическим прозрениям. Так, геометрическая интерпретация комплексных чисел, предложенная Весселем и Арганом, позволила радикально переосмыслить природу этих математических объектов.</p>
                    </div>
                    <div>
                        <div class="interactive-element">
                            <h3>Когнитивное восприятие особых точек</h3>
                            <canvas class="interactive-canvas" id="singularity-canvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <section id="phenomenology">
            <div class="section-content">
                <h2>Феноменология эстетического восприятия</h2>
                <p>Феноменологический анализ позволяет исследовать сущностные структуры опыта, возникающего при эстетическом созерцании визуализированных комплексных функций. Визуализации порождают особый феноменологический опыт "видения невидимого" — непосредственного созерцания абстрактных математических структур.</p>
                
                <div class="interactive-element">
                    <h3>Пространственность римановых поверхностей</h3>
                    <canvas class="interactive-canvas" id="riemann-canvas"></canvas>
                    <p>Поверхность логарифмической функции с её бесконечно закрученной спиралью вокруг начала координат даёт наглядное представление о понятии монодромии и многозначности аналитических функций.</p>
                </div>
                
                <p>Гуссерль различал "чувственное созерцание", направленное на эмпирические объекты, и "категориальное созерцание", направленное на идеальные сущности. Восприятие визуализаций комплексных функций соединяет оба эти типа созерцания в уникальном синтезе, делая возможным непосредственное схватывание математического через чувственное.</p>
            </div>
        </section>
        
        <section class="parallel-section" id="aesthetics">
            <div class="half-section text">
                <div class="section-content">
                    <h2>Эстетические категории</h2>
                    <p>Понятие возвышенного (sublime), разработанное в эстетике Эдмунда Бёрка и Иммануила Канта, обретает новое значение в контексте визуализации комплексных функций. Множество Мандельброта, с его бесконечной сложностью и самоподобием, порождает эстетический опыт, сходный с кантианским возвышенным — мы одновременно потрясены неохватностью его структуры и воодушевлены возможностью постичь эту структуру математически.</p>
                    <p>Визуализации аналитических функций часто обладают поразительной симметрией, отражающей их математические свойства. Так, визуализация z^n демонстрирует n-кратную радиальную симметрию, связанную с n различными значениями n-го корня из единицы.</p>
                </div>
            </div>
            <div class="half-section visual">
                <div class="visual-container">
                    <canvas id="mandelbrot-canvas" style="width: 100%; height: 100%;"></canvas>
                </div>
            </div>
        </section>
        
        <section id="chaos-order">
            <div class="section-content">
                <h2>Между хаосом и порядком</h2>
                <p>Особую эстетическую категорию в визуализации комплексных функций представляет диалектика хаоса и порядка, особенно ярко проявляющаяся во фрактальных визуализациях.</p>
                
                <div class="interactive-element">
                    <h3>Границы порядка и хаоса</h3>
                    <canvas class="interactive-canvas" id="chaos-canvas"></canvas>
                    <p>Граница множества Мандельброта — это область, где порядок и хаос находятся в постоянном динамическом взаимодействии. С одной стороны, эта граница имеет бесконечную сложность и кажется хаотичной; с другой стороны, она подчиняется строгим математическим закономерностям и демонстрирует самоподобие на всех масштабах.</p>
                </div>
                
                <p>Бенуа Мандельброт, вводя понятие "фрактальной геометрии природы", подчёркивал, что многие природные структуры находятся в промежуточном положении между полным порядком евклидовой геометрии и полным хаосом. Фрактальные визуализации комплексных функций демонстрируют именно такую "геометрию между" — ни полностью регулярную, ни полностью случайную, но обладающую статистическим самоподобием и дробной размерностью.</p>
            </div>
        </section>
        
        <section id="sacred">
            <div class="section-content">
                <h2>Сакральное и трансцендентное</h2>
                <p>Визуализация комплексных функций часто воспринимается как своеобразное "откровение" скрытых математических истин. Этот аспект сближает её с религиозными и мистическими практиками, направленными на постижение невидимой реальности.</p>
                
                <div class="interactive-element">
                    <h3>Эстетика бесконечного</h3>
                    <canvas class="interactive-canvas" id="infinite-canvas"></canvas>
                </div>
                
                <p>Философ Рудольф Отто в работе "Священное" описал "нуминозное" — опыт встречи со священным, характеризующийся чувством "mysterium tremendum et fascinans" (тайны, внушающей трепет и одновременно очаровывающей). Восприятие некоторых визуализаций комплексных функций, особенно множества Мандельброта с его бесконечной сложностью, вызывает сходное чувство — сочетание интеллектуального благоговения перед сложностью структуры и эстетического восхищения её красотой.</p>
            </div>
        </section>
        
        <section id="connections">
            <div class="section-content">
                <h2>Эстетические взаимосвязи</h2>
                <p>Визуализации комплексных функций обнаруживают поразительные эстетические параллели с различными направлениями изобразительного искусства, что позволяет глубже понять их эстетическую природу.</p>
                
                <div class="dual-pane">
                    <div>
                        <p>Абстрактный экспрессионизм, представленный работами Василия Кандинского и Пита Мондриана, акцентировал внимание на выразительных возможностях цвета, линии и формы, освобожденных от миметической функции. Визуализации комплексных функций методом цветового кодирования (domain coloring) создают абстрактные композиции, напоминающие работы Кандинского.</p>
                    </div>
                    <div>
                        <div class="interactive-element">
                            <h3>Взаимосвязи с искусством</h3>
                            <canvas class="interactive-canvas" id="art-canvas"></canvas>
                        </div>
                    </div>
                </div>
                
                <p>Эстетика визуализации комплексных функций обнаруживает богатую палитру эстетических категорий — от математического возвышенного и гармонии до своеобразной эстетики разрывов и пограничной эстетики между хаосом и порядком. Эти категории позволяют осмыслить многообразие эстетических эффектов, возникающих при визуализации различных функций и их особенностей.</p>
            </div>
        </section>
        
        <section id="conclusion">
            <div class="section-content">
                <h2>На границе видимого и невидимого</h2>
                <p>Как писал Мерло-Понти, "видимое и невидимое сплетаются в нашем опыте, создавая ткань мира". Эстетика визуализации функций комплексного переменного предоставляет нам уникальную возможность исследовать это сплетение — этот удивительный процесс, в котором невидимые математические структуры обретают видимую форму, пробуждая в нас эстетический отклик и открывая новые горизонты понимания.</p>
                
                <div class="interactive-element">
                    <h3>Континуум эстетического восприятия</h3>
                    <canvas class="interactive-canvas" id="conclusion-canvas"></canvas>
                </div>
                
                <p>Философское исследование эстетики визуализации функций комплексного переменного позволяет нам увидеть её как уникальный феномен, находящийся на пересечении математики, искусства и философии. Эта эстетика обнаруживает себя в продуктивном напряжении между абстрактным и конкретным, между интеллигибельным и сенсибельным, между математической строгостью и чувственной выразительностью.</p>
            </div>
        </section>
    </div>
    
    <script>
        // Main variables
        let activeFunction = 'mandelbrot';
        let paramValue = 0;
        let zoomValue = 1;
        let activeOntologyPerspective = 'platonic';
        
        // DOM Elements
        const mainCanvas = document.getElementById('main-canvas');
        const mainCtx = mainCanvas.getContext('2d');
        const panelCanvas = document.getElementById('panel-canvas');
        const panelCtx = panelCanvas.getContext('2d');
        const functionExplorer = document.getElementById('function-explorer');
        const functionPanel = document.getElementById('function-panel');
        const paramSlider = document.getElementById('param-slider');
        const paramValueDisplay = document.getElementById('param-value');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValueDisplay = document.getElementById('zoom-value');
        const functionSelect = document.getElementById('panel-function-select');
        const conceptMap = document.getElementById('concept-map');
        const conceptModal = document.getElementById('concept-modal');
        const closeModalButton = document.querySelector('.close-modal');
        const conceptCanvas = document.getElementById('concept-canvas');
        const conceptCtx = conceptCanvas.getContext('2d');
        
        // Interactive elements
        const ontologyCanvas = document.getElementById('ontology-canvas');
        const singularityCanvas = document.getElementById('singularity-canvas');
        const riemannCanvas = document.getElementById('riemann-canvas');
        const chaosCanvas = document.getElementById('chaos-canvas');
        const infiniteCanvas = document.getElementById('infinite-canvas');
        const artCanvas = document.getElementById('art-canvas');
        const conclusionCanvas = document.getElementById('conclusion-canvas');
        const mandelbrotCanvas = document.getElementById('mandelbrot-canvas');
        
        // Resize canvases
        function resizeCanvases() {
            // Main canvas
            mainCanvas.width = window.innerWidth;
            mainCanvas.height = window.innerHeight;
            
            // Set explicit sizes for all interactive canvases
            if (ontologyCanvas) {
                ontologyCanvas.width = ontologyCanvas.offsetWidth || 300;
                ontologyCanvas.height = ontologyCanvas.offsetHeight || 200;
            }
            
            if (singularityCanvas) {
                singularityCanvas.width = singularityCanvas.offsetWidth || 300;
                singularityCanvas.height = singularityCanvas.offsetHeight || 200;
            }
            
            if (riemannCanvas) {
                riemannCanvas.width = riemannCanvas.offsetWidth || 300;
                riemannCanvas.height = riemannCanvas.offsetHeight || 200;
            }
            
            if (chaosCanvas) {
                chaosCanvas.width = chaosCanvas.offsetWidth || 300;
                chaosCanvas.height = chaosCanvas.offsetHeight || 200;
            }
            
            if (infiniteCanvas) {
                infiniteCanvas.width = infiniteCanvas.offsetWidth || 300;
                infiniteCanvas.height = infiniteCanvas.offsetHeight || 200;
            }
            
            if (artCanvas) {
                artCanvas.width = artCanvas.offsetWidth || 300;
                artCanvas.height = artCanvas.offsetHeight || 200;
            }
            
            if (conclusionCanvas) {
                conclusionCanvas.width = conclusionCanvas.offsetWidth || 300;
                conclusionCanvas.height = conclusionCanvas.offsetHeight || 200;
            }
            
            if (mandelbrotCanvas) {
                mandelbrotCanvas.width = mandelbrotCanvas.offsetWidth || 300;
                mandelbrotCanvas.height = mandelbrotCanvas.offsetHeight || 200;
            }
            
            if (panelCanvas) {
                panelCanvas.width = panelCanvas.offsetWidth || 300; 
                panelCanvas.height = panelCanvas.offsetHeight || 200;
            }
            
            if (conceptCanvas) {
                conceptCanvas.width = conceptCanvas.offsetWidth || 800;
                conceptCanvas.height = conceptCanvas.offsetHeight || 500;
            }
            
            // Redraw all canvases
            drawMainCanvas();
            drawInteractiveCanvases();
            
            if (functionPanel.classList.contains('open')) {
                drawPanelCanvas();
            }
            
            if (conceptModal.classList.contains('active')) {
                drawConceptMap();
            }
        }
        
        // Initialize
        function init() {
            // Задержка для гарантии, что все элементы загружены и отображены
            setTimeout(() => {
                // Set canvas sizes
                resizeCanvases();
                
                // Event listeners
                window.addEventListener('resize', resizeCanvases);
                window.addEventListener('scroll', handleScroll);
                
                // Function explorer
                functionExplorer.addEventListener('click', () => {
                    functionPanel.classList.toggle('open');
                    if (functionPanel.classList.contains('open')) {
                        drawPanelCanvas();
                    }
                });
                
                // Parameter slider
                paramSlider.addEventListener('input', (e) => {
                    paramValue = parseFloat(e.target.value);
                    paramValueDisplay.textContent = paramValue.toFixed(2);
                    drawPanelCanvas();
                });
                
                // Zoom slider
                zoomSlider.addEventListener('input', (e) => {
                    zoomValue = parseFloat(e.target.value);
                    zoomValueDisplay.textContent = zoomValue.toFixed(1);
                    drawPanelCanvas();
                });
                
                // Function selector
                functionSelect.addEventListener('change', (e) => {
                    activeFunction = e.target.value;
                    drawPanelCanvas();
                });
                
                // Concept map
                conceptMap.addEventListener('click', () => {
                    conceptModal.classList.add('active');
                    drawConceptMap();
                });
                
                // Close modal
                closeModalButton.addEventListener('click', () => {
                    conceptModal.classList.remove('active');
                });
                
                // Ontology perspective buttons
                document.querySelectorAll('[data-perspective]').forEach(button => {
                    button.addEventListener('click', (e) => {
                        // Найти ближайший элемент с атрибутом data-perspective
                        const target = e.target.closest('[data-perspective]');
                        if (target) {
                            activeOntologyPerspective = target.dataset.perspective;
                            drawOntologyCanvas();
                            
                            // Выделить активную кнопку визуально
                            document.querySelectorAll('[data-perspective]').forEach(btn => {
                                btn.classList.remove('active');
                            });
                            target.classList.add('active');
                        }
                    });
                });
                
                // Initial drawings
                drawMainCanvas();
                drawInteractiveCanvases();
            }, 100); // Задержка 100мс для уверенности, что DOM полностью загружен
        }
        
        // Handle scroll for revealing content
        function handleScroll() {
            const sections = document.querySelectorAll('.section-content');
            
            sections.forEach(section => {
                const sectionTop = section.getBoundingClientRect().top;
                const sectionBottom = section.getBoundingClientRect().bottom;
                
                if (sectionTop < window.innerHeight * 0.8 && sectionBottom > 0) {
                    section.classList.add('visible');
                }
            });
        }
        
        // Draw main background canvas
        function drawMainCanvas() {
            const width = mainCanvas.width;
            const height = mainCanvas.height;
            
            mainCtx.clearRect(0, 0, width, height);
            
            // Draw a subtle animated gradient background
            const time = Date.now() * 0.0005;
            const gradient = mainCtx.createLinearGradient(0, 0, width, height);
            
            gradient.addColorStop(0, `hsl(${(time * 10) % 360}, 70%, 10%)`);
            gradient.addColorStop(0.5, `hsl(${(time * 5 + 120) % 360}, 60%, 15%)`);
            gradient.addColorStop(1, `hsl(${(time * 15 + 240) % 360}, 70%, 10%)`);
            
            mainCtx.fillStyle = gradient;
            mainCtx.fillRect(0, 0, width, height);
            
            // Draw subtle function visualization
            const scale = Math.min(width, height) * 0.003;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Draw a subtle visualization of complex exponential function
            for (let i = 0; i < width; i += 20) {
                for (let j = 0; j < height; j += 20) {
                    const x = (i - centerX) / scale;
                    const y = (j - centerY) / scale;
                    
                    // Complex exponential
                    const r = Math.sqrt(x * x + y * y);
                    const theta = Math.atan2(y, x);
                    
                    const expR = Math.exp(x);
                    const expTheta = y;
                    
                    const hue = (theta / Math.PI * 180 + 180) % 360;
                    const saturation = Math.min(100, r * 10);
                    const lightness = 50 + 30 * Math.sin(time + i / 50 + j / 50);
                    
                    mainCtx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.05)`;
                    mainCtx.beginPath();
                    mainCtx.arc(i, j, Math.max(0.1, 5 * Math.sin(time + i / 100 + j / 100) + 2), 0, 2 * Math.PI);
                    mainCtx.fill();
                }
            }
            
            // Request animation frame
            requestAnimationFrame(drawMainCanvas);
        }
        
        // Draw interactive canvases
        function drawInteractiveCanvases() {
            // Draw all specialized canvases with error handling
            try {
                drawOntologyCanvas();
            } catch (e) {
                console.error('Error in drawOntologyCanvas:', e);
            }
            
            try {
                drawSingularityCanvas();
            } catch (e) {
                console.error('Error in drawSingularityCanvas:', e);
            }
            
            try {
                drawRiemannCanvas();
            } catch (e) {
                console.error('Error in drawRiemannCanvas:', e);
            }
            
            try {
                drawChaosCanvas();
            } catch (e) {
                console.error('Error in drawChaosCanvas:', e);
            }
            
            try {
                drawInfiniteCanvas();
            } catch (e) {
                console.error('Error in drawInfiniteCanvas:', e);
            }
            
            try {
                drawArtCanvas();
            } catch (e) {
                console.error('Error in drawArtCanvas:', e);
            }
            
            try {
                drawConclusionCanvas();
            } catch (e) {
                console.error('Error in drawConclusionCanvas:', e);
            }
            
            try {
                drawMandelbrotCanvas();
            } catch (e) {
                console.error('Error in drawMandelbrotCanvas:', e);
            }
        }
        
        // Draw ontology canvas
        function drawOntologyCanvas() {
            if (!ontologyCanvas) return;
            
            const ctx = ontologyCanvas.getContext('2d');
            const width = ontologyCanvas.width = ontologyCanvas.offsetWidth;
            const height = ontologyCanvas.height = ontologyCanvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw based on active perspective
            ctx.fillStyle = '#080822';
            ctx.fillRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const time = Date.now() * 0.001;
            
            if (activeOntologyPerspective === 'platonic') {
                // Platonic perspective: perfect geometric forms
                ctx.save();
                ctx.translate(centerX, centerY);
                
                // Circles representing ideal forms
                for (let i = 0; i < 5; i++) {
                    const radius = 20 + i * 25;
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = `hsla(${(i * 60) % 360}, 70%, 70%, 0.7)`;
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, Math.max(0.1, radius), 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                // Radiating lines representing emanation from the ideal
                for (let i = 0; i < 12; i++) {
                    const angle = i * Math.PI / 6;
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = `hsla(${(i * 30) % 360}, 70%, 70%, 0.5)`;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    const length = 150 + 30 * Math.sin(time + i);
                    ctx.lineTo(Math.cos(angle) * length, Math.sin(angle) * length);
                    ctx.stroke();
                }
                
                ctx.restore();
                
                // Text
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Платоническая перспектива: красота как проявление идеального', centerX, height - 20);
                
            } else if (activeOntologyPerspective === 'constructivist') {
                // Constructivist perspective: building blocks and constructions
                
                // Grid representing cultural/social construction
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(100, 100, 200, 0.3)';
                
                for (let i = 0; i < width; i += 25) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, height);
                    ctx.stroke();
                }
                
                for (let i = 0; i < height; i += 25) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(width, i);
                    ctx.stroke();
                }
                
                // Constructivist shapes
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 5; j++) {
                        const x = width * 0.1 + i * width * 0.16;
                        const y = height * 0.1 + j * height * 0.16;
                        
                        ctx.fillStyle = `hsla(${(i * j * 20) % 360}, 70%, 50%, 0.5)`;
                        
                        if ((i + j) % 3 === 0) {
                            // Circle
                            ctx.beginPath();
                            ctx.arc(x, y, Math.max(0.1, 10 + 5 * Math.sin(time + i + j)), 0, 2 * Math.PI);
                            ctx.fill();
                        } else if ((i + j) % 3 === 1) {
                            // Rectangle
                            ctx.fillRect(x - 10, y - 10, 20 + 5 * Math.sin(time + i), 20 + 5 * Math.cos(time + j));
                        } else {
                            // Triangle
                            ctx.beginPath();
                            ctx.moveTo(x, y - 15);
                            ctx.lineTo(x + 15, y + 15);
                            ctx.lineTo(x - 15, y + 15);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }
                
                // Text
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Конструктивистская перспектива: красота как культурный конструкт', centerX, height - 20);
                
            } else if (activeOntologyPerspective === 'structuralist') {
                // Structuralist perspective: relationships and patterns
                
                // Network of relationships
                const nodes = [];
                const links = [];
                
                // Create nodes
                for (let i = 0; i < 15; i++) {
                    nodes.push({
                        x: centerX + 100 * Math.cos(i * Math.PI * 2 / 15),
                        y: centerY + 100 * Math.sin(i * Math.PI * 2 / 15),
                        size: 5 + 2 * Math.sin(time + i)
                    });
                }
                
                // Create links
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (Math.random() < 0.3 || j === i + 1 || (i === 0 && j === nodes.length - 1)) {
                            links.push({
                                source: i,
                                target: j,
                                strength: Math.random()
                            });
                        }
                    }
                }
                
                // Draw links
                links.forEach(link => {
                    const source = nodes[link.source];
                    const target = nodes[link.target];
                    
                    ctx.lineWidth = 1 + link.strength;
                    ctx.strokeStyle = `hsla(${(link.source * 20 + link.target * 15) % 360}, 70%, 70%, ${link.strength * 0.5})`;
                    
                    ctx.beginPath();
                    ctx.moveTo(source.x, source.y);
                    ctx.lineTo(target.x, target.y);
                    ctx.stroke();
                });
                
                // Draw nodes
                nodes.forEach((node, i) => {
                    ctx.fillStyle = `hsla(${(i * 24) % 360}, 70%, 70%, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.size, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Text
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Структуралистская перспектива: красота как проявление отношений', centerX, height - 20);
            }
        }
        
        // Draw singularity canvas
        function drawSingularityCanvas() {
            if (!singularityCanvas) return;
            
            const ctx = singularityCanvas.getContext('2d');
            const width = singularityCanvas.width = singularityCanvas.offsetWidth;
            const height = singularityCanvas.height = singularityCanvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw 1/z function visualization (pole at origin)
            ctx.fillStyle = '#080822';
            ctx.fillRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = Math.min(width, height) / 4;
            const time = Date.now() * 0.001;
            
            // Draw domain coloring for 1/z
            for (let i = 0; i < width; i += 4) {
                for (let j = 0; j < height; j += 4) {
                    const x = (i - centerX) / scale;
                    const y = (j - centerY) / scale;
                    
                    // Skip the singularity
                    if (Math.abs(x) < 0.01 && Math.abs(y) < 0.01) continue;
                    
                    // Complex division 1/z
                    const r = Math.sqrt(x * x + y * y);
                    const theta = Math.atan2(y, x);
                    
                    const invR = 1 / r;
                    const invTheta = -theta;
                    
                    // Use phase for hue and modulus for brightness
                    const hue = ((invTheta / Math.PI * 180) + 180) % 360;
                    const brightness = 50 * Math.min(1, invR);
                    
                    ctx.fillStyle = `hsl(${hue}, 100%, ${brightness}%)`;
                    ctx.fillRect(i, j, 4, 4);
                }
            }
            
            // Animated circles showing the singularity
            for (let i = 0; i < 10; i++) {
                const radius = 5 + i * 10 + 5 * Math.sin(time * 2 + i);
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 - i * 0.08})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, Math.max(0.1, radius), 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Label
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Визуализация полюса функции 1/z', centerX, height - 15);
        }
        
        // Draw Riemann canvas
        function drawRiemannCanvas() {
            if (!riemannCanvas) return;
            
            const ctx = riemannCanvas.getContext('2d');
            const width = riemannCanvas.width = riemannCanvas.offsetWidth;
            const height = riemannCanvas.height = riemannCanvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw a visualization of a Riemann surface (log function)
            ctx.fillStyle = '#080822';
            ctx.fillRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const time = Date.now() * 0.001;
            
            // Draw a 3D-like spiral representing the Riemann surface of log(z)
            ctx.save();
            ctx.translate(centerX, centerY);
            
            // Draw sheets of the Riemann surface
            for (let sheet = 0; sheet < 2; sheet++) {
                const sheetOffset = sheet * Math.PI;
                
                // Draw spiral representing the Riemann surface
                for (let r = 5; r < 150; r += 5) {
                    for (let theta = 0; theta < 2 * Math.PI; theta += 0.1) {
                        const x = r * Math.cos(theta);
                        const y = r * Math.sin(theta);
                        const z = 30 * (theta + sheetOffset) / (2 * Math.PI);
                        
                        // Perform a simple 3D projection
                        const angle = time * 0.3;
                        const projectedX = x * Math.cos(angle) - z * Math.sin(angle);
                        const projectedY = y;
                        const projectedZ = x * Math.sin(angle) + z * Math.cos(angle);
                        
                        // Use z-value for size and color
                        const size = 2 + 2 * (projectedZ + 50) / 100;
                        const hue = (theta / Math.PI * 180) % 360;
                        const lightness = 50 + 30 * (projectedZ + 50) / 100;
                        
                        ctx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
                        ctx.globalAlpha = 0.7 + 0.3 * (projectedZ + 50) / 100;
                        
                        ctx.beginPath();
                        ctx.arc(projectedX, projectedY, Math.max(0.1, size), 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
            }
            
            ctx.globalAlpha = 1;
            ctx.restore();
            
            // Label
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Риманова поверхность логарифмической функции', centerX, height - 15);
        }
        
        // Draw chaos canvas
        function drawChaosCanvas() {
            if (!chaosCanvas) return;
            
            const ctx = chaosCanvas.getContext('2d');
            const width = chaosCanvas.width = chaosCanvas.offsetWidth;
            const height = chaosCanvas.height = chaosCanvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw the boundary of a Julia set, showing chaos vs order
            ctx.fillStyle = '#080822';
            ctx.fillRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = Math.min(width, height) / 4;
            const time = Date.now() * 0.001;
            
            // Parameters for Julia set
            const cRe = 0.7885 * Math.cos(time * 0.1);
            const cIm = 0.7885 * Math.sin(time * 0.1);
            
            // Draw Julia set
            for (let i = 0; i < width; i += 2) {
                for (let j = 0; j < height; j += 2) {
                    const zRe = (i - centerX) / scale;
                    const zIm = (j - centerY) / scale;
                    
                    // Iterate to determine if point is in set
                    let re = zRe;
                    let im = zIm;
                    let iter = 0;
                    const maxIter = 100;
                    
                    while (re * re + im * im < 4 && iter < maxIter) {
                        // z = z^2 + c
                        const tempRe = re * re - im * im + cRe;
                        im = 2 * re * im + cIm;
                        re = tempRe;
                        iter++;
                    }
                    
                    if (iter === maxIter) {
                        // Point is in set
                        ctx.fillStyle = 'black';
                    } else {
                        // Point is outside set, color based on escape velocity
                        const hue = (iter * 10) % 360;
                        const sat = 100;
                        const light = 50;
                        ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
                    }
                    
                    ctx.fillRect(i, j, 2, 2);
                }
            }
            
            // Label
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Граница между хаосом и порядком в множестве Жюлиа', centerX, height - 15);
        }
        
        // Draw infinite canvas
        function drawInfiniteCanvas() {
            if (!infiniteCanvas) return;
            
            const ctx = infiniteCanvas.getContext('2d');
            const width = infiniteCanvas.width = infiniteCanvas.offsetWidth;
            const height = infiniteCanvas.height = infiniteCanvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw representation of infinity in complex plane
            ctx.fillStyle = '#080822';
            ctx.fillRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const time = Date.now() * 0.001;
            
            // Draw Riemann sphere projection
            ctx.save();
            ctx.translate(centerX, centerY);
            
            // Draw grid lines on sphere
            const numLines = 15;
            const radius = Math.min(width, height) * 0.4;
            
            for (let i = 0; i < numLines; i++) {
                const angle = i * Math.PI / (numLines - 1);
                
                // Horizontal circle
                ctx.beginPath();
                ctx.ellipse(0, radius * (1 - Math.cos(angle)) * 0.25, 
                            radius * Math.sin(angle), radius * Math.sin(angle) * 0.25, 
                            0, 0, 2 * Math.PI);
                ctx.strokeStyle = `rgba(100, 200, 255, ${0.2 + 0.8 * Math.sin(angle)})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Vertical circles
                const angleV = i * 2 * Math.PI / numLines;
                ctx.beginPath();
                
                for (let t = 0; t <= 2 * Math.PI; t += 0.1) {
                    const x = radius * Math.sin(t) * Math.cos(angleV);
                    const y = radius * Math.sin(t) * Math.sin(angleV);
                    const z = radius * Math.cos(t);
                    
                    // Simple 3D projection
                    const rotX = time * 0.1;
                    const rotY = time * 0.2;
                    
                    // Rotate around Y axis
                    const x1 = x * Math.cos(rotY) + z * Math.sin(rotY);
                    const z1 = -x * Math.sin(rotY) + z * Math.cos(rotY);
                    
                    // Rotate around X axis
                    const y1 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
                    const z2 = y * Math.sin(rotX) + z1 * Math.cos(rotX);
                    
                    // Project to 2D
                    const scale = 1.5 / (2 + z2 / radius);
                    const projX = x1 * scale;
                    const projY = y1 * scale;
                    
                    if (t === 0) {
                        ctx.moveTo(projX, projY);
                    } else {
                        ctx.lineTo(projX, projY);
                    }
                }
                
                ctx.strokeStyle = `rgba(255, 100, 200, ${0.2 + 0.6 * Math.sin(angleV)})`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // Draw the "infinity point" at the north pole
            const infX = 0;
            const infY = -radius * 0.25;
            
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(infX, infY, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.font = '16px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('∞', infX, infY - 15);
            
            // Animate some points moving toward infinity
            for (let i = 0; i < 5; i++) {
                const t = (time * 0.5 + i * 2) % 10;
                const progress = t / 10;
                
                if (progress < 1) {
                    const x = (0.5 - progress) * Math.cos(i * 2.5) * radius;
                    const y = (0.5 - progress) * Math.sin(i * 2.5) * radius * 0.25 + progress * infY;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${1 - progress})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            ctx.restore();
            
            // Label
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Бесконечность в комплексном анализе (сфера Римана)', centerX, height - 15);
        }
        
        // Draw art canvas
        function drawArtCanvas() {
            if (!artCanvas) return;
            
            const ctx = artCanvas.getContext('2d');
            const width = artCanvas.width = artCanvas.offsetWidth;
            const height = artCanvas.height = artCanvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw an artistic representation of a complex function, reminiscent of Kandinsky
            ctx.fillStyle = '#080822';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.001;
            
            // Draw artistic composition inspired by complex functions
            // Background shapes
            for (let i = 0; i < 30; i++) {
                const x = width * Math.random();
                const y = height * Math.random();
                const size = 10 + 50 * Math.random();
                
                ctx.fillStyle = `hsla(${(i * 20) % 360}, 70%, 50%, 0.2)`;
                
                if (i % 3 === 0) {
                    // Circle
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (i % 3 === 1) {
                    // Rectangle
                    ctx.fillRect(x - size/2, y - size/2, size, size);
                } else {
                    // Triangle
                    ctx.beginPath();
                    ctx.moveTo(x, y - size/2);
                    ctx.lineTo(x + size/2, y + size/2);
                    ctx.lineTo(x - size/2, y + size/2);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // Lines inspired by phase portraits
            for (let i = 0; i < 15; i++) {
                const startX = width * Math.random();
                const startY = height * Math.random();
                
                ctx.strokeStyle = `hsla(${(i * 30) % 360}, 100%, 70%, 0.6)`;
                ctx.lineWidth = 1 + 3 * Math.random();
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                let x = startX;
                let y = startY;
                
                for (let j = 0; j < 10; j++) {
                    // Simulate a flow based on complex function
                    const angle = Math.atan2(y - height/2, x - width/2) + Math.PI * Math.sin(time * 0.1);
                    const dist = Math.sqrt((x - width/2) * (x - width/2) + (y - height/2) * (y - height/2));
                    
                    x += 20 * Math.cos(angle + dist * 0.02);
                    y += 20 * Math.sin(angle + dist * 0.02);
                    
                    ctx.lineTo(x, y);
                }
                
                ctx.stroke();
            }
            
            // Focal points
            for (let i = 0; i < 5; i++) {
                const x = width * (0.2 + 0.6 * Math.random());
                const y = height * (0.2 + 0.6 * Math.random());
                const size = 10 + 10 * Math.random();
                
                ctx.fillStyle = `hsla(${(i * 72) % 360}, 100%, 70%, 0.8)`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, 2 * Math.PI);
                ctx.fill();
                
                // Add radiating lines
                ctx.strokeStyle = `hsla(${(i * 72) % 360}, 100%, 70%, 0.4)`;
                
                for (let j = 0; j < 8; j++) {
                    const angle = j * Math.PI / 4 + time * 0.2;
                    const length = 30 + 20 * Math.random();
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                    ctx.stroke();
                }
            }
            
            // Label
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Эстетические параллели с абстрактным искусством', width/2, height - 15);
        }
        
        // Draw conclusion canvas
        function drawConclusionCanvas() {
            if (!conclusionCanvas) return;
            
            const ctx = conclusionCanvas.getContext('2d');
            const width = conclusionCanvas.width = conclusionCanvas.offsetWidth;
            const height = conclusionCanvas.height = conclusionCanvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw a visual representation of the boundary between visible and invisible
            ctx.fillStyle = '#080822';
            ctx.fillRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const time = Date.now() * 0.001;
            
            // Create a gradient from dark to light
            const gradient = ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, width * 0.7
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.2, 'rgba(180, 180, 255, 0.5)');
            gradient.addColorStop(0.6, 'rgba(100, 100, 200, 0.2)');
            gradient.addColorStop(1, 'rgba(20, 20, 80, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Draw concentric circles representing the boundary
            for (let i = 0; i < 20; i++) {
                const radius = 30 + i * 15 + 5 * Math.sin(time + i * 0.3);
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 - i * 0.04})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, Math.max(0.1, radius), 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Draw flowing particles crossing the boundary
            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                const speed = 0.5 + 0.5 * Math.random();
                const distance = ((time * speed * 50) % 300);
                
                const x = centerX + Math.cos(angle + time * 0.1) * distance;
                const y = centerY + Math.sin(angle + time * 0.1) * distance;
                
                const alpha = distance < 50 ? distance / 50 : 
                              distance > 250 ? (300 - distance) / 50 : 1;
                
                ctx.fillStyle = `hsla(${(i * 7.2) % 360}, 100%, 70%, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw trail
                ctx.strokeStyle = `hsla(${(i * 7.2) % 360}, 100%, 70%, ${alpha * 0.3})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(centerX + Math.cos(angle + time * 0.1) * (distance - 10), 
                           centerY + Math.sin(angle + time * 0.1) * (distance - 10));
                ctx.stroke();
            }
            
            // Draw text labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Видимое', centerX, centerY - 120);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillText('Невидимое', centerX, centerY + 180);
            
            // Label
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Граница между видимым и невидимым', centerX, height - 15);
        }
        
        // Draw Mandelbrot canvas
        function drawMandelbrotCanvas() {
            if (!mandelbrotCanvas) return;
            
            const ctx = mandelbrotCanvas.getContext('2d');
            const width = mandelbrotCanvas.width = mandelbrotCanvas.offsetWidth;
            const height = mandelbrotCanvas.height = mandelbrotCanvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw Mandelbrot set
            ctx.fillStyle = '#080822';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.001;
            
            // Parameters for Mandelbrot set
            const zoom = 1 + 0.2 * Math.sin(time * 0.1);
            const offsetX = -0.5 + 0.1 * Math.sin(time * 0.05);
            const offsetY = 0 + 0.1 * Math.cos(time * 0.07);
            
            // Draw Mandelbrot set
            for (let i = 0; i < width; i += 2) {
                for (let j = 0; j < height; j += 2) {
                    const x0 = (i / width * 3.5 - 2.5) / zoom + offsetX;
                    const y0 = (j / height * 2 - 1) / zoom + offsetY;
                    
                    let x = 0;
                    let y = 0;
                    let iter = 0;
                    const maxIter = 100;
                    
                    while (x * x + y * y < 4 && iter < maxIter) {
                        const xTemp = x * x - y * y + x0;
                        y = 2 * x * y + y0;
                        x = xTemp;
                        iter++;
                    }
                    
                    if (iter === maxIter) {
                        // Point is in set
                        ctx.fillStyle = 'black';
                    } else {
                        // Point is outside set, color based on escape velocity
                        const hue = (iter * 10 + time * 30) % 360;
                        const sat = 100;
                        const light = 50;
                        ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
                    }
                    
                    ctx.fillRect(i, j, 2, 2);
                }
            }
        }
        
        // Draw panel canvas
        function drawPanelCanvas() {
            const width = panelCanvas.width = panelCanvas.offsetWidth;
            const height = panelCanvas.height = panelCanvas.offsetHeight;
            
            panelCtx.clearRect(0, 0, width, height);
            
            // Draw based on active function
            panelCtx.fillStyle = '#080822';
            panelCtx.fillRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = Math.min(width, height) / 4 * zoomValue;
            
            if (activeFunction === 'mandelbrot') {
                // Draw Mandelbrot set
                for (let i = 0; i < width; i += 2) {
                    for (let j = 0; j < height; j += 2) {
                        const x0 = (i / width * 3.5 - 2.5) / zoomValue + paramValue * 0.1;
                        const y0 = (j / height * 2 - 1) / zoomValue;
                        
                        let x = 0;
                        let y = 0;
                        let iter = 0;
                        const maxIter = 100;
                        
                        while (x * x + y * y < 4 && iter < maxIter) {
                            const xTemp = x * x - y * y + x0;
                            y = 2 * x * y + y0;
                            x = xTemp;
                            iter++;
                        }
                        
                        if (iter === maxIter) {
                            // Point is in set
                            panelCtx.fillStyle = 'black';
                        } else {
                            // Point is outside set, color based on escape velocity
                            const hue = (iter * 10) % 360;
                            const sat = 100;
                            const light = 50;
                            panelCtx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
                        }
                        
                        panelCtx.fillRect(i, j, 2, 2);
                    }
                }
                
                // Label
                panelCtx.fillStyle = 'white';
                panelCtx.font = '12px Arial';
                panelCtx.textAlign = 'center';
                panelCtx.fillText('Множество Мандельброта', centerX, height - 5);
                
                // Update parameter label
                document.getElementById('param-label').textContent = 'Смещение по X: ' + paramValue.toFixed(2);
                
            } else if (activeFunction === 'julia') {
                // Draw Julia set
                const cRe = paramValue;
                const cIm = paramValue * -0.75;
                
                for (let i = 0; i < width; i += 2) {
                    for (let j = 0; j < height; j += 2) {
                        const zRe = (i - centerX) / scale;
                        const zIm = (j - centerY) / scale;
                        
                        // Iterate to determine if point is in set
                        let re = zRe;
                        let im = zIm;
                        let iter = 0;
                        const maxIter = 100;
                        
                        while (re * re + im * im < 4 && iter < maxIter) {
                            // z = z^2 + c
                            const tempRe = re * re - im * im + cRe;
                            im = 2 * re * im + cIm;
                            re = tempRe;
                            iter++;
                        }
                        
                        if (iter === maxIter) {
                            // Point is in set
                            panelCtx.fillStyle = 'black';
                        } else {
                            // Point is outside set, color based on escape velocity
                            const hue = (iter * 10) % 360;
                            const sat = 100;
                            const light = 50;
                            panelCtx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
                        }
                        
                        panelCtx.fillRect(i, j, 2, 2);
                    }
                }
                
                // Label
                panelCtx.fillStyle = 'white';
                panelCtx.font = '12px Arial';
                panelCtx.textAlign = 'center';
                panelCtx.fillText(`Множество Жюлиа для c = ${cRe.toFixed(2)} + ${cIm.toFixed(2)}i`, centerX, height - 5);
                
                // Update parameter label
                document.getElementById('param-label').textContent = 'Параметр c: ' + paramValue.toFixed(2);
                
            } else if (activeFunction === 'exponential') {
                // Draw exponential function
                for (let i = 0; i < width; i += 2) {
                    for (let j = 0; j < height; j += 2) {
                        const x = (i - centerX) / scale;
                        const y = (j - centerY) / scale;
                        
                        // Complex exponential e^z
                        const ex = Math.exp(x * paramValue);
                        const re = ex * Math.cos(y * paramValue);
                        const im = ex * Math.sin(y * paramValue);
                        
                        // Use phase for hue and modulus for brightness
                        const phase = Math.atan2(im, re);
                        const modulus = Math.sqrt(re * re + im * im);
                        
                        const hue = ((phase / Math.PI * 180) + 180) % 360;
                        const brightness = Math.min(100, 50 + 10 * Math.log(modulus + 1));
                        
                        panelCtx.fillStyle = `hsl(${hue}, 100%, ${brightness}%)`;
                        panelCtx.fillRect(i, j, 2, 2);
                    }
                }
                
                // Label
                panelCtx.fillStyle = 'white';
                panelCtx.font = '12px Arial';
                panelCtx.textAlign = 'center';
                panelCtx.fillText(`Экспоненциальная функция e^(${paramValue.toFixed(2)}z)`, centerX, height - 5);
                
                // Update parameter label
                document.getElementById('param-label').textContent = 'Коэффициент: ' + paramValue.toFixed(2);
                
            } else if (activeFunction === 'power') {
                // Draw power function (z^n)
                const n = Math.round(paramValue * 2 + 2); // 0-4 to 2-10
                
                for (let i = 0; i < width; i += 2) {
                    for (let j = 0; j < height; j += 2) {
                        const x = (i - centerX) / scale;
                        const y = (j - centerY) / scale;
                        
                        // Convert to polar form
                        const r = Math.sqrt(x * x + y * y);
                        const theta = Math.atan2(y, x);
                        
                        // Compute z^n
                        const rn = Math.pow(r, n);
                        const thetaN = n * theta;
                        
                        // Convert back to cartesian
                        const reN = rn * Math.cos(thetaN);
                        const imN = rn * Math.sin(thetaN);
                        
                        // Use phase for hue and modulus for brightness
                        const phase = Math.atan2(imN, reN);
                        const modulus = Math.sqrt(reN * reN + imN * imN);
                        
                        const hue = ((phase / Math.PI * 180) + 180) % 360;
                        const brightness = Math.min(100, 50 + 10 * Math.log(modulus + 1));
                        
                        panelCtx.fillStyle = `hsl(${hue}, 100%, ${brightness}%)`;
                        panelCtx.fillRect(i, j, 2, 2);
                    }
                }
                
                // Label
                panelCtx.fillStyle = 'white';
                panelCtx.font = '12px Arial';
                panelCtx.textAlign = 'center';
                panelCtx.fillText(`Степенная функция z^${n}`, centerX, height - 5);
                
                // Update parameter label
                document.getElementById('param-label').textContent = 'Степень: ' + n;
                
            } else if (activeFunction === 'rational') {
                // Draw rational function (1/z)
                for (let i = 0; i < width; i += 2) {
                    for (let j = 0; j < height; j += 2) {
                        const x = (i - centerX) / scale;
                        const y = (j - centerY) / scale;
                        
                        // Add a small offset to avoid division by zero
                        const offsetX = paramValue;
                        const offsetY = paramValue * 0.5;
                        
                        // Skip the singularity
                        if (Math.abs(x - offsetX) < 0.01 && Math.abs(y - offsetY) < 0.01) continue;
                        
                        // Complex division 1/(z - offset)
                        const denomR = (x - offsetX) * (x - offsetX) + (y - offsetY) * (y - offsetY);
                        const re = (x - offsetX) / denomR;
                        const im = -(y - offsetY) / denomR;
                        
                        // Use phase for hue and modulus for brightness
                        const phase = Math.atan2(im, re);
                        const modulus = Math.sqrt(re * re + im * im);
                        
                        const hue = ((phase / Math.PI * 180) + 180) % 360;
                        const brightness = Math.min(100, 50 + 10 * Math.log(modulus + 1));
                        
                        panelCtx.fillStyle = `hsl(${hue}, 100%, ${brightness}%)`;
                        panelCtx.fillRect(i, j, 2, 2);
                    }
                }
                
                // Label
                panelCtx.fillStyle = 'white';
                panelCtx.font = '12px Arial';
                panelCtx.textAlign = 'center';
                panelCtx.fillText(`Рациональная функция 1/(z - ${paramValue.toFixed(2)})`, centerX, height - 5);
                
                // Update parameter label
                document.getElementById('param-label').textContent = 'Положение полюса: ' + paramValue.toFixed(2);
                
            } else if (activeFunction === 'logarithm') {
                // Draw logarithmic function
                for (let i = 0; i < width; i += 2) {
                    for (let j = 0; j < height; j += 2) {
                        const x = (i - centerX) / scale;
                        const y = (j - centerY) / scale;
                        
                        // Add offset to avoid branch cut
                        const offsetX = paramValue;
                        const offsetY = 0;
                        
                        // Skip near the branch point
                        if (Math.abs(x - offsetX) < 0.01 && Math.abs(y - offsetY) < 0.01) continue;
                        
                        // Complex logarithm
                        const r = Math.sqrt((x - offsetX) * (x - offsetX) + (y - offsetY) * (y - offsetY));
                        const theta = Math.atan2(y - offsetY, x - offsetX);
                        
                        const re = Math.log(r);
                        const im = theta;
                        
                        // Use phase for hue and real part for brightness
                        const hue = ((im / Math.PI * 180) + 180) % 360;
                        const brightness = Math.min(100, 50 + 20 * re);
                        
                        panelCtx.fillStyle = `hsl(${hue}, 100%, ${brightness}%)`;
                        panelCtx.fillRect(i, j, 2, 2);
                    }
                }
                
                // Draw branch cut
                panelCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                panelCtx.lineWidth = 2;
                panelCtx.beginPath();
                panelCtx.moveTo(centerX + paramValue * scale, centerY);
                panelCtx.lineTo(0, centerY);
                panelCtx.stroke();
                
                // Label
                panelCtx.fillStyle = 'white';
                panelCtx.font = '12px Arial';
                panelCtx.textAlign = 'center';
                panelCtx.fillText(`Логарифмическая функция ln(z - ${paramValue.toFixed(2)})`, centerX, height - 5);
                
                // Update parameter label
                document.getElementById('param-label').textContent = 'Положение точки ветвления: ' + paramValue.toFixed(2);
                
            } else if (activeFunction === 'sine') {
                // Draw sine function
                for (let i = 0; i < width; i += 2) {
                    for (let j = 0; j < height; j += 2) {
                        const x = (i - centerX) / scale;
                        const y = (j - centerY) / scale;
                        
                        // Complex sine: sin(z) = sin(x)cosh(y) + i*cos(x)sinh(y)
                        const sinX = Math.sin(x * paramValue);
                        const cosX = Math.cos(x * paramValue);
                        const sinhY = Math.sinh(y * paramValue);
                        const coshY = Math.cosh(y * paramValue);
                        
                        const re = sinX * coshY;
                        const im = cosX * sinhY;
                        
                        // Use phase for hue and modulus for brightness
                        const phase = Math.atan2(im, re);
                        const modulus = Math.sqrt(re * re + im * im);
                        
                        const hue = ((phase / Math.PI * 180) + 180) % 360;
                        const brightness = Math.min(100, 50 + 20 * Math.log(modulus + 1));
                        
                        panelCtx.fillStyle = `hsl(${hue}, 100%, ${brightness}%)`;
                        panelCtx.fillRect(i, j, 2, 2);
                    }
                }
                
                // Label
                panelCtx.fillStyle = 'white';
                panelCtx.font = '12px Arial';
                panelCtx.textAlign = 'center';
                panelCtx.fillText(`Синус sin(${paramValue.toFixed(2)}z)`, centerX, height - 5);
                
                // Update parameter label
                document.getElementById('param-label').textContent = 'Коэффициент: ' + paramValue.toFixed(2);
            }
        }
        
        // Draw concept map
        function drawConceptMap() {
            if (!conceptCanvas) return;
            
            const ctx = conceptCanvas.getContext('2d');
            const width = conceptCanvas.width = conceptCanvas.offsetWidth;
            const height = conceptCanvas.height = conceptCanvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw concept map
            ctx.fillStyle = 'rgba(8, 8, 34, 0.3)';
            ctx.fillRect(0, 0, width, height);
            
            // Define nodes (concepts)
            const nodes = [
                { id: 0, name: "Эстетика комплексного\nпеременного", x: width/2, y: height/2, radius: 50, color: "#aa64f8" },
                
                { id: 1, name: "Онтология\nэстетического", x: width*0.25, y: height*0.3, radius: 40, color: "#0bd9d9" },
                { id: 2, name: "Эпистемология\nэстетического", x: width*0.75, y: height*0.3, radius: 40, color: "#0bd9d9" },
                { id: 3, name: "Феноменология\nвосприятия", x: width*0.25, y: height*0.7, radius: 40, color: "#0bd9d9" },
                { id: 4, name: "Эстетические\nкатегории", x: width*0.75, y: height*0.7, radius: 40, color: "#0bd9d9" },
                
                { id: 5, name: "Платонизм", x: width*0.1, y: height*0.15, radius: 25, color: "#ff6b6b" },
                { id: 6, name: "Конструктивизм", x: width*0.25, y: height*0.15, radius: 25, color: "#ff6b6b" },
                { id: 7, name: "Структурализм", x: width*0.4, y: height*0.15, radius: 25, color: "#ff6b6b" },
                
                { id: 8, name: "Когнитивные\nоснования", x: width*0.6, y: height*0.15, radius: 25, color: "#ff6b6b" },
                { id: 9, name: "Герменевтика", x: width*0.8, y: height*0.15, radius: 25, color: "#ff6b6b" },
                { id: 10, name: "Эпистемическая\nроль", x: width*0.9, y: height*0.25, radius: 25, color: "#ff6b6b" },
                
                { id: 11, name: "Телесность", x: width*0.1, y: height*0.85, radius: 25, color: "#ff6b6b" },
                { id: 12, name: "Пространственность", x: width*0.3, y: height*0.85, radius: 25, color: "#ff6b6b" },
                { id: 13, name: "Статическое и\nдинамическое", x: width*0.45, y: height*0.9, radius: 25, color: "#ff6b6b" },
                
                { id: 14, name: "Возвышенное", x: width*0.6, y: height*0.85, radius: 25, color: "#ff6b6b" },
                { id: 15, name: "Гармония", x: width*0.75, y: height*0.9, radius: 25, color: "#ff6b6b" },
                { id: 16, name: "Хаос и\nпорядок", x: width*0.9, y: height*0.85, radius: 25, color: "#ff6b6b" }
            ];
            
            // Define links between nodes
            const links = [
                { source: 0, target: 1, thickness: 3 },
                { source: 0, target: 2, thickness: 3 },
                { source: 0, target: 3, thickness: 3 },
                { source: 0, target: 4, thickness: 3 },
                
                { source: 1, target: 5, thickness: 2 },
                { source: 1, target: 6, thickness: 2 },
                { source: 1, target: 7, thickness: 2 },
                
                { source: 2, target: 8, thickness: 2 },
                { source: 2, target: 9, thickness: 2 },
                { source: 2, target: 10, thickness: 2 },
                
                { source: 3, target: 11, thickness: 2 },
                { source: 3, target: 12, thickness: 2 },
                { source: 3, target: 13, thickness: 2 },
                
                { source: 4, target: 14, thickness: 2 },
                { source: 4, target: 15, thickness: 2 },
                { source: 4, target: 16, thickness: 2 },
                
                // Cross-connections
                { source: 5, target: 8, thickness: 1 },
                { source: 7, target: 16, thickness: 1 },
                { source: 10, target: 14, thickness: 1 },
                { source: 12, target: 15, thickness: 1 },
                { source: 9, target: 13, thickness: 1 }
            ];
            
            // Draw links first (so they're behind nodes)
            links.forEach(link => {
                const source = nodes.find(node => node.id === link.source);
                const target = nodes.find(node => node.id === link.target);
                
                const time = Date.now() * 0.001;
                const gradient = ctx.createLinearGradient(
                    source.x, source.y, target.x, target.y
                );
                
                gradient.addColorStop(0, source.color);
                gradient.addColorStop(1, target.color);
                
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.lineWidth = link.thickness;
                ctx.strokeStyle = gradient;
                ctx.globalAlpha = 0.5 + 0.3 * Math.sin(time + source.id + target.id);
                ctx.stroke();
                ctx.globalAlpha = 1;
            });
            
            // Draw animation dots on links
            links.forEach(link => {
                const source = nodes.find(node => node.id === link.source);
                const target = nodes.find(node => node.id === link.target);
                
                const time = Date.now() * 0.001;
                const progress = (time * 0.5 + source.id * 0.1) % 1;
                
                const x = source.x + (target.x - source.x) * progress;
                const y = source.y + (target.y - source.y) * progress;
                
                ctx.fillStyle = `rgba(255, 255, 255, 0.8)`;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw nodes
            nodes.forEach(node => {
                const time = Date.now() * 0.001;
                
                // Draw node circles
                const gradient = ctx.createRadialGradient(
                    node.x, node.y, 0,
                    node.x, node.y, node.radius
                );
                
                gradient.addColorStop(0, node.color);
                
                // Правильное преобразование HEX в RGB
                const r = parseInt(node.color.substring(1, 3), 16);
                const g = parseInt(node.color.substring(3, 5), 16);
                const b = parseInt(node.color.substring(5, 7), 16);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.1)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(node.x, node.y, Math.max(0.1, node.radius + 2 * Math.sin(time + node.id)), 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw node borders
                ctx.strokeStyle = node.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(node.x, node.y, Math.max(0.1, node.radius + 2 * Math.sin(time + node.id)), 0, 2 * Math.PI);
                ctx.stroke();
                
                // Draw node labels
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Handle multi-line labels
                const lines = node.name.split('\n');
                lines.forEach((line, i) => {
                    const lineOffset = (i - (lines.length - 1) / 2) * 18;
                    ctx.fillText(line, node.x, node.y + lineOffset);
                });
            });
            
            // Request animation frame for continuous updates
            requestAnimationFrame(drawConceptMap);
        }
        
        // Add Math functions that might be missing
        if (!Math.sinh) {
            Math.sinh = function(x) {
                return (Math.exp(x) - Math.exp(-x)) / 2;
            };
        }
        
        if (!Math.cosh) {
            Math.cosh = function(x) {
                return (Math.exp(x) + Math.exp(-x)) / 2;
            };
        }
        
        // Initialize after page load
        window.addEventListener('load', init);
    </script>
</body>
</html>