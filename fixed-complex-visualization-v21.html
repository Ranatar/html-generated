<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Визуализация комплексных функций</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .main-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .left-panel {
            flex: 1;
            min-width: 600px;
        }

        .right-panel {
            width: 520px;
            position: sticky;
            top: 20px;
            align-self: flex-start;
        }

        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
            }
            .left-panel, .right-panel {
                width: 100%;
            }
        }

        .collapsible-section {
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        .collapsible-header {
            background-color: #f5f5f5;
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }

        .collapsible-header:after {
            content: '▼';
            font-size: 12px;
        }

        .collapsible-header.collapsed:after {
            content: '►';
        }

        .collapsible-content {
            padding: 15px;
            display: none;
        }

        .collapsible-content.visible {
            display: block;
        }

        .templates-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
        }

        .template-tab-content {
            display: none;
            padding: 10px;
        }

        .template-tab-content.active {
            display: block;
        }

        .controls {
            margin-bottom: 20px;
        }
        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }
        .control-group {
            margin: 10px 0;
            flex: 1;
            min-width: 300px;
        }
        .circular-slider {
            position: relative;
            width: 150px;
            height: 150px;
            display: inline-block;
            vertical-align: middle;
            margin-right: 20px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .param-input {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        .param-input label {
            width: 30px;
            text-align: right;
            margin-right: 10px;
        }
        .param-input input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }
        .param-input input[type="number"] {
            width: 70px;
            padding: 4px;
        }
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 0 auto;
        }
        canvas.control-canvas {
            border: 1px solid #aaa;
            border-radius: 50%;
        }
        select {
            padding: 5px;
            margin: 5px 0;
            width: 100%;
        }
        .angles-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .angle-control {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .angle-value {
            margin-top: 5px;
            font-family: monospace;
            display: inline-block;
            width: 150px;
            text-align: center;
        }
        h2 {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #444;
        }
        h3 {
            font-size: 1em;
            margin: 10px 0 5px 0;
            color: #555;
        }
        button {
            padding: 8px 16px;
            margin-top: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        .template-btn {
            padding: 5px 10px;
            margin: 2px;
            background-color: #e8f4e8;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .template-btn:hover {
            background-color: #d8ecd8;
        }
        #customFunctionInput {
            font-size: 1.1em;
            padding: 8px;
            width: 100%;
            border: 1px solid #aaa;
            border-radius: 4px;
        }
        .error-message {
            color: #f44336;
            margin-top: 5px;
            font-size: 0.9em;
        }
        #debug-panel {
            margin-top: 20px;
            padding: 10px;
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: none;
        }
        
        .category-section {
            margin-bottom: 25px;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
        }
        
        .category-section h3 {
            color: #2c7744;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 5px;
            display: inline-block;
        }
        
        .template-category {
            margin-bottom: 15px;
        }
        
        .template-category h4 {
            color: #333;
            margin: 8px 0;
            font-size: 0.95em;
            font-weight: bold;
        }
        
        .template-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 5px;
            padding-left: 10px;
        }
        
        .template-btn {
            padding: 5px 10px;
            margin: 2px;
            background-color: #e8f4e8;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em;
            transition: background-color 0.2s, transform 0.1s;
        }
        
        .template-btn:hover {
            background-color: #d0e9d0;
            transform: translateY(-1px);
        }
        
        /* Разные цвета для разных категорий */
        .category-section:nth-child(1) .template-btn { background-color: #e8f4e8; }
        .category-section:nth-child(2) .template-btn { background-color: #e8f0f4; }
        .category-section:nth-child(3) .template-btn { background-color: #f0e8f4; }
        .category-section:nth-child(4) .template-btn { background-color: #f4e8e8; }
        .category-section:nth-child(5) .template-btn { background-color: #f4f0e8; }
        .category-section:nth-child(6) .template-btn { background-color: #e8f4f0; }
        
        .category-section:nth-child(1) .template-btn:hover { background-color: #d0e9d0; }
        .category-section:nth-child(2) .template-btn:hover { background-color: #d0e5f0; }
        .category-section:nth-child(3) .template-btn:hover { background-color: #e5d0f0; }
        .category-section:nth-child(4) .template-btn:hover { background-color: #f0d0d0; }
        .category-section:nth-child(5) .template-btn:hover { background-color: #f0e5d0; }
        .category-section:nth-child(6) .template-btn:hover { background-color: #d0f0e5; }

        .input-group {
            margin-bottom: 10px;
        }

        .input-label {
            width: 80px;
            display: inline-block;
            font-weight: bold;
        }

        .function-mode-selector {
            margin-bottom: 15px;
            padding: 8px;
            background-color: #f5f5f5;
            border-radius: 4px;
        }

        .function-mode-selector label {
            margin-right: 15px;
            cursor: pointer;
        }

        .template-category-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-gap: 10px;
            margin-bottom: 15px;
        }

        .template-column {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .template-example-row {
            grid-column: span 2;
            display: flex;
            justify-content: center;
            margin-top: 5px;
        }

        .template-tab {
            padding: 8px 15px;
            cursor: pointer;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
            transition: background-color 0.2s;
        }

        .template-tab:hover {
            background-color: #e8e8e8;
        }

        .template-tab.active {
            background-color: #4CAF50;
            color: white;
            border-color: #3d8b40;
        }

        .template-tab-content {
            display: none;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 5px;
        }

        .template-tab-content.active {
            display: block;
        }

        .tab-icon {
            margin-right: 5px;
            font-size: 1.1em;
        }

        .export-btn {
            padding: 8px 16px;
            margin: 5px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .export-btn:hover {
            background-color: #0b7dda;
        }

        #notifications-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 400px;
        }

        .notification {
            background-color: #f8f9fa;
            border: 1px solid #4CAF50;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            position: relative;
        }

        .notification-title {
            margin: 0 0 5px 0;
            color: #4CAF50;
            padding-right: 20px;
        }

        .notification-message {
            font-size: 0.9em;
            color: #333;
        }

        .notification-close {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 20px;
            cursor: pointer;
            color: #666;
        }

        .canvas-wrapper {
            position: relative;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .right-panel {
            width: 520px;
            min-width: 520px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #progress-container {
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
        }
        
    </style>
</head>
<body>
    <h1>Визуализация комплексных функций</h1>

    <div class="main-container">
        <div class="left-panel">

            <div class="collapsible-section">
                <div class="collapsible-header">Настройки холста</div>
                <div class="collapsible-content">
                    <h2>Размеры холста:</h2>
                    <div class="control-group">
                            <select id="canvasSizePreset" onchange="setCanvasSize()">
                                <option value="500x500">500 x 500 (по умолчанию)</option>
                                <option value="800x600">800 x 600</option>
                                <option value="1024x768">1024 x 768</option>
                                <option value="1200x900">1200 x 900</option>
                                <option value="1600x1200">1600 x 1200</option>
                                <option value="1920x1080">1920 x 1080 (FullHD)</option>
                                <option value="custom">Произвольный размер</option>
                            </select>
                        </div>
                    </div>
                    <div class="control-group" style="margin-top: 15px;">
                        <div style="display: flex; align-items: center; margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; cursor: pointer; margin-right: 20px;">
                                <input type="checkbox" id="keepAspectRatioCheckbox" checked onchange="toggleAspectRatioMode()">
                                <span style="margin-left: 5px;">Сохранять соотношение сторон</span>
                            </label>
                            
                            <button id="resetSquareButton" onclick="resetToSquare()" 
                                    style="background-color: #4CAF50; color: white; border: none; 
                                    padding: 5px 10px; border-radius: 4px; cursor: pointer;">
                                Сбросить до квадрата
                            </button>
                        </div>
                        <div id="aspectRatioInfo" style="font-size: 0.9em; color: #666; margin-top: 5px;">
                            Режим сохранения пропорций включен. Область будет автоматически корректироваться.
                        </div>
                    </div>

                    <div style="margin-top: 15px;">
                        <label style="display: flex; align-items: center; cursor: pointer; margin-right: 20px;">
                            <input type="checkbox" id="linkSWithDomainCheckbox" checked onchange="toggleSLinkMode()">
                            <span style="margin-left: 5px;">Связать параметр s с областью визуализации</span>
                        </label>
                        <div id="sLinkInfo" style="font-size: 0.9em; color: #666; margin-top: 5px;">
                            Режим связывания включен. Область будет автоматически обновляться при изменении s.
                        </div>
                    </div>

                    <div class="control-row" id="customSizeControl" style="display: none; margin-top: 10px;">
                        <div class="control-group">
                            <div class="param-input">
                                <label for="canvasWidth">Ширина:</label>
                                <input type="number" id="canvasWidth" min="100" max="4000" value="500" style="width: 80px;">
                                <span style="margin: 0 10px;">x</span>
                                <label for="canvasHeight">Высота:</label>
                                <input type="number" id="canvasHeight" min="100" max="4000" value="500" style="width: 80px;">
                                <button onclick="applyCustomSize()" style="margin-left: 10px;">Применить</button>
                            </div>
                        </div>
                    
                    <h2>Область комплексной плоскости:</h2>
                    <div class="control-row">
                        <div class="control-group">
                            <div class="param-input">
                                <label for="xMin">X мин:</label>
                                <input type="number" id="xMin" step="0.1" value="-3.14" style="width: 80px;">
                                <label for="xMax" style="margin-left: 10px;">X макс:</label>
                                <input type="number" id="xMax" step="0.1" value="3.14" style="width: 80px;">
                            </div>
                            <div class="param-input">
                                <label for="yMin">Y мин:</label>
                                <input type="number" id="yMin" step="0.1" value="-3.14" style="width: 80px;">
                                <label for="yMax" style="margin-left: 10px;">Y макс:</label>
                                <input type="number" id="yMax" step="0.1" value="3.14" style="width: 80px;">
                            </div>
                            <button onclick="applyComplexDomain()" style="margin-top: 10px;">Применить область</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="collapsible-section">
                <div class="collapsible-header">Управление функцией и константами</div>
                <div class="collapsible-content visible">

                    <div class="function-mode-selector" style="margin-bottom: 15px;">
                        <h2>Режим визуализации:</h2>
                        <div style="display: flex; margin-bottom: 10px;">
                            <div style="margin-right: 20px;">
                                <label>
                                    <input type="radio" name="vizMode" id="domainColoringRadio" checked onchange="toggleVizMode()">
                                    Раскраска области определения
                                </label>
                            </div>
                            <div>
                                <label>
                                    <input type="radio" name="vizMode" id="conformalMapRadio" onchange="toggleVizMode()">
                                    Конформные отображения
                                </label>
                            </div>
                        </div>
                    </div>

                    <div id="conformalSettingsContainer" style="display: none; margin-bottom: 20px; padding: 10px; background-color: #f9f9f9; border-radius: 4px; border: 1px solid #eee;">
                        <h2>Настройки конформных отображений:</h2>
                        
                        <div class="control-group">
                            <h3>Тип сетки:</h3>
                            <select id="gridType" onchange="updateGridType()">
                                <option value="rectangular">Прямоугольная</option>
                                <option value="polar">Полярная</option>
                                <option value="chessboard">Шахматное поле</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <h3>Плотность сетки:</h3>
                            <div class="param-input">
                                <label for="gridDensitySlider">Плотность:</label>
                                <input type="range" id="gridDensitySlider" min="4" max="50" step="1" value="10" oninput="updateGridDensity()">
                                <input type="number" id="gridDensityValue" min="4" step="1" value="10" oninput="updateGridDensityFromInput()">
                            </div>
                        </div>

                        <div class="control-group">
                            <h3>Цвета сетки:</h3>
                            <div style="display: flex; gap: 20px;">
                                <div class="param-input">
                                    <label for="gridColor1">Цвет 1:</label>
                                    <input type="color" id="gridColor1" value="#000000" onchange="updateGridColor1()">
                                </div>
                                <div class="param-input">
                                    <label for="gridColor2">Цвет 2:</label>
                                    <input type="color" id="gridColor2" value="#ffffff" onchange="updateGridColor2()">
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <h3>Цвет фона:</h3>
                            <div class="param-input">
                                <label for="gridBackgroundColor">Цвет фона:</label>
                                <input type="color" id="gridBackgroundColor" value="#ffffff" onchange="updateGridBackgroundColor()">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <h3>Толщина линий сетки (кроме шахматного поля):</h3>
                            <div class="param-input">
                                <label for="gridLineWidthSlider">Толщина:</label>
                                <input type="range" id="gridLineWidthSlider" min="1" max="20" step="1" value="2" oninput="updateGridLineWidth()">
                                <input type="number" id="gridLineWidthValue" min="1" step="1" value="2" oninput="updateGridLineWidthFromInput()">
                                <span style="margin-left: 5px;">%</span>
                            </div>
                        </div>
                    </div>

                    <div class="control-row">
                        <div class="control-group">
                            <h2>Метод расчета L:</h2>
                            <select id="lMethod" onchange="updateMethodControls(); updateVisualization()">
                                <option value="0">Равномерная яркость</option>
                                <option value="1">Радиальное затухание</option>
                                <option value="2">Объёмная сетка</option>
                                <option value="3">Масштабируемая объёмная сетка</option>
                                <option value="4">Масштабируемая плоская сетка</option>
                                <option value="5">Шахматная сетка</option>
                                <option value="6">Модифицированная шахматная сетка</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <h2>Константы:</h2>
                            <div class="param-input" id="sContainer">
                                <label for="sSlider">Масштаб</label>
                                <input type="range" id="sSlider" min="0.1" max="10" step="0.1" value="6.28" oninput="updateConstant('s')">
                                <input type="number" id="sValue" min="0.1" step="0.1" value="6.28" oninput="updateConstantFromInput('s')">
                            </div>

                            <div class="param-input" id="dContainer">
                                <label for="dSlider">Плотность сетки</label>
                                <input type="range" id="dSlider" min="1" max="10" step="0.1" value="4" oninput="updateConstant('d')">
                                <input type="number" id="dValue" min="0.1" step="0.1" value="4" oninput="updateConstantFromInput('d')">
                            </div>

                            <div class="param-input" id="lContainer">
                                <label for="lSlider">Контрастность</label>
                                <input type="range" id="lSlider" min="0.1" max="10" step="0.1" value="2" oninput="updateConstant('l')">
                                <input type="number" id="lValue" min="0.1" step="0.1" value="2" oninput="updateConstantFromInput('l')">
                            </div>

                            <div class="param-input" id="pContainer">
                                <label for="pSlider">Скорость затухания</label>
                                <input type="range" id="pSlider" min="0.1" max="5" step="0.1" value="1" oninput="updateConstant('p')">
                                <input type="number" id="pValue" min="0.1" step="0.1" value="1" oninput="updateConstantFromInput('p')">
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <h2>Углы поворота:</h2>
                        <div class="angles-container">
                            <div class="angle-control">
                                <h3>Поворот z</h3>
                                <div class="circular-slider" id="thetaCircularSlider">
                                    <canvas id="thetaCanvas" width="150" height="150" class="control-canvas"></canvas>
                                </div>
                                <div class="angle-value" id="thetaValue">0 (0 рад)</div>
                            </div>

                            <div class="angle-control">
                                <h3>Поворот f(z)</h3>
                                <div class="circular-slider" id="phiCircularSlider">
                                    <canvas id="phiCanvas" width="150" height="150" class="control-canvas"></canvas>
                                </div>
                                <div class="angle-value" id="phiValue">0 (0 рад)</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="collapsible-section">
                <div class="collapsible-header">Пользовательская функция</div>
                <div class="collapsible-content visible">
                    <div style="margin-bottom: 10px;">
                        <div style="display: flex; margin-bottom: 10px;">
                            <div style="margin-right: 20px;">
                                <label>
                                    <input type="radio" name="inputMode" id="zModeRadio" checked onchange="toggleInputMode()">
                                    Функция от z
                                </label>
                            </div>
                            <div>
                                <label>
                                    <input type="radio" name="inputMode" id="xyModeRadio" onchange="toggleInputMode()">
                                    Функция от (x,y) через Re и Im
                                </label>
                            </div>
                        </div>
                        
                        <!-- Поле ввода для режима z -->
                        <div id="zInputContainer" style="display: flex; margin-bottom: 10px;">
                            <input type="text" id="customFunctionInput" style="flex-grow: 1; padding: 8px; font-family: monospace;" value="(z^3 + i) / z" placeholder="Введите функцию комплексного переменного, например: z^2 + 1">
                            <button onclick="updateVisualization()" style="margin-left: 10px;">Применить</button>
                        </div>
                        
                        <!-- Поля ввода для режима (x,y) -->
                        <div id="xyInputContainer" style="display: none; margin-bottom: 10px;">
                            <div style="display: flex; margin-bottom: 5px;">
                                <label style="width: 80px; line-height: 36px;">Re(x,y) = </label>
                                <input type="text" id="reFunction" style="flex-grow: 1; padding: 8px; font-family: monospace;" value="x" placeholder="Выражение для действительной части, например: x/(x^2+y^2)">
                            </div>
                            <div style="display: flex; margin-bottom: 5px;">
                                <label style="width: 80px; line-height: 36px;">Im(x,y) = </label>
                                <input type="text" id="imFunction" style="flex-grow: 1; padding: 8px; font-family: monospace;" value="y" placeholder="Выражение для мнимой части, например: y/(x^2+y^2)">
                            </div>
                            <div style="text-align: right;">
                                <button onclick="updateVisualization()" style="padding: 8px 16px;">Применить</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="collapsible-section">
                <div class="collapsible-header">Шаблоны функций</div>
                <div class="collapsible-content">
                    <div class="template-category-grid">
                        <div class="template-column">
                            <div class="template-tab active" onclick="changeTab(event, 'basic')">
                                <span class="tab-icon">⚙️</span> Базовые
                            </div>
                            <div class="template-tab" onclick="changeTab(event, 'trig')">
                                <span class="tab-icon">📐</span> Тригонометрические
                            </div>
                            <div class="template-tab" onclick="changeTab(event, 'special')">
                                <span class="tab-icon">🔍</span> Специальные
                            </div>
                        </div>
                        <div class="template-column">
                            <div class="template-tab" onclick="changeTab(event, 'hyper')">
                                <span class="tab-icon">⚛️</span> Гиперболические
                            </div>
                            <div class="template-tab" onclick="changeTab(event, 'poly')">
                                <span class="tab-icon">📊</span> Полиномы
                            </div>
                            <div class="template-tab" onclick="changeTab(event, 'comp')">
                                <span class="tab-icon">🔄</span> Композиции
                            </div>
                        </div>
                        <div class="template-example-row">
                            <div class="template-tab" onclick="changeTab(event, 'examples')">
                                <span class="tab-icon">📝</span> Примеры
                            </div>
                        </div>
                    </div>
                    
                    <!-- Базовые -->
                    <div class="template-tab-content active" id="basic">
                        <h3>Базовые операции</h3>
                        <div class="templates-grid">
                            <button onclick="insertTemplate('z')" class="template-btn">z</button>
                            <button onclick="insertTemplate('(a + b)')" class="template-btn">a + b</button>
                            <button onclick="insertTemplate('(a - b)')" class="template-btn">a - b</button>
                            <button onclick="insertTemplate('(a * b)')" class="template-btn">a * b</button>
                            <button onclick="insertTemplate('(a / b)')" class="template-btn">a / b</button>
                            <button onclick="insertTemplate('a^b')" class="template-btn">a^b</button>
                            <button onclick="insertTemplate('1/z')" class="template-btn">1/z</button>
                            <button onclick="insertTemplate('-z')" class="template-btn">-z</button>
                            <button onclick="insertTemplate('mod(a, b)')" class="template-btn">a mod b</button>
                        </div>
                        
                        <h3>Константы</h3>
                        <div class="templates-grid">
                            <button onclick="insertTemplate('i')" class="template-btn">i</button>
                            <button onclick="insertTemplate('e')" class="template-btn">e</button>
                            <button onclick="insertTemplate('pi')" class="template-btn">π</button>
                            <button onclick="insertTemplate('phi')" class="template-btn">φ</button>
                            <button onclick="insertTemplate('gamma')" class="template-btn">γ</button>
                            <button onclick="insertTemplate('infinity')" class="template-btn">∞</button>
                            <button onclick="insertTemplate('sqrt(2)')" class="template-btn">√2</button>
                            <button onclick="insertTemplate('sqrt(3)')" class="template-btn">√3</button>
                        </div>
                        
                        <h3>Свойства комплексных чисел</h3>
                        <div class="templates-grid">
                            <button onclick="insertTemplate('abs(z)')" class="template-btn">|z|</button>
                            <button onclick="insertTemplate('arg(z)')" class="template-btn">arg(z)</button>
                            <button onclick="insertTemplate('conj(z)')" class="template-btn">z*</button>
                            <button onclick="insertTemplate('re(z)')" class="template-btn">Re(z)</button>
                            <button onclick="insertTemplate('im(z)')" class="template-btn">Im(z)</button>
                            <button onclick="insertTemplate('1/conj(z)')" class="template-btn">1/z*</button>
                            <button onclick="insertTemplate('z * conj(z)')" class="template-btn">z * z*</button>
                        </div>
                        
                        <h3>Степенные и логарифмические</h3>
                        <div class="templates-grid">
                            <button onclick="insertTemplate('z^n')" class="template-btn">z^n</button>
                            <button onclick="insertTemplate('z^(1/n)')" class="template-btn">z^(1/n)</button>
                            <button onclick="insertTemplate('exp(z)')" class="template-btn">e^z</button>
                            <button onclick="insertTemplate('log(z)')" class="template-btn">ln(z)</button>
                            <button onclick="insertTemplate('log10(z)')" class="template-btn">log₁₀(z)</button>
                            <button onclick="insertTemplate('log(a, b)')" class="template-btn">log_a(b)</button>
                            <button onclick="insertTemplate('sqrt(z)')" class="template-btn">√z</button>
                            <button onclick="insertTemplate('cbrt(z)')" class="template-btn">cbrt(z)</button>
                        </div>
                    </div>
                    
                    <!-- Тригонометрические -->
                    <div class="template-tab-content" id="trig">
                        <h3>Основные тригонометрические</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('sin(z)', 'sin(z)')" class="template-btn">sin(z)</button>
                            <button onclick="smartInsert('cos(z)', 'cos(z)')" class="template-btn">cos(z)</button>
                            <button onclick="smartInsert('tan(z)', 'tan(z)')" class="template-btn">tan(z)</button>
                        </div>
                        
                        <h3>Дополнительные тригонометрические</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('sec(z)', 'sec(z)')" class="template-btn">sec(z)</button>
                            <button onclick="smartInsert('csc(z)', 'csc(z)')" class="template-btn">csc(z)</button>
                            <button onclick="smartInsert('cot(z)', 'cot(z)')" class="template-btn">cot(z)</button>
                        </div>
                        
                        <h3>Обратные тригонометрические</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('asin(z)', 'asin(z)')" class="template-btn">asin(z)</button>
                            <button onclick="smartInsert('acos(z)', 'acos(z)')" class="template-btn">acos(z)</button>
                            <button onclick="smartInsert('atan(z)', 'atan(z)')" class="template-btn">atan(z)</button>
                            <button onclick="smartInsert('asec(z)', 'asec(z)')" class="template-btn">asec(z)</button>
                            <button onclick="smartInsert('acsc(z)', 'acsc(z)')" class="template-btn">acsc(z)</button>
                            <button onclick="smartInsert('acot(z)', 'acot(z)')" class="template-btn">acot(z)</button>
                        </div>
                        
                        <h3>Функции Гудермана</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('gd(z)', 'gd(z)')" class="template-btn">gd(z)</button>
                            <button onclick="smartInsert('gdInv(z)', 'gdInv(z)')" class="template-btn">gd⁻¹(z)</button>
                            <button onclick="setFunction('gd(z)')" class="template-btn">f(z) = gd(z)</button>
                            <button onclick="setFunction('gdInv(z)')" class="template-btn">f(z) = gd⁻¹(z)</button>
                        </div>
                    </div>
                    
                    <!-- Гиперболические -->
                    <div class="template-tab-content" id="hyper">
                        <h3>Основные гиперболические</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('sinh(z)', 'sinh(z)')" class="template-btn">sinh(z)</button>
                            <button onclick="smartInsert('cosh(z)', 'cosh(z)')" class="template-btn">cosh(z)</button>
                            <button onclick="smartInsert('tanh(z)', 'tanh(z)')" class="template-btn">tanh(z)</button>
                        </div>
                        
                        <h3>Дополнительные гиперболические</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('sech(z)', 'sech(z)')" class="template-btn">sech(z)</button>
                            <button onclick="smartInsert('csch(z)', 'csch(z)')" class="template-btn">csch(z)</button>
                            <button onclick="smartInsert('coth(z)', 'coth(z)')" class="template-btn">coth(z)</button>
                        </div>
                        
                        <h3>Обратные гиперболические</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('asinh(z)', 'asinh(z)')" class="template-btn">asinh(z)</button>
                            <button onclick="smartInsert('acosh(z)', 'acosh(z)')" class="template-btn">acosh(z)</button>
                            <button onclick="smartInsert('atanh(z)', 'atanh(z)')" class="template-btn">atanh(z)</button>
                            <button onclick="smartInsert('asech(z)', 'asech(z)')" class="template-btn">asech(z)</button>
                            <button onclick="smartInsert('acsch(z)', 'acsch(z)')" class="template-btn">acsch(z)</button>
                            <button onclick="smartInsert('acoth(z)', 'acoth(z)')" class="template-btn">acoth(z)</button>
                        </div>
                    </div>
                    
                    <!-- Специальные -->
                    <div class="template-tab-content" id="special">
                        <h3>Гамма-функция и связанные</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('gamma(z)', 'gamma(z)')" class="template-btn">Γ(z)</button>
                            <button onclick="smartInsert('factorial(z)', 'factorial(z)')" class="template-btn">z!</button>
                            <button onclick="setFunction('gamma(z) * gamma(1 - z)')" class="template-btn">Γ(z)Γ(1-z)</button>
                        </div>
                        
                        <h3>Аналитические специальные функции</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('zeta(z)', 'zeta(z)')" class="template-btn">ζ(z)</button>
                            <button onclick="smartInsert('erf(z)', 'erf(z)')" class="template-btn">erf(z)</button>
                            <button onclick="smartInsert('lambertW(z)', 'lambertW(z)')" class="template-btn">W(z)</button>
                        </div>
                        
                        <h3>Функции Бесселя и Эйри</h3>
                        <div class="templates-grid">
                            <button onclick="insertTemplate('besselJ(n, z)')" class="template-btn">J_n(z)</button>
                            <button onclick="insertTemplate('besselY(n, z)')" class="template-btn">Y_n(z)</button>
                            <button onclick="smartInsert('airyAi(z)', 'airyAi(z)')" class="template-btn">Ai(z)</button>
                            <button onclick="insertTemplate('airyBi(z)')" class="template-btn">Bi(z)</button>
                            <button onclick="setFunction('besselJ(0, z)')" class="template-btn">J₀(z)</button>
                            <button onclick="setFunction('besselJ(1, z)')" class="template-btn">J₁(z)</button>
                        </div>
                        
                        <h3>Интегральные функции</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('sinc(z)', 'sinc(z)')" class="template-btn">sinc(z)</button>
                            <button onclick="smartInsert('Si(z)', 'Si(z)')" class="template-btn">Si(z)</button>
                            <button onclick="smartInsert('Ci(z)', 'Ci(z)')" class="template-btn">Ci(z)</button>
                            <button onclick="smartInsert('Ei(z)', 'Ei(z)')" class="template-btn">Ei(z)</button>
                            <button onclick="smartInsert('fresnelS(z)', 'fresnelS(z)')" class="template-btn">S(z)</button>
                            <button onclick="smartInsert('fresnelC(z)', 'fresnelC(z)')" class="template-btn">C(z)</button>
                            <button onclick="setFunction('sinc(z)')" class="template-btn">f(z) = sinc(z)</button>
                        </div>
                        
                        <h3>Ортогональные полиномы</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('legendre(n, z)', 'legendre(2, z)')" class="template-btn">P_n(z)</button>
                            <button onclick="smartInsert('chebyshevT(n, z)', 'chebyshevT(2, z)')" class="template-btn">T_n(z)</button>
                            <button onclick="smartInsert('chebyshevU(n, z)', 'chebyshevU(2, z)')" class="template-btn">U_n(z)</button>
                            <button onclick="setFunction('legendre(2, z)')" class="template-btn">P₂(z)</button>
                            <button onclick="setFunction('chebyshevT(3, z)')" class="template-btn">T₃(z)</button>
                        </div>
                        
                        <h3>Эллиптические функции</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('ellipticSn(z, 0.5)', 'ellipticSn(z, 0.5)')" class="template-btn">sn(z,k)</button>
                            <button onclick="smartInsert('ellipticCn(z, 0.5)', 'ellipticCn(z, 0.5)')" class="template-btn">cn(z,k)</button>
                            <button onclick="smartInsert('ellipticDn(z, 0.5)', 'ellipticDn(z, 0.5)')" class="template-btn">dn(z,k)</button>
                            <button onclick="smartInsert('ellipticK(0.5)', 'ellipticK(0.5)')" class="template-btn">K(k)</button>
                            <button onclick="smartInsert('ellipticE(0.5)', 'ellipticE(0.5)')" class="template-btn">E(k)</button>
                            <button onclick="smartInsert('weierstrassP(z, 1, 0.5)', 'weierstrassP(z, 1, 0.5)')" class="template-btn">℘(z,g₂,g₃)</button>
                        </div>
                        
                        <h3>Тета-функции Якоби</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('theta1(z, 0.5)', 'theta1(z, 0.5)')" class="template-btn">θ₁(z,q)</button>
                            <button onclick="smartInsert('theta2(z, 0.5)', 'theta2(z, 0.5)')" class="template-btn">θ₂(z,q)</button>
                            <button onclick="smartInsert('theta3(z, 0.5)', 'theta3(z, 0.5)')" class="template-btn">θ₃(z,q)</button>
                            <button onclick="smartInsert('theta4(z, 0.5)', 'theta4(z, 0.5)')" class="template-btn">θ₄(z,q)</button>
                            <button onclick="smartInsert('thetaGeneral(z, math.complex(0, 1), 0, 0)', 'thetaGeneral(z, math.complex(0, 1), 0, 0)')" class="template-btn">θ[a,b](z,τ)</button>
                            <button onclick="setFunction('theta3(z, 0.5)')" class="template-btn">f(z) = θ₃(z,0.5)</button>
                            <button onclick="setFunction('theta1(z, 0.7)')" class="template-btn">f(z) = θ₁(z,0.7)</button>
                        </div>
                        
                        <h3>Другие специальные функции</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('polylog(2, z)', 'polylog(2, z)')" class="template-btn">Li_s(z)</button>
                            <button onclick="smartInsert('dirichlet(5, z)', 'dirichlet(5, z)')" class="template-btn">D_n(z)</button>
                            <button onclick="smartInsert('lorentz(z, 0.1)', 'lorentz(z, 0.1)')" class="template-btn">L(z,γ)</button>
                            <button onclick="smartInsert('landau(z)', 'landau(z)')" class="template-btn">Φ(z)</button>
                            <button onclick="smartInsert('wright(0.5, 1, z)', 'wright(0.5, 1, z)')" class="template-btn">W(a,b,z)</button>
                            <button onclick="setFunction('polylog(2, z)')" class="template-btn">f(z) = Li₂(z)</button>
                            <button onclick="setFunction('landau(z)')" class="template-btn">f(z) = Φ(z)</button>
                        </div>

                        <h3>Дифференцирование и суммы</h3>
                        <div class="templates-grid">
                            <button onclick="smartInsert('diff(z, z)', 'diff(z, z)')" class="template-btn">f'(z)</button>
                            <button onclick="smartInsert('deriv(z, 2)', 'deriv(z, 2)')" class="template-btn">f''(z)</button>
                            <button onclick="smartInsert('sum(z^k, k, 1, n)', 'sum(z^k, k, 1, 10)')" class="template-btn">Σz^k</button>
                            <button onclick="smartInsert('series(z^k/factorial(k), k, 0)', 'series(z^k/factorial(k), k, 0, 20)')" class="template-btn">Σz^k/k!</button>
                            <button onclick="setFunction('diff(sin(z), z)')" class="template-btn">f(z) = sin'(z)</button>
                            <button onclick="setFunction('deriv(exp(z), 2)')" class="template-btn">f(z) = exp''(z)</button>
                        </div>

                    </div>
                    
                    <!-- Полиномы -->
                    <div class="template-tab-content" id="poly">
                        <h3>Полиномы</h3>
                        <div class="templates-grid">
                            <button onclick="setFunction('z^2')" class="template-btn">f(z) = z²</button>
                            <button onclick="setFunction('z^3 - 1')" class="template-btn">f(z) = z³ - 1</button>
                            <button onclick="setFunction('z^4 - 1')" class="template-btn">f(z) = z⁴ - 1</button>
                            <button onclick="setFunction('z^5 - 1')" class="template-btn">f(z) = z⁵ - 1</button>
                            <button onclick="setFunction('z^2 - z - 1')" class="template-btn">f(z) = z² - z - 1</button>
                            <button onclick="setFunction('z^3 - z')" class="template-btn">f(z) = z³ - z</button>
                            <button onclick="setFunction('z^4 - z^2')" class="template-btn">f(z) = z⁴ - z²</button>
                            <button onclick="setFunction('z^2 + z + 1')" class="template-btn">f(z) = z² + z + 1</button>
                        </div>
                        
                        <h3>Рациональные функции</h3>
                        <div class="templates-grid">
                            <button onclick="setFunction('1/z')" class="template-btn">f(z) = 1/z</button>
                            <button onclick="setFunction('(z^3 + i) / z')" class="template-btn">f(z) = (z³ + i) / z</button>
                            <button onclick="setFunction('(z^2 - 1)/(z^2 + 1)')" class="template-btn">f(z) = (z² - 1)/(z² + 1)</button>
                            <button onclick="setFunction('(z^2 - 4)/(z^2 - 1)')" class="template-btn">f(z) = (z² - 4)/(z² - 1)</button>
                            <button onclick="setFunction('(z^3 - 1)/(z - 1)')" class="template-btn">f(z) = (z³ - 1)/(z - 1)</button>
                            <button onclick="setFunction('z/(z^2 + 1)')" class="template-btn">f(z) = z/(z² + 1)</button>
                        </div>
                    </div>
                    
                    <!-- Композиции -->
                    <div class="template-tab-content" id="comp">
                        <h3>Композиции элементарных функций</h3>
                        <div class="templates-grid">
                            <button onclick="setFunction('sin(z^2)')" class="template-btn">f(z) = sin(z²)</button>
                            <button onclick="setFunction('exp(sin(z))')" class="template-btn">f(z) = e^(sin(z))</button>
                            <button onclick="setFunction('log(sin(z))')" class="template-btn">f(z) = ln(sin(z))</button>
                            <button onclick="setFunction('z * exp(z)')" class="template-btn">f(z) = z * e^z</button>
                            <button onclick="setFunction('z * log(z)')" class="template-btn">f(z) = z * ln(z)</button>
                            <button onclick="setFunction('sin(z)/z')" class="template-btn">f(z) = sin(z)/z</button>
                            <button onclick="setFunction('(exp(z) - 1)/z')" class="template-btn">f(z) = (e^z - 1)/z</button>
                            <button onclick="setFunction('exp(1/z)')" class="template-btn">f(z) = e^(1/z)</button>
                            <button onclick="setFunction('log(1 + z)')" class="template-btn">f(z) = ln(1 + z)</button>
                            <button onclick="setFunction('exp(-z^2)')" class="template-btn">f(z) = e^(-z²)</button>
                        </div>
                        
                        <h3>Специальные комбинации</h3>
                        <div class="templates-grid">
                            <button onclick="insertTemplate('(z^2 + a)/(z^2 - a)')" class="template-btn">(z² + a)/(z² - a)</button>
                            <button onclick="insertTemplate('exp(i*z)')" class="template-btn">e^(iz)</button>
                            <button onclick="insertTemplate('sin(z)/z')" class="template-btn">sin(z)/z</button>
                            <button onclick="insertTemplate('exp(-z^2)')" class="template-btn">e^(-z²)</button>
                            <button onclick="insertTemplate('log(1 + z)/(1 + z)')" class="template-btn">ln(1+z)/(1+z)</button>
                            <button onclick="insertTemplate('z/(e^z - 1)')" class="template-btn">z/(e^z - 1)</button>
                            <button onclick="insertTemplate('(z - a)/(1 - conj(a)*z)')" class="template-btn">Мёбиус</button>
                            <button onclick="insertTemplate('(z^n - 1)/(z - 1)')" class="template-btn">Сумма z^k</button>
                        </div>
                    </div>
                    
                    <!-- Примеры -->
                    <div class="template-tab-content" id="examples">
                        <h3>Комплексные тождества</h3>
                        <div class="templates-grid">
                            <button onclick="setFunction('exp(i*z)')" class="template-btn">f(z) = e^(iz)</button>
                            <button onclick="setFunction('cos(z) + i*sin(z)')" class="template-btn">f(z) = cos(z) + i*sin(z)</button>
                            <button onclick="setFunction('(exp(z) - exp(-z))/2')" class="template-btn">f(z) = sinh(z)</button>
                            <button onclick="setFunction('(exp(z) + exp(-z))/2')" class="template-btn">f(z) = cosh(z)</button>
                            <button onclick="setFunction('i^z')" class="template-btn">f(z) = i^z</button>
                            <button onclick="setFunction('z^i')" class="template-btn">f(z) = z^i</button>
                            <button onclick="setFunction('z^z')" class="template-btn">f(z) = z^z</button>
                        </div>
                        
                        <h3>Преобразование Жуковского</h3>
                        <div class="templates-grid">
                            <button onclick="setFunction('(z + 1/z)/2')" class="template-btn">f(z) = (z + 1/z)/2</button>
                            <button onclick="setFunction('(z - 1/z)/2')" class="template-btn">f(z) = (z - 1/z)/2</button>
                            <button onclick="setFunction('(z + 1/z)/2 + i*(z - 1/z)/2')" class="template-btn">f(z) = Re(z) + i*Im(z)²</button>
                            <button onclick="setFunction('z/(exp(z) - 1)')" class="template-btn">f(z) = z/(e^z - 1)</button>
                        </div>
                        
                        <h3>Функции Мёбиуса</h3>
                        <div class="templates-grid">
                            <button onclick="setFunction('(z - 1)/(z + 1)')" class="template-btn">f(z) = (z - 1)/(z + 1)</button>
                            <button onclick="setFunction('(z^2 - 1)/(z^2 + 1)')" class="template-btn">f(z) = (z² - 1)/(z² + 1)</button>
                            <button onclick="setFunction('(z - i)/(z + i)')" class="template-btn">f(z) = (z - i)/(z + i)</button>
                            <button onclick="setFunction('z/(z^2 + 2*z + 2)')" class="template-btn">f(z) = z/(z² + 2z + 2)</button>
                        </div>
                        
                        <h3>Функции из квантовой механики</h3>
                        <div class="templates-grid">
                            <button onclick="setFunction('exp(-z*conj(z))')" class="template-btn">f(z) = e^(-|z|²)</button>
                            <button onclick="setFunction('(z^2)*exp(-z*conj(z))')" class="template-btn">f(z) = z²e^(-|z|²)</button>
                            <button onclick="setFunction('z*exp(-abs(z))')" class="template-btn">f(z) = z*e^(-|z|)</button>
                        </div>
                        
                        <h3>Фрактальные функции</h3>
                        <div class="templates-grid">
                            <button onclick="setFunction('z^2 - 0.75')" class="template-btn">f(z) = z² - 0.75</button>
                            <button onclick="setFunction('z^2 - 0.123 + 0.745i')" class="template-btn">f(z) = z² - 0.123 + 0.745i</button>
                            <button onclick="setFunction('z^2 + 0.36 + 0.1i')" class="template-btn">f(z) = z² + 0.36 + 0.1i</button>
                            <button onclick="setFunction('z^2 - 1.25')" class="template-btn">f(z) = z² - 1.25</button>
                            <button onclick="setFunction('z^3 - 1 + 0.1i')" class="template-btn">f(z) = z³ - 1 + 0.1i</button>
                        </div>
                        
                        <h3>Примеры в формате Re/Im</h3>
                        <div class="templates-grid">
                            <button onclick="setReImFunction('x', 'y')" class="template-btn">f(z) = z</button>
                            <button onclick="setReImFunction('x/(x^2+y^2)', 'y/(x^2+y^2)')" class="template-btn">f(z) = 1/z</button>
                            <button onclick="setReImFunction('x^2-y^2', '2*x*y')" class="template-btn">f(z) = z^2</button>
                            <button onclick="setReImFunction('exp(x)*cos(y)', 'exp(x)*sin(y)')" class="template-btn">f(z) = e^z</button>
                            <button onclick="setReImFunction('cos(x)*cosh(y)', 'sin(x)*sinh(y)')" class="template-btn">f(z) = cos(z)</button>
                        </div>

                        <h3>Примеры дифференцирования и сумм</h3>
                        <div class="templates-grid">
                            <button onclick="setFunction('diff(z^2, z)')" class="template-btn">f(z) = (z²)'</button>
                            <button onclick="setFunction('deriv(sin(z), 2)')" class="template-btn">f(z) = sin''(z)</button>
                            <button onclick="setFunction('diff(1/z, z)')" class="template-btn">f(z) = (1/z)'</button>
                            <button onclick="setFunction('sum(z^k, k, 1, 5)')" class="template-btn">f(z) = Σz^k (1-5)</button>
                            <button onclick="setFunction('series(z^k/factorial(k), k, 0)')" class="template-btn">f(z) = e^z как ряд</button>
                            <button onclick="setFunction('sum(k*z^k, k, 1, 10)')" class="template-btn">f(z) = Σk·z^k</button>
                        </div>

                    </div>
                </div>
            </div>
            
            <div class="collapsible-section">
                <div class="collapsible-header">Экспорт визуализации</div>
                <div class="collapsible-content">
                    <div class="control-row">
                        <div class="control-group">
                            <h2>Экспорт изображения:</h2>
                            <button id="exportPngButton" onclick="exportImage('png')" class="export-btn">Экспорт в PNG</button>
                            <button id="exportJpgButton" onclick="exportImage('jpg')" class="export-btn">Экспорт в JPEG</button>
                            <button id="exportSvgButton" onclick="exportImage('svg')" class="export-btn">Экспорт в SVG</button>
                        </div>
                        
                        <div class="control-group">
                            <h2>Метаданные визуализации:</h2>
                            <textarea id="metadataText" readonly style="width: 100%; height: 150px; font-family: monospace; padding: 10px;"></textarea>
                            <button onclick="copyMetadata()" class="export-btn" style="margin-top: 10px;">Копировать метаданные</button>
                            <button onclick="exportMetadata()" class="export-btn" style="margin-top: 10px;">Сохранить как .txt</button>
                        </div>
                    </div>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <button onclick="updateVisualization()" style="padding: 10px 20px; font-size: 16px;">Обновить визуализацию</button>
                <button onclick="toggleDebug()" style="background-color: #999; margin-left: 15px;">Показать отладку</button>
            </div>
        </div>
        
        <div class="right-panel">
            <div class="canvas-wrapper" style="position: relative;">
                <canvas id="screen" width="500" height="500"></canvas>
                
                <div id="progress-container" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 400px; text-align: center; background-color: rgba(255, 255, 255, 0.9); padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.2); z-index: 100;">
                    <h3 style="margin-top: 0; color: #333;">Вычисление визуализации...</h3>
                    <div style="background-color: #eee; border-radius: 5px; overflow: hidden; height: 25px; margin: 10px 0;">
                        <div id="progress-bar" style="background-color: #4CAF50; height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div id="progress-text">0%</div>
                    <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
                        Вычисление комплексной функции <span id="function-name" style="font-family: monospace; font-weight: bold;">z</span>
                    </div>
                    <button id="cancel-rendering" style="margin-top: 15px; padding: 5px 10px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Отменить</button>
                </div>
            </div>
        </div>
    </div>

    <div id="debug-panel">
        <h3>Информация для отладки:</h3>
        <div id="debug-output" style="font-family: monospace; white-space: pre-wrap; font-size: 12px;"></div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script>
    
        // Флаг для отмены рендеринга
        let renderingCancelled = false;

        // Флаг для отслеживания режима визуализации
        let vizMode = "domainColoring"; // Возможные значения: "domainColoring", "conformalMap"

        // Глобальные параметры конформных отображений
        let gridType = "rectangular";
        let gridDensity = 10;
        let gridLineWidth = 2; // в процентах от размера ячейки
        let gridColor1 = "#000000";
        let gridColor2 = "#ffffff";

        // Глобальная переменная для цвета фона решётки
        let gridBackgroundColor = "#ffffff";

        // Функция обновления цвета фона решётки
        function updateGridBackgroundColor() {
            gridBackgroundColor = document.getElementById('gridBackgroundColor').value;
            updateVisualization();
        }
    
        // Включение режима отладки
        let debugMode = false;
        
        function toggleDebug() {
            debugMode = !debugMode;
            document.getElementById('debug-panel').style.display = debugMode ? 'block' : 'none';
            if (debugMode) {
                updateDebugInfo();
            }
        }
        
        function updateDebugInfo() {
            if (!debugMode) return;
            
            const debugOutput = document.getElementById('debug-output');
            let debug = "Версия math.js: " + (math.version || 'неизвестна') + "\n\n";
            
            // ДОБАВЛЕНО: Подробная информация о состоянии параметров визуализации
            debug += "== Режимы работы ==\n";

            debug += "Режим визуализации: " + (vizMode === "domainColoring" ? "Раскраска области определения" : "Конформные отображения") + "\n";
            if (vizMode === "conformalMap") {
                debug += "Тип решётки: " + getGridTypeString() + "\n";
                debug += "Плотность решётки: " + gridDensity + "\n";
                debug += "Ширина линий: " + gridLineWidth + "%\n";
            }

            if (vizMode === "conformalMap") {
                debug += "== Параметры конформных отображений ==\n";
                debug += `Тип решётки: ${gridType} (${getGridTypeString()})\n`;
                debug += `Плотность решётки: ${gridDensity}\n`;
                debug += `Ширина линий: ${gridLineWidth}%\n`;
                debug += `Цвет 1: ${gridColor1}\n`;
                debug += `Цвет 2: ${gridColor2}\n`;
                
                // Считываем значения из HTML-элементов для сравнения
                const htmlGridType = document.getElementById('gridType').value;
                const htmlGridDensity = parseInt(document.getElementById('gridDensityValue').value);
                const htmlGridLineWidth = parseInt(document.getElementById('gridLineWidthValue').value);
                const htmlGridColor1 = document.getElementById('gridColor1').value;
                const htmlGridColor2 = document.getElementById('gridColor2').value;
                
                debug += "\nЗначения из HTML-элементов:\n";
                debug += `Тип решётки: ${htmlGridType}\n`;
                debug += `Плотность решётки: ${htmlGridDensity}\n`;
                debug += `Ширина линий: ${htmlGridLineWidth}%\n`;
                debug += `Цвет 1: ${htmlGridColor1}\n`;
                debug += `Цвет 2: ${htmlGridColor2}\n`;
            }

            debug += "Режим связывания s с областью: " + (linkSWithDomain ? "Включен" : "Выключен") + "\n";
            debug += "Сохранение пропорций: " + (keepAspectRatio ? "Включено" : "Выключено") + "\n\n";
            
            debug += "== Константы ==\n";
            debug += `s: ${s} (из поля ввода: ${document.getElementById('sValue').value})\n`;
            debug += `d: ${d} (из поля ввода: ${document.getElementById('dValue').value})\n`;
            debug += `l: ${l} (из поля ввода: ${document.getElementById('lValue').value})\n`;
            debug += `p: ${p} (из поля ввода: ${document.getElementById('pValue').value})\n\n`;
            
            debug += "== Границы комплексной плоскости ==\n";
            debug += "Значения переменных:\n";
            debug += `xMin: ${xMin}, xMax: ${xMax}, yMin: ${yMin}, yMax: ${yMax}\n`;
            
            debug += "Значения в полях ввода:\n";
            debug += `xMin: ${document.getElementById('xMin').value}, ` +
                     `xMax: ${document.getElementById('xMax').value}, ` +
                     `yMin: ${document.getElementById('yMin').value}, ` +
                     `yMax: ${document.getElementById('yMax').value}\n\n`;
            
            debug += "== Список определенных функций ==\n";
            
            const functions = [
                'sin', 'cos', 'tan', 'asin', 'acos', 'atan',
                'sinh', 'cosh', 'tanh', 'asinh', 'acosh', 'atanh',
                'exp', 'log', 'sqrt', 'abs', 'conj', 'arg',
                'sec', 'csc', 'cot', 'sech', 'csch', 'coth',
                'factorial', 'zeta', 'erf', 'besselJ', 'besselY',
                'lambertW', 'airyAi', 'airyBi', 'cbrt'
            ];
            
            for (const func of functions) {
                if (typeof math[func] === 'function') {
                    debug += `math.${func}: ✓\n`;
                } else {
                    debug += `math.${func}: ✗\n`;
                }
            }

            debug += "\n== Функции дифференцирования и сумм ==\n";
            debug += `deriv: ${typeof math.deriv === 'function' ? '✓' : '✗'}\n`;
            debug += `nthDeriv: ${typeof math.nthDeriv === 'function' ? '✓' : '✗'}\n`;
            debug += `diff: ${typeof math.diff === 'function' ? '✓' : '✗'}\n`;
            debug += `sum: ${typeof math.sum === 'function' ? '✓' : '✗'}\n`;
            debug += `series: ${typeof math.series === 'function' ? '✓' : '✗'}\n`;
            
            debug += "\nТекущий режим: " + (inputMode === "z" ? "Функция от z" : "Функция от (x,y)") + "\n";

            if (inputMode === "z") {
                debug += "Текущая функция: " + customFunction + "\n";
                
                if (compiledFunction) {
                    debug += "Функция скомпилирована: Да\n";
                } else {
                    debug += "Функция скомпилирована: Нет\n";
                }
            } else {
                debug += "Функция Re(x,y): " + reFunction + "\n";
                debug += "Функция Im(x,y): " + imFunction + "\n";
                
                if (compiledReFunction && compiledImFunction) {
                    debug += "Функции скомпилированы: Да\n";
                } else {
                    debug += "Функции скомпилированы: Нет\n";
                }
            }

            debug += "\nРазмеры холста: " + document.getElementById('screen').width + "x" + document.getElementById('screen').height + " пикселей\n";
            debug += "Область комплексной плоскости: X[" + xMin.toFixed(2) + ", " + xMax.toFixed(2) + "], Y[" + yMin.toFixed(2) + ", " + yMax.toFixed(2) + "]\n";
            
            debugOutput.innerHTML = debug;
        }
        
        // Создаем константные объекты и вычисления, которые не будут меняться
        const PI = Math.PI;
        const PI2 = PI * 2;
        const ANGLE_SNAP_THRESHOLD = 0.1; // Порог притягивания в радианах
        
        // Получаем элементы управления
        const lMethodSelect = document.getElementById('lMethod');
        
        // Константы
        let s = 2*Math.PI;
        let d = 4;
        let l = 2;
        let p = 1;

        // Флаг для отслеживания режима сохранения пропорций
        let keepAspectRatio = true;

        // Глобальные переменные для границ комплексной плоскости
        let xMin = -3.14, xMax = 3.14, yMin = -3.14, yMax = 3.14;

        // Флаг для отслеживания режима связи s с областью
        let linkSWithDomain = true;
        
        // Параметры угла
        let theta = 0;
        let phi = 0;

        // Пользовательская функция и скомпилированная версия
        let customFunction = "(z^3 + i) / z"; // Значение по умолчанию
        let compiledFunction = null;

        // Переменные для режима ввода (x,y)
        let inputMode = "z"; // По умолчанию используем режим z
        let reFunction = "x"; // По умолчанию для Re(x,y)
        let imFunction = "y"; // По умолчанию для Im(x,y)
        let compiledReFunction = null;
        let compiledImFunction = null;

        // Переменная для отслеживания активного поля ввода
        let activeInputField = 'customFunctionInput';

        // Функция переключения режима ввода
        function toggleInputMode() {
            const zModeRadio = document.getElementById('zModeRadio');
            const zInputContainer = document.getElementById('zInputContainer');
            const xyInputContainer = document.getElementById('xyInputContainer');
            
            if (zModeRadio.checked) {
                // Переключаемся на режим z
                inputMode = "z";
                zInputContainer.style.display = "flex";
                xyInputContainer.style.display = "none";
                activeInputField = 'customFunctionInput';
            } else {
                // Переключаемся на режим (x,y)
                inputMode = "xy";
                zInputContainer.style.display = "none";
                xyInputContainer.style.display = "block";
                activeInputField = 'reFunction'; // По умолчанию активно поле Re
            }
            
            // Сбрасываем скомпилированные функции
            compiledFunction = null;
            compiledReFunction = null;
            compiledImFunction = null;
        }
        
        // Функция для установки Re и Im функций
        function setReImFunction(re, im) {
            // Переключаемся на режим (x,y) если он еще не активен
            if (inputMode !== "xy") {
                document.getElementById('xyModeRadio').checked = true;
                toggleInputMode();
            }
            
            // Устанавливаем функции
            document.getElementById('reFunction').value = re;
            document.getElementById('imFunction').value = im;
            
            // Обновляем визуализацию
            compiledReFunction = null;
            compiledImFunction = null;
            //updateVisualization();
        }

        // Функция для преобразования функции от z в выражения Re и Im
        function transformZToXY(funcStr) {
            // Таблица известных преобразований
            const transformations = {
                'z': { re: 'x', im: 'y' },
                'z^2': { re: 'x^2-y^2', im: '2*x*y' },
                '1/z': { re: 'x/(x^2+y^2)', im: '-y/(x^2+y^2)' },
                'exp(z)': { re: 'exp(x)*cos(y)', im: 'exp(x)*sin(y)' },
                'sin(z)': { re: 'sin(x)*cosh(y)', im: 'cos(x)*sinh(y)' },
                'cos(z)': { re: 'cos(x)*cosh(y)', im: '-sin(x)*sinh(y)' },
                'tan(z)': { re: 'sin(2*x)/(cos(2*x)+cosh(2*y))', im: 'sinh(2*y)/(cos(2*x)+cosh(2*y))' },
                'log(z)': { re: 'log(sqrt(x^2+y^2))', im: 'atan2(y,x)' },
                'sqrt(z)': { re: 'sqrt((sqrt(x^2+y^2)+x)/2)', im: 'sign(y)*sqrt((sqrt(x^2+y^2)-x)/2)' }
            };
            
            // Если есть точное соответствие в таблице
            if (transformations[funcStr]) {
                return transformations[funcStr];
            }
            
            // Иначе выполняем простую замену z -> x для Re и z -> y для Im
            return {
                re: funcStr.replace(/z(?!\w)/g, 'x'),
                im: funcStr.replace(/z(?!\w)/g, 'y')
            };
        }

        // Функция для установки размера холста на основе предустановки
        function setCanvasSize() {
            const sizePreset = document.getElementById('canvasSizePreset').value;
            const customSizeControl = document.getElementById('customSizeControl');
            
            if (sizePreset === 'custom') {
                customSizeControl.style.display = 'block';
            } else {
                customSizeControl.style.display = 'none';
                
                const [width, height] = sizePreset.split('x').map(Number);
                resizeCanvas(width, height);

            }
        }

        // Функция для применения произвольного размера
        function applyCustomSize() {
            const width = parseInt(document.getElementById('canvasWidth').value);
            const height = parseInt(document.getElementById('canvasHeight').value);
            
            // Проверка на валидность введенных значений
            if (width < 100 || width > 4000 || height < 100 || height > 4000) {
                alert('Пожалуйста, введите размеры от 100 до 4000 пикселей');
                return;
            }
            
            resizeCanvas(width, height);

            if (linkSWithDomain) {
                updateDomainFromS();
            }
        }

        // Функция для изменения размера холста
        function resizeCanvas(width, height) {
            const canvas = document.getElementById('screen');
            
            // Запоминаем предыдущий размер для масштабирования
            const prevWidth = canvas.width;
            const prevHeight = canvas.height;
            
            // Устанавливаем новые размеры (количество пикселей)
            canvas.width = width;
            canvas.height = height;
            
            // Вычисляем соотношение сторон
            const aspectRatio = width / height;
            
            // Определяем, какую сторону использовать в качестве базовой для расчета с максимумом 500px
            let displayWidth, displayHeight;
            
            if (width >= height) {
                // Для альбомной или квадратной ориентации
                displayHeight = 500;
                displayWidth = displayHeight * aspectRatio;
            } else {
                // Для портретной ориентации
                displayWidth = 500;
                displayHeight = displayWidth / aspectRatio;
            }
            
            // Ограничиваем максимальную ширину для предотвращения проблем с макетом
            const maxWidth = 500;
            if (displayWidth > maxWidth) {
                displayWidth = maxWidth;
                displayHeight = displayWidth / aspectRatio;
            }
            
            // Устанавливаем размеры отображения с сохранением пропорций
            canvas.style.width = `${displayWidth}px`;
            canvas.style.height = `${displayHeight}px`;
            
            // Обновляем стили контейнера canvas-wrapper для лучшего отображения
            const canvasWrapper = canvas.closest('.canvas-wrapper');
            if (canvasWrapper) {
                canvasWrapper.style.width = `${displayWidth}px`;
                canvasWrapper.style.height = `${displayHeight}px`;
            }
            
            // Обновляем область визуализации в соответствии с режимом
            if (linkSWithDomain) {
                updateDomainFromS(); // Если режим связывания включен, обновляем область на основе s
            } else {
                // Корректируем область комплексной плоскости с учётом пропорций
                adjustComplexDomainAspectRatio();
            }
            
            console.log(`Размер холста изменен на ${width}x${height} пикселей (отображается как ${Math.round(displayWidth)}x${Math.round(displayHeight)} пикселей)`);
        }

        // Функция для применения границ комплексной плоскости
        function applyComplexDomain() {
            xMin = parseFloat(document.getElementById('xMin').value);
            xMax = parseFloat(document.getElementById('xMax').value);
            yMin = parseFloat(document.getElementById('yMin').value);
            yMax = parseFloat(document.getElementById('yMax').value);
            
            // Проверка на валидность границ
            if (xMin >= xMax || yMin >= yMax) {
                alert('Неверно заданы границы: минимальное значение должно быть меньше максимального');
                return;
            }
            
            // Корректируем область с учётом соотношения сторон, если включен режим сохранения пропорций
            adjustComplexDomainAspectRatio();

            // Отключаем режим связывания s с областью при ручном изменении
            if (linkSWithDomain) {
                linkSWithDomain = false;
                document.getElementById('linkSWithDomainCheckbox').checked = false;
                toggleSLinkMode();
            }
            
            // Перерисовываем с новыми границами
            updateVisualization();
            
            console.log(`Границы комплексной плоскости изменены: X[${xMin}, ${xMax}], Y[${yMin}, ${yMax}]`);
        }

        // Функция для корректировки границ комплексной плоскости с учётом соотношения сторон холста
        function adjustComplexDomainAspectRatio(showNotification = true) {
            // Если режим сохранения пропорций выключен, ничего не делаем
            if (!keepAspectRatio) return;
            
            // УДАЛЕНО: блок с проверкой linkSWithDomain, это уже делается в updateDomainFromS
            
            const canvas = document.getElementById('screen');
            const canvasRatio = canvas.width / canvas.height;
            
            // Вычисляем текущие размеры области
            const domainWidth = xMax - xMin;
            const domainHeight = yMax - yMin;
            const domainRatio = domainWidth / domainHeight;
            
            // Если соотношения сторон отличаются, корректируем область
            if (Math.abs(canvasRatio - domainRatio) > 0.001) {
                // Сохраняем центр области
                const centerX = (xMax + xMin) / 2;
                const centerY = (yMax + yMin) / 2;
                
                // Сохраняем старые значения для информационного сообщения
                const oldXMin = xMin;
                const oldXMax = xMax;
                const oldYMin = yMin;
                const oldYMax = yMax;
                
                if (canvasRatio > domainRatio) {
                    // Холст шире - увеличиваем ширину области
                    const newWidth = domainHeight * canvasRatio;
                    xMin = centerX - newWidth / 2;
                    xMax = centerX + newWidth / 2;
                } else {
                    // Холст выше - увеличиваем высоту области
                    const newHeight = domainWidth / canvasRatio;
                    yMin = centerY - newHeight / 2;
                    yMax = centerY + newHeight / 2;
                }
                
                // ВАЖНО: Обновляем поля ввода, чтобы отразить новые значения
                document.getElementById('xMin').value = xMin.toFixed(2);
                document.getElementById('xMax').value = xMax.toFixed(2);
                document.getElementById('yMin').value = yMin.toFixed(2);
                document.getElementById('yMax').value = yMax.toFixed(2);
                
                if (debugMode) {
                    console.log(`Область скорректирована: X[${xMin.toFixed(2)}, ${xMax.toFixed(2)}], Y[${yMin.toFixed(2)}, ${yMax.toFixed(2)}]`);
                }
                
                // Показываем уведомление об изменении, если нужно
                if (showNotification) {
                    showNotification('Область комплексной плоскости скорректирована для сохранения пропорций', 
                        `Старые значения: X[${oldXMin.toFixed(2)}, ${oldXMax.toFixed(2)}], Y[${oldYMin.toFixed(2)}, ${oldYMax.toFixed(2)}]<br>` + 
                        `Новые значения: X[${xMin.toFixed(2)}, ${xMax.toFixed(2)}], Y[${yMin.toFixed(2)}, ${yMax.toFixed(2)}]`);
                }
            }
        }

        // Функция для переключения режима сохранения пропорций
        function toggleAspectRatioMode() {
            keepAspectRatio = document.getElementById('keepAspectRatioCheckbox').checked;
            
            // Обновляем информационный текст
            const infoElement = document.getElementById('aspectRatioInfo');
            if (infoElement) {
                if (keepAspectRatio) {
                    infoElement.textContent = 'Режим сохранения пропорций включен. Область будет автоматически корректироваться.';
                    // Сразу применяем корректировку
                    adjustComplexDomainAspectRatio();
                    updateVisualization();
                } else {
                    infoElement.textContent = 'Режим сохранения пропорций выключен. Масштабы по осям X и Y могут отличаться.';
                }
            }
            
            if (debugMode) {
                console.log(`Режим сохранения пропорций ${keepAspectRatio ? 'включен' : 'выключен'}`);
            }
        }

        // Функция для переключения режима связи s с областью
        function toggleSLinkMode() {
            linkSWithDomain = document.getElementById('linkSWithDomainCheckbox').checked;
            
            // Обновляем информационный текст
            const infoElement = document.getElementById('sLinkInfo');
            if (infoElement) {
                if (linkSWithDomain) {
                    infoElement.textContent = 'Режим связывания включен. Область будет автоматически обновляться при изменении s.';
                    // ВАЖНО: Сразу применяем область на основе s
                    updateDomainFromS();
                } else {
                    infoElement.textContent = 'Режим связывания выключен. Параметр s и область могут изменяться независимо.';
                }
            }
            
            if (debugMode) {
                console.log(`Режим связывания s с областью ${linkSWithDomain ? 'включен' : 'выключен'}`);
                updateDebugInfo();
            }
        }

        // Функция для сброса области к квадрату с сохранением масштаба
        function resetToSquare() {
            const canvas = document.getElementById('screen');
            
            // Вычисляем текущие размеры области
            const domainWidth = xMax - xMin;
            const domainHeight = yMax - yMin;
            
            // Определяем центр области
            const centerX = (xMax + xMin) / 2;
            const centerY = (yMax + yMin) / 2;
            
            // Определяем максимальную сторону для создания квадрата
            const maxSide = Math.max(domainWidth, domainHeight);
            
            // Устанавливаем новые границы, создавая квадратную область
            xMin = centerX - maxSide / 2;
            xMax = centerX + maxSide / 2;
            yMin = centerY - maxSide / 2;
            yMax = centerY + maxSide / 2;
            
            // Обновляем поля ввода
            document.getElementById('xMin').value = xMin.toFixed(2);
            document.getElementById('xMax').value = xMax.toFixed(2);
            document.getElementById('yMin').value = yMin.toFixed(2);
            document.getElementById('yMax').value = yMax.toFixed(2);
            
            // Корректируем с учётом соотношения сторон холста
            adjustComplexDomainAspectRatio();
            
            // Обновляем визуализацию
            updateVisualization();
            
            // Показываем уведомление
            showNotification('Область сброшена до квадрата', 
                           `Новые значения: X[${xMin.toFixed(2)}, ${xMax.toFixed(2)}], Y[${yMin.toFixed(2)}, ${yMax.toFixed(2)}]`);
        }

        // Функция для отображения уведомлений
        function showNotification(title, message, duration = 4000) {
            // Проверяем, существует ли уже контейнер для уведомлений
            let notificationsContainer = document.getElementById('notifications-container');
            
            if (!notificationsContainer) {
                // Создаем контейнер для уведомлений, если он не существует
                notificationsContainer = document.createElement('div');
                notificationsContainer.id = 'notifications-container';
                notificationsContainer.style.position = 'fixed';
                notificationsContainer.style.top = '20px';
                notificationsContainer.style.right = '20px';
                notificationsContainer.style.zIndex = '1000';
                notificationsContainer.style.maxWidth = '400px';
                document.body.appendChild(notificationsContainer);
            }
            
            // Создаем новое уведомление
            const notification = document.createElement('div');
            notification.style.backgroundColor = '#f8f9fa';
            notification.style.border = '1px solid #4CAF50';
            notification.style.borderRadius = '4px';
            notification.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
            notification.style.padding = '15px';
            notification.style.marginBottom = '10px';
            notification.style.transition = 'all 0.3s ease';
            notification.style.opacity = '0';
            
            // Добавляем заголовок
            const titleElement = document.createElement('h4');
            titleElement.textContent = title;
            titleElement.style.margin = '0 0 5px 0';
            titleElement.style.color = '#4CAF50';
            notification.appendChild(titleElement);
            
            // Добавляем сообщение
            const messageElement = document.createElement('div');
            messageElement.innerHTML = message;
            messageElement.style.fontSize = '0.9em';
            messageElement.style.color = '#333';
            notification.appendChild(messageElement);
            
            // Добавляем кнопку закрытия
            const closeButton = document.createElement('span');
            closeButton.textContent = '×';
            closeButton.style.position = 'absolute';
            closeButton.style.top = '5px';
            closeButton.style.right = '10px';
            closeButton.style.fontSize = '20px';
            closeButton.style.cursor = 'pointer';
            closeButton.style.color = '#666';
            closeButton.onclick = () => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    notificationsContainer.removeChild(notification);
                }, 300);
            };
            notification.appendChild(closeButton);
            
            // Добавляем уведомление в контейнер
            notificationsContainer.appendChild(notification);
            
            // Анимация появления
            setTimeout(() => {
                notification.style.opacity = '1';
            }, 10);
            
            // Автоматическое закрытие через заданное время
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (notification.parentNode === notificationsContainer) {
                        notificationsContainer.removeChild(notification);
                    }
                }, 300);
            }, duration);
        }

        // Предварительно вычисляем углы для меток
        const angleLabels = {};
        [
            {val: 0, text: '0'},
            {val: PI/6, text: 'π/6'},
            {val: PI/4, text: 'π/4'},
            {val: PI/3, text: 'π/3'},
            {val: PI/2, text: 'π/2'},
            {val: 2*PI/3, text: '2π/3'},
            {val: 3*PI/4, text: '3π/4'},
            {val: 5*PI/6, text: '5π/6'},
            {val: PI, text: 'π'},
            {val: 7*PI/6, text: '7π/6'},
            {val: 5*PI/4, text: '5π/4'},
            {val: 4*PI/3, text: '4π/3'},
            {val: 3*PI/2, text: '3π/2'},
            {val: 5*PI/3, text: '5π/3'},
            {val: 7*PI/4, text: '7π/4'},
            {val: 11*PI/6, text: '11π/6'},
            {val: 2*PI, text: '2π'}
        ].forEach(item => {
            angleLabels[item.val.toFixed(5)] = item.text;
        });
        
        // Функция для показа/скрытия параметров в зависимости от выбранного метода
        function updateMethodControls() {
            const method = parseInt(lMethodSelect.value);
            
            // s показываем всегда
            document.getElementById('sContainer').style.display = 'flex';
            
            // d показываем для методов 2, 3, 4, 5, 6
            document.getElementById('dContainer').style.display = 
                (method >= 2) ? 'flex' : 'none';
            
            // l показываем только для метода 4
            document.getElementById('lContainer').style.display = 
                (method === 4) ? 'flex' : 'none';
                
            // p показываем только для метода 1
            document.getElementById('pContainer').style.display = 
                (method === 1) ? 'flex' : 'none';
        }
        
        // Глобальные переменные для ползунков
        let thetaSlider, phiSlider;

        // Модифицированная функция initCircularSliders
        function initCircularSliders() {
            // Инициализируем ползунок для theta
            const thetaCanvas = document.getElementById('thetaCanvas');
            const thetaCtx = thetaCanvas.getContext('2d');
            thetaSlider = initSlider(thetaCanvas, thetaCtx, 'thetaValue', value => {
                theta = value;
                return theta;
            });
            
            // Инициализируем ползунок для phi
            const phiCanvas = document.getElementById('phiCanvas');
            const phiCtx = phiCanvas.getContext('2d');
            phiSlider = initSlider(phiCanvas, phiCtx, 'phiValue', value => {
                phi = value;
                return phi;
            });
            
            // Отображаем начальные значения
            displayAngleValue('thetaValue', theta);
            displayAngleValue('phiValue', phi);
        }
        
        // Инициализация одного кругового ползунка
        function initSlider(canvas, ctx, valueElementId, updateFunction) {
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = width / 2 - 10;
            let isDragging = false;
            
            // Предварительно вычисляем координаты меток на круге
            const markPositions = [];
            for (let i = 0; i < 12; i++) {
                const markAngle = i * Math.PI / 6;
                markPositions.push({
                    angle: markAngle,
                    startX: centerX + (radius - 5) * Math.cos(markAngle),
                    startY: centerY + (radius - 5) * Math.sin(markAngle),
                    endX: centerX + radius * Math.cos(markAngle),
                    endY: centerY + radius * Math.sin(markAngle)
                });
            }
            
            // Функция отрисовки ползунка
            function drawSlider(angle) {
                ctx.clearRect(0, 0, width, height);
                
                // Рисуем круг
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, PI2);
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Рисуем метки по предварительно вычисленным координатам
                for (let i = 0; i < markPositions.length; i++) {
                    const mark = markPositions[i];
                    
                    ctx.beginPath();
                    ctx.moveTo(mark.startX, mark.startY);
                    ctx.lineTo(mark.endX, mark.endY);
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Добавляем текст для основных углов (0, π/2, π, 3π/2)
                    if (i % 3 === 0) {
                        const textX = centerX + (radius - 15) * Math.cos(mark.angle);
                        const textY = centerY + (radius - 15) * Math.sin(mark.angle);
                        ctx.fillStyle = '#555';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        let text = '';
                        if (i === 0) text = '0';
                        else if (i === 3) text = 'π/2';
                        else if (i === 6) text = 'π';
                        else if (i === 9) text = '3π/2';
                        
                        ctx.fillText(text, textX, textY);
                    }
                }
                
                // Рисуем указатель (маркер текущего положения)
                const markerX = centerX + radius * Math.cos(angle);
                const markerY = centerY + radius * Math.sin(angle);
                
                ctx.beginPath();
                ctx.arc(markerX, markerY, 8, 0, PI2);
                ctx.fillStyle = '#4CAF50';
                ctx.fill();
                
                // Рисуем линию от центра до указателя
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(markerX, markerY);
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Обновляем отображение значения угла
                displayAngleValue(valueElementId, angle);
            }
            
            // Рассчитываем угол из координат мыши
            function getAngleFromMousePosition(mouseX, mouseY) {
                const rect = canvas.getBoundingClientRect();
                const x = mouseX - rect.left - centerX;
                const y = mouseY - rect.top - centerY;
                let angle = Math.atan2(y, x);
                
                // Преобразуем отрицательные углы в положительные (0 до 2π)
                if (angle < 0) {
                    angle += PI2;
                }
                
                return angle;
            }
            
            // Проверяем, нужно ли притягивать угол к ближайшей метке
            function checkForSnapping(angle) {
                const snapInterval = Math.PI / 6;
                const nearestSnapAngle = Math.round(angle / snapInterval) * snapInterval;
                
                // Если угол находится в пределах порога притягивания от метки,
                // притягиваем его к метке
                if (Math.abs(angle - nearestSnapAngle) < ANGLE_SNAP_THRESHOLD) {
                    return nearestSnapAngle;
                }
                
                return angle;
            }
            
            // Обработчики событий мыши
            canvas.addEventListener('mousedown', function(e) {
                const angle = getAngleFromMousePosition(e.clientX, e.clientY);
                const snappedAngle = checkForSnapping(angle);
                const updatedAngle = updateFunction(snappedAngle);
                drawSlider(updatedAngle);
                isDragging = true;
            });
            
            canvas.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    const angle = getAngleFromMousePosition(e.clientX, e.clientY);
                    const snappedAngle = checkForSnapping(angle);
                    const updatedAngle = updateFunction(snappedAngle);
                    drawSlider(updatedAngle);
                }
            });
            
            canvas.addEventListener('mouseup', function() {
                isDragging = false;
            });
            
            canvas.addEventListener('mouseleave', function() {
                isDragging = false;
            });
            
            // Начальная отрисовка ползунка с текущим значением угла
            drawSlider(updateFunction(0)); // Устанавливаем начальное значение
            
            // Возвращаем функцию для внешнего обновления ползунка
            return {
                update: function(angle) {
                    drawSlider(angle);
                }
            };
        }
        
        // Показываем значение угла в градусах и радианах
        function displayAngleValue(elementId, radians) {
            // Форматируем градусы
            const degrees = Math.round(radians * 180 / Math.PI);
            
            // Форматируем радианы с использованием красивых обозначений
            let radiansText = '';
            // Сначала проверяем часто используемые значения
            const anglesMap = {
                '0': '0',
                [Math.PI/6]: 'π/6',
                [Math.PI/4]: 'π/4',
                [Math.PI/3]: 'π/3',
                [Math.PI/2]: 'π/2',
                [2*Math.PI/3]: '2π/3',
                [3*Math.PI/4]: '3π/4',
                [5*Math.PI/6]: '5π/6',
                [Math.PI]: 'π',
                [7*Math.PI/6]: '7π/6',
                [5*Math.PI/4]: '5π/4',
                [4*Math.PI/3]: '4π/3',
                [3*Math.PI/2]: '3π/2',
                [5*Math.PI/3]: '5π/3',
                [7*Math.PI/4]: '7π/4',
                [11*Math.PI/6]: '11π/6',
                [2*Math.PI]: '2π'
            };
            
            // Проверяем, есть ли значение в нашей карте углов с точностью 0.01
            let found = false;
            for (const [angle, text] of Object.entries(anglesMap)) {
                if (Math.abs(radians - angle) < 0.01) {
                    radiansText = text;
                    found = true;
                    break;
                }
            }
            
            // Если значение не найдено в карте, отображаем числовое значение
            if (!found) {
                radiansText = radians.toFixed(2) + ' рад';
            }
            
            // Обновляем текст в элементе
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = `${degrees}° (${radiansText})`;
            }
        }

        // Обновление констант из ползунков
        function updateConstant(constName) {
            const sliderValue = parseFloat(document.getElementById(constName + 'Slider').value);
            document.getElementById(constName + 'Value').value = sliderValue;
            
            // Обновляем глобальную переменную
            window[constName] = sliderValue;

            // Если обновляется параметр s и включен режим связывания, обновляем область
            if (constName === 's' && linkSWithDomain) {
                updateDomainFromS();
            }
            
            if (debugMode) {
                console.log(`Константа ${constName} обновлена: ${sliderValue}`);
                updateDebugInfo();
            }
        }

        // Обновление констант из полей ввода
        function updateConstantFromInput(constName) {
            const inputValue = parseFloat(document.getElementById(constName + 'Value').value);
            document.getElementById(constName + 'Slider').value = inputValue;
            
            // Обновляем глобальную переменную
            window[constName] = inputValue;
            
            // Если обновляется параметр s и включен режим связывания, обновляем область
            if (constName === 's' && linkSWithDomain) {
                updateDomainFromS();
            }
            
            if (debugMode) {
                console.log(`Константа ${constName} обновлена из поля ввода: ${inputValue}`);
                updateDebugInfo();
            }
        }

        // Функция для обновления области комплексной плоскости на основе s
        function updateDomainFromS() {
            // Вычисляем значения на основе s (симметричная область от -s/2 до s/2)
            const halfS = s / 2;
            xMin = -halfS;
            xMax = halfS;
            yMin = -halfS;
            yMax = halfS;
            
            // Обновляем поля ввода, чтобы значения были видны пользователю
            document.getElementById('xMin').value = xMin.toFixed(2);
            document.getElementById('xMax').value = xMax.toFixed(2);
            document.getElementById('yMin').value = yMin.toFixed(2);
            document.getElementById('yMax').value = yMax.toFixed(2);
            
            // Корректируем с учётом соотношения сторон, только если включен соответствующий режим
            if (keepAspectRatio) {
                adjustComplexDomainAspectRatio(false); // false - не показывать уведомление
            }
            
            if (debugMode) {
                console.log(`Область обновлена на основе s=${s}: X[${xMin}, ${xMax}], Y[${yMin}, ${yMax}]`);
            }
        }
        
        // Оптимизированная функция расчета L на основе выбранного метода
        function calculateL(abs, arg, method) {
            // Расчет базовых констант
            const logAbs = Math.log(abs);
            const absLogAbs = Math.abs(logAbs);
            const piDivided = Math.PI / (d * 3);
            const argDivided = arg / piDivided;
            
            switch(method) {
                case 0:
                    return 0.5; // Константа
                    
                case 1:
                    return Math.exp(-Math.LN2 * abs * p); // Затухание
                    
                case 2:
                    // Минимум дробных частей
                    const fracLogAbs = logAbs - Math.floor(logAbs);
                    const fracArgDiv = argDivided - Math.floor(argDivided);
                    return Math.min(fracLogAbs, fracArgDiv);
                    
                case 3:
                    // Масштабированный минимум дробных частей
                    const scaledLogAbs3 = d * logAbs;
                    const fracScaledLogAbs3 = scaledLogAbs3 - Math.floor(scaledLogAbs3);
                    const fracArgDiv3 = argDivided - Math.floor(argDivided);
                    return Math.min(fracScaledLogAbs3, fracArgDiv3);
                    
                case 4:
                    // Произведение дробных частей с нормализацией
                    const scaledLogAbs4 = d * logAbs;
                    const fracScaledLogAbs4 = scaledLogAbs4 - Math.floor(scaledLogAbs4);
                    const fracArgDiv4 = argDivided - Math.floor(argDivided);
                    const product = fracScaledLogAbs4 * fracArgDiv4;
                    return (product - 0.5) / l + 0.5;
                    
                case 5:
                    // Побитовое XOR дискретизированных значений
                    const scaledLogAbs5 = d * absLogAbs;
                    const binary1 = Math.floor(scaledLogAbs5) % 2;
                    const argShifted5 = arg + Math.PI;
                    const binary2 = Math.floor(argShifted5 / piDivided) % 2;
                    return binary1 ^ binary2;
                    
                case 6:
                    // Сложное XOR с поворотом
                    const turn = (abs >= 1) ? 1 : 0;
                    const factor = 1 - 2 * turn;
                    const scaledLogAbs6 = d * absLogAbs;
                    const binary1_6 = Math.floor(scaledLogAbs6) % 2;
                    const xorPart1 = Math.floor(turn + factor * binary1_6);
                    const argShifted6 = arg + Math.PI;
                    const xorPart2 = Math.floor(argShifted6 / piDivided) % 2;
                    return xorPart1 ^ xorPart2;
                    
                default:
                    return 0.5;
            }
        }
        
        // Использование нативных функций Math для HSL -> RGB
        function calculateRGB(H, L, S) {
            // Используем нативные функции JavaScript для лучшей производительности
            // в операциях с отдельными числами
            const C = (1 - Math.abs(2*L - 1)) * S;
            const H1 = H / (Math.PI/3);
            const Z = C * (1 - Math.abs((H1 % 2) - 1));
            const m = L - C/2;
            
            let R, G, B;
            
            // Используем Math.floor для оптимизации ветвления
            const segment = Math.floor(H1);
            
            if (H1 >= 0 && H1 <= 6) {
                if (segment === 5 || segment === 6) { R = C; G = 0; B = Z; }
                else if (segment === 4) { R = Z; G = 0; B = C; }
                else if (segment === 3) { R = 0; G = Z; B = C; }
                else if (segment === 2) { R = 0; G = C; B = Z; }
                else if (segment === 1) { R = Z; G = C; B = 0; }
                else { R = C; G = Z; B = 0; }
            } else {
                R = G = B = 0;
            }
            
            // Возвращаем целые числа для RGB компонентов
            return [
                Math.round((R + m) * 255),
                Math.round((G + m) * 255),
                Math.round((B + m) * 255)
            ];
        }

        // Вставка шаблона в поле ввода с учетом преобразований
        function insertTemplate(template) {
            // Определяем активное поле ввода
            const inputField = document.getElementById(activeInputField);
            if (!inputField) {
                console.error("Активное поле ввода не найдено:", activeInputField);
                return;
            }
            
            const start = inputField.selectionStart;
            const end = inputField.selectionEnd;
            const selectedText = inputField.value.substring(start, end);
            
            // Если текст выделен, решаем, как его вставить в шаблон
            let newText;
            if (selectedText) {
                if (template === 'z' || template === 'i' || template === 'e' || template === 'pi') {
                    // Простая замена - просто вставляем шаблон
                    newText = template;
                } else if (template.includes('(a + b)') || template.includes('(a - b)') || 
                           template.includes('(a * b)') || template.includes('(a / b)') || 
                           template.includes('a^b') || template.includes('log(a, b)')) {
                    // Для бинарных операторов заменяем 'a' на выделенный текст
                    newText = template.replace('a', selectedText);
                } else {
                    // Для функций заменяем аргумент (z) на выделенный текст
                    if (template.includes('z')) {
                        newText = template.replace(/z(?!\w)/g, selectedText); // Заменяем только 'z', а не часть слова
                    } else {
                        // Если в шаблоне нет 'z', просто оборачиваем выделенный текст в шаблон
                        newText = template.replace(/\(.*?\)/, '(' + selectedText + ')');
                    }
                }
            } else {
                // Если ничего не выделено, проверяем режим ввода
                if (inputMode === "xy" && template.includes('z') && (activeInputField === 'reFunction' || activeInputField === 'imFunction')) {
                    // Используем таблицу преобразований
                    const transformed = transformZToXY(template);
                    if (activeInputField === 'reFunction') {
                        newText = transformed.re;
                    } else {
                        newText = transformed.im;
                    }
                } else {
                    // Просто вставляем шаблон как есть
                    newText = template;
                }
            }
            
            // Вставляем новый текст
            const newValue = inputField.value.substring(0, start) + newText + inputField.value.substring(end);
            inputField.value = newValue;
            
            // Устанавливаем фокус обратно на поле ввода
            inputField.focus();
            
            // Определяем новую позицию курсора
            const newPosition = start + newText.length;
            inputField.setSelectionRange(newPosition, newPosition);
        }
        
        // Установка предустановленной функции
        function setFunction(func) {
            if (inputMode === "z") {
                document.getElementById('customFunctionInput').value = func;
            } else {
                // Попытка разделить на Re и Im если функция в формате "re + i*im"
                const match = func.match(/^(.*?)\s*\+\s*i\s*\*\s*(.*?)$/);
                if (match) {
                    document.getElementById('reFunction').value = match[1].trim();
                    document.getElementById('imFunction').value = match[2].trim();
                } else {
                    // Применяем преобразования
                    const transformed = transformZToXY(func);
                    document.getElementById('reFunction').value = transformed.re;
                    document.getElementById('imFunction').value = transformed.im;
                }
            }
            
            // Сбрасываем скомпилированную функцию и перерисовываем визуализацию
            compiledFunction = null;
            compiledReFunction = null;
            compiledImFunction = null;
            //updateVisualization();
        }

        // Функция для интеллектуальной вставки или установки функции
        function smartInsert(template, fullFunction) {
            // Определяем активное поле ввода
            const inputField = document.getElementById(activeInputField);
            if (!inputField) {
                console.error("Активное поле ввода не найдено:", activeInputField);
                return;
            }
            
            if (inputField.value.trim() === "" || 
                (inputField.selectionStart === 0 && inputField.selectionEnd === inputField.value.length)) {
                // Если поле пустое или весь текст выделен
                
                // Проверяем режим ввода
                if (inputMode === "xy" && (activeInputField === 'reFunction' || activeInputField === 'imFunction')) {
                    // Адаптируем шаблон для режима (x,y) используя трансформацию
                    const transformed = transformZToXY(fullFunction);
                    if (activeInputField === 'reFunction') {
                        inputField.value = transformed.re;
                    } else {
                        inputField.value = transformed.im;
                    }
                } else {
                    // Устанавливаем полную функцию
                    inputField.value = fullFunction;
                }
                
                // Устанавливаем фокус обратно на поле ввода
                inputField.focus();
            } else {
                // Иначе вставляем как шаблон
                insertTemplate(template);
            }
            
            // После изменения поля обновляем визуализацию
            compiledFunction = null;
            compiledReFunction = null;
            compiledImFunction = null;
        }

        // Функция для выделения активного поля ввода
        function highlightActiveField() {
            // Сбрасываем стили для всех полей
            document.getElementById('reFunction').style.backgroundColor = '#ffffff';
            document.getElementById('imFunction').style.backgroundColor = '#ffffff';
            document.getElementById('customFunctionInput').style.backgroundColor = '#ffffff';
            
            // Выделяем активное поле
            if (document.getElementById(activeInputField)) {
                document.getElementById(activeInputField).style.backgroundColor = '#f0f8ff';
            }
        }

        // =============================================
        // ОСНОВНАЯ ЧАСТЬ РЕШЕНИЯ ПРОБЛЕМЫ С ФУНКЦИЯМИ
        // =============================================

        // Глобальный объект для хранения наших кастомных функций
        window.customMathFunctions = {};

        // Функция для определения всех дополнительных математических функций
        function defineCustomMathFunctions() {
            console.log("Определение пользовательских математических функций...");

            // 1. Регистрируем все кастомные функции в нашем глобальном объекте
            
            // Секанс
            window.customMathFunctions.sec = function(z) {
                return math.divide(1, math.cos(z));
            };

            // Косеканс
            window.customMathFunctions.csc = function(z) {
                return math.divide(1, math.sin(z));
            };

            // Котангенс
            window.customMathFunctions.cot = function(z) {
                return math.divide(math.cos(z), math.sin(z));
            };

            // Гиперболический секанс
            window.customMathFunctions.sech = function(z) {
                return math.divide(1, math.cosh(z));
            };

            // Гиперболический косеканс
            window.customMathFunctions.csch = function(z) {
                return math.divide(1, math.sinh(z));
            };

            // Гиперболический котангенс
            window.customMathFunctions.coth = function(z) {
                return math.divide(math.cosh(z), math.sinh(z));
            };

            // Кубический корень
            window.customMathFunctions.cbrt = function(z) {
                return math.pow(z, 1/3);
            };

            // Факториал (через гамма-функцию для комплексных чисел)
            window.customMathFunctions.factorial = function(z) {
                return math.gamma(math.add(z, 1));
            };

            // Дзета-функция Римана (аппроксимация)
            window.customMathFunctions.zeta = function(z) {
                var sum = math.complex(0, 0);
                var terms = 20; // Для производительности
                
                for (var k = 1; k <= terms; k++) {
                    sum = math.add(sum, math.divide(1, math.pow(k, z)));
                }
                
                return sum;
            };

            // Функция ошибок
            window.customMathFunctions.erf = function(z) {
                return math.multiply(
                    math.divide(2, math.sqrt(math.pi)),
                    math.multiply(z, math.exp(math.multiply(-1, math.pow(z, 2))))
                );
            };

            // Функции Бесселя (простая аппроксимация)
            window.customMathFunctions.besselJ = function(n, z) {
                if (n === 0) {
                    return math.cos(z);
                } else if (n === 1) {
                    return math.divide(math.sin(z), 2);
                } else {
                    return math.multiply(
                        math.cos(math.subtract(z, math.multiply(n, math.pi/2))),
                        math.divide(1, math.sqrt(z))
                    );
                }
            };

            // Функция Бесселя второго рода
            window.customMathFunctions.besselY = function(n, z) {
                if (n === 0) {
                    return math.sin(z);
                } else {
                    return math.multiply(math.sin(z), math.log(z));
                }
            };

            // W-функция Ламберта (аппроксимация)
            window.customMathFunctions.lambertW = function(z) {
                return math.subtract(z, math.pow(z, 2));
            };

            // Функции Эйри
            window.customMathFunctions.airyAi = function(z) {
                return math.multiply(
                    math.exp(math.multiply(-0.333, math.pow(z, 1.5))),
                    math.cos(math.multiply(0.5, z))
                );
            };

            window.customMathFunctions.airyBi = function(z) {
                return math.multiply(
                    math.exp(math.multiply(0.333, math.pow(z, 1.5))),
                    math.sin(math.multiply(0.5, z))
                );
            };
            
            // Дополнительные обратные тригонометрические функции
            window.customMathFunctions.asec = function(z) {
                return math.acos(math.divide(1, z));
            };
            
            window.customMathFunctions.acsc = function(z) {
                return math.asin(math.divide(1, z));
            };
            
            window.customMathFunctions.acot = function(z) {
                return math.atan(math.divide(1, z));
            };
            
            // Дополнительные обратные гиперболические функции
            window.customMathFunctions.asech = function(z) {
                return math.acosh(math.divide(1, z));
            };
            
            window.customMathFunctions.acsch = function(z) {
                return math.asinh(math.divide(1, z));
            };
            
            window.customMathFunctions.acoth = function(z) {
                return math.atanh(math.divide(1, z));
            };
            
            // Функция Гудермана и обратная функция Гудермана
            window.customMathFunctions.gd = function(z) {
                return math.atan(math.sinh(z));
            };
            
            window.customMathFunctions.gdInv = function(z) {
                return math.asinh(math.tan(z));
            };
            
            // Дополнительные специальные функции
            
            // Синус-кардинал
            window.customMathFunctions.sinc = function(z) {
                if (math.abs(z) < 1e-10) {
                    return 1;
                }
                return math.divide(math.sin(z), z);
            };
            
            // Интегральный синус
            window.customMathFunctions.Si = function(z) {
                var sum = math.complex(0, 0);
                var terms = 20;
                
                for (var k = 0; k < terms; k++) {
                    var term = math.divide(
                        math.multiply(
                            math.pow(-1, k),
                            math.pow(z, 2*k+1)
                        ),
                        math.multiply(
                            2*k+1,
                            math.factorial(2*k+1)
                        )
                    );
                    sum = math.add(sum, term);
                }
                
                return sum;
            };
            
            // Интегральный косинус
            window.customMathFunctions.Ci = function(z) {
                var sum = math.complex(0, 0);
                var terms = 20;
                var gamma = 0.57721566490153286; // Константа Эйлера-Маскерони
                
                sum = math.add(sum, math.log(z));
                sum = math.add(sum, gamma);
                
                for (var k = 1; k < terms; k++) {
                    var term = math.divide(
                        math.multiply(
                            math.pow(-1, k),
                            math.pow(z, 2*k)
                        ),
                        math.multiply(
                            2*k,
                            math.factorial(2*k)
                        )
                    );
                    sum = math.add(sum, term);
                }
                
                return sum;
            };
            
            // Экспоненциальный интеграл
            window.customMathFunctions.Ei = function(z) {
                var sum = math.complex(0, 0);
                var terms = 20;
                var gamma = 0.57721566490153286; // Константа Эйлера-Маскерони
                
                sum = math.add(sum, gamma);
                sum = math.add(sum, math.log(math.abs(z)));
                
                for (var k = 1; k < terms; k++) {
                    var term = math.divide(
                        math.pow(z, k),
                        math.multiply(
                            k,
                            math.factorial(k)
                        )
                    );
                    sum = math.add(sum, term);
                }
                
                return sum;
            };
            
            // Интегралы Френеля
            window.customMathFunctions.fresnelS = function(z) {
                var sum = math.complex(0, 0);
                var terms = 10;
                
                for (var k = 0; k < terms; k++) {
                    var term = math.multiply(
                        math.pow(-1, k),
                        math.divide(
                            math.pow(z, 4*k+3),
                            math.multiply(
                                math.factorial(2*k+1),
                                4*k+3
                            )
                        )
                    );
                    sum = math.add(sum, term);
                }
                
                return math.multiply(
                    math.divide(math.pi, 2),
                    sum
                );
            };
            
            window.customMathFunctions.fresnelC = function(z) {
                var sum = math.complex(0, 0);
                var terms = 10;
                
                for (var k = 0; k < terms; k++) {
                    var term = math.multiply(
                        math.pow(-1, k),
                        math.divide(
                            math.pow(z, 4*k+1),
                            math.multiply(
                                math.factorial(2*k),
                                4*k+1
                            )
                        )
                    );
                    sum = math.add(sum, term);
                }
                
                return sum;
            };
            
            // Полиномы Лежандра
            window.customMathFunctions.legendre = function(n, z) {
                if (n === 0) {
                    return 1;
                } else if (n === 1) {
                    return z;
                } else {
                    var p0 = 1;
                    var p1 = z;
                    var p = 0;
                    
                    for (var k = 2; k <= n; k++) {
                        p = math.divide(
                            math.subtract(
                                math.multiply(
                                    math.multiply(2*k-1, z),
                                    p1
                                ),
                                math.multiply(k-1, p0)
                            ),
                            k
                        );
                        p0 = p1;
                        p1 = p;
                    }
                    
                    return p;
                }
            };
            
            // Полиномы Чебышева первого рода
            window.customMathFunctions.chebyshevT = function(n, z) {
                if (n === 0) {
                    return 1;
                } else if (n === 1) {
                    return z;
                } else {
                    var t0 = 1;
                    var t1 = z;
                    var t = 0;
                    
                    for (var k = 2; k <= n; k++) {
                        t = math.subtract(
                            math.multiply(2, math.multiply(z, t1)),
                            t0
                        );
                        t0 = t1;
                        t1 = t;
                    }
                    
                    return t;
                }
            };
            
            // Полиномы Чебышева второго рода
            window.customMathFunctions.chebyshevU = function(n, z) {
                if (n === 0) {
                    return 1;
                } else if (n === 1) {
                    return math.multiply(2, z);
                } else {
                    var u0 = 1;
                    var u1 = math.multiply(2, z);
                    var u = 0;
                    
                    for (var k = 2; k <= n; k++) {
                        u = math.subtract(
                            math.multiply(2, math.multiply(z, u1)),
                            u0
                        );
                        u0 = u1;
                        u1 = u;
                    }
                    
                    return u;
                }
            };
            
            // Эллиптические функции Якоби
            window.customMathFunctions.ellipticSn = function(z, k) {
                return math.sin(z); // Упрощенная реализация
            };
            
            window.customMathFunctions.ellipticCn = function(z, k) {
                return math.cos(z); // Упрощенная реализация
            };
            
            window.customMathFunctions.ellipticDn = function(z, k) {
                return math.sqrt(1 - k*k * math.pow(math.sin(z), 2)); // Упрощенная реализация
            };
            
            // Эллиптический интеграл первого рода
            window.customMathFunctions.ellipticK = function(k) {
                var sum = math.complex(0, 0);
                var terms = 10;
                
                for (var n = 0; n < terms; n++) {
                    var term = math.multiply(
                        math.pow(
                            math.divide(
                                math.factorial(2*n),
                                math.pow(math.factorial(n), 2)
                            ),
                            2
                        ),
                        math.divide(
                            math.pow(k, 2*n),
                            4*n+1
                        )
                    );
                    sum = math.add(sum, term);
                }
                
                return math.multiply(
                    math.divide(math.pi, 2),
                    sum
                );
            };
            
            // Эллиптический интеграл второго рода
            window.customMathFunctions.ellipticE = function(k) {
                var sum = math.complex(1, 0);
                var terms = 10;
                
                for (var n = 1; n < terms; n++) {
                    var term = math.multiply(
                        math.pow(
                            math.divide(
                                math.factorial(2*n),
                                math.pow(math.factorial(n), 2)
                            ),
                            2
                        ),
                        math.divide(
                            math.pow(k, 2*n),
                            1-2*n
                        )
                    );
                    sum = math.add(sum, term);
                }
                
                return math.multiply(
                    math.divide(math.pi, 2),
                    sum
                );
            };
            
            // Полилогарифм
            window.customMathFunctions.polylog = function(s, z) {
                var sum = math.complex(0, 0);
                var terms = 15;
                
                for (var k = 1; k <= terms; k++) {
                    sum = math.add(
                        sum,
                        math.divide(
                            math.pow(z, k),
                            math.pow(k, s)
                        )
                    );
                }
                
                return sum;
            };
            
            // Функция Дирихле
            window.customMathFunctions.dirichlet = function(n, z) {
                var sum = 0;
                for (var k = 1; k <= n; k++) {
                    if (n % k === 0) {
                        sum += Math.cos(k * z);
                    }
                }
                return sum;
            };
            
            // Функция Лоренца
            window.customMathFunctions.lorentz = function(z, gamma) {
                return math.divide(
                    1,
                    math.add(
                        1,
                        math.pow(
                            math.divide(z, gamma),
                            2
                        )
                    )
                );
            };
            
            // Функция Вейерштрасса (упрощенная)
            window.customMathFunctions.weierstrassP = function(z, g2, g3) {
                return math.divide(
                    1,
                    math.pow(z, 2)
                ); // Упрощенная, только ведущий член разложения
            };
            
            // Функция Ландау
            window.customMathFunctions.landau = function(z) {
                return math.exp(
                    math.multiply(
                        -1,
                        math.exp(math.multiply(-1, z))
                    )
                );
            };
            
            // Функция Райта (упрощенная)
            window.customMathFunctions.wright = function(a, b, z) {
                var sum = math.complex(0, 0);
                var terms = 10;
                
                for (var k = 0; k < terms; k++) {
                    sum = math.add(
                        sum,
                        math.divide(
                            math.pow(z, k),
                            math.multiply(
                                math.factorial(k),
                                math.gamma(a*k + b)
                            )
                        )
                    );
                }
                
                return sum;
            };
            
            // Тета-функции Якоби
            window.customMathFunctions.theta1 = function(z, q) {
                if (typeof q === 'undefined') q = 0.5;
                
                var sum = math.complex(0, 0);
                var terms = 10; // Ограничиваем число членов ряда для производительности
                
                for (var n = 0; n < terms; n++) {
                    var sign = Math.pow(-1, n);
                    var qPower = Math.pow(q, n * (n + 1));
                    var term = math.multiply(
                        sign * qPower,
                        math.sin(math.multiply(2 * n + 1, z))
                    );
                    sum = math.add(sum, term);
                }
                
                return math.multiply(2, sum);
            };
            
            window.customMathFunctions.theta2 = function(z, q) {
                if (typeof q === 'undefined') q = 0.5;
                
                var sum = math.complex(0, 0);
                var terms = 10;
                
                for (var n = 0; n < terms; n++) {
                    var qPower = Math.pow(q, n * (n + 1));
                    var term = math.multiply(
                        qPower,
                        math.cos(math.multiply(2 * n + 1, z))
                    );
                    sum = math.add(sum, term);
                }
                
                return math.multiply(2, sum);
            };
            
            window.customMathFunctions.theta3 = function(z, q) {
                if (typeof q === 'undefined') q = 0.5;
                
                var sum = math.complex(1, 0); // Начинаем с 1 (n=0 член)
                var terms = 10;
                
                for (var n = 1; n < terms; n++) {
                    var qPower = Math.pow(q, n * n);
                    var term = math.multiply(
                        2 * qPower,
                        math.cos(math.multiply(2 * n, z))
                    );
                    sum = math.add(sum, term);
                }
                
                return sum;
            };
            
            window.customMathFunctions.theta4 = function(z, q) {
                if (typeof q === 'undefined') q = 0.5;
                
                var sum = math.complex(1, 0); // Начинаем с 1 (n=0 член)
                var terms = 10;
                
                for (var n = 1; n < terms; n++) {
                    var sign = Math.pow(-1, n);
                    var qPower = Math.pow(q, n * n);
                    var term = math.multiply(
                        2 * sign * qPower,
                        math.cos(math.multiply(2 * n, z))
                    );
                    sum = math.add(sum, term);
                }
                
                return sum;
            };
            
            // Общая тета-функция с характеристиками
            window.customMathFunctions.thetaGeneral = function(z, tau, a, b) {
                if (typeof tau === 'undefined') tau = math.complex(0, 1);
                if (typeof a === 'undefined') a = 0;
                if (typeof b === 'undefined') b = 0;
                
                var sum = math.complex(0, 0);
                var terms = 7; // Меньше членов для общей формы (более сложные вычисления)
                var q = math.exp(math.multiply(math.pi, math.multiply(math.i, tau)));
                
                for (var n = -terms; n <= terms; n++) {
                    // exp(πi(n+a)²τ) * exp(2πi(n+a)(z+b))
                    var nPlusA = n + a;
                    var exponent1 = math.multiply(
                        math.multiply(math.pi, math.i),
                        math.multiply(nPlusA * nPlusA, tau)
                    );
                    var exponent2 = math.multiply(
                        math.multiply(2 * math.pi, math.i),
                        math.multiply(nPlusA, z + b)
                    );
                    
                    var term = math.multiply(
                        math.exp(exponent1),
                        math.exp(exponent2)
                    );
                    
                    sum = math.add(sum, term);
                }
                
                return sum;
            };
            
            // Действительная и мнимая части
            window.customMathFunctions.re = function(z) {
                if (math.typeOf(z) === 'Complex') {
                    return z.re;
                }
                return z;
            };

            window.customMathFunctions.im = function(z) {
                if (math.typeOf(z) === 'Complex') {
                    return z.im;
                }
                return 0;
            };
            
            // Константы
            window.customMathFunctions.phi = (1 + Math.sqrt(5)) / 2; // Золотое сечение
            window.customMathFunctions.eulergamma = 0.57721566490153286; // Постоянная Эйлера-Маскерони

            // Функция численного дифференцирования комплексной функции
            window.customMathFunctions.deriv = function(func, z, h) {
                if (typeof h === 'undefined') h = 1e-6;
                
                try {
                    // Вычисляем значение функции в точке z + h
                    const scope = { z: math.add(z, h) };
                    const f_z_plus_h = evaluateWithParser(func, scope);
                    
                    // Вычисляем значение функции в точке z
                    scope.z = z;
                    const f_z = evaluateWithParser(func, scope);
                    
                    // Вычисляем приближение производной
                    return math.divide(math.subtract(f_z_plus_h, f_z), h);
                } catch (error) {
                    console.error("Ошибка при вычислении производной:", error);
                    return math.complex(0, 0);
                }
            };

            // Функция для вычисления n-ой производной
            window.customMathFunctions.nthDeriv = function(func, z, n, h) {
                if (typeof h === 'undefined') h = 1e-6;
                if (typeof n === 'undefined') n = 1;
                
                // Для n = 0 возвращаем значение самой функции
                if (n === 0) {
                    try {
                        return evaluateWithParser(func, { z: z });
                    } catch (error) {
                        console.error("Ошибка при вычислении функции:", error);
                        return math.complex(0, 0);
                    }
                }
                
                // Для n = 1 используем обычное дифференцирование
                if (n === 1) {
                    return window.customMathFunctions.deriv(func, z, h);
                }
                
                // Для n > 1 рекурсивно вычисляем n-1 производную и дифференцируем её
                const derivFunc = function(z) {
                    return window.customMathFunctions.nthDeriv(func, z, n-1, h);
                };
                
                try {
                    // Вычисляем значение (n-1)-ой производной в точке z + h
                    const deriv_z_plus_h = derivFunc(math.add(z, h));
                    
                    // Вычисляем значение (n-1)-ой производной в точке z
                    const deriv_z = derivFunc(z);
                    
                    // Вычисляем приближение n-ой производной
                    return math.divide(math.subtract(deriv_z_plus_h, deriv_z), h);
                } catch (error) {
                    console.error(`Ошибка при вычислении ${n}-ой производной:`, error);
                    return math.complex(0, 0);
                }
            };

            // Обертка для удобного доступа к производной (для использования в выражениях)
            window.customMathFunctions.diff = function(func, z, h) {
                return window.customMathFunctions.deriv(func, z, h);
            };

            // Функция для вычисления суммы выражений
            window.customMathFunctions.sum = function(expr, variable, start, end) {
                if (typeof start !== 'number' || typeof end !== 'number') {
                    throw new Error("Пределы суммирования должны быть числовыми");
                }
                
                let result = math.complex(0, 0);
                
                for (let i = start; i <= end; i++) {
                    try {
                        // Создаем объект с текущим значением переменной суммирования
                        const scope = {};
                        scope[variable] = i;
                        
                        // Вычисляем значение выражения и добавляем к сумме
                        const termValue = evaluateWithParser(expr, scope);
                        result = math.add(result, termValue);
                    } catch (error) {
                        console.error(`Ошибка при вычислении суммы для ${variable}=${i}:`, error);
                    }
                }
                
                return result;
            };

            // Функция для вычисления бесконечного ряда с заданной точностью
            window.customMathFunctions.series = function(expr, variable, start, maxTerms, tolerance) {
                if (typeof start !== 'number') {
                    throw new Error("Начальный индекс должен быть числовым");
                }
                
                if (typeof maxTerms === 'undefined') maxTerms = 100;
                if (typeof tolerance === 'undefined') tolerance = 1e-10;
                
                let result = math.complex(0, 0);
                let prevResult = math.complex(0, 0);
                let i = start;
                let termCount = 0;
                
                while (termCount < maxTerms) {
                    try {
                        // Создаем объект с текущим значением переменной суммирования
                        const scope = {};
                        scope[variable] = i;
                        
                        // Вычисляем значение выражения и добавляем к сумме
                        const termValue = evaluateWithParser(expr, scope);
                        result = math.add(result, termValue);
                        
                        // Проверяем сходимость по абсолютной разнице
                        const diff = math.abs(math.subtract(result, prevResult));
                        if (diff < tolerance) {
                            break;
                        }
                        
                        prevResult = result;
                        i++;
                        termCount++;
                    } catch (error) {
                        console.error(`Ошибка при вычислении ряда для ${variable}=${i}:`, error);
                        break;
                    }
                }
                
                return result;
            };

            // 2. Регистрируем все функции в math.js

            // Создаем пользовательский parser
            try {
                window.parser = math.parser();
                
                // Импортируем все функции в parser
                Object.entries(window.customMathFunctions).forEach(([name, func]) => {
                    if (typeof func === 'function') {
                        math[name] = func; // Добавляем в math
                        window.parser.set(name, func); // И в parser
                        console.log(`Определена функция: ${name}`);
                    } else {
                        math[name] = func; // Добавляем константы в math
                        window.parser.set(name, func); // И в parser
                        console.log(`Определена константа: ${name} = ${func}`);
                    }
                });
                
                console.log("Все пользовательские математические функции успешно определены.");
            } catch (error) {
                console.error("Ошибка при определении математических функций:", error);
            }
        }

        // Функция вычисляет результат выражения с помощью готового parser
        function evaluateWithParser(expr, scope) {
            try {
                // Временно установить переменные в parser
                Object.entries(scope).forEach(([key, value]) => {
                    window.parser.set(key, value);
                });
                
                // Вычислить
                const result = window.parser.evaluate(expr);
                
                return result;
            } catch (error) {
                console.error("Ошибка вычисления:", error);
                throw error;
            }
        }

        // Функция для преобразования строки функции для дифференцирования
        function transformForDifferentiation(funcStr) {
            // Заменяем diff(f(z), z) на вызов нашей функции diff
            const diffPattern = /diff\s*\(\s*([^,]+)\s*,\s*z\s*(?:,\s*([^)]+))?\s*\)/g;
            funcStr = funcStr.replace(diffPattern, (match, innerFunc, step) => {
                if (step) {
                    return `diff("${innerFunc.replace(/"/g, '\\"')}", z, ${step})`;
                } else {
                    return `diff("${innerFunc.replace(/"/g, '\\"')}", z)`;
                }
            });
            
            // Заменяем deriv(f(z), n) на вызов nthDeriv
            const derivPattern = /deriv\s*\(\s*([^,]+)\s*,\s*(\d+)\s*(?:,\s*([^)]+))?\s*\)/g;
            funcStr = funcStr.replace(derivPattern, (match, innerFunc, order, step) => {
                if (step) {
                    return `nthDeriv("${innerFunc.replace(/"/g, '\\"')}", z, ${order}, ${step})`;
                } else {
                    return `nthDeriv("${innerFunc.replace(/"/g, '\\"')}", z, ${order})`;
                }
            });
            
            // Заменяем сумму sum(expr, i, start, end) на вызов нашей функции sum
            const sumPattern = /sum\s*\(\s*([^,]+)\s*,\s*([a-zA-Z][a-zA-Z0-9]*)\s*,\s*(\d+|\-\d+)\s*,\s*(\d+|\-\d+)\s*\)/g;
            funcStr = funcStr.replace(sumPattern, (match, expr, variable, start, end) => {
                return `sum("${expr.replace(/"/g, '\\"')}", "${variable}", ${start}, ${end})`;
            });
            
            // Заменяем ряд series(expr, i, start) на вызов нашей функции series
            const seriesPattern = /series\s*\(\s*([^,]+)\s*,\s*([a-zA-Z][a-zA-Z0-9]*)\s*,\s*(\d+|\-\d+)\s*(?:,\s*(\d+))?\s*(?:,\s*([^)]+))?\s*\)/g;
            funcStr = funcStr.replace(seriesPattern, (match, expr, variable, start, maxTerms, tolerance) => {
                let result = `series("${expr.replace(/"/g, '\\"')}", "${variable}", ${start}`;
                if (maxTerms) result += `, ${maxTerms}`;
                if (tolerance) result += `, ${tolerance}`;
                return result + ')';
            });
            
            return funcStr;
        }
        
        // Функция компиляции пользовательской функции
        function compileUserFunction() {
            let success = true;
            
            // Проверяем, есть ли в функции дифференцирование или суммы и преобразуем их
            if (inputMode === "z") {
                const functionText = document.getElementById('customFunctionInput').value;
                // Применяем преобразование для работы с diff, deriv, sum и series
                customFunction = transformForDifferentiation(functionText);
            } else {
                const reFunctionText = document.getElementById('reFunction').value;
                const imFunctionText = document.getElementById('imFunction').value;
                // Применяем преобразование для обеих частей
                reFunction = transformForDifferentiation(reFunctionText);
                imFunction = transformForDifferentiation(imFunctionText);
            }

            if (inputMode === "z") {
                // Режим z - компилируем одну функцию от z
                const functionText = document.getElementById('customFunctionInput').value;
                // Сохраняем исходный текст функции для отображения
                customFunction = functionText;
                // Используем преобразованную версию для вычислений
                const transformedFunction = transformForDifferentiation(functionText);
                
                if (debugMode) {
                    console.log("Компиляция функции:", functionText);
                    updateDebugInfo();
                }
                
                try {
                    // Тестируем функцию с простым значением
                    const z = math.complex(1, 1);
                    const result = evaluateWithParser(transformedFunction, { z: z });
                    
                    // Если успешно - запоминаем функцию
                    compiledFunction = transformedFunction;
                    
                    // Очищаем сообщение об ошибке
                    clearErrorMessages();
                    
                    if (debugMode) {
                        console.log("Функция успешно скомпилирована, результат для z=1+i:", result);
                        console.log("Преобразованная функция:", transformedFunction);
                    }
                } catch (error) {
                    // Показываем сообщение об ошибке
                    showErrorMessage('functionError', `Ошибка в функции: ${error.message}`, 
                                     document.getElementById('customFunctionInput').parentNode);
                    console.error("Ошибка компиляции:", error);
                    console.error("Преобразованная функция:", transformedFunction);
                    
                    // Используем базовую функцию в случае ошибки
                    compiledFunction = "z";
                    success = false;
                }
            } else {
                // Режим (x,y) - компилируем две функции от x и y
                const reFunctionText = document.getElementById('reFunction').value;
                const imFunctionText = document.getElementById('imFunction').value;
                
                reFunction = reFunctionText;
                imFunction = imFunctionText;
                
                if (debugMode) {
                    console.log("Компиляция функций Re:", reFunctionText, "Im:", imFunctionText);
                    updateDebugInfo();
                }
                
                // Компилируем Re функцию
                try {
                    // Тестируем функцию с простыми значениями
                    const result = evaluateWithParser(reFunctionText, { x: 1, y: 1 });
                    
                    // Если успешно - запоминаем функцию
                    compiledReFunction = reFunctionText;
                    
                    // Очищаем сообщение об ошибке
                    const errorElement = document.getElementById('reFunctionError');
                    if (errorElement) {
                        errorElement.remove();
                    }
                    
                    if (debugMode) {
                        console.log("Re функция успешно скомпилирована, результат для x=1,y=1:", result);
                    }
                } catch (error) {
                    // Показываем сообщение об ошибке
                    showErrorMessage('reFunctionError', `Ошибка в Re функции: ${error.message}`, 
                                    document.getElementById('reFunction').parentNode);
                    console.error("Ошибка компиляции Re:", error);
                    
                    // Используем базовую функцию в случае ошибки
                    compiledReFunction = "x";
                    success = false;
                }
                
                // Компилируем Im функцию
                try {
                    // Тестируем функцию с простыми значениями
                    const result = evaluateWithParser(imFunctionText, { x: 1, y: 1 });
                    
                    // Если успешно - запоминаем функцию
                    compiledImFunction = imFunctionText;
                    
                    // Очищаем сообщение об ошибке
                    const errorElement = document.getElementById('imFunctionError');
                    if (errorElement) {
                        errorElement.remove();
                    }
                    
                    if (debugMode) {
                        console.log("Im функция успешно скомпилирована, результат для x=1,y=1:", result);
                    }
                } catch (error) {
                    // Показываем сообщение об ошибке
                    showErrorMessage('imFunctionError', `Ошибка в Im функции: ${error.message}`, 
                                    document.getElementById('imFunction').parentNode);
                    console.error("Ошибка компиляции Im:", error);
                    
                    // Используем базовую функцию в случае ошибки
                    compiledImFunction = "y";
                    success = false;
                }
            }
            
            return success;
        }

        // Функция для очистки всех сообщений об ошибках
        function clearErrorMessages() {
            const errorElements = document.querySelectorAll('.error-message');
            errorElements.forEach(element => element.remove());
        }

        // Функция для отображения сообщений об ошибках
        function showErrorMessage(id, message, parentElement) {
            let errorElement = document.getElementById(id);
            
            if (!errorElement) {
                errorElement = document.createElement('div');
                errorElement.id = id;
                errorElement.className = 'error-message';
                parentElement.parentNode.insertBefore(errorElement, parentElement.nextSibling);
            }
            
            errorElement.textContent = message;
        }
        
        // Функции для управления индикатором прогресса
        function showProgressIndicator() {
            // Сбрасываем флаг отмены
            renderingCancelled = false;
            
            // Отображаем контейнер прогресса
            const progressContainer = document.getElementById('progress-container');
            if (progressContainer) {
                // Отображаем текущую функцию в индикаторе
                document.getElementById('function-name').textContent = customFunction;
                
                // Сбрасываем прогресс на 0%
                updateProgressBar(0);
                
                // Просто показываем индикатор - позиционирование уже задано в HTML/CSS
                progressContainer.style.display = 'block';
                
                // Добавляем обработчик кнопки отмены
                const cancelButton = document.getElementById('cancel-rendering');
                if (cancelButton) {
                    cancelButton.onclick = function() {
                        renderingCancelled = true;
                        hideProgressIndicator();
                    };
                }
            }
        }
        
        function hideProgressIndicator() {
            const progressContainer = document.getElementById('progress-container');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }
        
        function updateProgressBar(percent) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            
            if (progressBar && progressText) {
                // Ограничиваем процент между 0 и 100
                percent = Math.max(0, Math.min(100, percent));
                
                // Обновляем ширину полосы прогресса
                progressBar.style.width = percent + '%';
                
                // Обновляем текст прогресса
                progressText.textContent = Math.round(percent) + '%';
            }
        }
        
        // Функция для экспорта изображения
        function exportImage(format) {
            const canvas = document.getElementById('screen');
            let dataURL, filename, link;
            
            if (format === 'svg') {
                // Создание SVG изображения
                const svgData = createSVGFromCanvas(canvas);
                const blob = new Blob([svgData], {type: 'image/svg+xml'});
                dataURL = URL.createObjectURL(blob);
                filename = `complex_function_${getCurrentTimestamp()}.svg`;
            } else if (format === 'jpg') {
                dataURL = canvas.toDataURL('image/jpeg', 0.92);
                filename = `complex_function_${getCurrentTimestamp()}.jpg`;
            } else {
                // PNG по умолчанию
                dataURL = canvas.toDataURL('image/png');
                filename = `complex_function_${getCurrentTimestamp()}.png`;
            }
            
            // Создаем ссылку для скачивания
            link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            link.click();
            
            // Если был создан объектный URL, освобождаем его
            if (format === 'svg') {
                URL.revokeObjectURL(dataURL);
            }
            
            // Обновляем метаданные для экспорта
            updateMetadata();
        }

        // Функция для создания SVG из Canvas
        function createSVGFromCanvas(canvas) {
            const width = canvas.width;
            const height = canvas.height;
            const ctx = canvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, width, height);
            const pixels = imgData.data;
            
            // Создаем SVG с прямоугольниками для каждого пикселя
            let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`;
            
            // Добавляем метаданные в SVG
            svgContent += `<metadata>
                <function>${escapeXml(getFunctionString())}</function>
                <vizMode>${vizMode}</vizMode>`;
                
            if (vizMode === "domainColoring") {
                svgContent += `<method>${escapeXml(getMethodString())}</method>`;
            } else {
                svgContent += `<gridType>${getGridTypeString()}</gridType>
                <gridDensity>${gridDensity}</gridDensity>
                <gridLineWidth>${gridLineWidth}</gridLineWidth>`;
            }
            
            svgContent += `<domain>X[${xMin.toFixed(2)}, ${xMax.toFixed(2)}], Y[${yMin.toFixed(2)}, ${yMax.toFixed(2)}]</domain>
                <constants>s=${s.toFixed(2)}, d=${d.toFixed(2)}, l=${l.toFixed(2)}, p=${p.toFixed(2)}, theta=${(theta*180/Math.PI).toFixed(1)}°, phi=${(phi*180/Math.PI).toFixed(1)}°</constants>
                <date>${new Date().toISOString()}</date>
            </metadata>`;
            
            // Для оптимизации размера SVG, создаем прямоугольники по строкам одного цвета
            for (let y = 0; y < height; y++) {
                let currentColor = null;
                let startX = 0;
                let currentRun = 0;
                
                for (let x = 0; x <= width; x++) {
                    const isLastPixel = x === width;
                    let pixelColor = null;
                    
                    if (!isLastPixel) {
                        const idx = (y * width + x) * 4;
                        pixelColor = `rgb(${pixels[idx]},${pixels[idx+1]},${pixels[idx+2]})`;
                    }
                    
                    if (pixelColor !== currentColor || isLastPixel) {
                        if (currentColor !== null && currentRun > 0) {
                            svgContent += `<rect x="${startX}" y="${y}" width="${currentRun}" height="1" fill="${currentColor}" />`;
                        }
                        currentColor = pixelColor;
                        startX = x;
                        currentRun = 1;
                    } else {
                        currentRun++;
                    }
                }
            }
            
            svgContent += '</svg>';
            return svgContent;
        }

        // Функция для эскейпинга XML
        function escapeXml(unsafe) {
            return unsafe.replace(/[<>&'"]/g, c => {
                switch (c) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case "'": return '&apos;';
                    case '"': return '&quot;';
                }
            });
        }

        // Функция для получения текущей метки времени
        function getCurrentTimestamp() {
            const now = new Date();
            return now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
        }

        // Функция для получения строки функции
        function getFunctionString() {
            if (inputMode === "z") {
                return customFunction;
            } else {
                return `Re(x,y) = ${reFunction}, Im(x,y) = ${imFunction}`;
            }
        }

        // Функция для получения строки метода окраски
        function getMethodString() {
            const method = parseInt(lMethodSelect.value);
            const methodNames = [
                "L = 0.5 (константа)",
                "L = Math.pow(1/2, abs * p) (затухание)",
                "L = Math.min(Math.abs((Math.floor(Math.log(abs)))-Math.log(abs)), ...)",
                "L = Math.min(Math.abs((Math.floor(d*Math.log(abs)))-d*Math.log(abs)), ...)",
                "L = (Math.abs((Math.floor(ABS)-ABS)*(Math.floor(ARG)-ARG))-0.5)/l+0.5",
                "L = (Math.floor(d*Math.abs(Math.log(abs))%2))^(Math.floor((arg+Math.PI)/(Math.PI/(d*3)))%2)",
                "L = (turn+Math.pow(-1, turn)*(Math.floor(d*Math.abs(Math.log(abs))%2)))^(Math.floor((arg+Math.PI)/(Math.PI/(d*3)))%2)"
            ];
            
            return methodNames[method] || "Неизвестный метод";
        }

        // Функция для обновления метаданных
        function updateMetadata() {
            const metadataElem = document.getElementById('metadataText');
            if (!metadataElem) return;
            
            let metadata = `
        ВИЗУАЛИЗАЦИЯ КОМПЛЕКСНОЙ ФУНКЦИИ
        -------------------------------
        Дата: ${new Date().toLocaleString()}

        ФУНКЦИЯ:
        ${getFunctionString()}

        `;

            if (vizMode === "domainColoring") {
                metadata += `РЕЖИМ: Раскраска области определения

        МЕТОД ОКРАСКИ:
        ${getMethodString()}
        `;
            } else {
                metadata += `РЕЖИМ: Конформные отображения

        ТИП РЕШЁТКИ: ${getGridTypeString()}
        ПЛОТНОСТЬ РЕШЁТКИ: ${gridDensity}
        ШИРИНА ЛИНИЙ: ${gridLineWidth}%
        `;
            }

            metadata += `
        ОБЛАСТЬ КОМПЛЕКСНОЙ ПЛОСКОСТИ:
        X: [${xMin.toFixed(2)}, ${xMax.toFixed(2)}]
        Y: [${yMin.toFixed(2)}, ${yMax.toFixed(2)}]

        КОНСТАНТЫ:
        s = ${s.toFixed(2)}
        d = ${d.toFixed(2)}
        l = ${l.toFixed(2)}
        p = ${p.toFixed(2)}
        theta = ${(theta*180/Math.PI).toFixed(1)}° (${formatAngleValue(theta)})
        phi = ${(phi*180/Math.PI).toFixed(1)}° (${formatAngleValue(phi)})

        РАЗМЕРЫ ИЗОБРАЖЕНИЯ:
        ${document.getElementById('screen').width}x${document.getElementById('screen').height} пикселей
        -------------------------------
        `;
            
            metadataElem.value = metadata;
        }

        // Форматирование значения угла для отображения
        function formatAngleValue(radians) {
            // Поиск известных значений углов
            const anglesMap = {
                '0': '0',
                [Math.PI/6]: 'π/6',
                [Math.PI/4]: 'π/4',
                [Math.PI/3]: 'π/3',
                [Math.PI/2]: 'π/2',
                [2*Math.PI/3]: '2π/3',
                [3*Math.PI/4]: '3π/4',
                [5*Math.PI/6]: '5π/6',
                [Math.PI]: 'π',
                [7*Math.PI/6]: '7π/6',
                [5*Math.PI/4]: '5π/4',
                [4*Math.PI/3]: '4π/3',
                [3*Math.PI/2]: '3π/2',
                [5*Math.PI/3]: '5π/3',
                [7*Math.PI/4]: '7π/4',
                [11*Math.PI/6]: '11π/6',
                [2*Math.PI]: '2π'
            };
            
            // Проверяем, есть ли значение в нашей карте углов с точностью 0.01
            for (const [angle, text] of Object.entries(anglesMap)) {
                if (Math.abs(radians - angle) < 0.01) {
                    return text + ' рад';
                }
            }
            
            // Если значение не найдено в карте, отображаем числовое значение
            return radians.toFixed(2) + ' рад';
        }

        // Функция для копирования метаданных в буфер обмена
        function copyMetadata() {
            const metadataElem = document.getElementById('metadataText');
            metadataElem.select();
            document.execCommand('copy');
            
            // Показываем уведомление о копировании
            const tempNotice = document.createElement('div');
            tempNotice.textContent = 'Метаданные скопированы!';
            tempNotice.style.position = 'fixed';
            tempNotice.style.bottom = '20px';
            tempNotice.style.left = '50%';
            tempNotice.style.transform = 'translateX(-50%)';
            tempNotice.style.backgroundColor = '#4CAF50';
            tempNotice.style.color = 'white';
            tempNotice.style.padding = '10px 20px';
            tempNotice.style.borderRadius = '4px';
            tempNotice.style.zIndex = '1000';
            document.body.appendChild(tempNotice);
            
            setTimeout(() => {
                document.body.removeChild(tempNotice);
            }, 2000);
        }

        // Функция для экспорта метаданных в текстовый файл
        function exportMetadata() {
            const metadata = document.getElementById('metadataText').value;
            const blob = new Blob([metadata], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `complex_function_metadata_${getCurrentTimestamp()}.txt`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Функция переключения режима визуализации
        function toggleVizMode() {
            const domainColoringRadio = document.getElementById('domainColoringRadio');
            const conformalSettingsContainer = document.getElementById('conformalSettingsContainer');
            const lMethodSelect = document.getElementById('lMethod');
            const lMethodContainer = lMethodSelect.closest('.control-group');
            
            if (domainColoringRadio.checked) {
                // Переключаемся на режим раскраски области определения
                vizMode = "domainColoring";
                conformalSettingsContainer.style.display = "none";
                lMethodContainer.style.display = "block";
            } else {
                // Переключаемся на режим конформных отображений
                vizMode = "conformalMap";
                conformalSettingsContainer.style.display = "block";
                lMethodContainer.style.display = "none";
            }
            
            // Обновляем визуализацию
            updateVisualization();
        }

        // Функция обновления плотности решётки
        function updateGridDensity() {
            gridDensity = parseInt(document.getElementById('gridDensitySlider').value);
            document.getElementById('gridDensityValue').value = gridDensity;
            updateVisualization();
        }

        // Функция обновления плотности решётки из поля ввода
        function updateGridDensityFromInput() {
            gridDensity = parseInt(document.getElementById('gridDensityValue').value);
            document.getElementById('gridDensitySlider').value = gridDensity;
            updateVisualization();
        }

        // Функция обновления ширины линий решётки
        function updateGridLineWidth() {
            gridLineWidth = parseInt(document.getElementById('gridLineWidthSlider').value);
            document.getElementById('gridLineWidthValue').value = gridLineWidth;
            updateVisualization();
        }

        // Функция обновления ширины линий решётки из поля ввода
        function updateGridLineWidthFromInput() {
            gridLineWidth = parseInt(document.getElementById('gridLineWidthValue').value);
            document.getElementById('gridLineWidthSlider').value = gridLineWidth;
            updateVisualization();
        }

        // Вспомогательная функция для преобразования hex-цвета в RGB
        function hexToRgb(hex) {
            // Убираем # если есть
            hex = hex.replace(/^#/, '');
            
            // Преобразуем в RGB
            const bigint = parseInt(hex, 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            
            return { r, g, b };
        }

        // Вспомогательная функция для получения строкового представления типа решётки
        function getGridTypeString() {
            switch (gridType) {
                case "rectangular": return "Прямоугольная";
                case "polar": return "Полярная";
                case "chessboard": return "Шахматное поле";
                default: return "Неизвестный тип";
            }
        }

        // Функция обновления типа решётки
        function updateGridType() {
            gridType = document.getElementById('gridType').value;
            
            // Обновляем визуализацию
            updateVisualization();
            
            if (debugMode) {
                console.log(`Тип решётки изменен на: ${getGridTypeString()}`);
                updateDebugInfo();
            }
        }

        // Функция обновления цвета решётки 1
        function updateGridColor1() {
            gridColor1 = document.getElementById('gridColor1').value;
            updateVisualization();
        }

        // Функция обновления цвета решётки 2
        function updateGridColor2() {
            gridColor2 = document.getElementById('gridColor2').value;
            updateVisualization();
        }

        // Оптимизированная функция отрисовки с индикатором прогресса
        function drawComplex() {
            const c = document.getElementById('screen');
            const SWIDTH = c.width;
            const SHEIGHT = c.height;
            const ctx = c.getContext("2d");
            
            // ДОБАВЛЕНО: Создаем локальные копии границ для использования в функции
            // Это гарантирует, что мы используем актуальные значения
            const x_min = xMin;
            const x_max = xMax;
            const y_min = yMin;
            const y_max = yMax;
            
            // Показываем индикатор прогресса
            showProgressIndicator();

            // Проверяем режим визуализации
            if (vizMode === "conformalMap") {
                // Используем отдельную функцию для конформных отображений
                drawConformalMap();
                
                // Скрываем индикатор прогресса
                hideProgressIndicator();
                
                // Обновляем метаданные визуализации
                updateMetadata();
                
                return;  // Выходим из функции, так как конформные отображения уже нарисованы
            }
            
            // Создаем imgData один раз
            const imgData = ctx.createImageData(SWIDTH, SHEIGHT);
            const pixels = imgData.data;
            
            // Выбираем метод L
            const lMethod = parseInt(lMethodSelect.value);
            
            // Компилируем пользовательскую функцию, если необходимо
            if (!compiledFunction) {
                compileUserFunction();
            }
            
            // Функция трансформации комплексного числа с использованием пользовательской функции
            const w = z => {
                try {
                    // Применяем поворот к z
                    const rotatedZ = math.multiply(z, math.complex(Math.cos(theta), Math.sin(theta)));
                    
                    let result;
                    
                    if (inputMode === "z") {
                        // Режим z - применяем одну функцию от z
                        result = evaluateWithParser(compiledFunction, { 
                            z: rotatedZ, 
                            i: math.complex(0, 1), 
                            e: math.e, 
                            pi: math.pi 
                        });
                    } else {
                        // Режим (x,y) - применяем две функции от x и y
                        const x = rotatedZ.re;
                        const y = rotatedZ.im;
                        
                        // Вычисляем Re и Im части
                        const reResult = evaluateWithParser(compiledReFunction, { 
                            x: x,
                            y: y,
                            i: math.complex(0, 1), 
                            e: math.e, 
                            pi: math.pi 
                        });
                        
                        const imResult = evaluateWithParser(compiledImFunction, { 
                            x: x,
                            y: y,
                            i: math.complex(0, 1), 
                            e: math.e, 
                            pi: math.pi 
                        });
                        
                        // Создаем комплексное число из результатов
                        result = math.complex(reResult, imResult);
                    }
                    
                    // Применяем второй поворот к результату
                    return math.multiply(result, math.complex(Math.cos(phi), Math.sin(phi)));
                } catch (error) {
                    console.error("Ошибка при вычислении функции:", error);
                    // В случае ошибки возвращаем исходный z
                    return z;
                }
            };
            
            // Используем requestAnimationFrame для оптимизации отрисовки
            let y = 0;
            const startTime = performance.now(); // Для расчета времени вычисления
            
            // ИЗМЕНЕНО: Вычисляем шаг для отображения границ комплексной плоскости
            // используя локальные копии
            const xStep = (x_max - x_min) / SWIDTH;
            const yStep = (y_max - y_min) / SHEIGHT;
            
            // Для конформных отображений - вычисляем параметры решётки
            let gridSpacingX, gridSpacingY, lineWidthX, lineWidthY;
            if (vizMode === "conformalMap") {
                gridSpacingX = (x_max - x_min) / gridDensity;
                gridSpacingY = (y_max - y_min) / gridDensity;
                lineWidthX = gridSpacingX * (gridLineWidth / 100);
                lineWidthY = gridSpacingY * (gridLineWidth / 100);
                
                // Отображаем информацию о функции в индикаторе прогресса
                if (gridType === "chessboard") {
                    document.getElementById('function-name').textContent = `${customFunction} (шахматное поле ${gridDensity}x${gridDensity})`;
                } else {
                    document.getElementById('function-name').textContent = `${customFunction} (${getGridTypeString()} решётка ${gridDensity}x${gridDensity})`;
                }
            }
            
            function renderChunk() {
                // Обрабатываем небольшой кусок изображения за раз для предотвращения блокировки UI
                const chunkSize = 10;
                const endY = Math.min(y + chunkSize, SHEIGHT);
                
                for (; y < endY; y++) {
                    const yOffset = y * SWIDTH << 2; // Предварительный расчет смещения Y
                    // ИЗМЕНЕНО: Используем локальные копии границ
                    const Yc = y_max - y * yStep;
                    
                    for (let x = 0; x < SWIDTH; x++) {
                        const pixelOffset = yOffset + (x << 2); // Оптимизация расчета индекса пикселя
                        
                        // ИЗМЕНЕНО: Используем локальные копии границ
                        const Xc = x_min + x * xStep;
                        const z = math.complex(Xc, Yc);
                        
                        // Разные режимы обработки пикселей в зависимости от режима визуализации
                        if (vizMode === "domainColoring") {
                            // Режим раскраски области определения (оригинальный)
                            // Получаем результат трансформации
                            const res = w(z);
                            
                            // Рассчитываем модуль и аргумент используя math.js
                            const abs = math.abs(res);
                            const arg = math.arg(res);
                            
                            // Рассчитываем L по выбранному методу
                            const L = calculateL(abs, arg, lMethod);
                            
                            // Рассчитываем RGB на основе HSL модели
                            const [r, g, b] = calculateRGB(Math.PI - arg, L, 1);
                            
                            // Записываем пиксель напрямую
                            pixels[pixelOffset] = r;
                            pixels[pixelOffset+1] = g;
                            pixels[pixelOffset+2] = b;
                            pixels[pixelOffset+3] = 255;
                        } else {
                            // Режим конформных отображений
                            let isOnGrid = false;
                            let isFirstColor = true;

                            // Получаем актуальные значения из формы
                            const currentGridType = document.getElementById('gridType').value;
                            gridType = currentGridType; // Обновляем глобальную переменную

                            if (currentGridType === "rectangular") {
                                // Прямоугольная решётка
                                const xMod = Math.abs((Xc - x_min) % gridSpacingX);
                                const yMod = Math.abs((Yc - y_min) % gridSpacingY);
                                isOnGrid = (xMod < lineWidthX || xMod > gridSpacingX - lineWidthX || 
                                           yMod < lineWidthY || yMod > gridSpacingY - lineWidthY);
                                
                                // Определяем цвет на основе близости к оси
                                const isCloseToX = Math.abs(Yc) < lineWidthY;
                                const isCloseToY = Math.abs(Xc) < lineWidthX;
                                
                                // Подчеркиваем оси
                                if (isCloseToX || isCloseToY) {
                                    isFirstColor = true;
                                } else {
                                    isFirstColor = true; // Все линии сетки одного цвета
                                }
                            } else if (currentGridType === "polar") {
                                // Полярная решётка
                                const r = Math.sqrt(Xc * Xc + Yc * Yc);
                                const rMod = r % gridSpacingX;
                                const theta = Math.atan2(Yc, Xc);
                                const thetaStep = 2 * Math.PI / gridDensity;
                                const thetaMod = ((theta % thetaStep) + thetaStep) % thetaStep;
                                
                                // Для лучей и окружностей
                                isOnGrid = (rMod < lineWidthX || rMod > gridSpacingX - lineWidthX || 
                                           thetaMod < lineWidthY * thetaStep / gridSpacingY || 
                                           thetaMod > thetaStep - lineWidthY * thetaStep / gridSpacingY);
                                
                                // Подчеркиваем центральную окружность и основные оси
                                const isMainAxis = Math.abs(theta % (Math.PI/2)) < 0.05;
                                const isCentralCircle = r < lineWidthX * 2;
                                
                                if (isMainAxis || isCentralCircle) {
                                    isFirstColor = true;
                                } else {
                                    isFirstColor = false; // Второй цвет для неосновных линий
                                }
                            } else if (currentGridType === "chessboard") {
                                // Шахматное поле
                                // Нормализуем координаты к нижнему левому углу области
                                const normalizedX = Xc - x_min;
                                const normalizedY = Yc - y_min;
                                
                                // Определяем индексы ячейки
                                const xGrid = Math.floor(normalizedX / gridSpacingX);
                                const yGrid = Math.floor(normalizedY / gridSpacingY);
                                
                                // Черно-белый паттерн
                                isFirstColor = (xGrid + yGrid) % 2 === 0;
                                isOnGrid = true; // Всегда отображаем цвет для шахматного поля
                            }

                            if (vizMode === "conformalMap") {
                                // Считываем актуальные цвета из элементов формы
                                const color1 = document.getElementById('gridColor1').value;
                                const color2 = document.getElementById('gridColor2').value;
                                gridColor1 = color1;
                                gridColor2 = color2;
                                
                                if (isOnGrid) {
                                    // Если точка на решётке, используем цвет решётки и преобразуем её
                                    const res = w(z);
                                    
                                    if (isFinite(res.re) && isFinite(res.im)) {
                                        // Выбираем цвет на основе флага
                                        const color = isFirstColor ? hexToRgb(gridColor1) : hexToRgb(gridColor2);
                                        
                                        pixels[pixelOffset] = color.r;
                                        pixels[pixelOffset+1] = color.g;
                                        pixels[pixelOffset+2] = color.b;
                                        pixels[pixelOffset+3] = 255;
                                    } else {
                                        // Если результат не конечный, используем красный цвет
                                        pixels[pixelOffset] = 255;
                                        pixels[pixelOffset+1] = 0;
                                        pixels[pixelOffset+2] = 0;
                                        pixels[pixelOffset+3] = 255;
                                    }
                                } else {
                                    // Если точка не на решётке, используем белый цвет (фон)
                                    pixels[pixelOffset] = 255;
                                    pixels[pixelOffset+1] = 255;
                                    pixels[pixelOffset+2] = 255;
                                    pixels[pixelOffset+3] = 255;
                                }
                            }
                        }
                    }
                }
                
                // Обновляем индикатор прогресса
                const progress = (y / SHEIGHT) * 100;
                updateProgressBar(progress);
                
                // Если не закончили обработку и рендеринг не отменен, планируем следующий кусок
                if (y < SHEIGHT && !renderingCancelled) {
                    requestAnimationFrame(renderChunk);
                } else {
                    // Отображаем изображение на canvas, когда все пиксели обработаны или рендеринг отменен
                    if (!renderingCancelled) {
                        ctx.putImageData(imgData, 0, 0);
                        // Обновляем метаданные визуализации
                        updateMetadata();
                    }
                    
                    // Скрываем индикатор прогресса
                    hideProgressIndicator();
                    
                    // Логируем время выполнения для отладки
                    if (debugMode) {
                        const endTime = performance.now();
                        console.log(`Визуализация ${renderingCancelled ? 'отменена' : 'выполнена'} за ${(endTime - startTime).toFixed(2)} мс`);
                        updateDebugInfo();
                    }
                }
            }
            
            // Запускаем первый кусок рендеринга
            y = 0;
            renderChunk();
        }

        // Функция для рисования конформных отображений
        function drawConformalMap() {
            const canvas = document.getElementById('screen');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Очищаем холст и заполняем выбранным цветом фона
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = gridBackgroundColor;
            ctx.fillRect(0, 0, width, height);
            
            // Получаем локальные копии границ
            const x_min = xMin;
            const x_max = xMax;
            const y_min = yMin;
            const y_max = yMax;
            
            // Получаем тип решётки и другие параметры
            const currentGridType = document.getElementById('gridType').value;
            const currentGridDensity = parseInt(document.getElementById('gridDensityValue').value);
            const color1 = document.getElementById('gridColor1').value;
            const color2 = document.getElementById('gridColor2').value;
            
            // Вычисляем шаги для преобразования координат
            const xStep = (x_max - x_min) / width;
            const yStep = (y_max - y_min) / height;
            
            // Функция для преобразования комплексных координат в координаты холста
            const complexToCanvas = (z) => {
                if (!isFinite(z.re) || !isFinite(z.im)) return null;
                
                // Проверяем, находится ли точка в пределах области видимости
                if (z.re < x_min || z.re > x_max || z.im < y_min || z.im > y_max) return null;
                
                const x = Math.round((z.re - x_min) / xStep);
                const y = Math.round((y_max - z.im) / yStep);
                
                // Проверяем, находится ли точка на холсте
                if (x < 0 || x >= width || y < 0 || y >= height) return null;
                
                return { x, y };
            };
            
            // Функция применения пользовательской функции к комплексному числу
            const applyUserFunction = (z) => {
                try {
                    // Применяем поворот к z
                    const rotatedZ = math.multiply(z, math.complex(Math.cos(theta), Math.sin(theta)));
                    
                    let result;
                    
                    if (inputMode === "z") {
                        // Режим z - применяем одну функцию от z
                        result = evaluateWithParser(compiledFunction, { 
                            z: rotatedZ, 
                            i: math.complex(0, 1), 
                            e: math.e, 
                            pi: math.pi 
                        });
                    } else {
                        // Режим (x,y) - применяем две функции от x и y
                        const x = rotatedZ.re;
                        const y = rotatedZ.im;
                        
                        // Вычисляем Re и Im части
                        const reResult = evaluateWithParser(compiledReFunction, { 
                            x: x,
                            y: y,
                            i: math.complex(0, 1), 
                            e: math.e, 
                            pi: math.pi 
                        });
                        
                        const imResult = evaluateWithParser(compiledImFunction, { 
                            x: x,
                            y: y,
                            i: math.complex(0, 1), 
                            e: math.e, 
                            pi: math.pi 
                        });
                        
                        // Создаем комплексное число из результатов
                        result = math.complex(reResult, imResult);
                    }
                    
                    // Применяем второй поворот к результату
                    return math.multiply(result, math.complex(Math.cos(phi), Math.sin(phi)));
                } catch (error) {
                    console.error("Ошибка при вычислении функции:", error);
                    // В случае ошибки возвращаем null
                    return null;
                }
            };
            
            // Функция для рисования линии с учетом разрывов
            const drawContinuousLine = (points, color) => {
                if (points.length < 2) return;
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                // Начинаем новую линию
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                // Рисуем линию, разбивая на сегменты при больших разрывах
                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].x - points[i-1].x;
                    const dy = points[i].y - points[i-1].y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Если расстояние слишком большое, начинаем новую линию
                    if (distance > Math.max(width, height) / 20) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(points[i].x, points[i].y);
                    } else {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                }
                
                ctx.stroke();
            };
            
            // Получаем параметры для спейсинга сетки
            const gridSpacingX = (x_max - x_min) / currentGridDensity;
            const gridSpacingY = (y_max - y_min) / currentGridDensity;
            
            // Расчет прогресса
            let totalSteps = 0;
            let currentStep = 0;
            
            if (currentGridType === "rectangular") {
                totalSteps = 2 * currentGridDensity;
            } else if (currentGridType === "polar") {
                totalSteps = currentGridDensity * 2; // Круги + лучи
            } else if (currentGridType === "chessboard") {
                totalSteps = currentGridDensity * currentGridDensity;
            }
            
            // Показываем информацию о текущем процессе
            document.getElementById('function-name').textContent = 
                `${customFunction} (${getGridTypeString()} решётка ${currentGridDensity}x${currentGridDensity})`;
            
            // Рисуем решётку в зависимости от выбранного типа
            if (currentGridType === "rectangular") {
                // Прямоугольная решётка
                
                // Горизонтальные линии - первый цвет
                for (let j = 0; j <= currentGridDensity; j++) {
                    const y = y_min + j * (y_max - y_min) / currentGridDensity;
                    const points = [];
                    
                    // Дополнительная плотность точек для плавности
                    const numPoints = width * 2;
                    
                    for (let i = 0; i <= numPoints; i++) {
                        const x = x_min + i * (x_max - x_min) / numPoints;
                        const z = math.complex(x, y);
                        const transformedZ = applyUserFunction(z);
                        
                        if (transformedZ) {
                            const canvasPoint = complexToCanvas(transformedZ);
                            if (canvasPoint) {
                                points.push(canvasPoint);
                            }
                        }
                    }
                    
                    // Рисуем линию - первый цвет для горизонтальных линий
                    drawContinuousLine(points, color1);
                    
                    // Обновляем прогресс
                    currentStep++;
                    updateProgressBar((currentStep / totalSteps) * 100);
                    
                    // Проверяем на отмену
                    if (renderingCancelled) return;
                }
                
                // Вертикальные линии - второй цвет
                for (let i = 0; i <= currentGridDensity; i++) {
                    const x = x_min + i * (x_max - x_min) / currentGridDensity;
                    const points = [];
                    
                    // Дополнительная плотность точек для плавности
                    const numPoints = height * 2;
                    
                    for (let j = 0; j <= numPoints; j++) {
                        const y = y_min + j * (y_max - y_min) / numPoints;
                        const z = math.complex(x, y);
                        const transformedZ = applyUserFunction(z);
                        
                        if (transformedZ) {
                            const canvasPoint = complexToCanvas(transformedZ);
                            if (canvasPoint) {
                                points.push(canvasPoint);
                            }
                        }
                    }
                    
                    // Рисуем линию - второй цвет для вертикальных линий
                    drawContinuousLine(points, color2);
                    
                    // Обновляем прогресс
                    currentStep++;
                    updateProgressBar((currentStep / totalSteps) * 100);
                    
                    // Проверяем на отмену
                    if (renderingCancelled) return;
                }
            } 
            else if (currentGridType === "polar") {
                // Полярная решётка
                
                // Центр области
                const centerX = (x_min + x_max) / 2;
                const centerY = (y_min + y_max) / 2;
                
                // Максимальный радиус
                const maxRadius = Math.max(
                    Math.abs(x_max - centerX),
                    Math.abs(y_max - centerY)
                ) * 1.5;
                
                // Рисуем окружности - второй цвет
                for (let r = 0; r <= maxRadius; r += gridSpacingX) {
                    if (r < 0.001) continue; // Пропускаем центральную точку
                    
                    const points = [];
                    const numPoints = 360; // Точки через каждый градус
                    
                    for (let i = 0; i <= numPoints; i++) {
                        const angle = (i / numPoints) * 2 * Math.PI;
                        const x = centerX + r * Math.cos(angle);
                        const y = centerY + r * Math.sin(angle);
                        
                        // Пропускаем точки за пределами области
                        if (x < x_min || x > x_max || y < y_min || y > y_max) continue;
                        
                        const z = math.complex(x, y);
                        const transformedZ = applyUserFunction(z);
                        
                        if (transformedZ) {
                            const canvasPoint = complexToCanvas(transformedZ);
                            if (canvasPoint) {
                                points.push(canvasPoint);
                            }
                        }
                    }
                    
                    // Круговые линии - второй цвет
                    drawContinuousLine(points, color2);
                    
                    // Обновляем прогресс
                    currentStep++;
                    updateProgressBar((currentStep / totalSteps) * 100);
                    
                    // Проверяем на отмену
                    if (renderingCancelled) return;
                }
                
                // Рисуем лучи - первый цвет
                for (let i = 0; i < currentGridDensity; i++) {
                    const angle = (i / currentGridDensity) * 2 * Math.PI;
                    const points = [];
                    
                    // Создаем точки вдоль луча
                    const numPoints = 200; // Большое число для плавности
                    
                    for (let r = 0; r <= maxRadius; r += maxRadius / numPoints) {
                        const x = centerX + r * Math.cos(angle);
                        const y = centerY + r * Math.sin(angle);
                        
                        // Пропускаем точки за пределами области
                        if (x < x_min || x > x_max || y < y_min || y > y_max) continue;
                        
                        const z = math.complex(x, y);
                        const transformedZ = applyUserFunction(z);
                        
                        if (transformedZ) {
                            const canvasPoint = complexToCanvas(transformedZ);
                            if (canvasPoint) {
                                points.push(canvasPoint);
                            }
                        }
                    }
                    
                    // Лучи - первый цвет
                    drawContinuousLine(points, color1);
                    
                    // Обновляем прогресс
                    currentStep++;
                    updateProgressBar((currentStep / totalSteps) * 100);
                    
                    // Проверяем на отмену
                    if (renderingCancelled) return;
                }
            } 
            else if (currentGridType === "chessboard") {
                // Шахматное поле
                
                // Размер ячеек шахматной доски
                const cellWidth = (x_max - x_min) / currentGridDensity;
                const cellHeight = (y_max - y_min) / currentGridDensity;
                
                // Отрисовка по ячейкам
                for (let i = 0; i < currentGridDensity; i++) {
                    for (let j = 0; j < currentGridDensity; j++) {
                        // Координаты углов клетки
                        const x1 = x_min + i * cellWidth;
                        const y1 = y_min + j * cellHeight;
                        const x2 = x1 + cellWidth;
                        const y2 = y1 + cellHeight;
                        
                        // Цвет клетки
                        const cellColor = (i + j) % 2 === 0 ? color1 : color2;
                        
                        // Рисуем контур клетки
                        const contourPoints = [];
                        
                        // Нижняя сторона
                        for (let k = 0; k <= 20; k++) {
                            const x = x1 + (k / 20) * cellWidth;
                            const z = math.complex(x, y1);
                            const transformedZ = applyUserFunction(z);
                            
                            if (transformedZ) {
                                const canvasPoint = complexToCanvas(transformedZ);
                                if (canvasPoint) {
                                    contourPoints.push(canvasPoint);
                                }
                            }
                        }
                        
                        // Правая сторона
                        for (let k = 0; k <= 20; k++) {
                            const y = y1 + (k / 20) * cellHeight;
                            const z = math.complex(x2, y);
                            const transformedZ = applyUserFunction(z);
                            
                            if (transformedZ) {
                                const canvasPoint = complexToCanvas(transformedZ);
                                if (canvasPoint) {
                                    contourPoints.push(canvasPoint);
                                }
                            }
                        }
                        
                        // Верхняя сторона (в обратном направлении)
                        for (let k = 20; k >= 0; k--) {
                            const x = x1 + (k / 20) * cellWidth;
                            const z = math.complex(x, y2);
                            const transformedZ = applyUserFunction(z);
                            
                            if (transformedZ) {
                                const canvasPoint = complexToCanvas(transformedZ);
                                if (canvasPoint) {
                                    contourPoints.push(canvasPoint);
                                }
                            }
                        }
                        
                        // Левая сторона (в обратном направлении)
                        for (let k = 20; k >= 0; k--) {
                            const y = y1 + (k / 20) * cellHeight;
                            const z = math.complex(x1, y);
                            const transformedZ = applyUserFunction(z);
                            
                            if (transformedZ) {
                                const canvasPoint = complexToCanvas(transformedZ);
                                if (canvasPoint) {
                                    contourPoints.push(canvasPoint);
                                }
                            }
                        }
                        
                        // Рисуем заполненный контур, если есть достаточно точек
                        if (contourPoints.length > 2) {
                            ctx.beginPath();
                            ctx.moveTo(contourPoints[0].x, contourPoints[0].y);
                            
                            for (let k = 1; k < contourPoints.length; k++) {
                                const dx = contourPoints[k].x - contourPoints[k-1].x;
                                const dy = contourPoints[k].y - contourPoints[k-1].y;
                                const distance = Math.sqrt(dx*dx + dy*dy);
                                
                                // Если расстояние небольшое, добавляем точку к контуру
                                if (distance < Math.max(width, height) / 10) {
                                    ctx.lineTo(contourPoints[k].x, contourPoints[k].y);
                                } else {
                                    // В противном случае начинаем новый сегмент
                                    ctx.stroke();
                                    ctx.beginPath();
                                    ctx.moveTo(contourPoints[k].x, contourPoints[k].y);
                                }
                            }
                            
                            // Замыкаем контур
                            ctx.closePath();
                            
                            // Заливаем цветом
                            ctx.fillStyle = cellColor;
                            ctx.fill();
                            
                            // Обводим контур
                            ctx.strokeStyle = "rgba(0, 0, 0, 0.3)";
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                        
                        // Обновляем прогресс
                        currentStep++;
                        updateProgressBar((currentStep / totalSteps) * 100);
                        
                        // Проверяем на отмену
                        if (renderingCancelled) return;
                    }
                }
            }
            
            // Обновляем прогресс до 100%
            updateProgressBar(100);
        }

        // Обновление всех параметров и визуализации
        function updateVisualization() {
            // Обновляем константы
            s = parseFloat(document.getElementById('sValue').value);
            d = parseFloat(document.getElementById('dValue').value);
            l = parseFloat(document.getElementById('lValue').value);
            p = parseFloat(document.getElementById('pValue').value);
            
            // Обновляем параметры конформных отображений
            if (vizMode === "conformalMap") {
                gridType = document.getElementById('gridType').value;
                gridDensity = parseInt(document.getElementById('gridDensityValue').value);
                gridLineWidth = parseInt(document.getElementById('gridLineWidthValue').value);
                gridColor1 = document.getElementById('gridColor1').value;
                gridColor2 = document.getElementById('gridColor2').value;
            }
            
            // ДОБАВЛЕНО: Проверка режима связывания и правильный пересчет границ
            if (linkSWithDomain) {
                // Пересчитываем границы на основе текущего значения s
                updateDomainFromS();
            } else {
                // В противном случае, считываем актуальные значения из полей ввода
                xMin = parseFloat(document.getElementById('xMin').value);
                xMax = parseFloat(document.getElementById('xMax').value);
                yMin = parseFloat(document.getElementById('yMin').value);
                yMax = parseFloat(document.getElementById('yMax').value);
            }
            
            // Обновляем отображение ползунков, если они инициализированы
            if (thetaSlider) thetaSlider.update(theta);
            if (phiSlider) phiSlider.update(phi);
            
            // Очищаем предыдущую визуализацию и показываем индикатор
            const canvas = document.getElementById('screen');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Считываем значения из полей ввода в соответствии с выбранным режимом
            if (inputMode === "z") {
                customFunction = document.getElementById('customFunctionInput').value;
            } else {
                reFunction = document.getElementById('reFunction').value;
                imFunction = document.getElementById('imFunction').value;
            }
            
            // Компилируем функцию перед отрисовкой
            compileUserFunction();
            
            if (debugMode) {
                updateDebugInfo();
            }
            
            // Оттягиваем рендеринг на следующий кадр для обновления UI
            setTimeout(function() {
                // Отрисовываем
                drawComplex();
                
                // Обновляем метаданные
                updateMetadata();
            }, 50);
        }

        // Функция для изменения вкладок
        function changeTab(event, tabId) {
            // Скрываем все вкладки и сбрасываем активный класс
            const tabContents = document.getElementsByClassName('template-tab-content');
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove('active');
            }
            
            const tabs = document.getElementsByClassName('template-tab');
            for (let i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove('active');
            }
            
            // Активируем выбранную вкладку
            document.getElementById(tabId).classList.add('active');
            event.currentTarget.classList.add('active');
        }

        // Инициализируем интерфейс при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            // Проверяем загрузку math.js
            if (typeof math !== 'undefined') {
                initializePage();
            } else {
                // Если math.js не загружен, ждем и пробуем снова
                console.error("Библиотека math.js не загружена, ожидаем...");
                setTimeout(function() {
                    if (typeof math !== 'undefined') {
                        console.log("math.js загружен с задержкой, инициализация...");
                        initializePage();
                    } else {
                        alert("Не удалось загрузить библиотеку math.js. Пожалуйста, проверьте подключение к интернету и перезагрузите страницу.");
                    }
                }, 2000);
            }

            const headers = document.querySelectorAll('.collapsible-header');
                headers.forEach(header => {
                    header.addEventListener('click', function() {
                        this.classList.toggle('collapsed');
                        const content = this.nextElementSibling;
                        content.classList.toggle('visible');
                    });
                });

        });
        
        // Функция инициализации страницы
        function initializePage() {
            // Проверяем, нужно ли создавать обертку для canvas
            const canvas = document.getElementById('screen');
            
            // Проверяем, находится ли canvas уже в обертке
            if (!canvas.parentElement.classList.contains('canvas-wrapper')) {
                // Создаем обертку для canvas
                const wrapper = document.createElement('div');
                wrapper.classList.add('canvas-wrapper');
                wrapper.style.position = 'relative';
                
                // Вставляем обертку перед canvas
                canvas.parentNode.insertBefore(wrapper, canvas);
                
                // Помещаем canvas внутрь обертки
                wrapper.appendChild(canvas);
                
                // Перемещаем индикатор прогресса внутрь обертки
                const progressContainer = document.getElementById('progress-container');
                if (progressContainer) {
                    wrapper.appendChild(progressContainer);
                }
            }
            
            // Определяем дополнительные математические функции
            defineCustomMathFunctions();
            
            // Инициализация интерфейса
            updateMethodControls();
            initCircularSliders();

            // Инициализируем элементы управления размером холста
            document.getElementById('canvasSizePreset').addEventListener('change', setCanvasSize);
            
            // Инициализируем поля для областей комплексной плоскости
            document.getElementById('xMin').value = xMin.toFixed(2);
            document.getElementById('xMax').value = xMax.toFixed(2);
            document.getElementById('yMin').value = yMin.toFixed(2);
            document.getElementById('yMax').value = yMax.toFixed(2);
            
            // Генерируем начальные метаданные
            updateMetadata();
            
            // Добавляем обработчики событий focus для полей ввода
            document.getElementById('reFunction').addEventListener('focus', function() {
                activeInputField = 'reFunction';
                highlightActiveField();
                if (debugMode) console.log("Активное поле ввода: Re(x,y)");
            });
            
            document.getElementById('imFunction').addEventListener('focus', function() {
                activeInputField = 'imFunction';
                highlightActiveField();
                if (debugMode) console.log("Активное поле ввода: Im(x,y)");
            });
            
            document.getElementById('customFunctionInput').addEventListener('focus', function() {
                activeInputField = 'customFunctionInput';
                highlightActiveField();
                if (debugMode) console.log("Активное поле ввода: функция от z");
            });
            
            // Инициализируем состояние для режима сохранения пропорций
            document.getElementById('keepAspectRatioCheckbox').checked = keepAspectRatio;
            toggleAspectRatioMode();
            
            // Инициализируем состояние для режима связывания s с областью
            document.getElementById('linkSWithDomainCheckbox').checked = linkSWithDomain;
            toggleSLinkMode(); // Вызываем функцию переключения, чтобы инициализировать состояние

            // Корректируем область комплексной плоскости перед первой визуализацией
            adjustComplexDomainAspectRatio(false); // false - не показывать уведомление при первой загрузке

            // Вызываем функцию выделения при загрузке страницы
            highlightActiveField();

            // Устанавливаем начальную область на основе значения s
            updateDomainFromS();

            // Инициализация переключателя режима визуализации и настроек конформных отображений
            document.getElementById('gridBackgroundColor').value = gridBackgroundColor;
            document.getElementById('gridColor1').value = gridColor1;
            document.getElementById('gridColor2').value = gridColor2;
            document.getElementById('gridDensitySlider').value = gridDensity;
            document.getElementById('gridDensityValue').value = gridDensity;
            document.getElementById('gridLineWidthSlider').value = gridLineWidth;
            document.getElementById('gridLineWidthValue').value = gridLineWidth;
            document.getElementById('gridType').value = gridType;
            document.getElementById('domainColoringRadio').checked = true;
            document.getElementById('conformalMapRadio').checked = false;
            toggleVizMode(); // Инициализируем режим визуализации            
            
            updateVisualization();
        }
    </script>
</body>
</html>