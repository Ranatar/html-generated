<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –ò–≥—Ä–∞ "–ñ–∏–∑–Ω—å" - –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            color: #eee;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 26, 46, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            max-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
        }
        #cross-sections {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .section-view {
            background: rgba(26, 26, 46, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        .section-view h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #4ecdc4;
            text-align: center;
        }
        .section-canvas {
            border: 2px solid #4ecdc4;
            border-radius: 5px;
            display: block;
            image-rendering: pixelated;
        }
        .slider-container {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-container label {
            font-size: 11px;
            color: #aaa;
            min-width: 60px;
        }
        .slider-container input {
            flex: 1;
        }
        .slider-container span {
            font-size: 11px;
            color: #4ecdc4;
            min-width: 30px;
            text-align: right;
        }
        h2 {
            margin: 0 0 15px 0;
            font-size: 20px;
            color: #4ecdc4;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #aaa;
        }
        select, input[type="range"], input[type="number"] {
            width: 100%;
            padding: 8px;
            background: #16213e;
            border: 1px solid #4ecdc4;
            border-radius: 5px;
            color: #eee;
            font-size: 13px;
        }
        input[type="range"] {
            padding: 0;
        }
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        button {
            padding: 10px;
            background: #4ecdc4;
            border: none;
            border-radius: 5px;
            color: #1a1a2e;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
        }
        button:hover {
            background: #45b7aa;
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        button.full-width {
            grid-column: 1 / -1;
        }
        .stats {
            margin-top: 15px;
            padding: 10px;
            background: #16213e;
            border-radius: 5px;
            font-size: 12px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        .color-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        .color-btn {
            height: 35px;
            padding: 5px;
            font-size: 11px;
        }
        .rule-info {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
            padding: 8px;
            background: #16213e;
            border-radius: 5px;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
        .checkbox-group label {
            margin: 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h2>üéÆ 3D –ò–≥—Ä–∞ "–ñ–∏–∑–Ω—å"</h2>
        
        <div class="control-group">
            <label>–ü—Ä–∞–≤–∏–ª–∞:</label>
            <select id="rules">
                <option value="4555">4555 (–ö–ª–∞—Å—Å–∏–∫–∞ 3D)</option>
                <option value="5766">5766 (–°—Ç–∞–±–∏–ª—å–Ω–∞—è)</option>
                <option value="amoeba">Amoeba (–û—Ä–≥–∞–Ω–∏–∫–∞)</option>
                <option value="builder">Builder (–°—Ç—Ä–æ–∏—Ç–µ–ª—å)</option>
                <option value="crystals">Crystals (–ö—Ä–∏—Å—Ç–∞–ª–ª—ã)</option>
                <option value="custom">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ</option>
            </select>
            <div class="rule-info" id="rule-info"></div>
        </div>

        <div id="custom-rules" style="display: none;">
            <div class="control-group">
                <label>–í—ã–∂–∏–≤–∞–Ω–∏–µ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):</label>
                <input type="text" id="survive" placeholder="4" value="4">
            </div>
            <div class="control-group">
                <label>–†–æ–∂–¥–µ–Ω–∏–µ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):</label>
                <input type="text" id="birth" placeholder="5" value="5">
            </div>
        </div>
        
        <div class="control-group">
            <label>–†–∞–∑–º–µ—Ä —Å–µ—Ç–∫–∏: <span id="size-value">20</span></label>
            <input type="range" id="grid-size" min="10" max="40" value="20">
        </div>
        
        <div class="control-group">
            <label>–°–∫–æ—Ä–æ—Å—Ç—å: <span id="speed-value">5</span></label>
            <input type="range" id="speed" min="1" max="20" value="5">
        </div>
        
        <div class="control-group">
            <label>–ü–ª–æ—Ç–Ω–æ—Å—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è: <span id="density-value">15%</span></label>
            <input type="range" id="density" min="5" max="50" value="15">
        </div>
        
        <div class="control-group">
            <label>–¶–≤–µ—Ç–æ–≤–∞—è —Å—Ö–µ–º–∞:</label>
            <div class="color-buttons">
                <button class="color-btn" onclick="setColorScheme('cyan')">Cyan</button>
                <button class="color-btn" onclick="setColorScheme('rainbow')">Rainbow</button>
                <button class="color-btn" onclick="setColorScheme('fire')">Fire</button>
                <button class="color-btn" onclick="setColorScheme('matrix')">Matrix</button>
                <button class="color-btn" onclick="setColorScheme('ocean')">Ocean</button>
                <button class="color-btn" onclick="setColorScheme('purple')">Purple</button>
                <button class="color-btn" onclick="setColorScheme('inherited')" style="grid-column: 1 / -1;">üß¨ –ù–∞—Å–ª–µ–¥—É–µ–º—ã–µ —Ü–≤–µ—Ç–∞</button>
            </div>
        </div>

        <div id="color-evolution-controls" style="display: none;">
            <div class="control-group">
                <label>–ú—É—Ç–∞—Ü–∏—è: <span id="mutation-value">2%</span></label>
                <input type="range" id="mutation-rate" min="0" max="10" value="2" step="0.5">
            </div>
            <div class="control-group">
                <label>–†–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ: <span id="diversity-value">3%</span></label>
                <input type="range" id="color-diversity" min="0" max="10" value="3" step="0.5">
            </div>
            <div class="rule-info">
                üí° –¶–≤–µ—Ç–∞ —É—Å—Ä–µ–¥–Ω—è—é—Ç—Å—è –ø–æ Hue (—Ü–∏—Ä–∫—É–ª—è—Ä–Ω–æ). –ú—É—Ç–∞—Ü–∏–∏ –ø–æ–∑–≤–æ–ª—è—é—Ç "–≤–æ–∑—Ä–æ–¥–∏—Ç—å" –∏—Å—á–µ–∑–Ω—É–≤—à–∏–µ —Ü–≤–µ—Ç–∞ - –Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–∏–Ω–∏–π + —Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π –º–æ–≥—É—Ç –¥–∞—Ç—å –∫—Ä–∞—Å–Ω—ã–π!
            </div>
        </div>

        <div class="control-group">
            <label>–°–µ–∫—É—â–∏–µ –ø–ª–æ—Å–∫–æ—Å—Ç–∏:</label>
            <div class="checkbox-group">
                <input type="checkbox" id="show-planes" checked>
                <label for="show-planes">–ü–æ–∫–∞–∑–∞—Ç—å –ø–ª–æ—Å–∫–æ—Å—Ç–∏</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="show-sections" checked>
                <label for="show-sections">–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ä–µ–∑—ã 2D</label>
            </div>
        </div>
        
        <div class="button-group">
            <button id="play-pause">‚è∏Ô∏è –ü–∞—É–∑–∞</button>
            <button id="step">‚è≠Ô∏è –®–∞–≥</button>
            <button id="reset" class="full-width">üîÑ –ù–æ–≤–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è</button>
            <button id="clear" class="full-width">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å</button>
        </div>
        
        <div class="stats">
            <div class="stat-row">
                <span>–ü–æ–∫–æ–ª–µ–Ω–∏–µ:</span>
                <span id="generation">0</span>
            </div>
            <div class="stat-row">
                <span>–ñ–∏–≤—ã—Ö –∫–ª–µ—Ç–æ–∫:</span>
                <span id="alive">0</span>
            </div>
            <div class="stat-row">
                <span>FPS:</span>
                <span id="fps">60</span>
            </div>
        </div>
    </div>

    <div id="cross-sections">
        <div class="section-view">
            <h3>–°—Ä–µ–∑ XY (Z-–ø–ª–æ—Å–∫–æ—Å—Ç—å)</h3>
            <canvas class="section-canvas" id="section-xy" width="200" height="200"></canvas>
            <div class="slider-container">
                <label>Z:</label>
                <input type="range" id="plane-z" min="0" max="19" value="10">
                <span id="plane-z-value">10</span>
            </div>
        </div>
        <div class="section-view">
            <h3>–°—Ä–µ–∑ XZ (Y-–ø–ª–æ—Å–∫–æ—Å—Ç—å)</h3>
            <canvas class="section-canvas" id="section-xz" width="200" height="200"></canvas>
            <div class="slider-container">
                <label>Y:</label>
                <input type="range" id="plane-y" min="0" max="19" value="10">
                <span id="plane-y-value">10</span>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // –ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã
        const RULES = {
            '4555': { survive: [4], birth: [5], description: '–ü—Ä–æ—Å—Ç—ã–µ —Å—Ç–∞–±–∏–ª—å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã' },
            '5766': { survive: [5, 6, 7], birth: [6], description: '–î–æ–ª–≥–æ–∂–∏–≤—É—â–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã' },
            'amoeba': { survive: [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26], birth: [5, 6, 7], description: '–û—Ä–≥–∞–Ω–∏—á–µ—Å–∫–∏–π —Ä–æ—Å—Ç' },
            'builder': { survive: [2, 6, 9], birth: [4, 6, 8, 9], description: '–°–ª–æ–∂–Ω—ã–µ –º–µ–¥–ª–µ–Ω–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã' },
            'crystals': { survive: [5, 6, 7, 8], birth: [6, 7, 8], description: '–ö—Ä–∏—Å—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏–µ —Ñ–æ—Ä–º–∞—Ü–∏–∏' }
        };

        // –¶–≤–µ—Ç–æ–≤—ã–µ —Å—Ö–µ–º—ã
        const COLOR_SCHEMES = {
            cyan: { cell: 0x4ecdc4, glow: 0x00ffff },
            rainbow: { cell: null, glow: 0xffffff },
            fire: { cell: 0xff6b35, glow: 0xffaa00 },
            matrix: { cell: 0x00ff41, glow: 0x00ff41 },
            ocean: { cell: 0x0077be, glow: 0x00d4ff },
            purple: { cell: 0x9d4edd, glow: 0xc77dff },
            inherited: { cell: null, glow: 0xffffff }
        };

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        scene.fog = new THREE.Fog(0x0a0a1a, 30, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(25, 25, 25);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // –û—Å–≤–µ—â–µ–Ω–∏–µ
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);

        // –°–µ–∫—É—â–∏–µ –ø–ª–æ—Å–∫–æ—Å—Ç–∏
        let planeXY, planeXZ;
        let planeYPosition = 10;
        let planeZPosition = 10;

        function createPlanes(size) {
            const offset = -size / 2;
            
            // –ü–ª–æ—Å–∫–æ—Å—Ç—å XY (–ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω–∞ Z)
            const geometryXY = new THREE.PlaneGeometry(size, size);
            const materialXY = new THREE.MeshBasicMaterial({ 
                color: 0x4ecdc4, 
                transparent: true, 
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            planeXY = new THREE.Mesh(geometryXY, materialXY);
            planeXY.position.set(0, 0, planeZPosition + offset);
            scene.add(planeXY);

            // –ü–ª–æ—Å–∫–æ—Å—Ç—å XZ (–ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω–∞ Y)
            const geometryXZ = new THREE.PlaneGeometry(size, size);
            const materialXZ = new THREE.MeshBasicMaterial({ 
                color: 0xff6b35, 
                transparent: true, 
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            planeXZ = new THREE.Mesh(geometryXZ, materialXZ);
            planeXZ.rotation.x = Math.PI / 2;
            planeXZ.position.set(0, planeYPosition + offset, 0);
            scene.add(planeXZ);
        }

        function updatePlanePositions(size) {
            const offset = -size / 2;
            if (planeXY) {
                planeXY.position.z = planeZPosition + offset;
            }
            if (planeXZ) {
                planeXZ.position.y = planeYPosition + offset;
            }
        }

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä–æ–π
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRotation = { x: 0, y: 0 };
        let cameraDistance = 40;

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                cameraRotation.y += deltaX * 0.005;
                cameraRotation.x += deltaY * 0.005;
                cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));
                
                updateCameraPosition();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.05;
            cameraDistance = Math.max(10, Math.min(100, cameraDistance));
            updateCameraPosition();
        });

        function updateCameraPosition() {
            const x = cameraDistance * Math.cos(cameraRotation.x) * Math.sin(cameraRotation.y);
            const y = cameraDistance * Math.sin(cameraRotation.x);
            const z = cameraDistance * Math.cos(cameraRotation.x) * Math.cos(cameraRotation.y);
            camera.position.set(x, y, z);
            camera.lookAt(0, 0, 0);
        }

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
        let gridSize = 20;
        let grid = [];
        let nextGrid = [];
        let meshes = new Map();
        let playing = true;
        let generation = 0;
        let currentRules = RULES['4555'];
        let currentColorScheme = 'cyan';
        let speed = 5;
        let frameCount = 0;
        let showPlanes = true;
        let showSections = true;
        let mutationRate = 0.02; // 2%
        let colorDiversity = 0.03; // 3%

        // –ì–µ–æ–º–µ—Ç—Ä–∏—è –¥–ª—è –∫–ª–µ—Ç–æ–∫
        const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        
        function rgbToHex(r, g, b) {
            return (r << 16) | (g << 8) | b;
        }

        function hexToRgb(hex) {
            return {
                r: (hex >> 16) & 255,
                g: (hex >> 8) & 255,
                b: hex & 255
            };
        }

        // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –º–µ–∂–¥—É HSL –∏ RGB
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            
            return { h, s, l };
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        function hexToHsl(hex) {
            const rgb = hexToRgb(hex);
            return rgbToHsl(rgb.r, rgb.g, rgb.b);
        }

        function hslToHex(h, s, l) {
            const rgb = hslToRgb(h, s, l);
            return rgbToHex(rgb.r, rgb.g, rgb.b);
        }

        function createMaterial(colorScheme, color = null, age = 0) {
            if (colorScheme === 'inherited' && color !== null) {
                return new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    shininess: 100
                });
            }
            if (colorScheme === 'rainbow') {
                const hue = (age * 0.1) % 1;
                const c = new THREE.Color().setHSL(hue, 1, 0.5);
                return new THREE.MeshPhongMaterial({
                    color: c,
                    emissive: c,
                    emissiveIntensity: 0.3,
                    shininess: 100
                });
            }
            const scheme = COLOR_SCHEMES[colorScheme];
            return new THREE.MeshPhongMaterial({
                color: scheme.cell,
                emissive: scheme.glow,
                emissiveIntensity: 0.3,
                shininess: 100
            });
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ç–∫–∏
        function initGrid(size) {
            gridSize = size;
            grid = [];
            for (let x = 0; x < size; x++) {
                grid[x] = [];
                for (let y = 0; y < size; y++) {
                    grid[x][y] = [];
                    for (let z = 0; z < size; z++) {
                        grid[x][y][z] = { 
                            alive: false, 
                            age: 0,
                            color: 0x4ecdc4
                        };
                    }
                }
            }
        }

        // –°–ª—É—á–∞–π–Ω–æ–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ
        function randomFill(density) {
            clearMeshes();
            generation = 0;
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        grid[x][y][z].alive = Math.random() < density / 100;
                        grid[x][y][z].age = 0;
                        // –°–ª—É—á–∞–π–Ω—ã–π –Ω–∞—á–∞–ª—å–Ω—ã–π —Ü–≤–µ—Ç –¥–ª—è —Ä–µ–∂–∏–º–∞ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è
                        if (currentColorScheme === 'inherited') {
                            const hue = Math.random();
                            const color = new THREE.Color().setHSL(hue, 0.8, 0.5);
                            grid[x][y][z].color = color.getHex();
                        }
                    }
                }
            }
            updateVisualization();
        }

        // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ —Å–æ—Å–µ–¥–µ–π
        function getNeighborColors(x, y, z) {
            const colors = [];
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (dx === 0 && dy === 0 && dz === 0) continue;
                        
                        const nx = x + dx;
                        const ny = y + dy;
                        const nz = z + dz;
                        
                        if (nx >= 0 && nx < gridSize && 
                            ny >= 0 && ny < gridSize && 
                            nz >= 0 && nz < gridSize &&
                            grid[nx][ny][nz].alive) {
                            colors.push(grid[nx][ny][nz].color);
                        }
                    }
                }
            }
            return colors;
        }

        // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–≥–æ —Ü–≤–µ—Ç–∞ —Å —Ü–∏—Ä–∫—É–ª—è—Ä–Ω—ã–º —É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ–º Hue
        function averageColor(colors) {
            if (colors.length === 0) return 0x4ecdc4;
            
            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤—Å–µ —Ü–≤–µ—Ç–∞ –≤ HSL
            const hslColors = colors.map(color => hexToHsl(color));
            
            // –¶–∏—Ä–∫—É–ª—è—Ä–Ω–æ–µ —É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ Hue (—É–≥–æ–ª –Ω–∞ —Ü–≤–µ—Ç–æ–≤–æ–º –∫—Ä—É–≥–µ)
            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —É–≥–ª—ã –≤ –≤–µ–∫—Ç–æ—Ä—ã –Ω–∞ –µ–¥–∏–Ω–∏—á–Ω–æ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏
            let sumX = 0, sumY = 0;
            hslColors.forEach(hsl => {
                const angle = hsl.h * 2 * Math.PI; // –ø–µ—Ä–µ–≤–æ–¥–∏–º –≤ —Ä–∞–¥–∏–∞–Ω—ã
                sumX += Math.cos(angle);
                sumY += Math.sin(angle);
            });
            
            // –°—Ä–µ–¥–Ω–µ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            let avgHue = Math.atan2(sumY, sumX) / (2 * Math.PI);
            if (avgHue < 0) avgHue += 1; // –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫ [0, 1]
            
            // –£—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ –Ω–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç–∏, –Ω–æ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º –ø–æ—Ä–æ–≥–æ–º –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —è—Ä–∫–æ—Å—Ç–∏
            let avgSaturation = hslColors.reduce((sum, hsl) => sum + hsl.s, 0) / hslColors.length;
            avgSaturation = Math.max(0.7, Math.min(1.0, avgSaturation * 1.1)); // —É—Å–∏–ª–∏–≤–∞–µ–º –Ω–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç—å
            
            // –£—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ —Å–≤–µ—Ç–ª–æ—Å—Ç–∏ —Å –Ω–µ–±–æ–ª—å—à–æ–π –≤–∞—Ä–∏–∞—Ü–∏–µ–π
            let avgLightness = hslColors.reduce((sum, hsl) => sum + hsl.l, 0) / hslColors.length;
            avgLightness = Math.max(0.4, Math.min(0.6, avgLightness)); // –¥–µ—Ä–∂–∏–º –≤ —Ä–∞–∑—É–º–Ω—ã—Ö –ø—Ä–µ–¥–µ–ª–∞—Ö
            
            // –ú—É—Ç–∞—Ü–∏—è: —à–∞–Ω—Å —Å–ª—É—á–∞–π–Ω–æ–≥–æ —Å–¥–≤–∏–≥–∞ Hue –¥–ª—è "–≤–æ–∑—Ä–æ–∂–¥–µ–Ω–∏—è" —Ü–≤–µ—Ç–æ–≤
            if (Math.random() < mutationRate) {
                const mutationStrength = (Math.random() - 0.5) * 0.15; // —Å–¥–≤–∏–≥ –Ω–∞ ¬±27¬∞
                avgHue = (avgHue + mutationStrength + 1) % 1;
            }
            
            // –ù–µ–±–æ–ª—å—à–∞—è –¥–∏—Å–ø–µ—Ä—Å–∏—è –¥–ª—è –∫–∞–∂–¥–æ–π –Ω–æ–≤–æ–π –∫–ª–µ—Ç–∫–∏
            avgHue = (avgHue + (Math.random() - 0.5) * colorDiversity + 1) % 1;
            
            return hslToHex(avgHue, avgSaturation, avgLightness);
        }

        // –ü–æ–¥—Å—á—ë—Ç —Å–æ—Å–µ–¥–µ–π
        function countNeighbors(x, y, z) {
            let count = 0;
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (dx === 0 && dy === 0 && dz === 0) continue;
                        
                        const nx = x + dx;
                        const ny = y + dy;
                        const nz = z + dz;
                        
                        if (nx >= 0 && nx < gridSize && 
                            ny >= 0 && ny < gridSize && 
                            nz >= 0 && nz < gridSize &&
                            grid[nx][ny][nz].alive) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä—ã
        function updateGame() {
            nextGrid = JSON.parse(JSON.stringify(grid));
            
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        const neighbors = countNeighbors(x, y, z);
                        const cell = grid[x][y][z];
                        
                        if (cell.alive) {
                            nextGrid[x][y][z].alive = currentRules.survive.includes(neighbors);
                            if (nextGrid[x][y][z].alive) {
                                nextGrid[x][y][z].age = cell.age + 1;
                                // –ù–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Ü–≤–µ—Ç–∞ –ø—Ä–∏ –≤—ã–∂–∏–≤–∞–Ω–∏–∏
                                if (currentColorScheme === 'inherited') {
                                    const neighborColors = getNeighborColors(x, y, z);
                                    neighborColors.push(cell.color); // –¥–æ–±–∞–≤–ª—è–µ–º —Å–≤–æ–π —Ü–≤–µ—Ç
                                    nextGrid[x][y][z].color = averageColor(neighborColors);
                                }
                            } else {
                                nextGrid[x][y][z].age = 0;
                            }
                        } else {
                            nextGrid[x][y][z].alive = currentRules.birth.includes(neighbors);
                            if (nextGrid[x][y][z].alive) {
                                nextGrid[x][y][z].age = 1;
                                // –ù–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Ü–≤–µ—Ç–∞ –ø—Ä–∏ —Ä–æ–∂–¥–µ–Ω–∏–∏
                                if (currentColorScheme === 'inherited') {
                                    const neighborColors = getNeighborColors(x, y, z);
                                    nextGrid[x][y][z].color = averageColor(neighborColors);
                                }
                            } else {
                                nextGrid[x][y][z].age = 0;
                            }
                        }
                    }
                }
            }
            
            grid = nextGrid;
            generation++;
            updateVisualization();
            updateCrossSections();
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
        function updateVisualization() {
            const offset = -gridSize / 2;
            
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        const key = `${x},${y},${z}`;
                        const cell = grid[x][y][z];
                        
                        if (cell.alive && !meshes.has(key)) {
                            const material = createMaterial(currentColorScheme, cell.color, cell.age);
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.position.set(x + offset, y + offset, z + offset);
                            scene.add(mesh);
                            meshes.set(key, mesh);
                        } else if (!cell.alive && meshes.has(key)) {
                            const mesh = meshes.get(key);
                            scene.remove(mesh);
                            mesh.geometry.dispose();
                            mesh.material.dispose();
                            meshes.delete(key);
                        } else if (cell.alive && meshes.has(key)) {
                            const mesh = meshes.get(key);
                            mesh.material.dispose();
                            mesh.material = createMaterial(currentColorScheme, cell.color, cell.age);
                        }
                    }
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            document.getElementById('generation').textContent = generation;
            document.getElementById('alive').textContent = meshes.size;
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ 2D —Å—Ä–µ–∑–æ–≤
        function updateCrossSections() {
            if (!showSections) return;

            // –°—Ä–µ–∑ XY (Z = const)
            const canvasXY = document.getElementById('section-xy');
            const ctxXY = canvasXY.getContext('2d');
            const cellSize = canvasXY.width / gridSize;
            
            ctxXY.fillStyle = '#16213e';
            ctxXY.fillRect(0, 0, canvasXY.width, canvasXY.height);
            
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    if (grid[x][y][planeZPosition].alive) {
                        const color = grid[x][y][planeZPosition].color;
                        ctxXY.fillStyle = '#' + color.toString(16).padStart(6, '0');
                        ctxXY.fillRect(x * cellSize, (gridSize - 1 - y) * cellSize, cellSize, cellSize);
                    }
                }
            }

            // –°—Ä–µ–∑ XZ (Y = const)
            const canvasXZ = document.getElementById('section-xz');
            const ctxXZ = canvasXZ.getContext('2d');
            
            ctxXZ.fillStyle = '#16213e';
            ctxXZ.fillRect(0, 0, canvasXZ.width, canvasXZ.height);
            
            for (let x = 0; x < gridSize; x++) {
                for (let z = 0; z < gridSize; z++) {
                    if (grid[x][planeYPosition][z].alive) {
                        const color = grid[x][planeYPosition][z].color;
                        ctxXZ.fillStyle = '#' + color.toString(16).padStart(6, '0');
                        ctxXZ.fillRect(x * cellSize, (gridSize - 1 - z) * cellSize, cellSize, cellSize);
                    }
                }
            }
        }

        // –û—á–∏—Å—Ç–∫–∞ –º–µ—à–µ–π
        function clearMeshes() {
            meshes.forEach((mesh) => {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            });
            meshes.clear();
        }

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π UI
        document.getElementById('play-pause').addEventListener('click', function() {
            playing = !playing;
            this.textContent = playing ? '‚è∏Ô∏è –ü–∞—É–∑–∞' : '‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç';
        });

        document.getElementById('step').addEventListener('click', () => {
            updateGame();
        });

        document.getElementById('reset').addEventListener('click', () => {
            const density = parseInt(document.getElementById('density').value);
            randomFill(density);
        });

        document.getElementById('clear').addEventListener('click', () => {
            clearMeshes();
            generation = 0;
            initGrid(gridSize);
            updateVisualization();
            updateCrossSections();
        });

        document.getElementById('rules').addEventListener('change', function() {
            const customRulesDiv = document.getElementById('custom-rules');
            const ruleInfo = document.getElementById('rule-info');
            
            if (this.value === 'custom') {
                customRulesDiv.style.display = 'block';
                ruleInfo.textContent = '–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é';
            } else {
                customRulesDiv.style.display = 'none';
                currentRules = RULES[this.value];
                ruleInfo.textContent = currentRules.description;
            }
        });

        document.getElementById('survive').addEventListener('input', updateCustomRules);
        document.getElementById('birth').addEventListener('input', updateCustomRules);

        function updateCustomRules() {
            const survive = document.getElementById('survive').value.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            const birth = document.getElementById('birth').value.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            currentRules = { survive, birth };
        }

        document.getElementById('grid-size').addEventListener('input', function() {
            document.getElementById('size-value').textContent = this.value;
            const newSize = parseInt(this.value);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ª–∞–π–¥–µ—Ä–æ–≤ –ø–ª–æ—Å–∫–æ—Å—Ç–µ–π
            document.getElementById('plane-y').max = newSize - 1;
            document.getElementById('plane-z').max = newSize - 1;
            planeYPosition = Math.floor(newSize / 2);
            planeZPosition = Math.floor(newSize / 2);
            document.getElementById('plane-y').value = planeYPosition;
            document.getElementById('plane-z').value = planeZPosition;
            document.getElementById('plane-y-value').textContent = planeYPosition;
            document.getElementById('plane-z-value').textContent = planeZPosition;
            
            clearMeshes();
            if (planeXY) {
                scene.remove(planeXY);
                scene.remove(planeXZ);
            }
            initGrid(newSize);
            createPlanes(newSize);
            const density = parseInt(document.getElementById('density').value);
            randomFill(density);
        });

        document.getElementById('speed').addEventListener('input', function() {
            document.getElementById('speed-value').textContent = this.value;
            speed = parseInt(this.value);
        });

        document.getElementById('density').addEventListener('input', function() {
            document.getElementById('density-value').textContent = this.value + '%';
        });

        document.getElementById('plane-y').addEventListener('input', function() {
            planeYPosition = parseInt(this.value);
            document.getElementById('plane-y-value').textContent = planeYPosition;
            updatePlanePositions(gridSize);
            updateCrossSections();
        });

        document.getElementById('plane-z').addEventListener('input', function() {
            planeZPosition = parseInt(this.value);
            document.getElementById('plane-z-value').textContent = planeZPosition;
            updatePlanePositions(gridSize);
            updateCrossSections();
        });

        document.getElementById('show-planes').addEventListener('change', function() {
            showPlanes = this.checked;
            if (planeXY && planeXZ) {
                planeXY.visible = showPlanes;
                planeXZ.visible = showPlanes;
            }
        });

        document.getElementById('show-sections').addEventListener('change', function() {
            showSections = this.checked;
            document.getElementById('cross-sections').style.display = showSections ? 'flex' : 'none';
        });

        function setColorScheme(scheme) {
            currentColorScheme = scheme;
            
            // –ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –∫–æ–Ω—Ç—Ä–æ–ª–∏ —ç–≤–æ–ª—é—Ü–∏–∏ —Ü–≤–µ—Ç–∞
            const colorEvolutionControls = document.getElementById('color-evolution-controls');
            if (scheme === 'inherited') {
                colorEvolutionControls.style.display = 'block';
            } else {
                colorEvolutionControls.style.display = 'none';
            }
            
            // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∞—Ç—å –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∫–ª–µ—Ç–∫–∏
            meshes.forEach((mesh, key) => {
                const [x, y, z] = key.split(',').map(Number);
                const cell = grid[x][y][z];
                mesh.material.dispose();
                mesh.material = createMaterial(scheme, cell.color, cell.age);
            });
            updateCrossSections();
        }

        document.getElementById('mutation-rate').addEventListener('input', function() {
            mutationRate = parseFloat(this.value) / 100;
            document.getElementById('mutation-value').textContent = this.value + '%';
        });

        document.getElementById('color-diversity').addEventListener('input', function() {
            colorDiversity = parseFloat(this.value) / 100;
            document.getElementById('diversity-value').textContent = this.value + '%';
        });

        // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª
        let lastTime = 0;
        let fpsTime = 0;
        let fpsFrames = 0;

        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = currentTime - lastTime;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ FPS
            fpsFrames++;
            fpsTime += deltaTime;
            if (fpsTime >= 1000) {
                document.getElementById('fps').textContent = fpsFrames;
                fpsFrames = 0;
                fpsTime = 0;
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä—ã
            if (playing) {
                frameCount++;
                if (frameCount >= (21 - speed)) {
                    updateGame();
                    frameCount = 0;
                }
            }
            
            // –õ—ë–≥–∫–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –∫–ª–µ—Ç–æ–∫
            meshes.forEach(mesh => {
                mesh.rotation.x += 0.001;
                mesh.rotation.y += 0.001;
            });
            
            renderer.render(scene, camera);
            lastTime = currentTime;
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        initGrid(gridSize);
        createPlanes(gridSize);
        randomFill(15);
        updateCameraPosition();
        updateCrossSections();
        document.getElementById('rule-info').textContent = RULES['4555'].description;
        animate(0);
    </script>
</body>
</html>