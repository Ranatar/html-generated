<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Римановы поверхности</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        h2 {
            color: #3498db;
            margin-top: 30px;
        }
        .canvas-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        canvas {
            border: 1px solid #ddd;
            margin: 10px;
        }
        .controls {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        .advantages-disadvantages {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }
        .advantages, .disadvantages {
            width: 48%;
            padding: 15px;
            border-radius: 5px;
        }
        .advantages {
            background-color: #e8f8f5;
            border-left: 5px solid #1abc9c;
        }
        .disadvantages {
            background-color: #fef5e7;
            border-left: 5px solid #f39c12;
        }
        ul {
            padding-left: 20px;
        }
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background-color: #eaf2f8;
            border-radius: 5px;
        }
        .control-group {
            margin-right: 15px;
        }
        .demo-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .range-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .range-control input {
            width: 150px;
        }
        .rotation-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .rotation-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
        }
        .rotation-button {
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .rotation-button:hover {
            background-color: #2980b9;
        }
        .empty-cell {
            width: 30px;
            height: 30px;
        }
        .surface-info {
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f4fc;
            border-radius: 5px;
            border-left: 5px solid #3498db;
        }
        .surface-info h3 {
            margin-top: 0;
            color: #3498db;
        }
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border: 1px solid #000;
        }
        .checkbox-group {
            display: flex;
            gap: 15px;
        }
    </style>
</head>
<body>
    <h1>Римановы поверхности для функций комплексного переменного</h1>
    
    <p>
        Римановы поверхности — это математические объекты, используемые для визуализации многозначных 
        функций комплексного переменного. Они позволяют представить разные ветви функции как отдельные 
        листы, соединенные вдоль линий ветвления, образуя единую поверхность.
    </p>

    <div class="controls">
        <div class="control-group">
            <label for="function-select">Выберите функцию: </label>
            <select id="function-select">
                <option value="sqrt">f(z) = √z</option>
                <option value="log">f(z) = log(z)</option>
                <option value="cbrt">f(z) = ∛z</option>
                <option value="z_sqrt">f(z) = z√z</option>
                <option value="asin">f(z) = arcsin(z)</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="mode-select">Режим отображения: </label>
            <select id="mode-select">
                <option value="sheets">Листы поверхности</option>
                <option value="real">Действительная часть</option>
                <option value="imag">Мнимая часть</option>
                <option value="modulus">Модуль функции</option>
                <option value="phase">Фаза функции</option>
            </select>
        </div>
    </div>
    
    <div class="controls">
        <div class="rotation-controls">
            <span>Вращение: </span>
            <div class="rotation-buttons">
                <div class="empty-cell"></div>
                <button class="rotation-button" id="rotate-up">↑</button>
                <div class="empty-cell"></div>
                <button class="rotation-button" id="rotate-left">←</button>
                <button class="rotation-button" id="reset-rotation">R</button>
                <button class="rotation-button" id="rotate-right">→</button>
                <div class="empty-cell"></div>
                <button class="rotation-button" id="rotate-down">↓</button>
                <div class="empty-cell"></div>
            </div>
        </div>
        
        <div class="control-group range-control">
            <label for="opacity">Прозрачность: </label>
            <input type="range" id="opacity" min="0.1" max="1" step="0.1" value="0.8">
            <span id="opacity-value">0.8</span>
        </div>
        
        <div class="checkbox-group">
            <div>
                <input type="checkbox" id="show-branch-cuts" checked>
                <label for="show-branch-cuts">Показать линии ветвления</label>
            </div>
            
            <div>
                <input type="checkbox" id="show-grid" checked>
                <label for="show-grid">Показать сетку</label>
            </div>
        </div>
    </div>
    
    <div class="demo-area">
        <canvas id="riemann-surface-canvas" width="800" height="600"></canvas>
    </div>
    
    <div class="legend" id="legend">
        <!-- Легенда будет заполнена с помощью JavaScript -->
    </div>
    
    <div class="surface-info" id="surface-info">
        <h3>Информация о римановой поверхности функции</h3>
        <div id="function-description"></div>
    </div>

    <div class="explanation">
        <h2>Интерпретация римановых поверхностей</h2>
        <p>
            Римановы поверхности позволяют корректно определить многозначные функции комплексного переменного путем 
            размещения каждой ветви функции на отдельном "листе". Эти листы соединяются вдоль линий разреза 
            (линий ветвления), образуя единую связную поверхность.
        </p>
        
        <p>
            <strong>Ключевые элементы римановой поверхности:</strong>
        </p>
        <ul>
            <li><strong>Листы</strong> — отдельные экземпляры комплексной плоскости, соответствующие различным ветвям функции</li>
            <li><strong>Точки ветвления</strong> — особые точки, вокруг которых происходит переход с одного листа на другой</li>
            <li><strong>Линии разреза</strong> — линии, соединяющие точки ветвления или уходящие в бесконечность</li>
        </ul>
        
        <p>
            <strong>Важные свойства:</strong>
        </p>
        <ul>
            <li><strong>Аналитическое продолжение</strong> — при обходе вокруг точки ветвления, значение функции изменяется непрерывно, 
                переходя с одной ветви на другую</li>
            <li><strong>Монодромия</strong> — при обходе вокруг точки, не являющейся точкой ветвления, 
                значение функции возвращается к исходному</li>
            <li><strong>Топологическая структура</strong> — для различных функций римановы поверхности имеют различные 
                топологические свойства (количество листов, род поверхности)</li>
        </ul>
    </div>

    <div class="advantages-disadvantages">
        <div class="advantages">
            <h2>Преимущества</h2>
            <ul>
                <li>Позволяет корректно визуализировать многозначные функции</li>
                <li>Наглядно показывает точки ветвления и аналитическое продолжение</li>
                <li>Демонстрирует топологическую структуру функции</li>
                <li>Позволяет понять связь между различными ветвями функции</li>
                <li>Дает целостное представление о глобальной структуре функции</li>
                <li>Помогает понять существенные особенности многозначных функций</li>
            </ul>
        </div>
        <div class="disadvantages">
            <h2>Недостатки</h2>
            <ul>
                <li>Высокая сложность реализации и визуализации</li>
                <li>Требует абстрактного мышления для интерпретации</li>
                <li>Ограничения в изображении сложных поверхностей в трехмерном пространстве</li>
                <li>Сложность представления функций с большим количеством листов</li>
                <li>Трудности в отображении численных значений функции</li>
                <li>Необходимость упрощений для визуализации, особенно для функций с бесконечным числом листов</li>
            </ul>
        </div>
    </div>

    <script>
        // Подключаем библиотеку Three.js из CDN
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
        document.head.appendChild(script);
        
        script.onload = function() {
            let scene, camera, renderer;
            let surface;
            let rotationX = 0.5;
            let rotationY = 0.5;
            let animationId;
            
            const canvas = document.getElementById('riemann-surface-canvas');
            
            // Описания функций
            const functionDescriptions = {
                sqrt: {
                    title: "Квадратный корень (f(z) = √z)",
                    description: `
                        <p>Функция квадратного корня имеет две ветви, соответствующие двум значениям √z. 
                        Точка ветвления находится в z = 0, а линия разреза обычно проводится вдоль отрицательной 
                        действительной полуоси.</p>
                        <p>При обходе вокруг начала координат один раз, происходит переход с одного листа на другой, 
                        а при полном обходе в 360° (4π для аргумента) возвращение к исходному значению.</p>
                        <p>Риманова поверхность для √z имеет два листа и топологически эквивалентна плоскости.</p>
                    `,
                    branchPoints: [{ x: 0, y: 0 }],
                    numSheets: 2
                },
                log: {
                    title: "Логарифмическая функция (f(z) = log(z))",
                    description: `
                        <p>Логарифмическая функция имеет бесконечно много ветвей, отличающихся на 2πi.
                        Точка ветвления находится в z = 0, а линия разреза обычно проводится вдоль отрицательной 
                        действительной полуоси.</p>
                        <p>При каждом полном обходе вокруг начала координат происходит переход на следующий лист,
                        добавляя 2πi к значению функции. Риманова поверхность имеет бесконечно много листов,
                        соединенных в виде спирали (или "винтовой лестницы").</p>
                        <p>В данной визуализации показаны только несколько первых листов для наглядности.</p>
                    `,
                    branchPoints: [{ x: 0, y: 0 }],
                    numSheets: "бесконечно"
                },
                cbrt: {
                    title: "Кубический корень (f(z) = ∛z)",
                    description: `
                        <p>Функция кубического корня имеет три ветви, соответствующие трем значениям ∛z.
                        Точка ветвления находится в z = 0, а линия разреза обычно проводится вдоль отрицательной 
                        действительной полуоси.</p>
                        <p>При обходе вокруг начала координат происходит последовательный переход между тремя листами.
                        Полный возврат к исходному значению происходит после трех полных оборотов вокруг начала координат.</p>
                        <p>Риманова поверхность для ∛z имеет три листа и также топологически эквивалентна плоскости.</p>
                    `,
                    branchPoints: [{ x: 0, y: 0 }],
                    numSheets: 3
                },
                z_sqrt: {
                    title: "Произведение (f(z) = z√z)",
                    description: `
                        <p>Функция z√z сочетает линейную функцию и квадратный корень. Она имеет две ветви из-за √z.
                        Точка ветвления находится в z = 0, и линия разреза обычно проводится вдоль отрицательной 
                        действительной полуоси.</p>
                        <p>Интересно, что z = 0 является одновременно точкой ветвления и нулем функции, 
                        что придает особые свойства поведению функции вблизи этой точки.</p>
                        <p>Риманова поверхность для z√z имеет два листа и демонстрирует взаимодействие алгебраической 
                        и многозначной частей функции.</p>
                    `,
                    branchPoints: [{ x: 0, y: 0 }],
                    numSheets: 2
                },
                asin: {
                    title: "Арксинус (f(z) = arcsin(z))",
                    description: `
                        <p>Функция arcsin(z) обратна к sin(z) и имеет бесконечно много ветвей, отличающихся на 2π.
                        Точки ветвления находятся в z = -1 и z = 1, а линии разреза обычно проводятся 
                        от -∞ до -1 и от 1 до +∞ вдоль действительной оси.</p>
                        <p>При обходе вокруг одной из точек ветвления происходит переход на следующий лист.
                        Полный обход вокруг обеих точек ветвления возвращает к исходному значению.</p>
                        <p>Риманова поверхность arcsin(z) имеет сложную структуру и в данной визуализации 
                        представлены только ее основные ветви.</p>
                    `,
                    branchPoints: [{ x: -1, y: 0 }, { x: 1, y: 0 }],
                    numSheets: "бесконечно"
                }
            };
            
            // Функции для вычисления значений комплексных функций
            function complex(re, im) {
                return { re, im };
            }
            
            function complexAdd(a, b) {
                return { re: a.re + b.re, im: a.im + b.im };
            }
            
            function complexMul(a, b) {
                return {
                    re: a.re * b.re - a.im * b.im,
                    im: a.re * b.im + a.im * b.re
                };
            }
            
            function complexAbs(z) {
                return Math.sqrt(z.re * z.re + z.im * z.im);
            }
            
            function complexArg(z) {
                return Math.atan2(z.im, z.re);
            }
            
            function complexExp(z) {
                const exp_re = Math.exp(z.re);
                return {
                    re: exp_re * Math.cos(z.im),
                    im: exp_re * Math.sin(z.im)
                };
            }
            
            function complexLog(z, branch = 0) {
                const r = complexAbs(z);
                let theta = complexArg(z);
                
                // Добавляем 2π * branch для других ветвей
                theta += 2 * Math.PI * branch;
                
                return {
                    re: Math.log(r),
                    im: theta
                };
            }
            
            function complexPow(z, n, branch = 0) {
                if (complexAbs(z) === 0) return { re: 0, im: 0 };
                
                const log_z = complexLog(z, branch);
                const scaled = { re: n * log_z.re, im: n * log_z.im };
                return complexExp(scaled);
            }
            
            function complexSqrt(z, branch = 0) {
                return complexPow(z, 0.5, branch);
            }
            
            function complexCbrt(z, branch = 0) {
                return complexPow(z, 1/3, branch);
            }
            
            function complexZSqrt(z, branch = 0) {
                const sqrt_z = complexSqrt(z, branch);
                return complexMul(z, sqrt_z);
            }
            
            function complexAsin(z, branch = 0) {
                // arcsin(z) = -i * log(i*z + sqrt(1 - z^2))
                const z_squared = complexMul(z, z);
                const one_minus_z_squared = { re: 1 - z_squared.re, im: -z_squared.im };
                
                // Выбор подходящей ветви для sqrt с учетом ветви arcsin
                const branch_sqrt = branch % 2; // Для arcsin нужно учитывать parity ветви для sqrt
                const sqrt_result = complexSqrt(one_minus_z_squared, branch_sqrt);
                
                const i_z = { re: -z.im, im: z.re };
                const sum = complexAdd(i_z, sqrt_result);
                
                const log_result = complexLog(sum, Math.floor(branch / 2));
                
                // Умножение на -i
                return { re: log_result.im, im: -log_result.re };
            }
            
            // Инициализация Three.js сцены
            function init() {
                // Создаем сцену
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                
                // Создаем камеру
                const aspect = canvas.width / canvas.height;
                camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                camera.position.z = 5;
                
                // Создаем рендерер
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                
                // Добавляем оси координат
                const axisHelper = new THREE.AxesHelper(2);
                scene.add(axisHelper);
                
                // Добавляем освещение
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                
                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
                directionalLight2.position.set(-1, -1, -1);
                scene.add(directionalLight2);
                
                // Обновляем камеру
                updateCamera();
                
                // Создаем риманову поверхность
                createRiemannSurface();
                
                // Запускаем анимацию
                animate();
                
                // Обновляем информацию о функции
                updateFunctionInfo();
            }
            
            // Функция для создания римановой поверхности
            function createRiemannSurface() {
                // Удаляем предыдущую поверхность, если она существует
                if (surface) {
                    scene.remove(surface);
                }
                
                // Получаем параметры
                const functionName = document.getElementById('function-select').value;
                const mode = document.getElementById('mode-select').value;
                const opacity = parseFloat(document.getElementById('opacity').value);
                const showBranchCuts = document.getElementById('show-branch-cuts').checked;
                const showGrid = document.getElementById('show-grid').checked;
                
                // Создаем группу для всех частей поверхности
                surface = new THREE.Group();
                
                // Определяем функцию для вычисления значения в зависимости от выбранного режима
                function getValue(z, branch, func) {
                    const result = func(z, branch);
                    
                    switch(mode) {
                        case 'real': return result.re;
                        case 'imag': return result.im;
                        case 'modulus': return complexAbs(result);
                        case 'phase': return complexArg(result);
                        default: return result;
                    }
                }
                
                // Определяем функцию для вычисления
                let func;
                let numBranches;
                
                switch(functionName) {
                    case 'sqrt':
                        func = complexSqrt;
                        numBranches = 2;
                        break;
                    case 'log':
                        func = complexLog;
                        numBranches = 3; // Показываем только 3 ветви для наглядности
                        break;
                    case 'cbrt':
                        func = complexCbrt;
                        numBranches = 3;
                        break;
                    case 'z_sqrt':
                        func = complexZSqrt;
                        numBranches = 2;
                        break;
                    case 'asin':
                        func = complexAsin;
                        numBranches = 2; // Показываем 2 основные ветви
                        break;
                }
                
                // Если режим "листы", создаем поверхности для каждой ветви
                if (mode === 'sheets') {
                    for (let branch = 0; branch < numBranches; branch++) {
                        createSheetSurface(func, branch, numBranches, opacity, functionName);
                    }
                    
                    // Добавляем линии ветвления, если нужно
                    if (showBranchCuts) {
                        addBranchCuts(functionName);
                    }
                } else {
                    // Для других режимов создаем поверхности для визуализации компоненты
                    for (let branch = 0; branch < numBranches; branch++) {
                        createComponentSurface(func, branch, mode, opacity);
                    }
                    
                    // Добавляем линии ветвления, если нужно
                    if (showBranchCuts) {
                        addBranchCuts(functionName);
                    }
                }
                
                // Добавляем сетку, если нужно
                if (showGrid) {
                    addGridToSurfaces();
                }
                
                // Добавляем поверхность в сцену
                scene.add(surface);
                
                // Обновляем легенду
                updateLegend(mode);
            }
            
            // Функция для создания поверхности отдельного листа
            function createSheetSurface(func, branch, totalBranches, opacity, functionName) {
                const resolution = 50; // Разрешение сетки
                const size = 3; // Размер области
                
                // Создаем геометрию
                const geometry = new THREE.BufferGeometry();
                
                // Параметры для разных ветвей
                const offset = branch - (totalBranches - 1) / 2; // Смещение по Z для разделения листов
                const color = getBranchColor(branch, totalBranches);
                
                // Создаем массивы для вершин и индексов
                const vertices = [];
                const indices = [];
                const colors = [];
                
                // Создаем вершины
                for (let i = 0; i <= resolution; i++) {
                    for (let j = 0; j <= resolution; j++) {
                        const u = (i / resolution) * 2 - 1;
                        const v = (j / resolution) * 2 - 1;
                        
                        const x = u * size;
                        const y = v * size;
                        
                        const z = { re: x, im: y };
                        
                        // Избегаем точек ветвления, добавляя небольшое смещение
                        if (functionName === 'sqrt' || functionName === 'log' || 
                            functionName === 'cbrt' || functionName === 'z_sqrt') {
                            if (Math.abs(x) < 0.05 && Math.abs(y) < 0.05) {
                                continue;
                            }
                        } else if (functionName === 'asin') {
                            if ((Math.abs(x - 1) < 0.05 && Math.abs(y) < 0.05) || 
                                (Math.abs(x + 1) < 0.05 && Math.abs(y) < 0.05)) {
                                continue;
                            }
                        }
                        
                        // Добавляем смещение по Z для разделения листов
                        const z_offset = offset * 0.5;
                        
                        vertices.push(x, y, z_offset);
                        
                        // Добавляем цвет (один для всего листа)
                        colors.push(color.r, color.g, color.b);
                    }
                }
                
                // Создаем индексы треугольников
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const a = i * (resolution + 1) + j;
                        const b = i * (resolution + 1) + (j + 1);
                        const c = (i + 1) * (resolution + 1) + j;
                        const d = (i + 1) * (resolution + 1) + (j + 1);
                        
                        // Пропускаем треугольники, содержащие точки ветвления
                        if (isNaN(vertices[a * 3]) || isNaN(vertices[b * 3]) || 
                            isNaN(vertices[c * 3]) || isNaN(vertices[d * 3])) {
                            continue;
                        }
                        
                        // Первый треугольник
                        indices.push(a, b, c);
                        // Второй треугольник
                        indices.push(c, b, d);
                    }
                }
                
                // Устанавливаем атрибуты геометрии
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setIndex(indices);
                
                // Вычисляем нормали
                geometry.computeVertexNormals();
                
                // Создаем материал
                const material = new THREE.MeshLambertMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: opacity
                });
                
                // Создаем меш
                const sheetMesh = new THREE.Mesh(geometry, material);
                
                // Добавляем меш в группу
                surface.add(sheetMesh);
            }
            
            // Функция для создания поверхности компоненты
            function createComponentSurface(func, branch, mode, opacity) {
                const resolution = 50; // Разрешение сетки
                const size = 3; // Размер области
                
                // Создаем геометрию
                const geometry = new THREE.BufferGeometry();
                
                // Параметры для разных ветвей
                const offset = branch - 1; // Смещение по Z для разделения ветвей
                
                // Создаем массивы для вершин, цветов и индексов
                const vertices = [];
                const colors = [];
                const indices = [];
                
                // Находим минимальное и максимальное значения для нормализации цветов
                let minVal = Infinity;
                let maxVal = -Infinity;
                
                // Создаем двумерный массив для хранения значений компоненты
                const componentValues = [];
                
                for (let i = 0; i <= resolution; i++) {
                    componentValues[i] = [];
                    for (let j = 0; j <= resolution; j++) {
                        const u = (i / resolution) * 2 - 1;
                        const v = (j / resolution) * 2 - 1;
                        
                        const x = u * size;
                        const y = v * size;
                        
                        const z = { re: x, im: y };
                        
                        // Вычисляем значение компоненты
                        let value;
                        
                        // Избегаем точек ветвления
                        if ((functionName === 'sqrt' || functionName === 'log' || 
                             functionName === 'cbrt' || functionName === 'z_sqrt') && 
                            Math.abs(x) < 0.05 && Math.abs(y) < 0.05) {
                            componentValues[i][j] = NaN;
                            continue;
                        } else if (functionName === 'asin' && 
                                  ((Math.abs(x - 1) < 0.05 && Math.abs(y) < 0.05) || 
                                   (Math.abs(x + 1) < 0.05 && Math.abs(y) < 0.05))) {
                            componentValues[i][j] = NaN;
                            continue;
                        }
                        
                        try {
                            // Вычисляем значение функции
                            const result = func(z, branch);
                            
                            // Выбираем компоненту в зависимости от режима
                            switch(mode) {
                                case 'real': value = result.re; break;
                                case 'imag': value = result.im; break;
                                case 'modulus': value = complexAbs(result); break;
                                case 'phase': value = complexArg(result); break;
                            }
                            
                            // Ограничиваем значения для визуализации
                            value = Math.max(-5, Math.min(5, value));
                            
                            // Обновляем минимальное и максимальное значения
                            minVal = Math.min(minVal, value);
                            maxVal = Math.max(maxVal, value);
                            
                            componentValues[i][j] = value;
                        } catch (e) {
                            componentValues[i][j] = NaN;
                        }
                    }
                }
                
                // Создаем вершины и цвета
                for (let i = 0; i <= resolution; i++) {
                    for (let j = 0; j <= resolution; j++) {
                        const u = (i / resolution) * 2 - 1;
                        const v = (j / resolution) * 2 - 1;
                        
                        const x = u * size;
                        const y = v * size;
                        
                        const value = componentValues[i][j];
                        
                        if (isNaN(value)) continue;
                        
                        // Используем значение компоненты для высоты
                        const normalizedValue = (value - minVal) / (maxVal - minVal);
                        
                        vertices.push(x, y, value);
                        
                        // Цвет в зависимости от значения
                        let color;
                        
                        if (mode === 'phase') {
                            // Для фазы используем HSL цветовую модель
                            const hue = ((value + Math.PI) / (2 * Math.PI)) * 360;
                            color = hslToRgb(hue / 360, 1, 0.5);
                        } else {
                            // Для других компонент используем градиент от синего к красному
                            color = getColorForValue(normalizedValue);
                        }
                        
                        colors.push(color.r, color.g, color.b);
                    }
                }
                
                // Создаем индексы треугольников
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const vertexCount = (resolution + 1);
                        const a = i * vertexCount + j;
                        const b = i * vertexCount + (j + 1);
                        const c = (i + 1) * vertexCount + j;
                        const d = (i + 1) * vertexCount + (j + 1);
                        
                        // Пропускаем треугольники, содержащие точки ветвления
                        if (isNaN(componentValues[i][j]) || isNaN(componentValues[i][j+1]) || 
                            isNaN(componentValues[i+1][j]) || isNaN(componentValues[i+1][j+1])) {
                            continue;
                        }
                        
                        // Первый треугольник
                        indices.push(a, b, c);
                        // Второй треугольник
                        indices.push(c, b, d);
                    }
                }
                
                // Устанавливаем атрибуты геометрии
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setIndex(indices);
                
                // Вычисляем нормали
                geometry.computeVertexNormals();
                
                // Создаем материал
                const material = new THREE.MeshLambertMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: opacity
                });
                
                // Создаем меш
                const componentMesh = new THREE.Mesh(geometry, material);
                
                // Добавляем меш в группу
                surface.add(componentMesh);
            }
            
            // Функция для добавления линий ветвления
            function addBranchCuts(functionName) {
                const desc = functionDescriptions[functionName];
                
                if (!desc.branchPoints || desc.branchPoints.length === 0) return;
                
                // Создаем материал для линий ветвления
                const material = new THREE.LineBasicMaterial({
                    color: 0xff0000,
                    linewidth: 3
                });
                
                // Для каждой точки ветвления
                for (const point of desc.branchPoints) {
                    // Для sqrt, log, cbrt, z_sqrt - линия от точки ветвления вдоль отрицательной действительной полуоси
                    if (functionName === 'sqrt' || functionName === 'log' || 
                        functionName === 'cbrt' || functionName === 'z_sqrt') {
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(point.x, point.y, 0),
                            new THREE.Vector3(-3, point.y, 0)
                        ]);
                        const line = new THREE.Line(geometry, material);
                        surface.add(line);
                    } 
                    // Для asin - линии от -1 до -∞ и от 1 до +∞
                    else if (functionName === 'asin') {
                        if (point.x === -1) {
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(point.x, point.y, 0),
                                new THREE.Vector3(-3, point.y, 0)
                            ]);
                            const line = new THREE.Line(geometry, material);
                            surface.add(line);
                        } else if (point.x === 1) {
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(point.x, point.y, 0),
                                new THREE.Vector3(3, point.y, 0)
                            ]);
                            const line = new THREE.Line(geometry, material);
                            surface.add(line);
                        }
                    }
                    
                    // Добавляем сферу для обозначения точки ветвления
                    const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
                    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.set(point.x, point.y, 0);
                    surface.add(sphere);
                }
            }
            
            // Функция для добавления сетки на поверхности
            function addGridToSurfaces() {
                const size = 3;
                const step = 0.5;
                
                // Материал для сетки
                const material = new THREE.LineBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.2
                });
                
                // Горизонтальные линии
                for (let y = -size; y <= size; y += step) {
                    const points = [];
                    for (let x = -size; x <= size; x += 0.1) {
                        points.push(new THREE.Vector3(x, y, 0));
                    }
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, material);
                    surface.add(line);
                }
                
                // Вертикальные линии
                for (let x = -size; x <= size; x += step) {
                    const points = [];
                    for (let y = -size; y <= size; y += 0.1) {
                        points.push(new THREE.Vector3(x, y, 0));
                    }
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, material);
                    surface.add(line);
                }
            }
            
            // Функция для определения цвета ветви
            function getBranchColor(branch, totalBranches) {
                const hue = (branch / totalBranches) * 360;
                const rgb = hslToRgb(hue / 360, 0.7, 0.5);
                return rgb;
            }
            
            // Функция для получения цвета в зависимости от значения (для режимов real, imag, modulus)
            function getColorForValue(value) {
                // От синего (0) через зеленый (0.5) к красному (1)
                let r, g, b;
                
                if (value < 0.5) {
                    // От синего к зеленому
                    b = 1 - 2 * value;
                    g = 2 * value;
                    r = 0;
                } else {
                    // От зеленого к красному
                    b = 0;
                    g = 2 - 2 * value;
                    r = 2 * value - 1;
                }
                
                return {
                    r: r,
                    g: g,
                    b: b
                };
            }
            
            // Функция для преобразования HSL в RGB
            function hslToRgb(h, s, l) {
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l; // ахроматический
                } else {
                    const hue2rgb = function hue2rgb(p, q, t) {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    }
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return { r: r, g: g, b: b };
            }
            
            // Функция для обновления легенды
            function updateLegend(mode) {
                const legendContainer = document.getElementById('legend');
                let html = '';
                
                if (mode === 'sheets') {
                    // Легенда для листов поверхности
                    const functionName = document.getElementById('function-select').value;
                    const desc = functionDescriptions[functionName];
                    const numBranches = typeof desc.numSheets === 'number' ? desc.numSheets : 3;
                    
                    html += '<div class="legend-item"><span>Ветви функции:</span></div>';
                    
                    for (let branch = 0; branch < numBranches; branch++) {
                        const color = getBranchColor(branch, numBranches);
                        const rgb = `rgb(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)})`;
                        
                        html += `
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: ${rgb};"></div>
                                <span>Ветвь ${branch + 1}</span>
                            </div>
                        `;
                    }
                } else if (mode === 'phase') {
                    // Легенда для фазы
                    html += '<div class="legend-item"><span>Фаза функции:</span></div>';
                    
                    const phases = [0, Math.PI/4, Math.PI/2, 3*Math.PI/4, Math.PI, 5*Math.PI/4, 3*Math.PI/2, 7*Math.PI/4];
                    const labels = ['0', 'π/4', 'π/2', '3π/4', 'π', '5π/4', '3π/2', '7π/4'];
                    
                    for (let i = 0; i < phases.length; i++) {
                        const hue = ((phases[i] + Math.PI) / (2 * Math.PI)) * 360;
                        const color = hslToRgb(hue / 360, 1, 0.5);
                        const rgb = `rgb(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)})`;
                        
                        html += `
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: ${rgb};"></div>
                                <span>${labels[i]}</span>
                            </div>
                        `;
                    }
                } else {
                    // Легенда для real, imag, modulus
                    html += '<div class="legend-item"><span>Значение:</span></div>';
                    
                    const values = [0, 0.2, 0.4, 0.6, 0.8, 1];
                    
                    for (const value of values) {
                        const color = getColorForValue(value);
                        const rgb = `rgb(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)})`;
                        
                        html += `
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: ${rgb};"></div>
                                <span>${value.toFixed(1)}</span>
                            </div>
                        `;
                    }
                }
                
                // Добавляем легенду для линий ветвления, если они показаны
                if (document.getElementById('show-branch-cuts').checked) {
                    html += `
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: rgb(255, 0, 0);"></div>
                            <span>Линия ветвления</span>
                        </div>
                    `;
                }
                
                legendContainer.innerHTML = html;
            }
            
            // Функция для обновления информации о функции
            function updateFunctionInfo() {
                const functionName = document.getElementById('function-select').value;
                const desc = functionDescriptions[functionName];
                
                const titleElement = document.querySelector('#surface-info h3');
                const descriptionElement = document.getElementById('function-description');
                
                titleElement.textContent = desc.title;
                descriptionElement.innerHTML = desc.description;
            }
            
            // Функция для обновления положения камеры
            function updateCamera() {
                const radius = 7;
                
                // Преобразуем сферические координаты в декартовы
                camera.position.x = radius * Math.sin(rotationY * Math.PI) * Math.cos(rotationX * 2 * Math.PI);
                camera.position.y = radius * Math.cos(rotationY * Math.PI);
                camera.position.z = radius * Math.sin(rotationY * Math.PI) * Math.sin(rotationX * 2 * Math.PI);
                
                camera.lookAt(0, 0, 0);
            }
            
            // Функция анимации
            function animate() {
                animationId = requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            
            // Обработчики событий для элементов управления
            document.getElementById('function-select').addEventListener('change', function() {
                createRiemannSurface();
                updateFunctionInfo();
            });
            
            document.getElementById('mode-select').addEventListener('change', function() {
                createRiemannSurface();
            });
            
            document.getElementById('opacity').addEventListener('input', function(e) {
                document.getElementById('opacity-value').textContent = e.target.value;
                createRiemannSurface();
            });
            
            document.getElementById('show-branch-cuts').addEventListener('change', function() {
                createRiemannSurface();
            });
            
            document.getElementById('show-grid').addEventListener('change', function() {
                createRiemannSurface();
            });
            
            // Кнопки вращения
            document.getElementById('rotate-up').addEventListener('click', function() {
                rotationY = Math.max(0.1, rotationY - 0.1);
                updateCamera();
            });
            
            document.getElementById('rotate-down').addEventListener('click', function() {
                rotationY = Math.min(0.9, rotationY + 0.1);
                updateCamera();
            });
            
            document.getElementById('rotate-left').addEventListener('click', function() {
                rotationX = (rotationX - 0.1 + 1) % 1;
                updateCamera();
            });
            
            document.getElementById('rotate-right').addEventListener('click', function() {
                rotationX = (rotationX + 0.1) % 1;
                updateCamera();
            });
            
            document.getElementById('reset-rotation').addEventListener('click', function() {
                rotationX = 0.5;
                rotationY = 0.5;
                updateCamera();
            });
            
            // Инициализация
            init();
        };
    </script>
</body>
</html>
