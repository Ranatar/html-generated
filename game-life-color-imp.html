<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#667eea">
    <title>Цветная Игра "Жизнь"</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Светлая тема (по умолчанию) */
            --bg-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-secondary: rgba(255, 255, 255, 0.95);
            --bg-tertiary: rgba(102, 126, 234, 0.1);
            --bg-overlay: rgba(255, 255, 255, 0.1);
            --bg-hover: rgba(255, 255, 255, 0.2);
            
            --text-primary: #333;
            --text-secondary: #555;
            --text-inverse: #fff;
            --text-muted: #666;
            
            --border-color: #333;
            --border-light: #ddd;
            
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.15);
            --shadow-md: 0 4px 15px rgba(0,0,0,0.2);
            --shadow-lg: 0 8px 25px rgba(0,0,0,0.3);
            
            --button-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --button-danger: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --button-success: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --button-active: linear-gradient(135deg, #00b09b, #96c93d);
            
            --canvas-bg: #000;
        }

        /* Темная тема */
        [data-theme="dark"] {
            --bg-primary: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            --bg-secondary: rgba(30, 30, 46, 0.95);
            --bg-tertiary: rgba(50, 50, 70, 0.3);
            --bg-overlay: rgba(40, 40, 60, 0.4);
            --bg-hover: rgba(60, 60, 80, 0.5);
            
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --text-inverse: #fff;
            --text-muted: #888;
            
            --border-color: #555;
            --border-light: #444;
            
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.5);
            --shadow-md: 0 4px 15px rgba(0,0,0,0.6);
            --shadow-lg: 0 8px 25px rgba(0,0,0,0.7);
            
            --button-primary: linear-gradient(135deg, #4a5d8f 0%, #5a4d7a 100%);
            --button-danger: linear-gradient(135deg, #c06c84 0%, #d94356 100%);
            --button-success: linear-gradient(135deg, #3a7fa0 0%, #00a8cc 100%);
            --button-active: linear-gradient(135deg, #00796b, #689f38);
            
            --canvas-bg: #0a0a0a;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            color: var(--text-inverse);
            overflow-x: hidden;
            transition: background 0.5s ease, color 0.3s ease;
        }

        h1 {
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            text-align: center;
            color: var(--text-inverse);
        }

        .description {
            text-align: center;
            margin-bottom: 20px;
            background: var(--bg-overlay);
            padding: 15px;
            border-radius: 10px;
            max-width: 1400px;
            backdrop-filter: blur(10px);
            color: var(--text-inverse);
        }

        .container {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 15px;
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 1400px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }

        /* Обёртка для canvas */
        .game-canvas-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        canvas {
            border: 3px solid var(--border-color);
            border-radius: 5px;
            cursor: crosshair;
            display: block;
            background: var(--canvas-bg);
            width: 100%;
            height: auto;
            max-width: 100%;
            transition: border-color 0.3s ease;
        }

        /* Обёртка для всех элементов управления */
        .controls-wrapper {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
            align-items: center;
        }

        button {
            padding: 8px 16px;
            font-size: 13px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: var(--button-primary);
            color: var(--text-inverse);
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: var(--shadow-sm);
        }


        button:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        button.active {
            background: var(--button-active);
            box-shadow: 0 0 20px rgba(0,176,155,0.5);
        }

        button.danger {
            background: var(--button-danger);
        }

        button.success {
            background: var(--button-success);
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-tertiary);
            padding: 5px 10px;
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 12px;
            white-space: nowrap;
            flex: 1 1 auto;
            min-width: 180px;
            transition: background 0.3s ease;
        }

        .slider-group label {
            font-weight: 600;
            min-width: 60px;
            font-size: 11px;
            color: var(--text-primary);
        }

        input[type="range"] {
            flex: 1;
            min-width: 80px;
        }

        .stats {
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 5px;
            text-align: center;
            color: #333;
            font-weight: bold;
        }

        .patterns {
            margin-top: 0;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 5px;
            color: var(--text-primary);
            transition: background 0.3s ease, color 0.3s ease;
        }

        .patterns h3 {
            margin-bottom: 10px;
            text-align: center;
            color: var(--text-primary);
        }

        .pattern-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .pattern-buttons button {
            font-size: 12px;
            padding: 8px 15px;
        }

        .legend {
            margin-top: 0;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 13px;
            transition: background 0.3s ease;
        }

        .legend h3 {
            margin-bottom: 8px;
            color: var(--text-primary);
        }
        .legend ul {
            list-style-position: inside;
            line-height: 1.6;
        }

        .state-indicator {
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            background: var(--bg-hover);
            transition: all 0.3s ease;
        }

        .state-indicator.running {
            background: linear-gradient(135deg, #00b09b, #96c93d);
            animation: pulse 2s infinite;
        }

        .state-indicator.paused {
            background: linear-gradient(135deg, #ff9a9e, #fad0c4);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .control-panel {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .panel-section {
            margin-top: 0;
            padding: 15px 10px;
            background: var(--bg-tertiary);
            border-radius: 5px;
            transition: background 0.3s ease;
        }

        .panel-section h4 {
            margin-bottom: 10px;
            color: var(--text-primary);
            font-weight: bold;
            text-align: center;
        }

        .color-mode-buttons,
        .tool-buttons,
        .rule-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .color-mode-buttons button,
        .tool-buttons button,
        .rule-buttons button {
            font-size: 12px;
            padding: 8px 15px;
        }

        .advanced-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            color: #333;
        }

        .advanced-stats div {
            font-size: 14px;
        }

        .save-section {
            margin-top: 0;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 5px;
            color: #333;
        }

        .save-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 10px;
        }

        .save-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            padding: 10px;
        }

        .save-item {
            background: var(--bg-hover);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }

        .save-item button {
            padding: 5px 10px;
            font-size: 11px;
        }

        .save-item:hover {
            transform: translateX(5px);
            box-shadow: var(--shadow-md);
        }

        .save-name {
            flex: 1;
            font-weight: 600;
            color: var(--text-primary);
        }

        .save-time {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .color-pick-btn {
            padding: 6px 12px;
            font-size: 11px;
        }

        .color-pick-btn.active {
            box-shadow: 0 0 10px rgba(0,176,155,0.5);
            border: 2px solid #00b09b;
        }

        /* ========================================
           АДАПТИВНАЯ ВЕРСТКА
           ======================================== */

        /* Десктоп: двухколоночный layout */
        @media (min-width: 900px) {
            .container {
                grid-template-columns: minmax(400px, 2fr) minmax(320px, 1fr);
                grid-template-rows: auto;
            }
            
            .game-canvas-wrapper {
                grid-column: 1;
                grid-row: 1 / -1;
            }
            
            .controls-wrapper {
                grid-column: 2;
                grid-row: 1 / -1;
                max-height: calc(100vh - 150px);
                overflow-y: auto;
                overflow-x: hidden;
                padding-right: 5px;
            }
            
            /* Стилизация скроллбара */
            .controls-wrapper::-webkit-scrollbar {
                width: 8px;
            }
            
            .controls-wrapper::-webkit-scrollbar-track {
                background: rgba(102, 126, 234, 0.1);
                border-radius: 4px;
            }
            
            .controls-wrapper::-webkit-scrollbar-thumb {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border-radius: 4px;
            }
        }

        /* Планшет: одноколоночный layout с оптимизацией */
        @media (max-width: 899px) and (min-width: 601px) {
            .description {
                font-size: 14px;
            }
        }

        /* Планшет/мобильные: вертикальный layout для панелей */
        @media (max-width: 768px) {
            .panel-section > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
            }
        }

        /* Мобильные устройства */
        @media (max-width: 600px) {
            body {
                padding: 5px;
            }
            
            h1 {
                font-size: 20px;
            }
            
            .description {
                font-size: 12px;
                padding: 10px;
                margin-bottom: 10px;
            }
            
            .container {
                padding: 10px;
                gap: 10px;
            }
            
            .controls-wrapper {
                gap: 10px;
            }
            
            .controls {
                gap: 4px;
            }
            
            .controls button {
                font-size: 11px;
                padding: 6px 10px;
            }
            
            button {
                font-size: 11px;
                padding: 6px 12px;
            }
            
            .slider-group {
                font-size: 11px;
                padding: 4px 8px;
                min-width: 150px;
            }
            
            .slider-group label {
                min-width: 50px;
                font-size: 10px;
            }
            
            .stats {
                font-size: 11px;
                padding: 8px;
            }
            
            .patterns h3 {
                font-size: 14px;
            }
            
            .pattern-buttons button {
                font-size: 10px;
                padding: 6px 10px;
            }
            
            .panel-section {
                padding: 10px 8px;
            }
            
            .panel-section h4 {
                font-size: 13px;
            }
            
            .legend {
                font-size: 11px;
            }
            
            .legend h3 {
                font-size: 14px;
            }
            
            .save-section h4 {
                font-size: 13px;
            }
        }

        /* Новые стили для инструментов */
        .tool-buttons button {
            font-size: 12px;
            padding: 8px 12px;
        }

        .mirror-options {
            background: rgba(255,255,255,0.2);
            padding: 10px;
            border-radius: 5px;
        }

        .mirror-options button {
            font-size: 11px;
            padding: 6px 10px;
        }

        .mirror-options button.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        canvas.stamp-preview {
            border: 2px dashed #667eea !important;
            opacity: 0.7;
        }

        .stamp-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.95);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Стили для категорий паттернов */
        .pattern-categories {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .category-tab {
            padding: 8px 15px;
            font-size: 12px;
            background: var(--bg-hover);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .category-tab:hover {
            background: var(--bg-overlay);
        }

        .category-tab.active {
            background: var(--button-primary);
            border-color: var(--text-inverse);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .pattern-category {
            animation: fadeIn 0.3s ease;
        }

        .pattern-category h4 {
            margin: 10px 0 8px 0;
            font-size: 13px;
            color: var(--text-secondary);
            text-align: left;
            padding-left: 5px;
            border-left: 3px solid var(--button-primary);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .pattern-info {
            margin-top: 15px;
            padding: 10px;
            background: var(--bg-hover);
            border-radius: 5px;
            transition: background 0.3s ease;
        }

        .pattern-info h4 {
            margin: 0 0 5px 0;
            color: var(--text-primary);
        }

        .pattern-info p {
            margin: 0;
            font-size: 11px;
            color: var(--text-secondary);
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 100px;
            }
        }

        /* Контейнер статистики */
        .stats-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            transition: background 0.3s ease;
        }

        /* Основная и расширенная статистика */
        .stats-main,
        .stats-extended {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .stat-item {
            background: var(--bg-hover);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }

        .stat-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-align: center;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: var(--text-primary);
        }

        /* Кнопка переключения графика */
        .toggle-chart-btn {
            width: 100%;
            margin-top: 5px;
        }

        /* Контейнер графика */
        .chart-container {
            background: var(--bg-hover);
            padding: 15px;
            border-radius: 10px;
            box-shadow: var(--shadow-md);
            animation: slideDown 0.3s ease;
            transition: background 0.3s ease;
        }

        #populationChart {
            width: 100% !important;
            height: 200px !important;
            max-height: 200px;
        }

        .chart-controls {
            margin-top: 10px;
            display: flex;
            justify-content: center;
        }

        /* Индикаторы состояния */
        .status-indicators {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            animation: fadeInBounce 0.5s ease;
        }

        .indicator-icon {
            font-size: 18px;
        }

        .indicator-text {
            flex: 1;
            color: #333;
        }

        #oscillatorIndicator {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
        }

        #stableIndicator {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        }

        #extinctionIndicator {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            animation: pulse 1s infinite;
        }

        #explosionIndicator {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            animation: pulse 1s infinite;
        }

        @keyframes fadeInBounce {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(-10px);
            }
            60% {
                transform: scale(1.05);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        /* Адаптация для маленьких экранов */
        @media (max-width: 768px) {
            .stats-main,
            .stats-extended {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .stat-value {
                font-size: 16px;
            }
            
            #populationChart {
                height: 150px !important;
            }
        }

        /* ========== МИНИ-КАРТА ========== */
        .minimap-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: var(--bg-secondary);
            border: 3px solid var(--button-primary);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .minimap-container.hidden {
            transform: translateX(250px);
        }

        #minimap {
            width: 100%;
            height: 100%;
            display: block;
        }

        .minimap-viewport {
            position: absolute;
            border: 2px solid #00f2fe;
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.5);
        }

        .minimap-toggle {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 30px;
            height: 30px;
            padding: 0;
            font-size: 16px;
            border-radius: 5px;
            background: rgba(102, 126, 234, 0.9);
            border: none;
            cursor: pointer;
            z-index: 10;
        }

        .minimap-toggle:hover {
            background: rgba(102, 126, 234, 1);
            transform: scale(1.1);
        }

        /* ========== ГОРЯЧИЕ КЛАВИШИ ========== */
        .hotkeys-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 10px;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            max-width: 300px;
            transition: background 0.3s ease;
        }

        .hotkeys-toggle {
            width: 100%;
            padding: 10px 15px;
            font-size: 13px;
            margin-bottom: 0;
        }

        .hotkeys-list {
            margin-top: 10px;
            max-height: 400px;
            overflow-y: auto;
            animation: slideDown 0.3s ease;
        }
      
        .hotkeys-list h4 {
            margin: 10px 0 5px 0;
            font-size: 12px;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--button-primary);
            padding-bottom: 3px;
        }

        .hotkeys-list h4:first-child {
            margin-top: 0;
        }

        .hotkey-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            font-size: 11px;
            color: var(--text-primary);
        }

        kbd {
    background: var(--button-primary);
    color: var(--text-inverse);
    padding: 3px 8px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 10px;
    font-weight: bold;
    box-shadow: var(--shadow-sm);
    min-width: 30px;
    text-align: center;
    display: inline-block;
}

        /* ========== ИНДИКАТОРЫ ========== */
        .zoom-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
       .hotkeys-panel {     box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .zoom-indicator.hidden {
            opacity: 0;
            transform: translateY(-20px);
        }

        .coords-indicator {
            position: fixed;
            top: 60px;
            right: 20px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
        }

        /* ========== СЕТКА ========== */
        .grid-overlay {
            pointer-events: none;
        }

        /* ========== КУРСОРЫ ========== */
        canvas.pan-mode {
            cursor: grab !important;
        }

        canvas.pan-mode:active {
            cursor: grabbing !important;
        }

        canvas.zoom-in {
            cursor: zoom-in !important;
        }

        canvas.zoom-out {
            cursor: zoom-out !important;
        }

        /* ========== АДАПТАЦИЯ ========== */
        @media (max-width: 768px) {
            .minimap-container {
                width: 150px;
                height: 112px;
                bottom: 10px;
                right: 10px;
            }
            
            .hotkeys-panel {
                bottom: 10px;
                left: 10px;
                max-width: 250px;
            }
            
            .zoom-indicator,
            .coords-indicator {
                position: fixed;
                right: 20px;
                background: var(--button-primary);
                color: var(--text-inverse);
                padding: 8px 15px;
                border-radius: 8px;
                font-size: 13px;
                font-weight: bold;
                box-shadow: var(--shadow-md);
                z-index: 1000;
                transition: all 0.3s ease;
            }

            .zoom-indicator {
                top: 20px;
            }

            .coords-indicator {
                top: 60px;
            }
        }

        /* Скроллбар для списка горячих клавиш */
        .hotkeys-list::-webkit-scrollbar {
            width: 6px;
        }

        .hotkeys-list::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.1);
            border-radius: 3px;
        }

        .hotkeys-list::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 3px;
        }

        .hotkeys-list::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }

        /* Стили для режимов визуализации */
        .visualization-settings {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .color-mode-buttons button {
            font-size: 11px;
            padding: 7px 12px;
        }

        /* Эффект свечения для canvas */
        canvas.glow {
            filter: blur(0px) brightness(1);
            transition: filter 0.3s ease;
        }

        canvas.glow-active {
            filter: blur(2px) brightness(1.2);
        }

        /* Particle effect overlay */
        .particle-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 5;
        }

        /* Matrix rain effect */
        @keyframes matrix-rain {
            0% {
                transform: translateY(-100%);
                opacity: 1;
            }
            100% {
                transform: translateY(100%);
                opacity: 0;
            }
        }

        .matrix-char {
            position: absolute;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 0 0 10px #0f0;
            animation: matrix-rain 2s linear infinite;
        }

        .theme-switcher {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }

        .theme-toggle-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 25px;
            background: var(--button-primary);
            color: var(--text-inverse);
            border: 2px solid var(--bg-overlay);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
        }

        .theme-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .theme-icon {
            font-size: 18px;
            transition: transform 0.3s ease;
        }

        .theme-toggle-btn:hover .theme-icon {
            transform: rotate(20deg) scale(1.1);
        }

        [data-theme="dark"] ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
        }

        [data-theme="dark"] ::-webkit-scrollbar-thumb {
            background: #4a5d8f;
        }

        [data-theme="dark"] ::-webkit-scrollbar-thumb:hover {
            background: #5a6d9f;
        }

        @keyframes themeTransition {
            0% {
                opacity: 1;
            }
            50% {
                opacity: 0.8;
            }
            100% {
                opacity: 1;
            }
        }

        .theme-transitioning {
            animation: themeTransition 0.3s ease;

        /* Улучшенная контрастность для темной темы */
        [data-theme="dark"] .stat-value {
            color: #fff;
        }

        [data-theme="dark"] .stat-label {
            color: #ccc;
        }

        [data-theme="dark"] .indicator-text {
            color: #fff;
        }

        [data-theme="dark"] input[type="range"] {
            accent-color: #4a5d8f;
        }

        /* Подсветка для активных элементов */
        [data-theme="dark"] button:hover {
            filter: brightness(1.2);
        }

        [data-theme="dark"] .pattern-buttons button:hover {
            filter: brightness(1.3);
        }

        /* Canvas border для темной темы */
        [data-theme="dark"] canvas {
            border-color: #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        /* Улучшение видимости сетки в темной теме */
        [data-theme="dark"] .grid-overlay {
            opacity: 0.3;
        }

        /* Плавный переход всех цветов */
        * {
            transition-property: background-color, border-color, color, box-shadow;
            transition-duration: 0.3s;
            transition-timing-function: ease;
        }

        /* Исключения для элементов, которые не должны анимироваться */
        canvas,
        .minimap-viewport,
        .particle-overlay,
        input[type="range"] {
            transition: none !important;
        }

        /* Специальный эффект при переключении темы */
        .theme-transitioning::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.1) 100%);
            pointer-events: none;
            z-index: 9999;
            animation: themeWave 0.6s ease-out;
        }

        @keyframes themeWave {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        /* Стили для экспорта/импорта */
        .export-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-bottom: 10px;
        }

        .export-buttons button {
            flex: 1;
            min-width: 100px;
            font-size: 12px;
        }

        .import-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid var(--border-light);
        }

        .file-input-label {
            display: block;
            padding: 10px 15px;
            background: var(--button-success);
            color: var(--text-inverse);
            text-align: center;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
            transition: all 0.2s;
            box-shadow: var(--shadow-sm);
        }

        .file-input-label:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .file-input-label:active {
            transform: translateY(0);
        }

        /* GIF Recording indicator */
        #gifRecordingStatus {
            animation: slideDown 0.3s ease;
        }

        @keyframes recordingPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        #gifRecordingStatus span:first-child {
            animation: recordingPulse 1.5s infinite;
        }

        /* Анимации для уведомлений */
        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Стили для режимов симуляции */
        .simulation-mode-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .simulation-mode-buttons button {
            flex: 1;
            min-width: 110px;
            font-size: 11px;
            padding: 8px 10px;
        }

        /* Цвета команд для режима соревнования */
        .team-0 { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%); }
        .team-1 { background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%); }
        .team-2 { background: linear-gradient(135deg, #ffd93d 0%, #f6c23e 100%); }
        .team-3 { background: linear-gradient(135deg, #a8e6cf 0%, #88d8b0 100%); }
        .team-4 { background: linear-gradient(135deg, #c7a4ff 0%, #b794f6 100%); }
        .team-5 { background: linear-gradient(135deg, #ff9ff3 0%, #feca57 100%); }

        /* Индикатор победителя */
        .winner-banner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-secondary);
            padding: 30px 50px;
            border-radius: 15px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
            z-index: 10000;
            text-align: center;
            animation: winnerAppear 0.5s ease;
        }

        .winner-banner h2 {
            margin: 0 0 10px 0;
            font-size: 32px;
            color: var(--text-primary);
        }

        .winner-banner p {
            margin: 0;
            font-size: 18px;
            color: var(--text-secondary);
        }

        @keyframes winnerAppear {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            60% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        /* Подсветка для квантового режима */
        @keyframes quantumGlow {
            0%, 100% {
                box-shadow: 0 0 5px rgba(102, 126, 234, 0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
            }
        }

        .quantum-cell {
            animation: quantumGlow 2s infinite;
        }

        /* ========== БАЗОВАЯ МОБИЛЬНАЯ АДАПТАЦИЯ ========== */

        /* Скрываем мобильные элементы на десктопе */
        .mobile-control-panel,
        .mobile-menu,
        .mobile-menu-overlay {
            display: none;
        }

        /* ========== МОБИЛЬНЫЕ СТИЛИ (≤768px) ========== */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            h1 {
                font-size: 20px;
                margin-bottom: 5px;
            }
            
            .description {
                font-size: 12px;
                padding: 10px;
                margin-bottom: 10px;
            }
            
            .container {
                padding: 10px;
                gap: 10px;
            }
            
            /* Мобильная панель управления */
            .mobile-control-panel {
                display: block;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: var(--bg-secondary);
                padding: 10px;
                box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
                z-index: 9999;
                backdrop-filter: blur(10px);
            }
            
            .mobile-buttons {
                display: flex;
                gap: 8px;
                justify-content: space-around;
            }
            
            .mobile-btn {
                flex: 1;
                padding: 12px 8px;
                font-size: 16px;
                border-radius: 8px;
                min-width: 50px;
                touch-action: manipulation;
            }
            
            /* Мобильное меню */
            .mobile-menu {
                display: none;
                position: fixed;
                top: 0;
                right: 0;
                width: 90%;
                max-width: 400px;
                height: 100vh;
                background: var(--bg-secondary);
                z-index: 10001;
                overflow-y: auto;
                transform: translateX(100%);
                transition: transform 0.3s ease;
                box-shadow: -5px 0 20px rgba(0,0,0,0.3);
            }
            
            .mobile-menu.active {
                display: block;
                transform: translateX(0);
            }
            
            .mobile-menu-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px;
                border-bottom: 2px solid var(--border-light);
                background: var(--bg-tertiary);
            }
            
            .mobile-menu-header h3 {
                margin: 0;
                color: var(--text-primary);
                font-size: 18px;
            }
            
            .close-btn {
                padding: 8px 12px;
                font-size: 16px;
                background: var(--button-danger);
            }
            
            .mobile-menu-content {
                padding: 15px;
            }
            
            .mobile-menu-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
                backdrop-filter: blur(3px);
            }
            
            .mobile-menu-overlay.active {
                display: block;
            }
            
            /* Скрываем обычные элементы управления */
            .controls-wrapper {
                display: none;
            }
            
            /* Адаптация canvas */
            canvas {
                touch-action: none;
                max-height: calc(100vh - 200px);
            }
            
            /* Адаптация кнопок */
            button {
                padding: 10px 14px;
                font-size: 14px;
                min-height: 44px; /* Минимум для touch */
            }
            
            .pattern-buttons button,
            .tool-buttons button,
            .color-mode-buttons button {
                padding: 10px 12px;
                font-size: 13px;
            }
            
            /* Увеличенные слайдеры */
            input[type="range"] {
                height: 36px;
                cursor: pointer;
            }
            
            /* Скрываем некоторые элементы на мобильных */
            .hotkeys-panel {
                display: none !important;
            }
            
            .minimap-container {
                width: 120px;
                height: 90px;
                bottom: 80px;
                right: 10px;
            }
            
            .zoom-indicator,
            .coords-indicator {
                font-size: 11px;
                padding: 6px 10px;
                right: 10px;
            }
            
            /* Адаптация секций */
            .panel-section {
                padding: 12px 8px;
            }
            
            .panel-section h4 {
                font-size: 14px;
            }
            
            /* Адаптация статистики */
            .stats-main,
            .stats-extended {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .stat-value {
                font-size: 16px;
            }
            
            /* Адаптация графика */
            #populationChart {
                height: 150px !important;
            }
            
            /* Индикатор жестов */
            .gesture-indicator {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                padding: 20px 30px;
                border-radius: 15px;
                font-size: 18px;
                font-weight: bold;
                color: var(--text-primary);
                box-shadow: var(--shadow-lg);
                z-index: 9998;
                pointer-events: none;
                animation: fadeIn 0.2s ease;
            }
            
            /* Адаптация theme switcher */
            .theme-switcher {
                margin-bottom: 5px;
            }
            
            .theme-toggle-btn {
                padding: 8px 15px;
                font-size: 13px;
            }
        }

        /* ========== ОЧЕНЬ МАЛЕНЬКИЕ ЭКРАНЫ (≤480px) ========== */
        @media (max-width: 480px) {
            h1 {
                font-size: 18px;
            }
            
            .description {
                font-size: 11px;
                padding: 8px;
            }
            
            .mobile-btn {
                padding: 10px 6px;
                font-size: 14px;
                min-width: 45px;
            }
            
            .mobile-menu {
                width: 95%;
            }
            
            .stats-main,
            .stats-extended {
                grid-template-columns: 1fr;
            }
            
            .minimap-container {
                width: 100px;
                height: 75px;
            }
        }

        /* ========== LANDSCAPE РЕЖИМ НА МОБИЛЬНЫХ ========== */
        @media (max-width: 768px) and (orientation: landscape) {
            canvas {
                max-height: calc(100vh - 120px);
            }
            
            .mobile-control-panel {
                padding: 5px 10px;
            }
            
            .mobile-btn {
                padding: 8px 6px;
                font-size: 14px;
            }
            
            h1 {
                font-size: 16px;
                margin-bottom: 3px;
            }
            
            .description {
                display: none;
            }
        }

        /* ========== ПОЛНОЭКРАННЫЙ РЕЖИМ ========== */
        .fullscreen-mode {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9999;
            background: #000;
        }

        .fullscreen-mode canvas {
            width: 100vw !important;
            height: calc(100vh - 70px) !important;
            max-width: 100vw;
            max-height: calc(100vh - 70px);
            border-radius: 0;
        }

        .fullscreen-mode .mobile-control-panel {
            position: fixed;
            bottom: 0;
        }

        /* ========== АНИМАЦИИ ДЛЯ TOUCH ========== */
        @keyframes touchRipple {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        .touch-ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255,255,255,0.5);
            pointer-events: none;
            animation: touchRipple 0.6s ease-out;
        }

        /* Улучшенный feedback для touch */
        @media (hover: none) {
            button:active {
                transform: scale(0.95);
                transition: transform 0.1s;
            }
        }

        /* Стили для звуковых настроек */
        .sound-options {
            background: var(--bg-hover);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .sound-options input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--button-primary);
        }

        .theme-btn {
            flex: 1;
            min-width: 80px;
            font-size: 11px;
            padding: 6px 10px;
        }

        .theme-btn.active {
            background: var(--button-active);
        }

        /* Индикатор звука */
        .sound-indicator {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 24px;
            box-shadow: var(--shadow-lg);
            z-index: 9997;
            pointer-events: none;
            animation: soundPulse 0.3s ease;
            opacity: 0;
        }

        .sound-indicator.show {
            opacity: 1;
        }

        @keyframes soundPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.2); }
        }

        /* Визуализатор звука */
        .audio-visualizer {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 40px;
            display: none;
            gap: 3px;
            align-items: flex-end;
            z-index: 9996;
        }

        .audio-visualizer.active {
            display: flex;
        }

        .audio-bar {
            flex: 1;
            background: linear-gradient(to top, var(--button-primary), var(--button-success));
            border-radius: 2px;
            transition: height 0.1s ease;
            min-height: 5px;
        }

        /* Стили для правил */
        .custom-rule-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid var(--border-light);
        }

        .custom-rule-section input {
            font-family: monospace;
            font-size: 12px;
        }

        .custom-rule-section input:focus {
            outline: none;
            border-color: var(--button-primary);
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }

        /* Анимация для правил Brian's Brain и Wireworld */
        @keyframes cellPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .dying-cell {
            animation: cellPulse 0.5s ease-in-out;
        }

        /* Стили для муравья Лэнгтона */
        .ant-cell {
            position: relative;
        }

        .ant-cell::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.8em;
        }
    </style>
</head>
<body>
    <h1> Цветная Игра "Жизнь" </h1>
    
    <div class="description">
        <p><strong>Расширенные правила:</strong> Каждая живая ячейка имеет цветовое состояние (оттенок). При рождении новая ячейка наследует смешанный цвет от своих "родителей". Цвет эволюционирует в зависимости от возраста ячейки и цветов соседей, создавая красивые цветовые паттерны!</p>
    </div>

    <div class="container">
        <!-- ЛЕВАЯ КОЛОНКА: Canvas и статистика -->
        <div class="game-canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div class="stats-container">
                <!-- Основная статистика -->
                <div class="stats-main">
                    <div class="stat-item">
                        <span class="stat-label"> Популяция:</span>
                        <span class="stat-value" id="population">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label"> Поколение:</span>
                        <span class="stat-value" id="generation">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">⚡ FPS:</span>
                        <span class="stat-value" id="fps">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label"> Плотность:</span>
                        <span class="stat-value" id="density">0%</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Тип поля:</span>
                        <span class="stat-value" id="fieldTypeIndicator">🔄 Торроид</span>
                    </div>
                </div>
                
                <!-- Расширенная статистика -->
                <div class="stats-extended">
                    <div class="stat-item">
                        <span class="stat-label"> Умерло:</span>
                        <span class="stat-value" id="deaths">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label"> Родилось:</span>
                        <span class="stat-value" id="births">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label"> Изменение:</span>
                        <span class="stat-value" id="change">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label"> Стабильность:</span>
                        <span class="stat-value" id="stability">Нет данных</span>
                    </div>
                    <div class="stat-item" id="stabilityIndicator" style="display: none;">
                        <span class="stat-label">Стабильность:</span>
                        <span class="stat-value" id="stabilityValue">0/30</span>
                    </div>
                </div>
                
                <!-- Кнопка для показа/скрытия графика -->
                <button onclick="toggleChart()" class="toggle-chart-btn" id="toggleChartBtn">
                     Показать график
                </button>
                
                <!-- График популяции -->
                <div class="chart-container" id="chartContainer" style="display:none;">
                    <canvas id="populationChart"></canvas>
                    <div class="chart-controls">
                        <button onclick="clearChartHistory()" class="danger" style="font-size:11px; padding:5px 10px;">
                            ️ Очистить историю
                        </button>
                    </div>
                </div>
                
                <!-- Индикаторы состояния -->
                <div class="status-indicators">
                    <div class="indicator" id="oscillatorIndicator" style="display:none;">
                        <span class="indicator-icon"></span>
                        <span class="indicator-text">Осциллятор (период: <span id="oscillatorPeriod">?</span>)</span>
                    </div>
                    <div class="indicator" id="stableIndicator" style="display:none;">
                        <span class="indicator-icon"></span>
                        <span class="indicator-text">Стабильное состояние</span>
                    </div>
                    <div class="indicator" id="extinctionIndicator" style="display:none;">
                        <span class="indicator-icon"></span>
                        <span class="indicator-text">Угроза вымирания!</span>
                    </div>
                    <div class="indicator" id="explosionIndicator" style="display:none;">
                        <span class="indicator-icon"></span>
                        <span class="indicator-text">Взрывной рост!</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Мобильная панель управления -->
        <div class="mobile-control-panel" id="mobileControls">
            <div class="mobile-buttons">
                <button onclick="toggleMobileMenu()" id="mobileMenuBtn" class="mobile-btn">
                    ☰ Меню
                </button>
                <button onclick="document.getElementById('startBtn').click()" class="mobile-btn success">
                    ▶️
                </button>
                <button onclick="document.getElementById('stopBtn').click()" class="mobile-btn danger">
                    ⏸️
                </button>
                <button onclick="document.getElementById('stepBtn').click()" class="mobile-btn">
                    ⏭️
                </button>
                <button onclick="toggleFullscreen()" class="mobile-btn" id="fullscreenBtn">
                    ⛶
                </button>
            </div>
        </div>

        <div class="audio-visualizer" id="audioVisualizer">
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
        </div>

        <!-- Мобильное меню -->
        <div class="mobile-menu" id="mobileMenu">
            <div class="mobile-menu-header">
                <h3>⚙️ Настройки</h3>
                <button onclick="toggleMobileMenu()" class="close-btn">✖️</button>
            </div>
            <div class="mobile-menu-content" id="mobileMenuContent">
                <!-- Контент будет перемещён сюда для мобильных -->
            </div>
        </div>

        <!-- Оверлей для меню -->
        <div class="mobile-menu-overlay" id="mobileMenuOverlay" onclick="toggleMobileMenu()"></div>

        <!-- Индикатор жестов -->
        <div class="gesture-indicator" id="gestureIndicator" style="display:none;">
            <span id="gestureText"></span>
        </div>
        
        <!-- Мини-карта -->
        <div class="minimap-container" id="minimapContainer">
            <canvas id="minimap"></canvas>
            <div class="minimap-viewport" id="minimapViewport"></div>
            <button class="minimap-toggle" onclick="toggleMinimap()" id="minimapToggle">
                ️
            </button>
        </div>

        <!-- Панель подсказок горячих клавиш -->
        <div class="hotkeys-panel" id="hotkeysPanel">
            <button class="hotkeys-toggle" onclick="toggleHotkeys()">⌨️ Горячие клавиши</button>
            <div class="hotkeys-list" id="hotkeysList" style="display:none;">
                <h4>⌨️ Управление</h4>
                <div class="hotkey-item"><kbd>Space</kbd> Старт/Стоп</div>
                <div class="hotkey-item"><kbd>S</kbd> Один шаг</div>
                <div class="hotkey-item"><kbd>C</kbd> Очистить поле</div>
                <div class="hotkey-item"><kbd>R</kbd> Случайное заполнение</div>
                
                <h4> Инструменты</h4>
                <div class="hotkey-item"><kbd>B</kbd> Кисть</div>
                <div class="hotkey-item"><kbd>E</kbd> Ластик</div>
                <div class="hotkey-item"><kbd>L</kbd> Линия</div>
                <div class="hotkey-item"><kbd>F</kbd> Заливка</div>
                <div class="hotkey-item"><kbd>T</kbd> Штамп</div>
                <div class="hotkey-item"><kbd>M</kbd> Зеркало</div>
                
                <h4> Навигация</h4>
                <div class="hotkey-item"><kbd>+</kbd> / <kbd>-</kbd> Zoom</div>
                <div class="hotkey-item"><kbd>0</kbd> Сбросить zoom</div>
                <div class="hotkey-item"><kbd>Пробел + Мышь</kbd> Перемещение</div>
                <div class="hotkey-item"><kbd>G</kbd> Показать сетку</div>
                <div class="hotkey-item"><kbd>N</kbd> Мини-карта</div>
                
                <h4> Действия</h4>
                <div class="hotkey-item"><kbd>Ctrl+S</kbd> Сохранить</div>
                <div class="hotkey-item"><kbd>Ctrl+Z</kbd> Отменить</div>
                <div class="hotkey-item"><kbd>Ctrl+Y</kbd> Повторить</div>
                
                <h4> Паттерны (1-9)</h4>
                <div class="hotkey-item"><kbd>1</kbd> Glider</div>
                <div class="hotkey-item"><kbd>2</kbd> Blinker</div>
                <div class="hotkey-item"><kbd>3</kbd> Toad</div>
                <div class="hotkey-item"><kbd>4</kbd> Beacon</div>
                <div class="hotkey-item"><kbd>5</kbd> Pulsar</div>

                <h4> Визуализация</h4>
                <div class="hotkey-item"><kbd>V</kbd> Смена режима</div>
                <div class="hotkey-item"><kbd>P</kbd> Частицы вкл/выкл</div>

                <h4> Интерфейс</h4>
                <div class="hotkey-item"><kbd>U</kbd> Тема (светлая/темная)</div>

                <h4> Экспорт</h4>
                <div class="hotkey-item"><kbd>Ctrl+E</kbd> Экспорт PNG</div>
                <div class="hotkey-item"><kbd>Ctrl+J</kbd> Экспорт JSON</div>

                <h4> Звук</h4>
                <div class="hotkey-item"><kbd>A</kbd> Звук вкл/выкл</div>
                <div class="hotkey-item"><kbd>Q</kbd> Музыка вкл/выкл</div>
            </div>
        </div>

        <!-- Индикатор Zoom -->
        <div class="zoom-indicator" id="zoomIndicator">
             <span id="zoomValue">100%</span>
        </div>

        <!-- Индикатор координат -->
        <div class="coords-indicator" id="coordsIndicator" style="display:none;">
             X: <span id="coordX">0</span>, Y: <span id="coordY">0</span>
        </div>

        <!-- ПРАВАЯ КОЛОНКА: Все элементы управления -->
        <div class="controls-wrapper">
            <!-- Переключатель темы -->
            <div class="theme-switcher">
                <button onclick="toggleTheme()" id="themeToggle" class="theme-toggle-btn" title="Переключить тему">
                    <span class="theme-icon" id="themeIcon"></span>
                    <span class="theme-text" id="themeText">Темная тема</span>
                </button>
            </div>
            <!-- Основные кнопки управления -->
            <div class="controls">
                <button id="startBtn" class="success">▶ Старт</button>
                <button id="stopBtn">⏸ Пауза</button>
                <button id="stepBtn">⏭ Шаг</button>
                <button id="clearBtn" class="danger"> Очистить</button>
                <button id="randomBtn"> Случайно</button>
                <button id="toggleTrailsBtn" onclick="toggleTrails()"> Шлейф</button>
                <button onclick="resetZoom()">🔄 Сброс вида</button>
                
                <div class="slider-group">
                    <label for="speedSlider">Скорость:</label>
                    <input type="range" id="speedSlider" min="1" max="60" value="10">
                    <span id="speedValue">10</span> FPS
                </div>
                
                <div class="slider-group">
                    <label for="cellSizeSlider">Размер:</label>
                    <input type="range" id="cellSizeSlider" min="4" max="20" value="8">
                    <span id="cellSizeValue">8</span> px
                </div>

                <div class="slider-group">
                    <label for="mutationRateSlider">Мутация:</label>
                    <input type="range" id="mutationRateSlider" min="0" max="100" value="10">
                    <span id="mutationRateValue">10%</span>
                </div>

                <div class="slider-group">
                    <label for="brushSizeSlider">Кисть:</label>
                    <input type="range" id="brushSizeSlider" min="1" max="5" value="1">
                    <span id="brushSizeValue">1</span>
                </div>

                <span id="stateIndicator" class="state-indicator paused">⏸ Пауза</span>
            </div>

            <!-- Готовые паттерны -->
            <div class="patterns">
                <h3> Библиотека Паттернов</h3>
                
                <!-- Категории паттернов -->
                <div class="pattern-categories">
                    <button class="category-tab active" onclick="showPatternCategory('oscillators')"> Осцилляторы</button>
                    <button class="category-tab" onclick="showPatternCategory('spaceships')"> Корабли</button>
                    <button class="category-tab" onclick="showPatternCategory('stable')"> Стабильные</button>
                    <button class="category-tab" onclick="showPatternCategory('guns')"> Генераторы</button>
                    <button class="category-tab" onclick="showPatternCategory('methuselahs')">⏳ Мезурацы</button>
                    <button class="category-tab" onclick="showPatternCategory('special')">✨ Специальные</button>
                </div>
                
                <!-- Осцилляторы -->
                <div class="pattern-category" id="category-oscillators">
                    <h4>Период 2</h4>
                    <div class="pattern-buttons">
                        <button onclick="placePattern('blinker')">Blinker</button>
                        <button onclick="placePattern('toad')">Toad</button>
                        <button onclick="placePattern('beacon')">Beacon</button>
                        <button onclick="placePattern('clock')">Clock</button>
                    </div>
                    <h4>Период 3</h4>
                    <div class="pattern-buttons">
                        <button onclick="placePattern('pulsar')">Pulsar</button>
                    </div>
                    <h4>Период 15</h4>
                    <div class="pattern-buttons">
                        <button onclick="placePattern('pentadecathlon')">Pentadecathlon</button>
                    </div>
                </div>
                
                <!-- Космические корабли -->
                <div class="pattern-category" id="category-spaceships" style="display:none;">
                    <div class="pattern-buttons">
                        <button onclick="placePattern('glider')">⬊ Glider</button>
                        <button onclick="placePattern('lwss')"> LWSS</button>
                        <button onclick="placePattern('mwss')"> MWSS</button>
                        <button onclick="placePattern('hwss')"> HWSS</button>
                        <button onclick="placePattern('loafer')"> Loafer</button>
                    </div>
                </div>
                
                <!-- Стабильные структуры -->
                <div class="pattern-category" id="category-stable" style="display:none;">
                    <div class="pattern-buttons">
                        <button onclick="placePattern('block')">Block</button>
                        <button onclick="placePattern('beehive')">Beehive</button>
                        <button onclick="placePattern('loaf')">Loaf</button>
                        <button onclick="placePattern('boat')">Boat</button>
                        <button onclick="placePattern('tub')">Tub</button>
                        <button onclick="placePattern('pond')">Pond</button>
                    </div>
                </div>
                
                <!-- Генераторы -->
                <div class="pattern-category" id="category-guns" style="display:none;">
                    <div class="pattern-buttons">
                        <button onclick="placePattern('gliderGun')">Gosper Glider Gun</button>
                        <button onclick="placePattern('simkinGliderGun')">Simkin Glider Gun</button>
                    </div>
                </div>
                
                <!-- Мезурацы (долгоживущие) -->
                <div class="pattern-category" id="category-methuselahs" style="display:none;">
                    <div class="pattern-buttons">
                        <button onclick="placePattern('rpentomino')">R-pentomino</button>
                        <button onclick="placePattern('acorn')">Acorn</button>
                        <button onclick="placePattern('diehard')">Diehard</button>
                        <button onclick="placePattern('rabbits')">Rabbits</button>
                    </div>
                </div>
                
                <!-- Специальные -->
                <div class="pattern-category" id="category-special" style="display:none;">
                    <div class="pattern-buttons">
                        <button onclick="placePattern('rainbow')"> Радуга</button>
                        <button onclick="placePattern('explosion')"> Взрыв</button>
                        <button onclick="placePattern('spiral')"> Спираль</button>
                        <button onclick="placePattern('galaxy')"> Галактика</button>
                    </div>
                </div>
                <!-- Информация о выбранном паттерне -->
                <div class="pattern-info" id="patternInfo" style="display:none; margin-top:15px; padding:10px; background:rgba(255,255,255,0.2); border-radius:5px;">
                    <h4 style="margin:0 0 5px 0; color:#333;"> <span id="patternName"></span></h4>
                    <p style="margin:0; font-size:11px; color:#555;" id="patternDescription"></p>
                </div>
            </div>
            
            <!-- Инструменты и цветовые режимы -->
            <div class="panel-section">
                <h4> Инструменты и цветовые режимы</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <div style="text-align: center; margin-bottom: 8px; font-size: 11px; color: #666; font-weight: 600;">
                            Инструменты:
                        </div>
                        <div class="tool-buttons">
                            <button id="brushBtn" onclick="setTool('brush')" class="active">️ Кисть</button>
                            <button id="eraserBtn" onclick="setTool('eraser')">粒 Ластик</button>
                            <button id="lineBtn" onclick="setTool('line')"> Линия</button>
                            <button id="fillBtn" onclick="setTool('fill')">画 Заливка</button>
                            <button id="rectBtn" onclick="setTool('rectangle')">▭ Прямоугольник</button>
                            <button id="circleBtn" onclick="setTool('circle')">⭕ Круг</button>
                            <button id="stampBtn" onclick="setTool('stamp')"> Штамп</button>
                            <button id="mirrorBtn" onclick="toggleMirrorMode()">爵 Зеркало: ВЫКЛ</button>
                        </div>
                        <div class="slider-group">
                            <label for="brushSizeSlider">Размер: <span id="brushSizeValue">3</span></label>
                            <input type="range" id="brushSizeSlider" min="1" max="20" value="3">
                        </div>
                        <div style="margin-top: 8px; display: flex; gap: 6px; flex-direction: column;">
                            <!-- Выбор основного цвета -->
                            <div style="display: flex; gap: 6px; justify-content: center; align-items: center; flex-wrap: wrap;">
                                <span style="font-size: 11px; color: #666; font-weight: 600;">Цвет:</span>
                                <button onclick="setDrawColor(null, this)" class="color-pick-btn active" 
                                        style="background: linear-gradient(to right, red, yellow, green, cyan, blue, magenta); font-size: 10px; padding: 4px 8px;">
                                     Случайный
                                </button>
                                <input type="color" id="colorPicker" value="#ff0000" onchange="setDrawColor(this.value)" 
                                       style="width: 40px; height: 26px; border: none; border-radius: 3px; cursor: pointer;">
                            </div>
                            
                            <!-- Режим цвета для линий и фигур -->
                            <div style="display: flex; gap: 6px; justify-content: center; align-items: center; flex-wrap: wrap;">
                                <span style="font-size: 11px; color: #666; font-weight: 600;">Режим цвета:</span>
                                <button onclick="setColorMode('random')" id="colorModeRandom" class="color-pick-btn active" 
                                        style="font-size: 10px; padding: 4px 8px;">
                                     Разноцветный
                                </button>
                                <button onclick="setColorMode('solid')" id="colorModeSolid" class="color-pick-btn" 
                                        style="font-size: 10px; padding: 4px 8px;">
                                    ⬛ Однотонный
                                </button>
                            </div>
                            
                            <!-- Режим фигур -->
                            <div style="display: flex; gap: 6px; justify-content: center; align-items: center; flex-wrap: wrap;">
                                <span style="font-size: 11px; color: #666; font-weight: 600;">Фигуры:</span>
                                <button onclick="setShapeMode('rectangle', 'filled')" id="rectModeFilled" class="color-pick-btn active" 
                                        style="font-size: 10px; padding: 4px 8px;">
                                    ▭ Сплошные
                                </button>
                                <button onclick="setShapeMode('rectangle', 'outline')" id="rectModeOutline" class="color-pick-btn" 
                                        style="font-size: 10px; padding: 4px 8px;">
                                    ▢ Контуры
                                </button>
                            </div>
                        </div>
                        <div class="mirror-options" id="mirrorOptions" style="display:none; margin-top:10px;">
                            <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:center;">
                                <button onclick="setMirrorType('horizontal')" id="mirrorH">↔️ Горизонтально</button>
                                <button onclick="setMirrorType('vertical')" id="mirrorV">↕️ Вертикально</button>
                                <button onclick="setMirrorType('both')" id="mirrorB">✖️ Оба</button>
                                <button onclick="setMirrorType('radial')" id="mirrorR"> Радиально</button>
                            </div>
                        
                    </div>
                    <div class="panel-section">
                        <h4> Режимы визуализации</h4>
                        <div class="color-mode-buttons">
                            <button onclick="setVisualizationMode('standard')" id="modeStandard" class="active"> Стандарт</button>
                            <button onclick="setVisualizationMode('age')" id="modeAge">⏰ Возраст</button>
                            <button onclick="setVisualizationMode('density')" id="modeDensity"> Плотность</button>
                            <button onclick="setVisualizationMode('speed')" id="modeSpeed">⚡ Скорость</button>
                            <button onclick="setVisualizationMode('heat')" id="modeHeat"> Тепловая</button>
                            <button onclick="setVisualizationMode('neon')" id="modeNeon"> Неон</button>
                            <button onclick="setVisualizationMode('matrix')" id="modeMatrix"> Матрица</button>
                            <button onclick="setVisualizationMode('retro')" id="modeRetro"> Ретро</button>
                            <button onclick="setVisualizationMode('random')" id="modeRandom">🎨 Случайные</button>
                        </div>
                        
                        <!-- Настройки визуализации -->
                        <div class="visualization-settings">
                            <div class="slider-group">
                                <label for="glowIntensity">✨ Свечение: <span id="glowValue">0</span></label>
                                <input type="range" id="glowIntensity" min="0" max="20" value="0">
                            </div>
                            <div class="slider-group">
                                <label for="particleMode">🌟 Частицы: <span id="particleValue">0</span></label>
                                <input type="range" id="particleMode" min="0" max="10" value="0">
                            </div>
                            <div class="slider-group">
                               <label for="saturationSlider"> Насыщенность: <span id="saturationValue">70</span>%</label>
                               <input type="range" id="saturationSlider" min="0" max="100" value="70">
                           </div>
                           <div class="slider-group">
                               <label for="brightnessSlider"> Яркость: <span id="brightnessValue">60</span>%</label>
                               <input type="range" id="brightnessSlider" min="0" max="100" value="60">
                           </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h4> Звук и музыка</h4>
                
                <!-- Основной переключатель звука -->
                <div style="display:flex; gap:10px; margin-bottom:10px;">
                    <button onclick="toggleSound()" id="soundToggle" style="flex:1;">
                         Звук: ВЫКЛ
                    </button>
                    <button onclick="toggleMusic()" id="musicToggle" style="flex:1;">
                         Музыка: ВЫКЛ
                    </button>
                </div>
                
                <!-- Громкость звуков -->
                <div class="slider-group">
                    <label for="soundVolume"> Громкость звуков: <span id="soundVolumeValue">50%</span></label>
                    <input type="range" id="soundVolume" min="0" max="100" value="50">
                </div>
                
                <!-- Громкость музыки -->
                <div class="slider-group">
                    <label for="musicVolume"> Громкость музыки: <span id="musicVolumeValue">30%</span></label>
                    <input type="range" id="musicVolume" min="0" max="100" value="30">
                </div>
                
                <!-- Типы звуков -->
                <div class="sound-options">
                    <label style="display:flex; align-items:center; gap:8px; margin:5px 0; color:var(--text-primary); font-size:12px;">
                        <input type="checkbox" id="birthSoundCheck" checked>
                        <span> Звук рождения</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:8px; margin:5px 0; color:var(--text-primary); font-size:12px;">
                        <input type="checkbox" id="deathSoundCheck" checked>
                        <span> Звук смерти</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:8px; margin:5px 0; color:var(--text-primary); font-size:12px;">
                        <input type="checkbox" id="ambientSoundCheck">
                        <span> Амбиентные звуки</span>
                    </label>
                </div>
                
                <!-- Музыкальные темы -->
                <div id="musicThemes" style="margin-top:10px; display:none;">
                    <h5 style="margin:5px 0; font-size:12px; color:var(--text-secondary);">Музыкальная тема:</h5>
                    <div style="display:flex; flex-wrap:wrap; gap:5px;">
                        <button onclick="setMusicTheme('ambient')" class="theme-btn"> Ambient</button>
                        <button onclick="setMusicTheme('minimal')" class="theme-btn"> Minimal</button>
                        <button onclick="setMusicTheme('electronic')" class="theme-btn">️ Electronic</button>
                        <button onclick="setMusicTheme('nature')" class="theme-btn"> Nature</button>
                    </div>
                </div>
            </div>

            <!-- Правила и статистика -->
            <div class="panel-section">
                <h4>⚙️ Правила и статистика</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <div class="panel-section">
                            <h4> Правила игры</h4>
                            <div class="rule-buttons">
                                <button onclick="setRule('conway')" id="ruleConway" class="active">Conway</button>
                                <button onclick="setRule('highlife')" id="ruleHighlife">HighLife</button>
                                <button onclick="setRule('seeds')" id="ruleSeeds">Seeds</button>
                                <button onclick="setRule('maze')" id="ruleMaze">Maze</button>
                                <button onclick="setRule('replicator')" id="ruleReplicator">Replicator</button>
                                <button onclick="setRule('daynight')" id="ruleDaynight">Day&Night</button>
                                <button onclick="setRule('morley')" id="ruleMorley">Morley</button>
                                <button onclick="setRule('anneal')" id="ruleAnneal">Anneal</button>
                                <button onclick="setRule('coral')" id="ruleCoral">Coral</button>
                                <button onclick="setRule('34life')" id="rule34life">34 Life</button>
                                <button onclick="setRule('diamoeba')" id="ruleDiamoeba">Diamoeba</button>
                                <button onclick="setRule('2x2')" id="rule2x2">2x2</button>
                                <button onclick="setRule('fredkin')" id="ruleFredkin">Fredkin</button>
                            </div>
                            
                            <!-- Специальные правила -->
                            <div style="margin-top:10px;">
                                <h5 style="margin:5px 0; font-size:12px; color:var(--text-secondary);">離 Специальные правила:</h5>
                                <div class="rule-buttons">
                                    <button onclick="setRule('briansbrain')" id="ruleBriansbrain">Brian's Brain</button>
                                    <button onclick="setRule('wireworld')" id="ruleWireworld">Wireworld</button>
                                    <button onclick="setRule('langton')" id="ruleLangton">Langton's Ant</button>
                                </div>
                            </div>
                            
                            <!-- Пользовательское правило -->
                            <div class="custom-rule-section">
                                <h5 style="margin:10px 0 5px 0; font-size:12px; color:var(--text-secondary);">⚙️ Своё правило (B/S):</h5>
                                <div style="display:flex; gap:8px; align-items:center;">
                                    <input type="text" id="customRuleBirth" placeholder="B: 3" 
                                           style="flex:1; padding:8px; border-radius:5px; border:2px solid var(--border-light); 
                                                  background:var(--bg-hover); color:var(--text-primary);">
                                    <input type="text" id="customRuleSurvive" placeholder="S: 23" 
                                           style="flex:1; padding:8px; border-radius:5px; border:2px solid var(--border-light); 
                                                  background:var(--bg-hover); color:var(--text-primary);">
                                    <button onclick="applyCustomRule()" style="padding:8px 15px;">
                                        ✓ Применить
                                    </button>
                                </div>
                                <p style="font-size:10px; color:var(--text-muted); margin:5px 0 0 0;">
                                    Пример: B: 3 (рождение при 3 соседях), S: 23 (выживание при 2-3)
                                </p>
                            </div>
                        </div>
                        <div style="text-align: center; margin-top: 8px; font-size: 10px; color: #555; font-style: italic;">
                            <span id="currentRuleDescription">B3/S23 - Стандартные правила Конвея</span>
                        </div>
                    </div>
                    <div>
                        <div style="text-align: center; margin-bottom: 8px; font-size: 11px; color: #666; font-weight: 600;">
                            Статистика:
                        </div>
                        <div class="advanced-stats" style="gap: 8px; font-size: 12px;">
                            <div>Разнообразие: <span id="diversityValue">0%</span></div>
                            <div>Стабильность: <span id="stabilityValue">0%</span></div>
                            <div>Тренд: <span id="trendValue">➡️</span></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h4> Режимы симуляции</h4>
                <div class="simulation-mode-buttons">
                    <button onclick="setSimulationMode('standard')" id="simStandard" class="active">
                         Стандарт
                    </button>
                    <button onclick="setSimulationMode('competition')" id="simCompetition">
                        ⚔️ Соревнование
                    </button>
                    <button onclick="setSimulationMode('hexagonal')" id="simHexagonal">
                        ⬡ Гексагональная
                    </button>
                    <button onclick="setSimulationMode('triangular')" id="simTriangular">
                        △ Треугольная
                    </button>
                    <button onclick="setSimulationMode('evolution')" id="simEvolution">
                        溺 Эволюция
                    </button>
                    <button onclick="setSimulationMode('quantum')" id="simQuantum">
                        ⚛️ Квантовая
                    </button>
                </div>
                
                <!-- Настройки для режима соревнования -->
                <div id="competitionSettings" style="display:none; margin-top:10px;">
                    <div class="slider-group">
                        <label> Команд: <span id="teamsValue">2</span></label>
                        <input type="range" id="teamsSlider" min="2" max="6" value="2">
                    </div>
                    <div class="slider-group">
                        <label for="stabilityThresholdSlider">
                            Порог стабильности: <span id="stabilityThresholdValue">30</span> поколений
                        </label>
                        <input type="range" id="stabilityThresholdSlider" min="10" max="100" value="30" 
                               oninput="updateStabilityThreshold(this.value)">
                    </div>
                    <button onclick="initCompetitionMode()" style="width:100%; margin-top:5px;">
                         Новая игра
                    </button>
                </div>
                
                <!-- Настройки для режима эволюции -->
                <div id="evolutionSettings" style="display:none; margin-top:10px;">
                    <div class="slider-group">
                        <label>溺 Мутация: <span id="evolutionMutationValue">10%</span></label>
                        <input type="range" id="evolutionMutationSlider" min="1" max="50" value="10">
                    </div>
                    <div class="slider-group">
                        <label> Отбор: <span id="selectionPressureValue">50%</span></label>
                        <input type="range" id="selectionPressureSlider" min="10" max="90" value="50">
                    </div>
                </div>
            </div>

            <!-- Настройки квантового режима -->
            <div id="quantumSettings" style="display: none; margin-top: 15px;">
                <h4>⚛️ Квантовые параметры</h4>
                <div class="slider-group">
                    <label for="quantumFluctSlider">
                        Флуктуации: <span id="quantumFluctValue">15</span>%
                    </label>
                    <input type="range" id="quantumFluctSlider" min="0" max="50" value="15"
                           oninput="quantumFluctuation = parseInt(this.value) / 100; document.getElementById('quantumFluctValue').textContent = this.value;">
                </div>
                <div class="slider-group">
                    <label for="quantumInterSlider">
                        Интерференция: <span id="quantumInterValue">2</span>%
                    </label>
                    <input type="range" id="quantumInterSlider" min="0" max="10" value="2"
                           oninput="quantumInterference = parseInt(this.value) / 100; document.getElementById('quantumInterValue').textContent = this.value;">
                </div>
                <div class="slider-group">
                    <label for="quantumEntSlider">
                        Запутанность: <span id="quantumEntValue">5</span>%
                    </label>
                    <input type="range" id="quantumEntSlider" min="0" max="20" value="5"
                           oninput="quantumEntanglement = parseInt(this.value) / 100; document.getElementById('quantumEntValue').textContent = this.value;">
                </div>
            </div>

            <!-- Переключатель типа поля -->
            <div class="panel-section" style="margin-top: 15px;">
                <h4>🌐 Тип поля</h4>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                    <button id="wrapAroundBtn" onclick="setWrapAround(true)" class="active" 
                            style="flex: 1; min-width: 120px;">
                        🔄 Торроидальное
                    </button>
                    <button id="boundariesBtn" onclick="setWrapAround(false)" 
                            style="flex: 1; min-width: 120px;">
                        🛡️ С границами
                    </button>
                </div>
                <div style="margin-top: 8px; font-size: 11px; color: var(--text-muted); text-align: center;" id="wrapAroundDescription">
                    Поле замыкается (края соединяются)
                </div>
            </div>

            <!-- Сохранение состояний -->
            <div class="save-section">
                <h4> Сохранение состояний</h4>
                <div class="save-controls">
                    <button onclick="saveCurrentState()"> Сохранить</button>
                    <button onclick="clearSaves()"> Очистить историю</button>
                </div>
                <div class="save-list" id="saveList"></div>
            </div>

            <div class="panel-section">
                <h4> Экспорт / Импорт</h4>
                <!-- Кнопки экспорта -->
                <div class="export-buttons">
                    <button onclick="exportToPNG()" class="success"> PNG</button>
                    <button onclick="exportToJSON()" class="success"> JSON</button>
                    <button onclick="exportToRLE()" class="success"> RLE</button>
                    <button onclick="startGIFRecording()" id="gifBtn" class="success"> Видео</button>
                </div>
                <!-- Статус записи GIF -->
                <div id="gifRecordingStatus" style="display:none; margin-top:10px;">
                    <div style="background: rgba(245, 87, 108, 0.2); padding:10px; border-radius:5px; text-align:center;">
                        <span style="color: #f5576c; font-weight:bold;">🎬 Запись видео...</span>
                        <span id="gifFrameCount" style="margin-left:10px;">Запись: 0 сек</span>
                        <div style="margin-top:8px; display:flex; gap:8px; justify-content:center;">
                            <button onclick="stopGIFRecording()" class="danger" style="font-size:11px; padding:5px 10px;">
                                ⏹️ Завершить
                            </button>
                            <button onclick="cancelGIFRecording()" style="font-size:11px; padding:5px 10px;">
                                ❌ Отменить
                            </button>
                        </div>
                    </div>
                </div>
                <!-- Импорт -->
                <div class="import-section">
                    <label for="fileInput" class="file-input-label">
                         Импорт файла
                    </label>
                    <input type="file" id="fileInput" accept=".json,.rle,.txt" style="display:none;" onchange="handleFileImport(event)">
                    <div style="margin-top:10px;">
                        <textarea id="rleInput" placeholder="Вставьте RLE код сюда..." 
                                  style="width:100%; height:80px; padding:8px; border-radius:5px; 
                                         border:2px solid var(--border-light); background:var(--bg-hover); 
                                         color:var(--text-primary); font-family:monospace; font-size:11px; resize:vertical;">
                        </textarea>
                        <button onclick="importFromRLEText()" style="width:100%; margin-top:5px;">
                            ⬆️ Импортировать из текста
                        </button>
                    </div>
                </div>
            </div>

            <!-- Легенда правил -->
            <div class="legend" id="rulesLegend">
                <h3> Правила игры:</h3>
                <ul id="rulesDescription">
                    <li><strong>Рождение:</strong> Мёртвая ячейка с 3 соседями оживает, получая смешанный цвет родителей</li>
                    <li><strong>Выживание:</strong> Живая ячейка с 2-3 соседями выживает</li>
                    <li><strong>Смерть:</strong> Ячейка умирает от одиночества (&lt;2 соседей) или перенаселения (&gt;3 соседей)</li>
                    <li><strong>Цветовая мутация:</strong> Цвет медленно дрейфует в зависимости от соседей</li>
                    <li><strong>Возраст:</strong> Старые ячейки становятся ярче</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // 1. НАСТРОЙКИ И КОНСТАНТЫ
        // ============================================
        
        const settings = {
            showTrails: false,
            showGrid: false,
            rules: {
                survival: [2, 3],
                birth: [3]
            }
        };

        const ruleSets = {
            classic: {
                name: "Классические",
                survival: [2, 3],
                birth: [3],
                description: "B3/S23 - Стандартные правила Конвея"
            },
            highLife: {
                name: "HighLife", 
                survival: [2, 3],
                birth: [3, 6],
                description: "B36/S23 - Альтернативные правила"
            },
            maze: {
                name: "Лабиринт",
                survival: [1, 2, 3, 4, 5],
                birth: [3],
                description: "B3/S12345 - Создает лабиринтообразные структуры"
            },
            coral: {
                name: "Коралл",
                survival: [4, 5, 6, 7, 8],
                birth: [3],
                description: "B3/S45678 - Образует кораллоподобные структуры"
            }
        };
        
        let currentRules = ruleSets.classic;
        let currentRule = 'conway';

        const drawingTools = {
            brush: {
                name: "Кисть",
                cursor: "crosshair"
            },
            eraser: {
                name: "Ластик", 
                cursor: "not-allowed"
            },
            fill: {
                name: "Заливка",
                cursor: "cell"
            },
            line: {
                name: "Линия",
                cursor: "crosshair"
            }
        };
        
        //let currentTool = 'brush';
        let brushSize = 1;
        let selectedDrawColor = null;

        // Настройки рисования
        let colorMode = 'random';  // 'random' - каждая ячейка случайная, 'solid' - сплошной цвет
        let solidColorType = 'picked';  // 'picked' - выбранный цвет, 'random' - случайный но одинаковый
        let shapeMode = {
            rectangle: 'filled',  // 'filled' или 'outline'
            circle: 'filled'      // 'filled' или 'outline'
        };

        const colorModes = {
            inheritance: {
                name: "Наследование",
                description: "Классическое смешивание цветов соседей"
            },
            rainbow: {
                name: "Радуга", 
                description: "Цвет зависит от позиции на поле"
            },
            thermal: {
                name: "Тепловая карта",
                description: "Цвет показывает активность региона"
            },
            age: {
                name: "По возрасту",
                description: "Цвет меняется с возрастом клетки"
            },
            random: {
                name: "Случайный",
                description: "Случайные цвета при рождении"
            }
        };
        
        let currentColorMode = 'inheritance';
        let mutationRate = 0.1;
        
        // ============================================
        // 2. CANVAS И ПЕРЕМЕННЫЕ ИГРЫ
        // ============================================
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let cellSize = 8;
        let cols, rows;
        let grid = [];

        // Новые переменные для инструментов
        let currentTool = 'brush';
        let mirrorMode = false;
        let mirrorType = 'horizontal'; // horizontal, vertical, both, radial
        let stampData = null;
        let stampSelecting = false;
        let stampStart = null;
        let shapeStart = null; // Для рисования фигур
        let previewCanvas = null; // Для предпросмотра фигур

        let running = false;  // ВАЖНО: объявляется ДО функции resizeCanvas
        let intervalId = null;
        let speed = 10;
        
        // Переменные для отслеживания реальных изменений размера
        let previousCanvasWidth = 0;
        let previousCanvasHeight = 0;

        // Статистика
        let statistics = {
            birthRate: 0,
            deathRate: 0,
            diversity: 0,
            stability: 0
        };

        // Переменные для статистики
        let generation = 0;
        let populationHistory = [];
        let maxHistoryLength = 200; // Максимум точек на графике
        let birthsThisGen = 0;
        let deathsThisGen = 0;
        let stateHistory = []; // История состояний для детекции осцилляторов
        let maxStateHistory = 20;
        let lastFPSUpdate = Date.now();
        let frameCount = 0;
        let currentFPS = 0;
        let chartVisible = false;
        let populationChart = null;

        // Переменные для Zoom и Pan
        let zoomLevel = 1;
        let minZoom = 0.5;
        let maxZoom = 5;
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let showGrid = false;
        let minimapVisible = true;
        let minimapCanvas = null;
        let minimapCtx = null;
        let spacePressed = false;

        // Переменные для визуализации
        let visualizationMode = 'standard';
        let glowIntensity = 0;
        let particleEffects = false;
        let particleIntensity = 0;
        let cellAges = []; // Возраст каждой клетки
        let cellSpeeds = []; // Скорость изменения для каждой клетки
        let densityMap = []; // Карта плотности
        let particles = []; // Массив частиц для эффектов

        // Настройки цвета для стандартного режима
        let colorSaturation = 70; // Насыщенность цвета (0-100%)
        let colorBrightness = 60; // Яркость цвета (0-100%)

        // Система сохранений
        let savedStates = JSON.parse(localStorage.getItem('gameOfLifeSaves')) || [];
        
        // Рисование
        let isDrawing = false;
        let lastPos = null;
        let lineStart = null;

        // Переменные для экспорта/импорта
        let isRecordingGIF = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = 0;
        let maxRecordingTime = 10000; // 10 секунд

        // Переменные для режимов симуляции
        let simulationMode = 'standard';
        let useWrapAround = true;
        let teamCount = 2;
        let cellTeams = []; // Массив для хранения команды каждой клетки
        let teamScores = []; // Очки команд

        // Переменные для определения победителя в режиме соревнования
        let competitionStateHistory = []; // Отдельная история для режима соревнования
        let stableGenerations = 0; // Счётчик стабильных поколений
        let minStableGenerations = 30; // Порог стабильности для объявления победителя

        let evolutionMutation = 0.1;
        let selectionPressure = 0.5;
        // Параметры квантового режима (настраиваемые)
        let quantumFluctuation = 0.15;  // Сила квантовых флуктуаций (по умолчанию 15%)
        let quantumInterference = 0.02; // Сила интерференции (по умолчанию 2%)
        let quantumEntanglementBase = 0.05; // Базовая запутанность (по умолчанию 5%)

        // Переменные для touch управления
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let touchStartDistance = 0;
        let lastTouchDistance = 0;
        let isTouchPanning = false;
        let isTouchPinching = false;
        let touchIdentifiers = [];
        let doubleTapTimer = null;
        let lastTapTime = 0;
        let isMobileMenuOpen = false;
        let isFullscreen = false;

        // Переменные для звука
        let soundEnabled = false;
        let musicEnabled = false;
        let soundVolume = 0.5;
        let musicVolume = 0.3;
        let birthSoundEnabled = true;
        let deathSoundEnabled = true;
        let ambientSoundEnabled = false;
        let currentMusicTheme = 'ambient';

        // Web Audio API контексты
        let audioContext = null;
        let musicGainNode = null;
        let sfxGainNode = null;
        let musicOscillators = [];
        let ambientInterval = null;

        // Частотные карты для генеративной музыки
        const musicScales = {
            ambient: [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25], // C мажор
            minimal: [220.00, 246.94, 277.18, 293.66, 329.63, 369.99, 415.30], // A минор
            electronic: [130.81, 146.83, 164.81, 174.61, 196.00, 220.00, 246.94], // C минор
            nature: [174.61, 196.00, 220.00, 233.08, 261.63, 293.66, 329.63] // F мажор
        };

        // Переменные для специальных правил
        let cellStates = []; // Для правил с несколькими состояниями (Brian's Brain, Wireworld)
        let langtonAnts = []; // Для муравьёв Лэнгтона
        let customBirthRule = [3];
        let customSurviveRule = [2, 3];

        // Определения правил
        const gameRules = {
            conway: { birth: [3], survive: [2, 3], name: 'Conway (B3/S23)' },
            highlife: { birth: [3, 6], survive: [2, 3], name: 'HighLife (B36/S23)' },
            seeds: { birth: [2], survive: [], name: 'Seeds (B2/S)' },
            maze: { birth: [3], survive: [1, 2, 3, 4, 5], name: 'Maze (B3/S12345)' },
            replicator: { birth: [1, 3, 5, 7], survive: [1, 3, 5, 7], name: 'Replicator (B1357/S1357)' },
            daynight: { birth: [3, 6, 7, 8], survive: [3, 4, 6, 7, 8], name: 'Day & Night (B3678/S34678)' },
            morley: { birth: [3, 6, 8], survive: [2, 4, 5], name: 'Morley (B368/S245)' },
            anneal: { birth: [4, 6, 7, 8], survive: [3, 5, 6, 7, 8], name: 'Anneal (B4678/S35678)' },
            coral: { birth: [3], survive: [4, 5, 6, 7, 8], name: 'Coral (B3/S45678)' },
            '34life': { birth: [3, 4], survive: [3, 4], name: '34 Life (B34/S34)' },
            diamoeba: { birth: [3, 5, 6, 7, 8], survive: [5, 6, 7, 8], name: 'Diamoeba (B35678/S5678)' },
            '2x2': { birth: [3, 6], survive: [1, 2, 5], name: '2x2 (B36/S125)' },
            fredkin: { birth: [1, 3, 5, 7], survive: [0, 2, 4, 6, 8], name: 'Fredkin (B1357/S02468)' },
            custom: { birth: customBirthRule, survive: customSurviveRule, name: 'Custom' }
        };

        // ========== ТЕМА ИНТЕРФЕЙСА ==========
        let currentTheme = 'light';

        function toggleTheme() {
            // Переключение темы
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            
            // Добавляем анимацию перехода
            document.body.classList.add('theme-transitioning');
            
            // Применяем тему
            document.documentElement.setAttribute('data-theme', currentTheme);
            
            // Обновляем кнопку
            updateThemeButton();
            
            // Перерисовываем canvas с новым фоном
            drawGrid();
            if (minimapVisible) {
                updateMinimap();
            }
            
            // Убираем класс анимации
            setTimeout(() => {
                document.body.classList.remove('theme-transitioning');
            }, 300);
            playUISound('click');
        }

        function updateThemeButton() {
            const icon = document.getElementById('themeIcon');
            const text = document.getElementById('themeText');
            
            if (currentTheme === 'dark') {
                icon.textContent = '☀️';
                text.textContent = 'Светлая тема';
            } else {
                icon.textContent = '';
                text.textContent = 'Темная тема';
            }
        }

        // Инициализация темы при загрузке
        function initTheme() {
            // Можно добавить определение системной темы
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            // Если хотите использовать системную тему по умолчанию:
            // currentTheme = prefersDark ? 'dark' : 'light';
            // document.documentElement.setAttribute('data-theme', currentTheme);
            
            updateThemeButton();
        }
        
        // ========== ЭКСПОРТ В PNG ==========
        function exportToPNG() {
            // Создаём временный canvas с текущим состоянием
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            
            // Устанавливаем размер
            exportCanvas.width = cols * cellSize;
            exportCanvas.height = rows * cellSize;
            
            // Фон
            exportCtx.fillStyle = currentTheme === 'dark' ? '#0a0a0a' : '#000';
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // Рисуем клетки
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = grid[i][j];
                    
                    if (cell.alive) {
                        exportCtx.fillStyle = `hsl(${cell.hue}, ${colorSaturation}%, ${colorBrightness}%)`;
                        exportCtx.fillRect(j * cellSize, i * cellSize, cellSize - 1, cellSize - 1);
                    }
                }
            }
            
            // Конвертируем в blob и скачиваем
            exportCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                link.download = `game-of-life-${timestamp}.png`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            });
            
            showNotification('✅ PNG экспортирован!');
            playUISound('success');
        }

        // ========== ЭКСПОРТ В JSON ==========
        function exportToJSON() {
            const data = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                generation: generation,
                rows: rows,
                cols: cols,
                cellSize: cellSize,
                rule: currentRule,
                visualizationMode: visualizationMode,
                grid: []
            };
            
            // Сохраняем только живые клетки для экономии места
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (grid[i][j].alive) {
                        data.grid.push({
                            row: i,
                            col: j,
                            hue: grid[i][j].hue,
                            age: cellAges[i][j] || 0
                        });
                    }
                }
            }
            
            // Создаём blob и скачиваем
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            link.download = `game-of-life-${timestamp}.json`;
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
            
            showNotification('✅ JSON экспортирован!');
        }

        // ========== ЭКСПОРТ В RLE ==========
        function exportToRLE() {
            // RLE формат - стандарт для Game of Life паттернов
            let rle = '';
            
            // Заголовок
            rle += `#N Game of Life Export\n`;
            rle += `#O Unknown\n`;
            rle += `#C Exported from Game of Life - ${new Date().toISOString()}\n`;
            rle += `#C Generation: ${generation}\n`;
            rle += `x = ${cols}, y = ${rows}, rule = ${getRuleName()}\n`;
            
            // Кодирование паттерна
            let currentRun = 0;
            let currentChar = 'b'; // b = мёртвая, o = живая
            let lineLength = 0;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const isAlive = grid[i][j].alive;
                    const char = isAlive ? 'o' : 'b';
                    
                    if (char === currentChar) {
                        currentRun++;
                    } else {
                        // Записываем предыдущую последовательность
                        if (currentRun > 0) {
                            const runStr = currentRun > 1 ? currentRun + currentChar : currentChar;
                            rle += runStr;
                            lineLength += runStr.length;
                            
                            // Перенос строки каждые 70 символов
                            if (lineLength > 70) {
                                rle += '\n';
                                lineLength = 0;
                            }
                        }
                        currentChar = char;
                        currentRun = 1;
                    }
                }
                
                // Конец строки
                if (currentRun > 0) {
                    const runStr = currentRun > 1 ? currentRun + currentChar : currentChar;
                    rle += runStr;
                    lineLength += runStr.length;
                }
                
                // Добавляем символ конца строки, кроме последней
                if (i < rows - 1) {
                    rle += '$';
                    lineLength++;
                    if (lineLength > 70) {
                        rle += '\n';
                        lineLength = 0;
                    }
                }
                
                currentRun = 0;
                currentChar = 'b';
            }
            
            // Конец паттерна
            rle += '!\n';
            
            // Скачиваем файл
            const blob = new Blob([rle], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            link.download = `game-of-life-${timestamp}.rle`;
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
            
            showNotification('✅ RLE экспортирован!');
        }

        function getRuleName() {
            const ruleNames = {
                'conway': 'B3/S23',
                'highlife': 'B36/S23',
                'seeds': 'B2/S',
                'maze': 'B3/S12345',
                'replicator': 'B1357/S1357',
                'daynight': 'B3678/S34678'
            };
            return ruleNames[currentRule] || 'B3/S23';
        }

        // ========== ЗАПИСЬ ВИДЕО ==========
        function startGIFRecording() {
            if (isRecordingGIF) {
                showNotification('⚠️ Запись уже идёт!');
                return;
            }
            
            try {
                // Создаём stream из canvas
                const stream = canvas.captureStream(speed); // Захват с текущей скоростью FPS
                
                // Настройки записи
                const options = {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 2500000
                };
                
                // Проверяем поддержку формата
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm;codecs=vp8';
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/webm';
                    }
                }
                
                mediaRecorder = new MediaRecorder(stream, options);
                recordedChunks = [];
                isRecordingGIF = true;
                recordingStartTime = Date.now();
                
                // Обработчик получения данных
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                // Обработчик завершения записи
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    link.download = `game-of-life-${timestamp}.webm`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    showNotification('✅ Видео успешно сохранено!');
                };
                
                // Запускаем запись
                mediaRecorder.start();
                
                // Показываем статус
                document.getElementById('gifRecordingStatus').style.display = 'block';
                document.getElementById('gifBtn').textContent = '⏺️ Идёт запись...';
                document.getElementById('gifBtn').disabled = true;
                document.getElementById('gifFrameCount').textContent = 'Запись: 0 сек';
                
                // Запускаем симуляцию, если она не запущена
                if (!running) {
                    document.getElementById('startBtn').click();
                }
                
                // Обновляем счётчик времени
                const updateTimer = setInterval(() => {
                    if (!isRecordingGIF) {
                        clearInterval(updateTimer);
                        return;
                    }
                    
                    const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                    document.getElementById('gifFrameCount').textContent = `Запись: ${elapsed} сек`;
                    
                    // Автоматическая остановка после максимального времени
                    if (Date.now() - recordingStartTime >= maxRecordingTime) {
                        stopGIFRecording();
                    }
                }, 100);
                
                showNotification('🎬 Запись видео начата!');
                
            } catch (error) {
                console.error('Recording error:', error);
                showNotification('❌ Ошибка записи: ' + error.message);
                isRecordingGIF = false;
            }
        }

        function stopGIFRecording() {
            if (!isRecordingGIF || !mediaRecorder) return;
            
            isRecordingGIF = false;
            
            // Останавливаем запись
            if (mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            // Скрываем статус
            document.getElementById('gifRecordingStatus').style.display = 'none';
            document.getElementById('gifBtn').textContent = '🎬 Видео';
            document.getElementById('gifBtn').disabled = false;
            
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            showNotification(`⏹️ Запись остановлена (${elapsed} сек)`);
        }

        function cancelGIFRecording() {
            if (!isRecordingGIF || !mediaRecorder) return;
            
            isRecordingGIF = false;
            
            // Останавливаем и отменяем запись
            if (mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            recordedChunks = [];
            
            document.getElementById('gifRecordingStatus').style.display = 'none';
            document.getElementById('gifBtn').textContent = '🎬 Видео';
            document.getElementById('gifBtn').disabled = false;
            
            showNotification('❌ Запись отменена');
        }

        // ========== ИМПОРТ ==========
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            const extension = file.name.split('.').pop().toLowerCase();
            
            reader.onload = function(e) {
                const content = e.target.result;
                
                try {
                    if (extension === 'json') {
                        importFromJSON(content);
                    } else if (extension === 'rle' || extension === 'txt') {
                        importFromRLE(content);
                    } else {
                        showNotification('⚠️ Неподдерживаемый формат файла!');
                    }
                } catch (error) {
                    console.error('Import error:', error);
                    showNotification('❌ Ошибка импорта: ' + error.message);
                }
            };
            
            reader.readAsText(file);
            
            // Сброс input для повторного выбора того же файла
            event.target.value = '';
        }

        // Импорт из JSON
        function importFromJSON(jsonString) {
            const data = JSON.parse(jsonString);
            
            // Останавливаем симуляцию
            if (running) {
                document.getElementById('stopBtn').click();
            }
            
            // Очищаем поле
            initGrid();
            
            // Загружаем клетки
            data.grid.forEach(cell => {
                if (cell.row < rows && cell.col < cols) {
                    grid[cell.row][cell.col].alive = true;
                    grid[cell.row][cell.col].hue = cell.hue || Math.random() * 360;
                    if (cellAges[cell.row] && cellAges[cell.row][cell.col] !== undefined) {
                        cellAges[cell.row][cell.col] = cell.age || 0;
                    }
                }
            });
            
            // Восстанавливаем настройки если есть
            if (data.rule && currentRule !== data.rule) {
                setRule(data.rule);
            }
            
            generation = data.generation || 0;
            
            drawGrid();
            updateStats();
            
            showNotification(`✅ Импортировано ${data.grid.length} клеток из JSON!`);
        }

        // Импорт из RLE
        function importFromRLE(rleString) {
            // Парсинг RLE формата
            const lines = rleString.split('\n');
            let patternLines = [];
            let width = 0, height = 0;
            let rule = 'B3/S23';
            
            // Читаем заголовок
            for (let line of lines) {
                line = line.trim();
                
                // Пропускаем комментарии
                if (line.startsWith('#')) continue;
                
                // Читаем размер и правило
                if (line.startsWith('x')) {
                    const match = line.match(/x\s*=\s*(\d+)\s*,\s*y\s*=\s*(\d+)(?:\s*,\s*rule\s*=\s*(\S+))?/i);
                    if (match) {
                        width = parseInt(match[1]);
                        height = parseInt(match[2]);
                        if (match[3]) rule = match[3];
                    }
                    continue;
                }
                
                // Собираем паттерн
                if (line.length > 0 && !line.startsWith('#')) {
                    patternLines.push(line);
                }
            }
            
            // Объединяем строки паттерна
            const pattern = patternLines.join('');
            
            // Декодируем RLE
            const decoded = decodeRLE(pattern, width, height);
            
            // Останавливаем симуляцию
            if (running) {
                document.getElementById('stopBtn').click();
            }
            
            // Очищаем поле
            initGrid();
            
            // Размещаем паттерн в центре
            const startRow = Math.floor((rows - decoded.length) / 2);
            const startCol = Math.floor((cols - (decoded[0]?.length || 0)) / 2);
            
            let cellCount = 0;
            for (let i = 0; i < decoded.length; i++) {
                for (let j = 0; j < decoded[i].length; j++) {
                    const row = startRow + i;
                    const col = startCol + j;
                    
                    if (row >= 0 && row < rows && col >= 0 && col < cols) {
                        if (decoded[i][j]) {
                            grid[row][col].alive = true;
                            grid[row][col].hue = Math.random() * 360;
                            cellCount++;
                        }
                    }
                }
            }
            
            // Устанавливаем правило если распознано
            applyRuleFromString(rule);
            
            drawGrid();
            updateStats();
            
            showNotification(`✅ Импортировано ${cellCount} клеток из RLE!`);
        }

        // Декодирование RLE строки
        function decodeRLE(rleString, width, height) {
            const result = [];
            let currentRow = [];
            let runCount = '';
            
            for (let i = 0; i < rleString.length; i++) {
                const char = rleString[i];
                
                if (char >= '0' && char <= '9') {
                    runCount += char;
                } else if (char === 'b' || char === '.') {
                    // Мёртвые клетки
                    const count = runCount ? parseInt(runCount) : 1;
                    for (let j = 0; j < count; j++) {
                        currentRow.push(false);
                    }
                    runCount = '';
                } else if (char === 'o' || char === 'O') {
                    // Живые клетки
                    const count = runCount ? parseInt(runCount) : 1;
                    for (let j = 0; j < count; j++) {
                        currentRow.push(true);
                    }
                    runCount = '';
                } else if (char === '$') {
                    // Конец строки
                    const count = runCount ? parseInt(runCount) : 1;
                    for (let j = 0; j < count; j++) {
                        result.push([...currentRow]);
                        currentRow = [];
                    }
                    runCount = '';
                } else if (char === '!') {
                    // Конец паттерна
                    if (currentRow.length > 0) {
                        result.push(currentRow);
                    }
                    break;
                }
            }
            
            return result;
        }

        // Применение правила из строки
        function applyRuleFromString(ruleString) {
            const ruleMap = {
                'B3/S23': 'conway',
                'B36/S23': 'highlife',
                'B2/S': 'seeds',
                'B3/S12345': 'maze',
                'B1357/S1357': 'replicator',
                'B3678/S34678': 'daynight'
            };
            
            const ruleName = ruleMap[ruleString];
            if (ruleName) {
                setRule(ruleName);
            }
        }

        // Импорт из текстового поля
        function importFromRLEText() {
            const text = document.getElementById('rleInput').value.trim();
            
            if (!text) {
                showNotification('⚠️ Введите RLE код!');
                return;
            }
            
            try {
                importFromRLE(text);
                document.getElementById('rleInput').value = '';
            } catch (error) {
                console.error('RLE import error:', error);
                showNotification('❌ Ошибка импорта RLE: ' + error.message);
            }
        }

        // ========== УВЕДОМЛЕНИЯ ==========
        function showNotification(message, duration = 3000) {
            const existing = document.getElementById('notification');
            if (existing) existing.remove();
            
            const notification = document.createElement('div');
            notification.id = 'notification';
            notification.textContent = message;
            
            // Позиционирование для мобильных
            const isMobile = isMobileDevice();
            const topPosition = isMobile ? '100px' : '80px';
            
            notification.style.cssText = `
                position: fixed;
                top: ${topPosition};
                right: ${isMobile ? '10px' : '20px'};
                left: ${isMobile ? '10px' : 'auto'};
                background: var(--button-success);
                color: white;
                padding: ${isMobile ? '10px 15px' : '12px 20px'};
                border-radius: 8px;
                font-weight: bold;
                font-size: ${isMobile ? '12px' : '13px'};
                box-shadow: var(--shadow-lg);
                z-index: 10000;
                animation: slideInRight 0.3s ease;
                text-align: center;
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, duration);
        }

        // ========== РЕЖИМЫ СИМУЛЯЦИИ ==========

        function setSimulationMode(mode) {
            // Останавливаем симуляцию при смене режима
            if (running) {
                document.getElementById('stopBtn').click();
            }
            
            simulationMode = mode;
            
            // Обновление активной кнопки
            document.querySelectorAll('.simulation-mode-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('sim' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');
            
            // Показываем/скрываем настройки для разных режимов
            const competitionSettings = document.getElementById('competitionSettings');
            const evolutionSettings = document.getElementById('evolutionSettings');
            const quantumSettings = document.getElementById('quantumSettings');
            
            if (competitionSettings) {
                competitionSettings.style.display = mode === 'competition' ? 'block' : 'none';
            }
            
            if (evolutionSettings) {
                evolutionSettings.style.display = mode === 'evolution' ? 'block' : 'none';
            }
            
            if (quantumSettings) {
                quantumSettings.style.display = mode === 'quantum' ? 'block' : 'none';
            }
            
            // Инициализация режима
            switch(mode) {
                case 'standard':
                    // Возврат к стандартному режиму
                    currentRules = {
                        birth: [3],
                        survival: [2, 3]
                    };
                    updateRulesLegend();
                    break;
                case 'competition':
                    showNotification('⚔️ Режим соревнования! Нажмите "Новая игра"');
                    break;
                case 'hexagonal':
                    initHexagonalGrid();
                    break;
                case 'triangular':
                    initTriangularGrid();
                    break;
                case 'evolution':
                    showNotification('🧬 Режим эволюции активирован!');
                    break;
                case 'quantum':
                    initQuantumMode();
                    break;
            }
            
            drawGrid();
        }

        // Переключение типа поля
        function setWrapAround(wrap) {
            useWrapAround = wrap;
            
            // Обновление активной кнопки
            document.getElementById('wrapAroundBtn').classList.toggle('active', wrap);
            document.getElementById('boundariesBtn').classList.toggle('active', !wrap);
            
            // Обновление описания
            const description = document.getElementById('wrapAroundDescription');
            if (wrap) {
                description.textContent = 'Поле замыкается (края соединяются)';
            } else {
                description.textContent = 'Поле имеет жёсткие границы';
            }
            
            // Показать уведомление
            const message = wrap ? '🔄 Торроидальное поле активировано' : '🛡️ Поле с границами активировано';
            showNotification(message);
            
            // Если режим соревнования активен, показать подсказку
            if (simulationMode === 'competition') {
                setTimeout(() => {
                    showNotification('💡 Нажмите "Новая игра" для применения изменений', 5000);
                }, 500);
            }
        }

        // ========== РЕЖИМ СОРЕВНОВАНИЯ ==========

        function initCompetitionMode() {
            // Сброс ТОЛЬКО новых переменных
            competitionStateHistory = [];
            stableGenerations = 0;
            
            teamCount = parseInt(document.getElementById('teamsSlider').value);
            
            // Очистка поля
            initGrid();
            
            // Инициализация массивов команд
            cellTeams = [];
            for (let i = 0; i < rows; i++) {
                cellTeams[i] = [];
                for (let j = 0; j < cols; j++) {
                    cellTeams[i][j] = -1; // -1 = нет команды
                }
            }
            
            // Инициализация счёта команд
            teamScores = new Array(teamCount).fill(0);
            
            // Размещаем стартовые позиции для каждой команды
            const positions = getTeamStartPositions(teamCount);
            
            positions.forEach((pos, teamIndex) => {
                // Создаём случайный паттерн для каждой команды
                placeTeamPattern(pos.row, pos.col, teamIndex);
            });
            
            drawGrid();
            updateStats();
            showNotification(`⚔️ Игра началась! ${teamCount} команд сражаются!`);
        }

        // Получение стартовых позиций команд
        function getTeamStartPositions(teams) {
            const positions = [];
            const margin = 10;
            
            if (teams === 2) {
                positions.push(
                    { row: margin, col: Math.floor(cols / 4) },
                    { row: rows - margin, col: Math.floor(cols * 3 / 4) }
                );
            } else if (teams === 3) {
                positions.push(
                    { row: margin, col: Math.floor(cols / 2) },
                    { row: rows - margin, col: Math.floor(cols / 4) },
                    { row: rows - margin, col: Math.floor(cols * 3 / 4) }
                );
            } else if (teams === 4) {
                positions.push(
                    { row: margin, col: margin },
                    { row: margin, col: cols - margin },
                    { row: rows - margin, col: margin },
                    { row: rows - margin, col: cols - margin }
                );
            } else {
                // Круговое расположение для 5-6 команд
                const centerRow = Math.floor(rows / 2);
                const centerCol = Math.floor(cols / 2);
                const radius = Math.min(rows, cols) / 3;
                
                for (let i = 0; i < teams; i++) {
                    const angle = (i / teams) * Math.PI * 2 - Math.PI / 2;
                    positions.push({
                        row: Math.floor(centerRow + radius * Math.sin(angle)),
                        col: Math.floor(centerCol + radius * Math.cos(angle))
                    });
                }
            }
            
            return positions;
        }

        // Размещение паттерна команды - выбор в зависимости от типа поля
        function placeTeamPattern(centerRow, centerCol, teamIndex) {
            if (useWrapAround) {
                // Торроидальное поле - используем генераторы глайдеров
                placeTeamPatternGun(centerRow, centerCol, teamIndex);
            } else {
                // Поле с границами - используем случайные области
                placeTeamPatternRandom(centerRow, centerCol, teamIndex);
            }
        }

        // Размещение паттерна команды - Gosper Glider Gun (для торроидального поля)
        function placeTeamPatternGun(centerRow, centerCol, teamIndex) {
            // Упрощённый генератор глайдеров
            const gun = [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ];
            
            const offsetY = Math.floor(gun.length / 2);
            const offsetX = Math.floor(gun[0].length / 2);
            
            for (let i = 0; i < gun.length; i++) {
                for (let j = 0; j < gun[i].length; j++) {
                    if (gun[i][j] === 1) {
                        const y = centerRow - offsetY + i;
                        const x = centerCol - offsetX + j;
                        
                        if (y >= 0 && y < rows && x >= 0 && x < cols) {
                            grid[y][x].alive = true;
                            grid[y][x].hue = (teamIndex * 60) % 360;
                            cellTeams[y][x] = teamIndex;
                        }
                    }
                }
            }
        }

        // Размещение паттерна команды - случайная область (для поля с границами)
        function placeTeamPatternRandom(centerRow, centerCol, teamIndex) {
            const size = 15;
            const density = 0.4;
            
            for (let i = -size; i <= size; i++) {
                for (let j = -size; j <= size; j++) {
                    const y = centerRow + i;
                    const x = centerCol + j;
                    
                    if (y >= 0 && y < rows && x >= 0 && x < cols) {
                        if (Math.random() < density) {
                            grid[y][x].alive = true;
                            grid[y][x].hue = (teamIndex * 60) % 360;
                            cellTeams[y][x] = teamIndex;
                        }
                    }
                }
            }
        }

        // Обновление сетки для режима соревнования
        function updateGridCompetition() {
            birthsThisGen = 0;
            deathsThisGen = 0;
            generation++;
            
            const newGrid = [];
            const newTeams = [];
            const newAges = [];
            
            for (let i = 0; i < rows; i++) {
                newGrid[i] = [];
                newTeams[i] = [];
                newAges[i] = [];
                
                for (let j = 0; j < cols; j++) {
                    const { count: neighbors } = countNeighbors(i, j);
                    const wasAlive = grid[i][j].alive;
                    let willBeAlive = false;
                    let newTeam = -1;
                    
                    // Применяем правила Conway
                    if (wasAlive) {
                        willBeAlive = neighbors === 2 || neighbors === 3;
                        newTeam = cellTeams[i][j];
                    } else {
                        willBeAlive = neighbors === 3;
                        
                        // Если клетка рождается, определяем её команду
                        if (willBeAlive) {
                            newTeam = getMajorityTeam(i, j);
                        }
                    }
                    
                    newGrid[i][j] = {
                        alive: willBeAlive,
                        hue: willBeAlive ? (newTeam * 60) % 360 : grid[i][j].hue,
                        trailStrength: grid[i][j].trailStrength * 0.9
                    };
                    
                    newTeams[i][j] = newTeam;
                    newAges[i][j] = willBeAlive ? (wasAlive ? cellAges[i][j] + 1 : 0) : 0;
                    
                    // Подсчёт рождений/смертей
                    if (willBeAlive && !wasAlive) birthsThisGen++;
                    if (!willBeAlive && wasAlive) deathsThisGen++;
                }
            }
            
            grid = newGrid;
            cellTeams = newTeams;
            cellAges = newAges;
            
            // Обновление счёта команд
            updateTeamScores();
            
            // Проверка победителя
            checkCompetitionWinner();
            
            drawGrid();
            // Обновление статистики (использует существующие birthsThisGen, deathsThisGen, generation)
            updateStats();
            
            // Проверка стабильности поля
            const stabilityCheck = checkCompetitionStability();
            
            if (stabilityCheck.stable) {
                determineCompetitionWinner(stabilityCheck.period);
            }
            
            // Старая проверка (если осталась одна команда)
            checkCompetitionWinner();
        }

        // Создание хеша состояния поля для режима соревнования
        function getCompetitionStateHash() {
            // Используем более эффективный способ создания хеша
            let hash = '';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    // Кодируем только живые клетки с командой
                    if (grid[i][j].alive && cellTeams[i][j] >= 0) {
                        hash += cellTeams[i][j];
                    } else {
                        hash += '.';
                    }
                }
            }
            return hash;
        }

        // Проверка стабильности поля (использует существующие переменные!)
        function checkCompetitionStability() {
            const currentState = getCompetitionStateHash();
            
            // Добавляем текущее состояние в историю
            competitionStateHistory.push(currentState);
            
            // Ограничиваем размер истории (проверяем только периоды 1-3)
            if (competitionStateHistory.length > 4) {
                competitionStateHistory.shift();
            }
            
            // Проверяем циклы периода 1, 2, 3
            let isStable = false;
            let period = 0;
            
            for (let p = 1; p <= 3 && p < competitionStateHistory.length; p++) {
                const currentIdx = competitionStateHistory.length - 1;
                if (competitionStateHistory[currentIdx] === competitionStateHistory[currentIdx - p]) {
                    isStable = true;
                    period = p;
                    break;
                }
            }
            
            // Используем СУЩЕСТВУЮЩИЕ переменные birthsThisGen и deathsThisGen!
            // Если нет изменений - это тоже стабильность
            if (birthsThisGen === 0 && deathsThisGen === 0) {
                isStable = true;
                period = 1; // Still lifes
            }
            
            if (isStable) {
                stableGenerations++;
                
                if (stableGenerations >= minStableGenerations) {
                    return { stable: true, period: period };
                }
            } else {
                stableGenerations = 0;
            }
            
            return { stable: false, period: 0 };
        }

        // Создание хеша состояния поля для сравнения
        function getGridStateHash() {
            let hash = '';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    // Кодируем: 1 = живая клетка с командой, 0 = мёртвая
                    if (grid[i][j].alive && cellTeams[i][j] >= 0) {
                        hash += cellTeams[i][j];
                    } else {
                        hash += '.';
                    }
                }
                hash += '|'; // Разделитель строк
            }
            return hash;
        }

        // Проверка стабильности поля
        function checkFieldStability() {
            const currentState = getGridStateHash();
            
            // Добавляем текущее состояние в историю
            stateHistory.push(currentState);
            
            // Ограничиваем размер истории
            if (stateHistory.length > maxHistoryLength) {
                stateHistory.shift();
            }
            
            // Проверяем, есть ли текущее состояние в истории (цикл)
            // Проверяем периоды 1, 2, 3
            let isStable = false;
            let period = 0;
            
            for (let p = 1; p <= 3 && p < stateHistory.length; p++) {
                if (stateHistory[stateHistory.length - 1] === stateHistory[stateHistory.length - 1 - p]) {
                    isStable = true;
                    period = p;
                    break;
                }
            }
            
            // Также проверяем, нет ли изменений вообще (births и deaths = 0)
            if (birthsThisGen === 0 && deathsThisGen === 0) {
                isStable = true;
                period = 1;
            }
            
            if (isStable) {
                stableGenerations++;
                
                // Если стабильно достаточно долго - объявляем победителя
                if (stableGenerations >= minStableGenerations) {
                    return { stable: true, period: period };
                }
            } else {
                // Сбрасываем счётчик если стабильность нарушена
                stableGenerations = 0;
            }
            
            return { stable: false, period: 0 };
        }

        // Получение команды большинства соседей
        function getMajorityTeam(row, col) {
            const teamCounts = new Array(teamCount).fill(0);
            
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    
                    let newRow, newCol;
                    
                    if (useWrapAround) {
                        newRow = (row + i + rows) % rows;
                        newCol = (col + j + cols) % cols;
                    } else {
                        newRow = row + i;
                        newCol = col + j;
                        
                        if (newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols) {
                            continue;
                        }
                    }
                    
                    if (grid[newRow][newCol].alive && cellTeams[newRow][newCol] >= 0) {
                        teamCounts[cellTeams[newRow][newCol]]++;
                    }
                }
            }
            
            // Возвращаем команду с максимальным количеством
            let maxTeam = 0;
            let maxCount = teamCounts[0];
            
            for (let i = 1; i < teamCount; i++) {
                if (teamCounts[i] > maxCount) {
                    maxCount = teamCounts[i];
                    maxTeam = i;
                }
            }
            
            return maxTeam;
        }

        // Обновление счёта команд
        function updateTeamScores() {
            teamScores.fill(0);
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (grid[i][j].alive && cellTeams[i][j] >= 0) {
                        teamScores[cellTeams[i][j]]++;
                    }
                }
            }
        }

        // Проверка победителя
        function checkCompetitionWinner() {
            if (generation < 100) return; // Минимум 100 поколений
            
            // Подсчёт активных команд
            const activeTeams = teamScores.filter(score => score > 0).length;
            
            if (activeTeams === 1) {
                const winnerTeam = teamScores.findIndex(score => score > 0);
                showWinnerBanner(winnerTeam);
                document.getElementById('stopBtn').click();
            }
        }

        // Определение победителя по стабильному состоянию
        function determineCompetitionWinner(period) {
            // Останавливаем симуляцию
            if (running) {
                document.getElementById('stopBtn').click();
            }
            
            // Используем СУЩЕСТВУЮЩУЮ функцию updateTeamScores()
            updateTeamScores();
            
            // Используем СУЩЕСТВУЮЩИЙ массив teamScores
            let maxScore = Math.max(...teamScores);
            let winnerTeams = [];
            
            for (let i = 0; i < teamCount; i++) {
                if (teamScores[i] === maxScore && teamScores[i] > 0) {
                    winnerTeams.push(i);
                }
            }
            
            // Формируем сообщение
            let periodText = period === 1 ? 'Still lifes' : `Осцилляторы периода ${period}`;
            
            let message = '';
            if (winnerTeams.length === 1) {
                // Один победитель
                message = `
                    <h2>🏆 Победа!</h2>
                    <p style="font-size: 18px; margin: 15px 0;">Команда ${winnerTeams[0] + 1} победила!</p>
                    <p style="font-size: 14px; color: #888;">Клеток: ${teamScores[winnerTeams[0]]}</p>
                    <p style="font-size: 12px; color: #666; margin-top: 10px;">
                        Поле стабилизировалось: ${periodText}<br>
                        Поколение: ${generation}
                    </p>
                    <div style="margin-top: 20px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                        <h4 style="margin: 0 0 8px 0;">📊 Финальные результаты:</h4>
                        ${getTeamScoresHTML()}
                    </div>
                    <button onclick="this.parentElement.remove()" style="margin-top: 15px;">
                        ✖️ Закрыть
                    </button>
                `;
            } else if (winnerTeams.length > 1) {
                // Ничья
                const teamsList = winnerTeams.map(t => `Команда ${t + 1}`).join(', ');
                message = `
                    <h2>🤝 Ничья!</h2>
                    <p style="font-size: 18px; margin: 15px 0;">${teamsList}</p>
                    <p style="font-size: 14px; color: #888;">Клеток у каждой: ${maxScore}</p>
                    <p style="font-size: 12px; color: #666; margin-top: 10px;">
                        Поле стабилизировалось: ${periodText}<br>
                        Поколение: ${generation}
                    </p>
                    <div style="margin-top: 20px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                        <h4 style="margin: 0 0 8px 0;">📊 Финальные результаты:</h4>
                        ${getTeamScoresHTML()}
                    </div>
                    <button onclick="this.parentElement.remove()" style="margin-top: 15px;">
                        ✖️ Закрыть
                    </button>
                `;
            } else {
                // Все погибли
                message = `
                    <h2>💀 Все погибли!</h2>
                    <p style="font-size: 14px; color: #888;">Ни одна команда не выжила</p>
                    <p style="font-size: 12px; color: #666; margin-top: 10px;">Поколение: ${generation}</p>
                    <button onclick="this.parentElement.remove()" style="margin-top: 15px;">✖️ Закрыть</button>
                `;
            }
            
            showWinnerBanner(message);
            
            // Сброс ТОЛЬКО новых переменных
            competitionStateHistory = [];
            stableGenerations = 0;
        }

        // Форматирование результатов команд (использует teamScores)
        function getTeamScoresHTML() {
            let html = '<div style="display: flex; flex-direction: column; gap: 5px;">';
            
            // Используем СУЩЕСТВУЮЩИЙ массив teamScores
            const totalCells = teamScores.reduce((sum, s) => sum + s, 0);
            
            for (let i = 0; i < teamCount; i++) {
                const hue = (i * 60) % 360;
                const percentage = totalCells > 0 ? (teamScores[i] / totalCells * 100).toFixed(1) : 0;
                
                html += `
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 16px; height: 16px; background: hsl(${hue}, 70%, 50%); border-radius: 2px;"></div>
                        <span style="flex: 1;">Команда ${i + 1}:</span>
                        <span style="font-weight: bold;">${teamScores[i]} клеток (${percentage}%)</span>
                    </div>
                `;
            }
            
            html += '</div>';
            return html;
        }

        // Показ баннера победителя (универсальная версия)
        function showWinnerBanner(content) {
            const banner = document.createElement('div');
            banner.className = 'winner-banner';
            
            // Если передана строка - используем её как HTML, иначе это старый формат
            if (typeof content === 'string') {
                banner.innerHTML = content;
            } else {
                // Старый формат (для обратной совместимости с checkCompetitionWinner)
                banner.innerHTML = `
                    <h2>🏆 Победа!</h2>
                    <p>Команда ${content + 1} победила!</p>
                    <p style="margin-top:10px; font-size:14px;">Клеток: ${teamScores[content]}</p>
                    <button onclick="this.parentElement.remove()" style="margin-top:15px;">
                        ✖️ Закрыть
                    </button>
                `;
            }
            
            document.body.appendChild(banner);
            
            // Автоудаление через 30 секунд (больше времени для чтения результатов)
            setTimeout(() => {
                if (banner.parentElement) banner.remove();
            }, 30000);
        }

        // ========== ГЕКСАГОНАЛЬНАЯ СЕТКА ==========

        function initHexagonalGrid() {
            // Для гексагональной сетки используем правила B2/S34
            // (рождение при 2 соседях, выживание при 3-4 соседях)
            // Это классические правила для гексагональной топологии
            
            currentRules = {
                birth: [2],
                survival: [3, 4]
            };
            
            updateRulesLegend();
            showNotification('⬡ Гексагональная сетка! Правила: B2/S34 (оптимальны для 6 соседей)');
        }

        // Подсчёт соседей для гексагональной сетки
        function countNeighborsHexagonal(row, col) {
            let count = 0;
            let hues = [];
            
            // Гексагональная сетка: соседи зависят от чётности строки
            const isEvenRow = row % 2 === 0;
            
            const neighbors = isEvenRow ? [
                [-1, -1], [-1, 0],  // Верхние
                [0, -1],  [0, 1],   // Боковые
                [1, -1],  [1, 0]    // Нижние
            ] : [
                [-1, 0],  [-1, 1],  // Верхние
                [0, -1],  [0, 1],   // Боковые
                [1, 0],   [1, 1]    // Нижние
            ];
            
            neighbors.forEach(([di, dj]) => {
                let newRow, newCol;
                
                if (useWrapAround) {
                    // Торроидальное поле
                    newRow = (row + di + rows) % rows;
                    newCol = (col + dj + cols) % cols;
                } else {
                    // Поле с границами
                    newRow = row + di;
                    newCol = col + dj;
                    
                    if (newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols) {
                        return; // Пропускаем клетки за границей
                    }
                }
                
                if (grid[newRow][newCol].alive) {
                    count++;
                    hues.push(grid[newRow][newCol].hue);
                }
            });
            
            // Вычисляем средний оттенок
            if (hues.length > 0) {
                const avgHue = averageHue(hues);
                return { count, avgHue };
            }
            
            return { count, avgHue: 0 };
        }

        // Отрисовка гексагональной сетки
        function drawHexagonalGrid() {
            ctx.fillStyle = currentTheme === 'dark' ? '#0a0a0a' : '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoomLevel, zoomLevel);
            
            const hexRadius = cellSize / 2;
            const hexHeight = hexRadius * Math.sqrt(3);
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = grid[i][j];
                    
                    if (!cell.alive) continue;
                    
                    // Смещение для чётных рядов
                    const xOffset = (i % 2) * (hexRadius * 1.5);
                    const x = j * hexRadius * 3 + xOffset;
                    const y = i * hexHeight;
                    
                    ctx.fillStyle = `hsl(${cell.hue}, ${colorSaturation}%, ${colorBrightness}%)`;
                    
                    // Рисуем гексагон
                    ctx.beginPath();
                    for (let angle = 0; angle < 6; angle++) {
                        const pointAngle = (angle * 60 - 90) * Math.PI / 180;
                        const px = x + hexRadius * Math.cos(pointAngle);
                        const py = y + hexRadius * Math.sin(pointAngle);
                        
                        if (angle === 0) {
                            ctx.moveTo(px, py);
                        } else {
                            ctx.lineTo(px, py);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }

        // ========== ТРЕУГОЛЬНАЯ СЕТКА ==========

        function initTriangularGrid() {
            // Для треугольной сетки с 12 соседями используем B34/S456
            // Рождение при 3-4, выживание при 4-5-6
            
            currentRules = {
                birth: [3, 4],
                survival: [4, 5, 6]
            };
            
            updateRulesLegend();
            showNotification('△ Треугольная сетка! Правила: B34/S456 (оптимальны для 12 соседей)');
        }

        // Подсчёт соседей для треугольной сетки
        function countNeighborsTriangular(row, col) {
            let count = 0;
            let hues = [];
            
            // Треугольная сетка: 12 соседей
            // Треугольники чередуются: вершиной вверх/вниз
            const pointUp = (row + col) % 2 === 0;
            
            let neighbors;
            if (pointUp) {
                // Треугольник вершиной вверх: 3 примыкающих + 9 по вершинам
                neighbors = [
                    // 3 примыкающих ребра
                    [-1, 0], [0, -1], [0, 1],
                    // 9 по вершинам (3 группы по 3)
                    [-1, -1], [-1, 1],
                    [1, -1], [1, 0], [1, 1],
                    [-2, -1], [-2, 0], [-2, 1]
                ];
            } else {
                // Треугольник вершиной вниз
                neighbors = [
                    // 3 примыкающих ребра
                    [1, 0], [0, -1], [0, 1],
                    // 9 по вершинам
                    [-1, -1], [-1, 0], [-1, 1],
                    [1, -1], [1, 1],
                    [2, -1], [2, 0], [2, 1]
                ];
            }
            
            neighbors.forEach(([di, dj]) => {
                let newRow, newCol;
                
                if (useWrapAround) {
                    newRow = (row + di + rows) % rows;
                    newCol = (col + dj + cols) % cols;
                } else {
                    newRow = row + di;
                    newCol = col + dj;
                    
                    if (newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols) {
                        return;
                    }
                }
                
                if (grid[newRow][newCol].alive) {
                    count++;
                    hues.push(grid[newRow][newCol].hue);
                }
            });
            
            // Вычисляем средний оттенок
            if (hues.length > 0) {
                const avgHue = averageHue(hues);
                return { count, avgHue };
            }
            
            return { count, avgHue: 0 };
        }

        // Отрисовка треугольной сетки
        function drawTriangularGrid() {
            ctx.fillStyle = currentTheme === 'dark' ? '#0a0a0a' : '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoomLevel, zoomLevel);
            
            const triSize = cellSize;
            const triHeight = triSize * Math.sqrt(3) / 2;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = grid[i][j];
                    
                    if (!cell.alive) continue;
                    
                    const x = j * triSize;
                    const y = i * triHeight;
                    
                    // Чередуем направление треугольников
                    const pointUp = (i + j) % 2 === 0;
                    
                    ctx.fillStyle = `hsl(${cell.hue}, ${colorSaturation}%, ${colorBrightness}%)`;
                    ctx.beginPath();
                    
                    if (pointUp) {
                        ctx.moveTo(x + triSize / 2, y);
                        ctx.lineTo(x, y + triHeight);
                        ctx.lineTo(x + triSize, y + triHeight);
                    } else {
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + triSize, y);
                        ctx.lineTo(x + triSize / 2, y + triHeight);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }

        // ========== РЕЖИМ ЭВОЛЮЦИИ ==========

        function updateGridEvolution() {
            birthsThisGen = 0;
            deathsThisGen = 0;
            generation++;
            
            // Стандартное обновление
            const newGrid = [];
            const newAges = [];
            const fitnessScores = [];
            
            // Вычисляем fitness для каждой клетки
            for (let i = 0; i < rows; i++) {
                fitnessScores[i] = [];
                for (let j = 0; j < cols; j++) {
                    fitnessScores[i][j] = calculateFitness(i, j);
                }
            }
            
            // Обновление с учётом эволюционного давления
            for (let i = 0; i < rows; i++) {
                newGrid[i] = [];
                newAges[i] = [];
                
                for (let j = 0; j < cols; j++) {
                    const { count: neighbors } = countNeighbors(i, j);
                    const wasAlive = grid[i][j].alive;
                    const fitness = fitnessScores[i][j];
                    
                    let willBeAlive = false;
                    
                    // Правила с модификацией на основе fitness
                    if (wasAlive) {
                        willBeAlive = neighbors === 2 || neighbors === 3;
                        // Дополнительный шанс выживания для высокого fitness
                        if (!willBeAlive && fitness > 0.7 && Math.random() < evolutionMutation) {
                            willBeAlive = true;
                        }
                    } else {
                        willBeAlive = neighbors === 3;
                        // Мутация: рождение с вероятностью
                        if (!willBeAlive && Math.random() < evolutionMutation * 0.1) {
                            willBeAlive = true;
                        }
                    }
                    
                    newGrid[i][j] = {
                        alive: willBeAlive,
                        hue: willBeAlive ? (grid[i][j].hue + Math.random() * 10 - 5) % 360 : grid[i][j].hue,
                        trailStrength: grid[i][j].trailStrength * 0.9
                    };
                    
                    newAges[i][j] = willBeAlive ? (wasAlive ? cellAges[i][j] + 1 : 0) : 0;
                    
                    if (willBeAlive && !wasAlive) birthsThisGen++;
                    if (!willBeAlive && wasAlive) deathsThisGen++;
                }
            }
            
            grid = newGrid;
            cellAges = newAges;
            
            drawGrid();
            updateStats();
        }

        // Расчёт fitness клетки
        function calculateFitness(row, col) {
            if (!grid[row][col].alive) return 0;
            
            let fitness = 0;
            
            // Факторы fitness:
            // 1. Возраст (старые клетки более fit)
            fitness += Math.min(cellAges[row][col] / 50, 0.3);
            
            // 2. Количество соседей (оптимально 2-3)
            const { count: neighbors } = countNeighbors(row, col);
            if (neighbors === 2 || neighbors === 3) {
                fitness += 0.4;
            }
            
            // 3. Стабильность локальной области
            let stableNeighbors = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const ni = row + i;
                    const nj = col + j;
                    if (ni >= 0 && ni < rows && nj >= 0 && nj < cols) {
                        if (cellAges[ni][nj] > 5) stableNeighbors++;
                    }
                }
            }
            fitness += (stableNeighbors / 9) * 0.3;
            
            return Math.min(fitness, 1.0);
        }

        // Обработчики слайдеров эволюции
        document.getElementById('evolutionMutationSlider')?.addEventListener('input', (e) => {
            evolutionMutation = parseInt(e.target.value) / 100;
            document.getElementById('evolutionMutationValue').textContent = e.target.value + '%';
        });

        document.getElementById('selectionPressureSlider')?.addEventListener('input', (e) => {
            selectionPressure = parseInt(e.target.value) / 100;
            document.getElementById('selectionPressureValue').textContent = e.target.value + '%';
        });

        // ========== КВАНТОВЫЙ РЕЖИМ ==========

        function initQuantumMode() {
            // Инициализация квантовой суперпозиции
            quantumSuperposition = [];
            quantumPhases = []; // Новый массив для фаз
            quantumEntanglement = []; // Новый массив для запутанности
            
            for (let i = 0; i < rows; i++) {
                quantumSuperposition[i] = [];
                quantumPhases[i] = [];
                quantumEntanglement[i] = [];
                
                for (let j = 0; j < cols; j++) {
                    quantumSuperposition[i][j] = grid[i][j].alive ? 1.0 : 0.0;
                    quantumPhases[i][j] = Math.random() * Math.PI * 2; // Случайная фаза
                    quantumEntanglement[i][j] = Math.random() * 0.3; // Степень запутанности
                }
            }
            
            showNotification('⚛️ Квантовый режим: суперпозиция, интерференция, запутанность активированы!');
        }

        function updateGridQuantum() {
            birthsThisGen = 0;
            deathsThisGen = 0;
            generation++;
            
            const newSuperposition = [];
            const newPhases = [];
            const newEntanglement = [];
            const newGrid = [];
            
            for (let i = 0; i < rows; i++) {
                newSuperposition[i] = [];
                newPhases[i] = [];
                newEntanglement[i] = [];
                newGrid[i] = [];
                
                for (let j = 0; j < cols; j++) {
                    const { count: neighbors } = countNeighbors(i, j);
                    const currentProb = quantumSuperposition[i][j];
                    const currentPhase = quantumPhases[i][j];
                    const entanglement = quantumEntanglement[i][j];
                    
                    // === КВАНТОВАЯ ЭВОЛЮЦИЯ ===
                    
                    // 1. Базовая эволюция вероятности (как в классическом GoL)
                    let newProb = 0;
                    
                    if (currentProb > 0.5) {
                        // "Живая" клетка
                        if (neighbors === 2 || neighbors === 3) {
                            newProb = Math.min(currentProb + 0.1, 1.0);
                        } else {
                            newProb = Math.max(currentProb - 0.2, 0.0);
                        }
                    } else {
                        // "Мёртвая" клетка
                        if (neighbors === 3) {
                            newProb = Math.min(currentProb + 0.3, 1.0);
                        } else {
                            newProb = Math.max(currentProb - 0.05, 0.0);
                        }
                    }
                    
                    // 2. Квантовые флуктуации (используем настраиваемый параметр)
                    newProb += (Math.random() - 0.5) * quantumFluctuation;
                    newProb = Math.max(0, Math.min(1, newProb));
                    
                    // 3. Квантовая интерференция (фазы соседей влияют)
                    let phaseInterference = 0;
                    let entanglementEffect = 0;
                    
                    for (let di = -1; di <= 1; di++) {
                        for (let dj = -1; dj <= 1; dj++) {
                            if (di === 0 && dj === 0) continue;
                            
                            let ni, nj;
                            if (useWrapAround) {
                                ni = (i + di + rows) % rows;
                                nj = (j + dj + cols) % cols;
                            } else {
                                ni = i + di;
                                nj = j + dj;
                                if (ni < 0 || ni >= rows || nj < 0 || nj >= cols) continue;
                            }
                            
                            // Интерференция на основе разности фаз (используем настраиваемый параметр)
                            const phaseDiff = quantumPhases[ni][nj] - currentPhase;
                            phaseInterference += Math.cos(phaseDiff) * quantumSuperposition[ni][nj] * quantumInterference;
                            
                            // Запутанность: если сосед запутан, влияет сильнее (используем настраиваемый параметр)
                            entanglementEffect += quantumEntanglement[ni][nj] * quantumSuperposition[ni][nj] * quantumEntanglementBase;
                        }
                    }
                    
                    newProb += phaseInterference + entanglementEffect;
                    newProb = Math.max(0, Math.min(1, newProb));
                    
                    // 4. Эволюция фазы
                    let newPhase = currentPhase + 0.1 + (Math.random() - 0.5) * 0.3;
                    
                    // Фаза зависит от окружения
                    if (neighbors > 0) {
                        newPhase += neighbors * 0.05;
                    }
                    
                    // Нормализуем фазу
                    newPhase = newPhase % (Math.PI * 2);
                    
                    // 5. Эволюция запутанности
                    let newEnt = entanglement;
                    
                    // Запутанность растёт при наличии соседей
                    if (neighbors > 0) {
                        newEnt = Math.min(entanglement + 0.02, 0.8);
                    } else {
                        // Декогеренция при изоляции
                        newEnt = Math.max(entanglement - 0.05, 0.1);
                    }
                    
                    // Сохраняем новые значения
                    newSuperposition[i][j] = newProb;
                    newPhases[i][j] = newPhase;
                    newEntanglement[i][j] = newEnt;
                    
                    // === КОЛЛАПС ВОЛНОВОЙ ФУНКЦИИ для отображения ===
                    const willBeAlive = newProb > 0.5;
                    
                    // ЦВЕТ зависит от нескольких параметров:
                    // - Вероятность (основной оттенок)
                    // - Фаза (сдвиг оттенка)
                    // - Запутанность (насыщенность)
                    
                    const baseHue = 200 + newProb * 160; // 200-360 (голубой через фиолетовый к красному)
                    const phaseShift = (newPhase / (Math.PI * 2)) * 60; // Фаза добавляет до 60 градусов
                    const hue = (baseHue + phaseShift) % 360;
                    
                    const saturation = 50 + newEnt * 50; // Запутанность влияет на насыщенность (50-100%)
                    const lightness = 40 + newProb * 30; // Вероятность влияет на яркость (40-70%)
                    
                    newGrid[i][j] = {
                        alive: willBeAlive,
                        hue: hue,
                        trailStrength: newProb * 0.5,
                        // Дополнительная информация для визуализации
                        quantumProb: newProb,
                        quantumPhase: newPhase,
                        quantumEnt: newEnt
                    };
                    
                    if (willBeAlive && !grid[i][j].alive) birthsThisGen++;
                    if (!willBeAlive && grid[i][j].alive) deathsThisGen++;
                }
            }
            
            quantumSuperposition = newSuperposition;
            quantumPhases = newPhases;
            quantumEntanglement = newEntanglement;
            grid = newGrid;
            
            drawGrid();
            updateStats();
        }

        // ========== МОБИЛЬНОЕ УПРАВЛЕНИЕ ==========

        function toggleMobileMenu() {
            isMobileMenuOpen = !isMobileMenuOpen;
            const menu = document.getElementById('mobileMenu');
            const overlay = document.getElementById('mobileMenuOverlay');
            
            if (isMobileMenuOpen) {
                // Перемещаем контент в мобильное меню
                moveControlsToMobile();
                menu.classList.add('active');
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            } else {
                menu.classList.remove('active');
                overlay.classList.remove('active');
                document.body.style.overflow = '';
            }
        }

        function moveControlsToMobile() {
            const mobileContent = document.getElementById('mobileMenuContent');
            const controlsWrapper = document.querySelector('.controls-wrapper');
            
            // Клонируем контент, если ещё не клонирован
            if (mobileContent.children.length === 0 && controlsWrapper) {
                const clone = controlsWrapper.cloneNode(true);
                clone.style.display = 'flex';
                mobileContent.appendChild(clone);
                
                // Переназначаем обработчики событий для клонированных элементов
                reassignEventHandlers(clone);
            }
        }

        function reassignEventHandlers(element) {
            // Обработчики для слайдеров
            const sliders = element.querySelectorAll('input[type="range"]');
            sliders.forEach(slider => {
                const originalId = slider.id;
                if (originalId) {
                    slider.addEventListener('input', (e) => {
                        // Синхронизируем с оригинальным слайдером
                        const original = document.getElementById(originalId);
                        if (original && original !== slider) {
                            original.value = e.target.value;
                            original.dispatchEvent(new Event('input'));
                        }
                    });
                }
            });
        }

        // Полноэкранный режим
        function toggleFullscreen() {
            const container = document.querySelector('.game-canvas-wrapper');
            
            if (!isFullscreen) {
                // Входим в полноэкранный режим
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                } else if (container.mozRequestFullScreen) {
                    container.mozRequestFullScreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
                
                document.body.classList.add('fullscreen-mode');
                document.getElementById('fullscreenBtn').textContent = '⛶';
                isFullscreen = true;
            } else {
                // Выходим из полноэкранного режима
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                
                document.body.classList.remove('fullscreen-mode');
                document.getElementById('fullscreenBtn').textContent = '⛶';
                isFullscreen = false;
            }
        }

        // Слушатель изменения полноэкранного режима
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);

        function handleFullscreenChange() {
            const isCurrentlyFullscreen = !!(document.fullscreenElement || 
                                             document.webkitFullscreenElement || 
                                             document.mozFullScreenElement || 
                                             document.msFullscreenElement);
            
            if (!isCurrentlyFullscreen) {
                document.body.classList.remove('fullscreen-mode');
                isFullscreen = false;
            }
        }

        // ========== TOUCH СОБЫТИЯ ==========

        // Touch Start
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            
            const touches = e.touches;
            touchIdentifiers = Array.from(touches).map(t => t.identifier);
            
            if (touches.length === 1) {
                // Одно касание - рисование или двойной тап
                const touch = touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartTime = Date.now();
                
                // Проверка на двойной тап
                const currentTime = Date.now();
                if (currentTime - lastTapTime < 300) {
                    handleDoubleTap(touch);
                }
                lastTapTime = currentTime;
                
                // Начинаем рисование
                const pos = getTouchCellPos(touch);
                if (pos.row >= 0 && pos.row < rows && pos.col >= 0 && pos.col < cols) {
                    isDrawing = true;
                    lastPos = pos;
                    
                    if (['line', 'rectangle', 'circle'].includes(currentTool)) {
                        shapeStart = pos;
                    }
                    
                    if (currentTool === 'stamp' && !stampData) {
                        stampSelecting = true;
                        stampStart = pos;
                    }
                    
                    handleTouchDrawing(touch);
                }
                
            } else if (touches.length === 2) {
                // Два касания - pinch to zoom или pan
                isTouchPinching = true;
                const distance = getTouchDistance(touches[0], touches[1]);
                touchStartDistance = distance;
                lastTouchDistance = distance;
                
                // Центр между двумя пальцами
                const centerX = (touches[0].clientX + touches[1].clientX) / 2;
                const centerY = (touches[0].clientY + touches[1].clientY) / 2;
                touchStartX = centerX;
                touchStartY = centerY;
                
                showGestureIndicator(' Pinch to Zoom');
            }
        }, { passive: false });

        // Touch Move
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            const touches = e.touches;
            
            if (touches.length === 1 && isDrawing && !isTouchPinching) {
                // Рисование
                handleTouchDrawing(touches[0]);
                
            } else if (touches.length === 2 && isTouchPinching) {
                // Pinch zoom
                const distance = getTouchDistance(touches[0], touches[1]);
                const scale = distance / lastTouchDistance;
                
                // Zoom
                const centerX = (touches[0].clientX + touches[1].clientX) / 2;
                const centerY = (touches[0].clientY + touches[1].clientY) / 2;
                const rect = canvas.getBoundingClientRect();
                const canvasX = centerX - rect.left;
                const canvasY = centerY - rect.top;
                
                if (Math.abs(scale - 1) > 0.01) {
                    const delta = scale > 1 ? 1 : -1;
                    zoom(delta * 0.5, canvasX, canvasY);
                }
                
                lastTouchDistance = distance;
                
                // Pan
                const deltaX = centerX - touchStartX;
                const deltaY = centerY - touchStartY;
                
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                    offsetX += deltaX;
                    offsetY += deltaY;
                    touchStartX = centerX;
                    touchStartY = centerY;
                    drawGrid();
                    updateMinimap();
                }
            }
        }, { passive: false });

        // Touch End
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            const touches = e.changedTouches;
            
            if (isDrawing) {
                // Завершение рисования
                const touch = touches[0];
                const pos = getTouchCellPos(touch);
                
                if (currentTool === 'line' && shapeStart) {
                    drawLine(shapeStart.row, shapeStart.col, pos.row, pos.col);
                    shapeStart = null;
                }
                
                if (currentTool === 'rectangle' && shapeStart) {
                    const hue = Math.random() * 360;
                    drawRectangle(shapeStart.row, shapeStart.col, pos.row, pos.col, true, hue);
                    drawGrid();
                    shapeStart = null;
                }
                
                if (currentTool === 'circle' && shapeStart) {
                    const hue = Math.random() * 360;
                    drawCircle(shapeStart.row, shapeStart.col, pos.row, pos.col, true, hue);
                    drawGrid();
                    shapeStart = null;
                }
                
                if (currentTool === 'stamp' && stampSelecting && stampStart) {
                    copyStamp(stampStart.row, stampStart.col, pos.row, pos.col);
                    stampSelecting = false;
                    stampStart = null;
                }
                
                isDrawing = false;
                lastPos = null;
                updateStats();
            }
            
            if (e.touches.length === 0) {
                isTouchPinching = false;
                isTouchPanning = false;
                hideGestureIndicator();
            }
        }, { passive: false });

        // Touch Cancel
        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            isDrawing = false;
            isTouchPinching = false;
            isTouchPanning = false;
            hideGestureIndicator();
        }, { passive: false });

        // Вспомогательные функции для touch
        function getTouchCellPos(touch) {
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            const worldX = (x - offsetX) / zoomLevel;
            const worldY = (y - offsetY) / zoomLevel;
            
            return {
                row: Math.floor(worldY / cellSize),
                col: Math.floor(worldX / cellSize)
            };
        }

        function getTouchDistance(touch1, touch2) {
            const dx = touch2.clientX - touch1.clientX;
            const dy = touch2.clientY - touch1.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function handleTouchDrawing(touch) {
            const pos = getTouchCellPos(touch);
            
            if (pos.row < 0 || pos.row >= rows || pos.col < 0 || pos.col >= cols) return;
            
            const isEraser = currentTool === 'eraser';
            const hue = isEraser ? 0 : Math.random() * 360;
            
            switch (currentTool) {
                case 'brush':
                case 'eraser':
                    applyMirrorDrawing(pos.row, pos.col, !isEraser, hue);
                    break;
                    
                case 'fill':
                    if (isDrawing) {
                        isDrawing = false;
                        floodFill(pos.row, pos.col, true, hue);
                    }
                    break;
                    
                case 'line':
                    if (shapeStart) {
                        drawGrid();
                        drawTemporaryLine(shapeStart.row, shapeStart.col, pos.row, pos.col);
                    }
                    break;
                    
                case 'rectangle':
                    if (shapeStart) {
                        drawGrid();
                        drawTemporaryRectangle(shapeStart.row, shapeStart.col, pos.row, pos.col);
                    }
                    break;
                    
                case 'circle':
                    if (shapeStart) {
                        drawGrid();
                        drawTemporaryCircle(shapeStart.row, shapeStart.col, pos.row, pos.col);
                    }
                    break;
                    
                case 'stamp':
                    if (stampData && !stampSelecting) {
                        pasteStamp(pos.row, pos.col);
                    } else if (stampSelecting && stampStart) {
                        drawGrid();
                        drawTemporaryRectangle(stampStart.row, stampStart.col, pos.row, pos.col);
                    }
                    break;
            }
            
            lastPos = pos;
            updateStats();
            if (particleEffects && !wasAlive && willBeAlive) {
            vibrate(5); }
        }

        function handleDoubleTap(touch) {
            // Двойной тап для zoom in
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            zoom(1, x, y);
            showGestureIndicator(' Zoom In');
        }

        function showGestureIndicator(text) {
            const indicator = document.getElementById('gestureIndicator');
            const textEl = document.getElementById('gestureText');
            
            if (indicator && textEl) {
                textEl.textContent = text;
                indicator.style.display = 'block';
                
                clearTimeout(window.gestureIndicatorTimeout);
                window.gestureIndicatorTimeout = setTimeout(() => {
                    hideGestureIndicator();
                }, 1500);
            }
        }

        function hideGestureIndicator() {
            const indicator = document.getElementById('gestureIndicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }

        // ========== МОБИЛЬНАЯ ОПТИМИЗАЦИЯ ==========

        // Определение мобильного устройства
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // Оптимизация производительности для мобильных
        function optimizeForMobile() {
            if (isMobileDevice()) {
                // Уменьшаем размер сетки для лучшей производительности
                const maxCells = 5000;
                const currentCells = rows * cols;
                
                if (currentCells > maxCells) {
                    const scale = Math.sqrt(maxCells / currentCells);
                    cellSize = Math.ceil(cellSize / scale);
                }
                
                // Отключаем некоторые эффекты
                if (particleEffects) {
                    particleEffects = false;
                    document.getElementById('particleMode').value = 0;
                    document.getElementById('particleValue').textContent = 'ВЫКЛ';
                }
                
                // Уменьшаем количество шлейфов
                if (settings.showTrails) {
                    // Можно отключить или уменьшить
                }
                
                // Отключаем мини-карту по умолчанию
                if (minimapVisible) {
                    toggleMinimap();
                }
            }
        }

        // Адаптация размера canvas под ориентацию
        function handleOrientationChange() {
            setTimeout(() => {
                resizeCanvas();
                drawGrid();
                if (minimapVisible) updateMinimap();
            }, 200);
        }

        // Слушатель изменения ориентации
        window.addEventListener('orientationchange', handleOrientationChange);
        window.addEventListener('resize', () => {
            if (isMobileDevice()) {
                handleOrientationChange();
            }
        });

        // Предотвращение bounce эффекта на iOS
        document.addEventListener('touchmove', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });

        // Предотвращение контекстного меню на длинном нажатии
        canvas.addEventListener('contextmenu', (e) => {
            if (isMobileDevice()) {
                e.preventDefault();
            }
        });

        // ========== ВИБРАЦИЯ (HAPTIC FEEDBACK) ==========

        function vibrate(pattern = 10) {
            if ('vibrate' in navigator && isMobileDevice()) {
                navigator.vibrate(pattern);
            }
        }

        // ========== SWIPE ЖЕСТЫ ==========

        let swipeStartX = 0;
        let swipeStartY = 0;
        let swipeEndX = 0;
        let swipeEndY = 0;
        const swipeThreshold = 50;

        document.addEventListener('touchstart', (e) => {
            if (e.target !== canvas) {
                const touch = e.touches[0];
                swipeStartX = touch.clientX;
                swipeStartY = touch.clientY;
            }
        }, { passive: true });

        document.addEventListener('touchend', (e) => {
            if (e.target !== canvas) {
                const touch = e.changedTouches[0];
                swipeEndX = touch.clientX;
                swipeEndY = touch.clientY;
                handleSwipe();
            }
        }, { passive: true });

        function handleSwipe() {
            const deltaX = swipeEndX - swipeStartX;
            const deltaY = swipeEndY - swipeStartY;
            
            if (Math.abs(deltaX) < swipeThreshold && Math.abs(deltaY) < swipeThreshold) {
                return;
            }
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Горизонтальный swipe
                if (deltaX > 0) {
                    // Swipe right - открыть меню
                    if (!isMobileMenuOpen) {
                        toggleMobileMenu();
                    }
                } else {
                    // Swipe left - закрыть меню
                    if (isMobileMenuOpen) {
                        toggleMobileMenu();
                    }
                }
            } else {
                // Вертикальный swipe
                if (deltaY > 0) {
                    // Swipe down
                } else {
                    // Swipe up
                }
            }
        }

        // ========== ИНИЦИАЛИЗАЦИЯ АУДИО ==========

        function initAudio() {
            try {
                // Создаём AudioContext
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContextClass();
                
                // Создаём gain nodes для управления громкостью
                musicGainNode = audioContext.createGain();
                musicGainNode.gain.value = musicVolume;
                musicGainNode.connect(audioContext.destination);
                
                sfxGainNode = audioContext.createGain();
                sfxGainNode.gain.value = soundVolume;
                sfxGainNode.connect(audioContext.destination);
                
                return true;
            } catch (e) {
                console.error('Web Audio API не поддерживается:', e);
                return false;
            }
        }

        // Возобновление AudioContext (требуется для некоторых браузеров)
        function resumeAudioContext() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // ========== УПРАВЛЕНИЕ ЗВУКОМ ==========

        function toggleSound() {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('soundToggle');
            
            if (soundEnabled) {
                if (!audioContext) {
                    if (!initAudio()) {
                        soundEnabled = false;
                        showNotification('❌ Звук не поддерживается');
                        return;
                    }
                }
                resumeAudioContext();
                btn.textContent = ' Звук: ВКЛ';
                btn.classList.add('active');
                showSoundIndicator('');
                playUISound('enable');
            } else {
                btn.textContent = ' Звук: ВЫКЛ';
                btn.classList.remove('active');
                showSoundIndicator('');
            }
        }

        function toggleMusic() {
            musicEnabled = !musicEnabled;
            const btn = document.getElementById('musicToggle');
            const themesDiv = document.getElementById('musicThemes');
            
            if (musicEnabled) {
                if (!audioContext) {
                    if (!initAudio()) {
                        musicEnabled = false;
                        showNotification('❌ Музыка не поддерживается');
                        return;
                    }
                }
                resumeAudioContext();
                btn.textContent = ' Музыка: ВКЛ';
                btn.classList.add('active');
                themesDiv.style.display = 'block';
                startGenerativeMusic();
                showSoundIndicator('');
            } else {
                btn.textContent = ' Музыка: ВЫКЛ';
                btn.classList.remove('active');
                themesDiv.style.display = 'none';
                stopGenerativeMusic();
                showSoundIndicator('');
            }
        }

        function showSoundIndicator(icon) {
            const indicator = document.createElement('div');
            indicator.className = 'sound-indicator show';
            indicator.textContent = icon;
            document.body.appendChild(indicator);
            
            setTimeout(() => {
                indicator.classList.remove('show');
                setTimeout(() => indicator.remove(), 300);
            }, 500);
        }

        // ========== ЗВУКОВЫЕ ЭФФЕКТЫ ==========

        // Звук рождения клетки
        function playBirthSound(frequency = null) {
            if (!soundEnabled || !birthSoundEnabled || !audioContext) return;
            
            const freq = frequency || 440 + Math.random() * 220; // A4 - A5
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(soundVolume * 0.1, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.connect(gainNode);
            gainNode.connect(sfxGainNode);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        // Звук смерти клетки
        function playDeathSound() {
            if (!soundEnabled || !deathSoundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(55, audioContext.currentTime + 0.15);
            
            gainNode.gain.setValueAtTime(soundVolume * 0.08, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            oscillator.connect(gainNode);
            gainNode.connect(sfxGainNode);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
        }

        // Звук интерфейса
        function playUISound(type = 'click') {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'triangle';
            oscillator.connect(gainNode);
            gainNode.connect(sfxGainNode);
            
            switch(type) {
                case 'click':
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(soundVolume * 0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.05);
                    break;
                case 'enable':
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(900, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(soundVolume * 0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'success':
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.05);
                    oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(soundVolume * 0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
            }
        }

        // Амбиентный звук популяции
        function playAmbientSound() {
            if (!soundEnabled || !ambientSoundEnabled || !audioContext) return;
            
            const aliveCount = grid.flat().filter(cell => cell.alive).length;
            const density = aliveCount / (rows * cols);
            
            // Частота зависит от плотности
            const baseFreq = 100 + density * 300;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1000 + density * 2000, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(soundVolume * 0.05, audioContext.currentTime);
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(sfxGainNode);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // ========== ГЕНЕРАТИВНАЯ МУЗЫКА ==========

        function startGenerativeMusic() {
            if (!musicEnabled || !audioContext) return;
            
            stopGenerativeMusic(); // Остановить предыдущую музыку
            
            const scale = musicScales[currentMusicTheme];
            let noteIndex = 0;
            
            // Создаём базовую нотную последовательность
            const playNote = () => {
                if (!musicEnabled) return;
                
                const note = scale[noteIndex % scale.length];
                const octaveShift = Math.floor(noteIndex / scale.length) % 2;
                const frequency = note * (octaveShift === 0 ? 1 : 0.5);
                
                createMusicNote(frequency, 0.5);
                
                noteIndex++;
                
                // Следующая нота через случайный интервал
                const nextDelay = 200 + Math.random() * 400;
                setTimeout(playNote, nextDelay);
            };
            
            // Добавляем базовый дрон
            createDrone(scale[0]);
            
            // Запускаем мелодию
            playNote();
            
            // Амбиентные эффекты
            if (ambientSoundEnabled) {
                ambientInterval = setInterval(() => {
                    playAmbientSound();
                }, 2000);
            }
        }

        function stopGenerativeMusic() {
            // Останавливаем все осцилляторы
            musicOscillators.forEach(osc => {
                try {
                    osc.stop();
                } catch(e) {}
            });
            musicOscillators = [];
            
            if (ambientInterval) {
                clearInterval(ambientInterval);
                ambientInterval = null;
            }
        }

        function createMusicNote(frequency, duration) {
            if (!audioContext || !musicGainNode) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(musicVolume * 0.15, audioContext.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(musicGainNode);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
            
            musicOscillators.push(oscillator);
            
            // Очистка массива
            setTimeout(() => {
                const index = musicOscillators.indexOf(oscillator);
                if (index > -1) musicOscillators.splice(index, 1);
            }, duration * 1000 + 100);
        }

        function createDrone(frequency) {
            if (!audioContext || !musicGainNode) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(frequency * 0.5, audioContext.currentTime);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(500, audioContext.currentTime);
            filter.Q.setValueAtTime(5, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(musicVolume * 0.1, audioContext.currentTime);
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(musicGainNode);
            
            oscillator.start(audioContext.currentTime);
            
            musicOscillators.push(oscillator);
        }

        function setMusicTheme(theme) {
            currentMusicTheme = theme;
            
            // Обновление активной кнопки
            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Перезапуск музыки с новой темой
            if (musicEnabled) {
                stopGenerativeMusic();
                startGenerativeMusic();
            }
            
            playUISound('click');
            showNotification(` Тема: ${theme}`);
        }

        // ========== ВИЗУАЛИЗАЦИЯ ЗВУКА ==========

        function updateAudioVisualizer() {
            if (!musicEnabled || !audioContext) {
                document.getElementById('audioVisualizer').classList.remove('active');
                return;
            }
            
            document.getElementById('audioVisualizer').classList.add('active');
            
            const bars = document.querySelectorAll('.audio-bar');
            const aliveCount = grid.flat().filter(cell => cell.alive).length;
            const density = aliveCount / (rows * cols);
            
            bars.forEach((bar, index) => {
                const baseHeight = 5 + density * 30;
                const variation = Math.sin(Date.now() * 0.001 + index) * 10;
                const height = baseHeight + variation + Math.random() * 5;
                bar.style.height = Math.max(5, Math.min(40, height)) + 'px';
            });
        }

        // ========== УСТАНОВКА ПРАВИЛ ==========

        function setRule(ruleName) {
            currentRule = ruleName;
            
            // Обновление активной кнопки
            document.querySelectorAll('.rule-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const ruleBtn = document.getElementById('rule' + ruleName.charAt(0).toUpperCase() + ruleName.slice(1));
            if (ruleBtn) ruleBtn.classList.add('active');
            
            // Инициализация специальных правил
            if (ruleName === 'briansbrain') {
                initBriansBrain();
                showNotification('易 Brian\'s Brain: 3 состояния!');
            } else if (ruleName === 'wireworld') {
                initWireworld();
                showNotification(' Wireworld: электронные схемы!');
            } else if (ruleName === 'langton') {
                initLangtonAnt();
                showNotification(' Langton\'s Ant активирован!');
            } else {
                const rule = gameRules[ruleName];
                if (rule) {
                    showNotification(` Правило: ${rule.name}`);
                }
            }
            
            updateRulesLegend();
            playUISound('click');
        }

        // Применение пользовательского правила
        function applyCustomRule() {
            const birthInput = document.getElementById('customRuleBirth').value.trim();
            const surviveInput = document.getElementById('customRuleSurvive').value.trim();
            
            // Парсинг правил
            const birthNumbers = birthInput.replace(/[^0-9]/g, '').split('').map(n => parseInt(n));
            const surviveNumbers = surviveInput.replace(/[^0-9]/g, '').split('').map(n => parseInt(n));
            
            if (birthNumbers.length === 0 && surviveNumbers.length === 0) {
                showNotification('⚠️ Введите хотя бы одно число!');
                return;
            }
            
            customBirthRule = birthNumbers;
            customSurviveRule = surviveNumbers;
            gameRules.custom.birth = customBirthRule;
            gameRules.custom.survive = customSurviveRule;
            
            setRule('custom');
            showNotification(`✓ Правило: B${birthNumbers.join('')}/S${surviveNumbers.join('')}`);
        }

        // ========== BRIAN'S BRAIN ==========
        // Состояния: 0 = мёртвая, 1 = живая, 2 = умирающая

        function initBriansBrain() {
            cellStates = [];
            for (let i = 0; i < rows; i++) {
                cellStates[i] = [];
                for (let j = 0; j < cols; j++) {
                    cellStates[i][j] = grid[i][j].alive ? 1 : 0;
                }
            }
        }

        function updateGridBriansBrain() {
            generation++;
            
            const newStates = [];
            const newGrid = [];
            
            for (let i = 0; i < rows; i++) {
                newStates[i] = [];
                newGrid[i] = [];
                
                for (let j = 0; j < cols; j++) {
                    const currentState = cellStates[i][j];
                    let newState = 0;
                    
                    if (currentState === 0) {
                        // Мёртвая клетка рождается при 2 живых соседях
                        const liveNeighbors = countStateNeighbors(i, j, 1);
                        if (liveNeighbors === 2) {
                            newState = 1;
                        }
                    } else if (currentState === 1) {
                        // Живая клетка всегда переходит в умирающее состояние
                        newState = 2;
                    } else if (currentState === 2) {
                        // Умирающая клетка становится мёртвой
                        newState = 0;
                    }
                    
                    newStates[i][j] = newState;
                    
                    // Обновление grid для отображения
                    newGrid[i][j] = {
                        alive: newState > 0,
                        hue: newState === 1 ? 200 : newState === 2 ? 0 : grid[i][j].hue,
                        trailStrength: 0
                    };
                }
            }
            
            cellStates = newStates;
            grid = newGrid;
            
            drawGrid();
            updateStats();
        }

        function countStateNeighbors(row, col, targetState) {
            let count = 0;
            
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    
                    const newRow = row + i;
                    const newCol = col + j;
                    
                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                        if (cellStates[newRow][newCol] === targetState) count++;
                    }
                }
            }
            
            return count;
        }

        // ========== WIREWORLD ==========
        // Состояния: 0 = пусто, 1 = проводник, 2 = электронная голова, 3 = электронный хвост

        function initWireworld() {
            cellStates = [];
            for (let i = 0; i < rows; i++) {
                cellStates[i] = [];
                for (let j = 0; j < cols; j++) {
                    cellStates[i][j] = grid[i][j].alive ? 1 : 0;
                }
            }
            
            // Создаём простую схему для демонстрации
            createWireworldDemo();
        }

        function createWireworldDemo() {
            // Очистка
            initGrid();
            
            const centerRow = Math.floor(rows / 2);
            const centerCol = Math.floor(cols / 2);
            
            // Горизонтальный провод
            for (let j = centerCol - 20; j <= centerCol + 20; j++) {
                if (j >= 0 && j < cols) {
                    cellStates[centerRow][j] = 1; // Проводник
                    grid[centerRow][j].alive = true;
                    grid[centerRow][j].hue = 60;
                }
            }
            
            // Электроны
            if (centerCol - 15 >= 0) {
                cellStates[centerRow][centerCol - 15] = 2; // Голова
                grid[centerRow][centerCol - 15].hue = 200;
            }
            if (centerCol - 16 >= 0) {
                cellStates[centerRow][centerCol - 16] = 3; // Хвост
                grid[centerRow][centerCol - 16].hue = 0;
            }
            
            drawGrid();
        }

        function updateGridWireworld() {
            generation++;
            
            const newStates = [];
            const newGrid = [];
            
            for (let i = 0; i < rows; i++) {
                newStates[i] = [];
                newGrid[i] = [];
                
                for (let j = 0; j < cols; j++) {
                    const currentState = cellStates[i][j];
                    let newState = currentState;
                    
                    if (currentState === 0) {
                        // Пусто остаётся пустым
                        newState = 0;
                    } else if (currentState === 1) {
                        // Проводник становится головой, если рядом 1-2 головы
                        const heads = countStateNeighbors(i, j, 2);
                        if (heads === 1 || heads === 2) {
                            newState = 2;
                        }
                    } else if (currentState === 2) {
                        // Голова всегда становится хвостом
                        newState = 3;
                    } else if (currentState === 3) {
                        // Хвост всегда становится проводником
                        newState = 1;
                    }
                    
                    newStates[i][j] = newState;
                    
                    // Цвета для разных состояний
                    const stateColors = {
                        0: 0,     // Пусто
                        1: 60,    // Проводник (жёлтый)
                        2: 200,   // Голова (синий)
                        3: 0      // Хвост (красный)
                    };
                    
                    newGrid[i][j] = {
                        alive: newState > 0,
                        hue: stateColors[newState],
                        trailStrength: 0
                    };
                }
            }
            
            cellStates = newStates;
            grid = newGrid;
            
            drawGrid();
            updateStats();
        }

        // ========== LANGTON'S ANT ==========

        function initLangtonAnt() {
            // Очистка поля
            initGrid();
            
            // Создаём муравья в центре
            langtonAnts = [{
                row: Math.floor(rows / 2),
                col: Math.floor(cols / 2),
                direction: 0 // 0=вверх, 1=право, 2=вниз, 3=лево
            }];
            
            drawGrid();
        }

        function updateGridLangtonAnt() {
            generation++;
            
            langtonAnts.forEach(ant => {
                const currentCell = grid[ant.row][ant.col];
                
                // Правило: на белой клетке поворот направо, на чёрной - налево
                if (currentCell.alive) {
                    // Чёрная клетка - поворот налево
                    ant.direction = (ant.direction + 3) % 4;
                    currentCell.alive = false;
                    currentCell.hue = 0;
                } else {
                    // Белая клетка - поворот направо
                    ant.direction = (ant.direction + 1) % 4;
                    currentCell.alive = true;
                    currentCell.hue = Math.random() * 360;
                }
                
                // Движение вперёд
                switch(ant.direction) {
                    case 0: ant.row--; break; // Вверх
                    case 1: ant.col++; break; // Право
                    case 2: ant.row++; break; // Вниз
                    case 3: ant.col--; break; // Лево
                }
                
                // Обработка границ (wrap around)
                if (ant.row < 0) ant.row = rows - 1;
                if (ant.row >= rows) ant.row = 0;
                if (ant.col < 0) ant.col = cols - 1;
                if (ant.col >= cols) ant.col = 0;
            });
            
            drawGrid();
            
            // Рисуем муравьёв поверх
            drawAnts();
            
            updateStats();
        }

        function drawAnts() {
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoomLevel, zoomLevel);
            
            langtonAnts.forEach(ant => {
                const x = ant.col * cellSize + cellSize / 2;
                const y = ant.row * cellSize + cellSize / 2;
                
                // Рисуем муравья как треугольник
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                
                const size = cellSize * 0.4;
                const angle = ant.direction * Math.PI / 2 - Math.PI / 2;
                
                ctx.moveTo(x + Math.cos(angle) * size, y + Math.sin(angle) * size);
                ctx.lineTo(x + Math.cos(angle + 2.5) * size, y + Math.sin(angle + 2.5) * size);
                ctx.lineTo(x + Math.cos(angle - 2.5) * size, y + Math.sin(angle - 2.5) * size);
                ctx.closePath();
                ctx.fill();
            });
            
            ctx.restore();
        }

        // ============================================
        // 3. ФУНКЦИЯ АДАПТИВНОГО РАЗМЕРА (ПОСЛЕ ПЕРЕМЕННЫХ!)
        // ============================================
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            const isMobile = window.innerWidth < 600;
            
            // Для мобильных - квадрат, для десктопа - 4:3
            const aspectRatio = isMobile ? 1 : 4/3;
            const canvasWidth = Math.min(containerWidth, isMobile ? 600 : 800);
            const canvasHeight = canvasWidth / aspectRatio;

             // Игнорируем незначительные изменения (меньше размера клетки)
            const widthDiff = Math.abs(canvas.width - canvasWidth);
            const heightDiff = Math.abs(canvas.height - canvasHeight);
            
            if (widthDiff < cellSize && heightDiff < cellSize) {
                // Изменение незначительное (прокрутка с изменением UI браузера)
                // НЕ пересоздаем сетку!
                return;
            }
            
            // Сохраняем старую сетку перед изменением размера
            const oldGrid = grid.length > 0 ? JSON.parse(JSON.stringify(grid)) : null;
            const oldCols = cols;
            const oldRows = rows;
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // Пересчитываем размеры сетки
            const wasRunning = running; // Теперь running уже объявлена!
            running = false;
            clearInterval(intervalId);
            
            initGrid();

            // ВОССТАНАВЛИВАЕМ старое состояние насколько возможно
            if (oldGrid) {
                for (let i = 0; i < Math.min(rows, oldRows); i++) {
                    for (let j = 0; j < Math.min(cols, oldCols); j++) {
                        grid[i][j] = oldGrid[i][j];
                    }
                }
            }

            drawGrid();

            // Обновляем мини-карту
            if (minimapCanvas) {
                const mmContainer = document.getElementById('minimapContainer');
                minimapCanvas.width = mmContainer.clientWidth;
                minimapCanvas.height = mmContainer.clientHeight;
                updateMinimap();
            }
            
            if (wasRunning) {
                running = true;
                intervalId = setInterval(gameLoop, 1000 / speed);
            }

            // Запоминаем новые размеры
            previousCanvasWidth = canvasWidth;
            previousCanvasHeight = canvasHeight;

        }
        
        // ============================================
        // 4. ВСЕ ОСТАЛЬНЫЕ ФУНКЦИИ ИЗ ВАШЕГО КОДА
        // ============================================
        
        // Инициализация сетки
        function initGrid() {
            cols = Math.floor(canvas.width / cellSize);
            rows = Math.floor(canvas.height / cellSize);
            grid = [];
            cellAges = [];
            cellSpeeds = [];
            densityMap = [];
            
             for (let i = 0; i < rows; i++) {
                grid[i] = [];
                cellAges[i] = [];
                cellSpeeds[i] = [];
                densityMap[i] = [];
                
                for (let j = 0; j < cols; j++) {
                    grid[i][j] = {
                        alive: false,
                        hue: 0,
                        trailStrength: 0
                    };
                    cellAges[i][j] = 0;
                    cellSpeeds[i][j] = 0;
                    densityMap[i][j] = 0;
                }
            }
            generation = 0;
            updateStats();
        }

        function drawGrid() {
            // Выбираем функцию отрисовки в зависимости от режима
            if (simulationMode === 'hexagonal') {
                drawHexagonalGrid();
            } else if (simulationMode === 'triangular') {
                drawTriangularGrid();
            } else {
                drawGridStandard(); // Оригинальная отрисовка
            }
        }

        // Отрисовка сетки
        function drawGridStandard() {

            // Определяем цвет фона в зависимости от темы
            const bgColor = currentTheme === 'dark' ? '#0a0a0a' : '#000';
            
             // Очистка с учетом темы
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const brightnessBoost = currentTheme === 'dark' ? 1.2 : 1.0;
            
            // Обновление карты плотности для соответствующего режима
            if (visualizationMode === 'density') {
                updateDensityMap();
            }
            
            // Сохраняем состояние
            ctx.save();
            
            // Применяем трансформации
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoomLevel, zoomLevel);
            
            // Отрисовка клеток в зависимости от режима
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = grid[i][j];
                    
                    // Проверка видимости
                    const x = j * cellSize;
                    const y = i * cellSize;
                    const screenX = x * zoomLevel + offsetX;
                    const screenY = y * zoomLevel + offsetY;
                    const size = cellSize * zoomLevel;
                    
                    if (screenX + size < 0 || screenX > canvas.width || 
                        screenY + size < 0 || screenY > canvas.height) {
                        continue;
                    }
                    
                    let color;
                    
                    // Выбор цвета в зависимости от режима визуализации
                    switch (visualizationMode) {
                        case 'standard':
                            if (cell.alive) {
                                const adjustedBrightness = currentTheme === 'dark' 
                                    ? Math.min(colorBrightness * brightnessBoost, 80)
                                    : colorBrightness;
                                color = `hsl(${cell.hue}, ${colorSaturation}%, ${colorBrightness}%)`;
                            } else if (settings.showTrails && cell.trailStrength > 0) {
                                // Рисуем шлейф как КОНТУР с утончающейся толщиной
                                const alpha = cell.trailStrength * 0.7;
                                // Утончение более агрессивное - квадратичная функция
                                const thinningFactor = Math.pow(cell.trailStrength, 1.5);
                                ctx.save();
                                ctx.strokeStyle = `hsla(${cell.hue}, ${colorSaturation}%, ${colorBrightness}%, ${alpha})`;
                                // Толщина теперь уменьшается экспоненциально вместе с угасанием
                                ctx.lineWidth = Math.max(0.5, cellSize * 0.2 * thinningFactor);
                                ctx.strokeRect(x + 1, y + 1, cellSize - 3, cellSize - 3);
                                ctx.restore();
                                color = null;
                            }
                            break;
                            
                        case 'age':
                            if (cell.alive) {
                                color = getAgeColor(cellAges[i][j]);
                            } else {
                                color = 'rgba(10, 10, 10, 0.5)';
                            }
                            break;
                            
                        case 'density':
                            // Показываем плотность для ВСЕХ клеток
                            if (densityMap[i][j] > 0.01) {
                                color = getDensityColor(densityMap[i][j]);
                            } else {
                                color = 'rgba(0, 0, 0, 0.8)';
                            }
                            break;
                            
                        case 'speed':
                            // Показываем скорость для клеток с изменениями
                            if (cellSpeeds[i][j] > 0) {
                                color = getSpeedColor(cellSpeeds[i][j]);
                            } else if (cell.alive) {
                                color = 'hsl(240, 50%, 30%)'; // Живые без изменений - темно-синие
                            } else {
                                color = 'rgba(10, 10, 10, 0.5)';
                            }
                            break;
                            
                        case 'heat':
                            if (cell.alive) {
                                const heatValue = Math.min(cellAges[i][j] / 50, 1.0);
                                color = getHeatColor(heatValue);
                            } else {
                                color = getHeatColor(0);
                            }
                            break;
                            
                        case 'neon':
                            color = getNeonColor(cell.hue, cell.alive);
                            if (cell.alive && glowIntensity > 0) {
                                ctx.shadowBlur = glowIntensity;
                                ctx.shadowColor = color;
                            }
                            break;
                            
                        case 'matrix':
                            color = getMatrixColor(cell.alive, cellAges[i][j]);
                            if (cell.alive) {
                                ctx.shadowBlur = 5;
                                ctx.shadowColor = '#0f0';
                            }
                            break;
                            
                        case 'retro':
                            color = getRetroColor(cell.alive);
                            break;

                        case 'random':
                            // Режим случайных цветов
                            if (cell.alive) {
                                // Каждая клетка получает уникальный случайный цвет
                                const hue = (cell.hue + Math.sin(i * j + generation * 0.1) * 180 + 180) % 360;
                                const saturation = 80 + Math.random() * 20;
                                const lightness = 45 + Math.random() * 20;
                                color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                            } else {
                                color = 'rgba(0, 0, 0, 0.9)';
                            }
                            break;

                        case 'quantum':
                            // Специальная визуализация для квантового режима
                            if (cell.alive && cell.quantumProb !== undefined) {
                                // Используем сохранённые квантовые параметры
                                const prob = cell.quantumProb;
                                const phase = cell.quantumPhase || 0;
                                const ent = cell.quantumEnt || 0;
                                
                                const baseHue = 200 + prob * 160;
                                const phaseShift = (phase / (Math.PI * 2)) * 60;
                                const hue = (baseHue + phaseShift) % 360;
                                
                                const saturation = 50 + ent * 50;
                                const lightness = 40 + prob * 30;
                                
                                color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                                
                                // Свечение зависит от запутанности
                                if (glowIntensity > 0 || ent > 0.5) {
                                    ctx.shadowBlur = glowIntensity + ent * 10;
                                    ctx.shadowColor = color;
                                }
                            }
                            break;
                    }
                    
                    if (color) {
                        ctx.fillStyle = color;
                        
                        if (cell.alive && glowIntensity > 0) {
                                ctx.shadowBlur = glowIntensity;
                                ctx.shadowColor = color;
                            }

                        // Для неона и матрицы - закруглённые клетки
                        if (visualizationMode === 'neon' || visualizationMode === 'matrix') {
                            ctx.beginPath();
                            ctx.arc(x + cellSize / 2, y + cellSize / 2, cellSize / 2 - 1, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                        }
                        
                        // Сброс shadow
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'transparent';
                    }
                }
            }
            
            // Восстанавливаем состояние
            ctx.restore();
            
            // Рисуем сетку поверх всего
            drawGridLines();
            
            // Рисуем частицы
            if (particleEffects) {
                drawParticles();
            }
            
            // Эффект сканлайнов для ретро режима
            if (visualizationMode === 'retro') {
                drawScanlines();
            }
        }

        // Эффект сканлайнов (ЭЛТ монитор)
        function drawScanlines() {
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.05)';
            ctx.lineWidth = 1;
            
            for (let y = 0; y < canvas.height; y += 4) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        function drawGridLines() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;
            
            for (let i = 0; i <= rows; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();
            }
            
            for (let j = 0; j <= cols; j++) {
                ctx.beginPath();
                ctx.moveTo(j * cellSize, 0);
                ctx.lineTo(j * cellSize, canvas.height);
                ctx.stroke();
            }
        }
        
        function getCellColor(cell, x, y) {
            switch (currentColorMode) {
                case 'rainbow':
                    const hue = ((x / rows + y / cols) * 180 + generation * 2) % 360;
                    return `hsl(${hue}, ${cell.saturation}%, ${cell.lightness}%)`;
                    
                case 'thermal':
                    const thermalHue = 240 - (cell.energy * 2.4);
                    return `hsl(${thermalHue}, 100%, 50%)`;
                    
                case 'age':
                    const ageHue = (cell.age * 10) % 360;
                    return `hsl(${ageHue}, 100%, ${50 + Math.min(cell.age, 10)}%)`;
                    
                case 'random':
                    return `hsl(${cell.hue}, ${cell.saturation}%, ${cell.lightness}%)`;
                    
                case 'inheritance':
                default:
                    const lightness = Math.min(50 + cell.age * 2, 70);
                    return `hsl(${cell.hue}, ${cell.saturation}%, ${lightness}%)`;
            }
        }

        function getTrailColor(color, lastActive) {
            const match = color.match(/hsl\((\d+\.?\d*),\s*(\d+\.?\d*)%,\s*(\d+\.?\d*)%\)/);
            if (match) {
                const hue = match[1];
                const saturation = match[2];
                // Чем меньше lastActive, тем темнее и прозрачнее
                const lightness = 1 + (lastActive * 2); // 5-15%
                const alpha = lastActive * 0.02; // 0.08-0.4
                return `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
            }
            return 'hsla(0, 0%, 5%, 0.1)';
        }

        // Подсчёт соседей и их средний цвет
        function countNeighbors(x, y) {
            let count = 0;
            let hues = [];
            
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    
                    let newX, newY;
                    
                    if (useWrapAround) {
                        // Торроидальное поле - с замыканием
                        newX = (x + i + rows) % rows;
                        newY = (y + j + cols) % cols;
                    } else {
                        // Поле с границами
                        newX = x + i;
                        newY = y + j;
                        
                        // Проверка границ
                        if (newX < 0 || newX >= rows || newY < 0 || newY >= cols) {
                            continue;
                        }
                    }
                    
                    if (grid[newX][newY].alive) {
                        count++;
                        hues.push(grid[newX][newY].hue);
                    }
                }
            }
            
            // Вычисляем средний оттенок
            if (hues.length > 0) {
                const avgHue = averageHue(hues);
                return { count, avgHue };
            }
            
            return { count, avgHue: 0 };
        }

        // Средний оттенок с учётом цикличности
        function averageHue(hues) {
            let x = 0, y = 0;
            
            for (let hue of hues) {
                const rad = (hue * Math.PI) / 180;
                x += Math.cos(rad);
                y += Math.sin(rad);
            }
            
            x /= hues.length;
            y /= hues.length;
            
            let avgHue = (Math.atan2(y, x) * 180) / Math.PI;
            if (avgHue < 0) avgHue += 360;
            
            return avgHue;
        }

        // Применение цветовой эволюции
        function applyColorEvolution(cell, avgHue, neighborCount) {
            if (neighborCount > 0) {
                const hueDiff = avgHue - cell.hue;
                let shortestDiff = hueDiff;
                
                if (Math.abs(hueDiff) > 180) {
                    shortestDiff = hueDiff > 0 ? hueDiff - 360 : hueDiff + 360;
                }
                
                cell.hue = (cell.hue + shortestDiff * mutationRate + 360) % 360;
                cell.energy = Math.min(cell.energy + neighborCount, 100);
            } else {
                cell.energy = Math.max(cell.energy - 1, 0);
            }
        }

        function updateGrid() {
            // Специальные правила
            if (currentRule === 'briansbrain') {
                updateGridBriansBrain();
                return;
            }
            
            if (currentRule === 'wireworld') {
                updateGridWireworld();
                return;
            }
            
            if (currentRule === 'langton') {
                updateGridLangtonAnt();
                return;
            }
            
            // Режимы симуляции
            switch(simulationMode) {
                case 'competition':
                    updateGridCompetition();
                    break;
                case 'evolution':
                    updateGridEvolution();
                    break;
                case 'quantum':
                    updateGridQuantum();
                    break;
                case 'hexagonal':
                case 'triangular':
                case 'standard':
                default:
                    updateGridStandard();
                    break;
            }
        }

        // Обновление сетки (следующее поколение)
        function updateGridStandard() {
            birthsThisGen = 0;
            deathsThisGen = 0;

            

            generation++;
            
            const newGrid = [];
            const newAges = [];
            const newSpeeds = [];

            // Получаем правила
            const rule = gameRules[currentRule] || gameRules.conway;
            const birthRule = rule.birth;
            const surviveRule = rule.survive;
            
            for (let i = 0; i < rows; i++) {
                newGrid[i] = [];
                newAges[i] = [];
                newSpeeds[i] = [];
                for (let j = 0; j < cols; j++) {
                    const cell = grid[i][j];
                    let count, avgHue;
                    if (simulationMode === 'hexagonal') {
                        ({ count, avgHue } = countNeighborsHexagonal(i, j));
                    } else if (simulationMode === 'triangular') {
                        ({ count, avgHue } = countNeighborsTriangular(i, j));
                    } else {
                        ({ count, avgHue } = countNeighbors(i, j));
                    }

                    // Создаем копию объекта ячейки для нового поколения
                    newGrid[i][j] = {
                        alive: cell.alive,
                        hue: cell.hue,
                        trailStrength: settings.showTrails ? cell.trailStrength * 0.9 : 0
                    };
                    
                    const wasAlive = grid[i][j].alive;
                    const willBeAlive = cell.alive 
                        ? surviveRule.includes(count)
                        : birthRule.includes(count);
                    
                    // Обновление возраста
                    if (willBeAlive) {
                        if (wasAlive) {
                            newAges[i][j] = cellAges[i][j] + 1;
                        } else {
                            newAges[i][j] = 0;
                            birthsThisGen++;
                            
                            // Создать частицу при рождении
                            if (particleEffects) {
                                createParticle(
                                    j * cellSize + cellSize / 2,
                                    i * cellSize + cellSize / 2,
                                    grid[i][j].hue
                                );
                            }
                        }
                    } else {
                        newAges[i][j] = 0;
                        if (wasAlive) {
                            deathsThisGen++;

                            if (settings.showTrails) {
                                newGrid[i][j].trailStrength = 1.0;
                                newGrid[i][j].hue = cell.hue;
                            }
                            
                            // Создать частицу при рождении
                            if (particleEffects) {
                                const particleCount = Math.max(1, Math.ceil(particleIntensity / 3));
                                for (let p = 0; p < particleCount; p++) {
                                    createParticle(
                                        j * cellSize + cellSize / 2,
                                        i * cellSize + cellSize / 2,
                                        grid[i][j].hue
                                    );
                                }
                            }
                        }
                    }
                    
                    // Обновление скорости (сколько изменений в окрестности)
                    let changes = 0;
                    for (let di = -1; di <= 1; di++) {
                        for (let dj = -1; dj <= 1; dj++) {
                            const ni = i + di;
                            const nj = j + dj;
                            
                            if (ni >= 0 && ni < rows && nj >= 0 && nj < cols) {
                                if (newGrid[ni] && newGrid[ni][nj] && grid[ni][nj].alive !== newGrid[ni][nj].alive) {
                                    changes++;
                                }
                            }
                        }
                    }
                    newSpeeds[i][j] = changes;
                    
                    if (cell.alive) {
                        // Применяем правила выживания
                        if (!surviveRule.includes(count)) {
                            newGrid[i][j].alive = false;
                            newGrid[i][j].age = 0;
                            newGrid[i][j].lastActive = 5;
                        } else {
                            // Ячейка выживает
                            newGrid[i][j].age++;
                            applyColorEvolution(newGrid[i][j], avgHue, count);
                        }
                    } else {
                        // Применяем правила рождения
                        if (birthRule.includes(count)) {
                            newGrid[i][j].alive = true;

                            // Цвет зависит от текущего режима
                            switch (currentColorMode) {
                                case 'random':
                                    newGrid[i][j].hue = Math.random() * 360;
                                    break;
                                case 'rainbow':
                                    newGrid[i][j].hue = ((i / rows + j / cols) * 180) % 360;
                                    break;
                                case 'thermal':
                                    newGrid[i][j].hue = 240; // Начинаем с синего
                                    break;
                                case 'age':
                                    newGrid[i][j].hue = 0; // Начинаем с красного
                                    break;
                                case 'inheritance':
                                default:
                                    newGrid[i][j].hue = avgHue; // Наследуем цвет от соседей
                                    break;
                            }
                            
                            newGrid[i][j].saturation = 100;
                            newGrid[i][j].lightness = 50;
                            newGrid[i][j].age = 0;
                        }
                    }

                    if (newGrid[i][j].alive && !grid[i][j].alive) {
                        birthsThisGen++;
                    } else if (!newGrid[i][j].alive && grid[i][j].alive) {
                        deathsThisGen++;
                    }
                }
            }
            
            grid = newGrid;
            cellAges = newAges;  
            cellSpeeds = newSpeeds;  

            // Воспроизведение звуков
            if (soundEnabled && audioContext) {
                // Звуки рождения (максимум 5 за такт)
                if (birthSoundEnabled && birthsThisGen > 0) {
                    const soundCount = Math.min(birthsThisGen, 5);
                    for (let i = 0; i < soundCount; i++) {
                        setTimeout(() => {
                            playBirthSound(440 + i * 55);
                        }, i * 30);
                    }
                }
                
                // Звуки смерти (максимум 3 за такт)
                if (deathSoundEnabled && deathsThisGen > 0) {
                    const soundCount = Math.min(deathsThisGen, 3);
                    for (let i = 0; i < soundCount; i++) {
                        setTimeout(() => {
                            playDeathSound();
                        }, i * 50);
                    }
                }
            }

            updateStats();

            if (minimapVisible && minimapCtx) {
                updateMinimap();
            }
        }

        // Обновление статистики
        function updateStats() {
            const aliveCount = grid.flat().filter(cell => cell.alive).length;
            const totalCells = rows * cols;
            const density = ((aliveCount / totalCells) * 100).toFixed(2);
            
            // Обновление основной статистики
            document.getElementById('population').textContent = aliveCount;
            document.getElementById('generation').textContent = generation;
            document.getElementById('density').textContent = density + '%';
            
            // Обновление расширенной статистики
            document.getElementById('births').textContent = birthsThisGen;
            document.getElementById('deaths').textContent = deathsThisGen;
            
            const change = birthsThisGen - deathsThisGen;
            const changeEl = document.getElementById('change');
            changeEl.textContent = (change >= 0 ? '+' : '') + change;
            changeEl.style.color = change > 0 ? '#00b09b' : change < 0 ? '#f5576c' : '#666';
            
            // Добавление в историю популяции
            populationHistory.push(aliveCount);
            if (populationHistory.length > maxHistoryLength) {
                populationHistory.shift();
            }
            
            // Обновление графика, если видим
            if (chartVisible && populationChart) {
                updateChart();
            }
            
            // Обновление FPS
            updateFPS();
            
            // Детекция особых состояний
            detectSpecialStates(aliveCount);
            
            // Детекция стабильности
            updateStabilityIndicator();

            // Индикатор стабильности для режима соревнования
            if (simulationMode === 'competition') {
                const stabilityIndicator = document.getElementById('stabilityIndicator');
                const stabilityValue = document.getElementById('stabilityValue');
                
                if (stabilityIndicator && stabilityValue) {
                    stabilityIndicator.style.display = 'flex';
                    stabilityValue.textContent = `${stableGenerations}/${minStableGenerations}`;
                    
                    // Подсветка при приближении к порогу
                    if (stableGenerations > minStableGenerations * 0.7) {
                        stabilityValue.style.color = '#ffa500';
                    } else {
                        stabilityValue.style.color = 'inherit';
                    }
                }
            } else {
                const stabilityIndicator = document.getElementById('stabilityIndicator');
                if (stabilityIndicator) {
                    stabilityIndicator.style.display = 'none';
                }
            }
        }

        // Обновление FPS
        function updateFPS() {
            frameCount++;
            const now = Date.now();
            const elapsed = now - lastFPSUpdate;
            
            if (elapsed >= 1000) {
                currentFPS = Math.round((frameCount * 1000) / elapsed);
                document.getElementById('fps').textContent = currentFPS;
                frameCount = 0;
                lastFPSUpdate = now;
            }
        }

        // Детекция особых состояний
        function detectSpecialStates(population) {
            const totalCells = rows * cols;
            const density = population / totalCells;
            
            // Угроза вымирания
            const extinctionIndicator = document.getElementById('extinctionIndicator');
            if (population > 0 && population < 10) {
                extinctionIndicator.style.display = 'flex';
            } else {
                extinctionIndicator.style.display = 'none';
            }
            
            // Взрывной рост
            const explosionIndicator = document.getElementById('explosionIndicator');
            if (density > 0.7) {
                explosionIndicator.style.display = 'flex';
            } else {
                explosionIndicator.style.display = 'none';
            }
            
            // Детекция осцилляторов и стабильных состояний
            detectPatterns();
        }

        // Детекция осцилляторов и стабильных состояний
        function detectPatterns() {
            // Создаём хеш текущего состояния
            const stateHash = hashGridState();
            
            // Добавляем в историю
            stateHistory.push(stateHash);
            if (stateHistory.length > maxStateHistory) {
                stateHistory.shift();
            }
            
            // Ищем повторения
            const oscillatorIndicator = document.getElementById('oscillatorIndicator');
            const stableIndicator = document.getElementById('stableIndicator');
            
            if (stateHistory.length >= 2) {
                // Проверка на стабильное состояние (период 1)
                if (stateHistory[stateHistory.length - 1] === stateHistory[stateHistory.length - 2]) {
                    stableIndicator.style.display = 'flex';
                    oscillatorIndicator.style.display = 'none';
                    return;
                } else {
                    stableIndicator.style.display = 'none';
                }
                
                // Проверка на осцилляторы (период 2-10)
                for (let period = 2; period <= 10; period++) {
                    if (stateHistory.length >= period * 2) {
                        let isOscillator = true;
                        
                        for (let i = 0; i < period; i++) {
                            const idx1 = stateHistory.length - 1 - i;
                            const idx2 = stateHistory.length - 1 - i - period;
                            
                            if (idx2 >= 0 && stateHistory[idx1] !== stateHistory[idx2]) {
                                isOscillator = false;
                                break;
                            }
                        }
                        
                        if (isOscillator) {
                            oscillatorIndicator.style.display = 'flex';
                            document.getElementById('oscillatorPeriod').textContent = period;
                            return;
                        }
                    }
                }
                
                oscillatorIndicator.style.display = 'none';
            }
        }

        // Хеширование состояния сетки
        function hashGridState() {
            let hash = '';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    hash += grid[i][j].alive ? '1' : '0';
                }
            }
            return hash;
        }

        // Обновление индикатора стабильности
        function updateStabilityIndicator() {
            if (populationHistory.length < 10) {
                document.getElementById('stability').textContent = 'Нет данных';
                return;
            }
            
            // Вычисляем стандартное отклонение последних 10 поколений
            const recent = populationHistory.slice(-10);
            const avg = recent.reduce((a, b) => a + b, 0) / recent.length;
            const variance = recent.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / recent.length;
            const stdDev = Math.sqrt(variance);
            
            // Коэффициент вариации
            const cv = avg > 0 ? (stdDev / avg) * 100 : 0;
            
            let stabilityText = '';
            let stabilityColor = '';
            
            if (cv < 5) {
                stabilityText = 'Очень стабильно';
                stabilityColor = '#00b09b';
            } else if (cv < 15) {
                stabilityText = 'Стабильно';
                stabilityColor = '#4facfe';
            } else if (cv < 30) {
                stabilityText = 'Умеренно';
                stabilityColor = '#f5a623';
            } else {
                stabilityText = 'Хаотично';
                stabilityColor = '#f5576c';
            }
            
            const stabilityEl = document.getElementById('stability');
            stabilityEl.textContent = stabilityText;
            stabilityEl.style.color = stabilityColor;
        }
        
        // Инициализация графика
        function initChart() {
            const canvas = document.getElementById('populationChart');
            const ctx = canvas.getContext('2d');
            
            populationChart = {
                canvas: canvas,
                ctx: ctx
            };
        }

        // Отрисовка графика
        function updateChart() {
            if (!populationChart) return;
            
            const canvas = populationChart.canvas;
            const ctx = populationChart.ctx;
            
            // Устанавливаем размеры canvas
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 200;
            
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            
            // Очистка
            ctx.clearRect(0, 0, width, height);
            
            if (populationHistory.length < 2) return;
            
            // Найти минимум и максимум
            const maxPop = Math.max(...populationHistory);
            const minPop = Math.min(...populationHistory);
            const range = maxPop - minPop || 1;
            
            // Отрисовка сетки
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 5; i++) {
                const y = padding + (height - 2 * padding) * i / 5;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding / 2, y);
                ctx.stroke();
                
                // Подписи
                const value = Math.round(maxPop - (range * i / 5));
                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(value.toString(), padding - 5, y + 4);
            }
            
            // Отрисовка линии графика
            ctx.beginPath();
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            
            populationHistory.forEach((pop, index) => {
                const x = padding + (width - padding * 1.5) * index / (maxHistoryLength - 1);
                const normalizedPop = (pop - minPop) / range;
                const y = height - padding - (height - 2 * padding) * normalizedPop;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Заливка под графиком
            ctx.lineTo(width - padding / 2, height - padding);
            ctx.lineTo(padding, height - padding);
            ctx.closePath();
            
            const gradient = ctx.createLinearGradient(0, padding, 0, height - padding);
            gradient.addColorStop(0, 'rgba(102, 126, 234, 0.3)');
            gradient.addColorStop(1, 'rgba(102, 126, 234, 0.05)');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Текущее значение
            if (populationHistory.length > 0) {
                const lastPop = populationHistory[populationHistory.length - 1];
                const lastX = padding + (width - padding * 1.5) * (populationHistory.length - 1) / (maxHistoryLength - 1);
                const normalizedPop = (lastPop - minPop) / range;
                const lastY = height - padding - (height - 2 * padding) * normalizedPop;
                
                // Точка
                ctx.beginPath();
                ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#667eea';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Подпись
                ctx.fillStyle = '#333';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(lastPop.toString(), lastX, lastY - 10);
            }
            
            // Подписи осей
            ctx.fillStyle = '#666';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Популяция во времени', width / 2, 15);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Количество клеток', 0, 0);
            ctx.restore();
            
            ctx.fillText(`Поколения (последние ${populationHistory.length})`, width / 2, height - 5);
        }

        // Переключение видимости графика
        function toggleChart() {
            chartVisible = !chartVisible;
            const container = document.getElementById('chartContainer');
            const btn = document.getElementById('toggleChartBtn');
            
            if (chartVisible) {
                container.style.display = 'block';
                btn.textContent = ' Скрыть график';
                
                if (!populationChart) {
                    initChart();
                }
                
                updateChart();
            } else {
                container.style.display = 'none';
                btn.textContent = ' Показать график';
            }
        }

        // Очистка истории графика
        function clearChartHistory() {
            if (confirm('Очистить историю графика?')) {
                populationHistory = [];
                stateHistory = [];
                generation = 0;
                updateChart();
                updateStats();
            }
        }

        // ========== ZOOM ФУНКЦИИ ==========
        function zoom(delta, centerX, centerY) {
            const oldZoom = zoomLevel;
            
            // Изменяем zoom
            if (delta > 0) {
                zoomLevel = Math.min(zoomLevel * 1.2, maxZoom);
            } else {
                zoomLevel = Math.max(zoomLevel / 1.2, minZoom);
            }
            
            // Корректируем offset для zoom в точку курсора
            if (centerX !== undefined && centerY !== undefined) {
                const scale = zoomLevel / oldZoom;
                offsetX = centerX - (centerX - offsetX) * scale;
                offsetY = centerY - (centerY - offsetY) * scale;
            }
            
            updateZoomIndicator();
            drawGrid();
            updateMinimap();
        }

        function resetZoom() {
            zoomLevel = 1;
            offsetX = 0;
            offsetY = 0;
            updateZoomIndicator();
            drawGrid();
            updateMinimap();
        }

        function updateZoomIndicator() {
            const indicator = document.getElementById('zoomIndicator');
            const value = document.getElementById('zoomValue');
            value.textContent = Math.round(zoomLevel * 100) + '%';
            
            // Показываем индикатор на 2 секунды
            indicator.classList.remove('hidden');
            clearTimeout(window.zoomIndicatorTimeout);
            window.zoomIndicatorTimeout = setTimeout(() => {
                indicator.classList.add('hidden');
            }, 2000);
        }

        // ========== PAN ФУНКЦИИ ==========
        function startPan(x, y) {
            isPanning = true;
            panStart = { x: x - offsetX, y: y - offsetY };
            canvas.classList.add('pan-mode');
        }

        function updatePan(x, y) {
            if (!isPanning) return;
            
            offsetX = x - panStart.x;
            offsetY = y - panStart.y;
            
            drawGrid();
            updateMinimap();
        }

        function endPan() {
            isPanning = false;
            canvas.classList.remove('pan-mode');
        }

        // ========== СЕТКА ==========
        function toggleGrid() {
            showGrid = !showGrid;
            drawGrid();
        }

        function drawGridLines() {
            if (!showGrid || zoomLevel < 1.5) return;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // Вертикальные линии
            for (let i = 0; i <= cols; i++) {
                const x = i * cellSize * zoomLevel + offsetX;
                if (x >= 0 && x <= canvas.width) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
            }
            
            // Горизонтальные линии
            for (let i = 0; i <= rows; i++) {
                const y = i * cellSize * zoomLevel + offsetY;
                if (y >= 0 && y <= canvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
        }

        // ========== МИНИ-КАРТА ==========
        function initMinimap() {
            minimapCanvas = document.getElementById('minimap');
            minimapCtx = minimapCanvas.getContext('2d');
            
            const container = document.getElementById('minimapContainer');
            minimapCanvas.width = container.clientWidth;
            minimapCanvas.height = container.clientHeight;
            
            updateMinimap();
        }

        function updateMinimap() {
             if (!minimapVisible || !minimapCtx) return;
    
            const mmWidth = minimapCanvas.width;
            const mmHeight = minimapCanvas.height;
            
            // Цвет фона в зависимости от темы
            const bgColor = currentTheme === 'dark' ? '#0a0a0a' : '#000';
            
            // Очистка
            minimapCtx.fillStyle = bgColor;
            minimapCtx.fillRect(0, 0, mmWidth, mmHeight);
            
            // Масштаб
            const scaleX = mmWidth / cols;
            const scaleY = mmHeight / rows;
            
            // Обновляем карту плотности если нужно
            if (visualizationMode === 'density') {
                updateDensityMap();
            }
            
            // Рисуем клетки с учётом текущего режима визуализации
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = grid[i][j];
                    let color = null;
                    
                    // Выбираем цвет в зависимости от режима визуализации
                    switch (visualizationMode) {
                        case 'standard':
                            if (cell.alive) {
                                color = `hsl(${cell.hue}, ${colorSaturation}%, ${colorBrightness}%)`;
                            }
                            break;
                            
                        case 'age':
                            if (cell.alive) {
                                color = getAgeColor(cellAges[i][j]);
                            }
                            break;
                            
                        case 'density':
                            if (densityMap[i][j] > 0.1) { // Показываем только значимую плотность
                                color = getDensityColor(densityMap[i][j]);
                            }
                            break;
                            
                        case 'speed':
                            if (cellSpeeds[i][j] > 0) {
                                color = getSpeedColor(cellSpeeds[i][j]);
                            }
                            break;
                            
                        case 'heat':
                            if (cell.alive) {
                                const heatValue = Math.min(cellAges[i][j] / 50, 1.0);
                                color = getHeatColor(heatValue);
                            }
                            break;
                            
                        case 'neon':
                            if (cell.alive) {
                                color = `hsl(${cell.hue}, 100%, 50%)`;
                            }
                            break;
                            
                        case 'matrix':
                            if (cell.alive) {
                                color = getMatrixColor(cell.alive, cellAges[i][j]);
                            }
                            break;
                            
                        case 'retro':
                            if (cell.alive) {
                                color = '#00ff00';
                            }
                            break;

                        case 'random':
                            if (cell.alive) {
                                // Используем ту же формулу случайных цветов, что и в основном режиме
                                const hue = (cell.hue + Math.sin(i * j + generation * 0.1) * 180 + 180) % 360;
                                const saturation = 85 + Math.random() * 15;
                                const lightness = 50 + Math.random() * 15;
                                color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                            }
                            break;
                    }
                    
                    if (color) {
                        minimapCtx.fillStyle = color;
                        minimapCtx.fillRect(
                            j * scaleX,
                            i * scaleY,
                            Math.ceil(scaleX),
                            Math.ceil(scaleY)
                        );
                    }
                }
            }
            
            // Рисуем viewport
            updateMinimapViewport();
        }

        function updateMinimapViewport() {
            if (!minimapVisible) return;
            
            const viewport = document.getElementById('minimapViewport');
            const mmWidth = minimapCanvas.width;
            const mmHeight = minimapCanvas.height;
            
            const scaleX = mmWidth / (cols * cellSize);
            const scaleY = mmHeight / (rows * cellSize);
            
            const viewWidth = canvas.width / zoomLevel;
            const viewHeight = canvas.height / zoomLevel;
            const viewX = -offsetX / zoomLevel;
            const viewY = -offsetY / zoomLevel;
            
            viewport.style.left = (viewX * scaleX) + 'px';
            viewport.style.top = (viewY * scaleY) + 'px';
            viewport.style.width = (viewWidth * scaleX) + 'px';
            viewport.style.height = (viewHeight * scaleY) + 'px';
        }

        function toggleMinimap() {
            minimapVisible = !minimapVisible;
            const container = document.getElementById('minimapContainer');
            
            if (minimapVisible) {
                container.classList.remove('hidden');
                updateMinimap();
            } else {
                container.classList.add('hidden');
            }
        }

        // ========== РЕЖИМЫ ВИЗУАЛИЗАЦИИ ==========

        function setVisualizationMode(mode) {
            visualizationMode = mode;
            
            // Обновление активной кнопки
            document.querySelectorAll('.color-mode-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');
            
            drawGrid();
        }

        // Вычисление цвета на основе возраста
        function getAgeColor(age) {
            // От синего (новые) через зелёный к красному (старые)
            // Расширенный диапазон для более плавных переходов
            const maxAge = 200; // Увеличен максимальный возраст
            const normalized = Math.min(age / maxAge, 1);
            const hue = (240 - normalized * 240); // 240 (синий) -> 0 (красный)
            // Динамическая яркость для большей выразительности
            const lightness = 35 + normalized * 30; // От 35% до 65%
            return `hsl(${hue}, 95%, ${lightness}%)`;
        }

        // Вычисление цвета на основе плотности
        function getDensityColor(density) {
            // От синего (низкая) через зелёный и жёлтый к красному (высокая)
            // Расширенный цветовой диапазон для лучшей визуализации
            const normalizedDensity = Math.pow(density, 0.7); // Нелинейное масштабирование
            const hue = (1 - normalizedDensity) * 240; // 240 (синий) -> 0 (красный)
            // Динамическая насыщенность и яркость
            const saturation = 70 + normalizedDensity * 30; // От 70% до 100%
            const lightness = 40 + normalizedDensity * 20; // От 40% до 60%
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        // Вычисление цвета на основе скорости
        function getSpeedColor(speed) {
            // От фиолетового (медленно) через синий и зелёный к красному (быстро)
            const maxSpeed = 8; // Увеличенный диапазон
            const normalized = Math.min(speed / maxSpeed, 1);
            // Расширенный цветовой спектр для большей наглядности
            const hue = 280 - normalized * 280; // 280 (фиолетовый) -> 0 (красный)
            // Динамическая яркость для акцента на быстрых изменениях
            const lightness = 35 + normalized * 30; // От 35% до 65%
            const saturation = 85 + normalized * 15; // От 85% до 100%
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        // Тепловая карта
        function getHeatColor(value) {
            // Более яркая и контрастная тепловая карта
            // Чёрный -> Тёмно-синий -> Фиолетовый -> Красный -> Оранжевый -> Жёлтый -> Белый
            if (value < 0.15) {
                // Чёрный -> Тёмно-синий
                const t = value / 0.15;
                return `rgb(0, 0, ${Math.floor(180 * t)})`;
            } else if (value < 0.3) {
                // Тёмно-синий -> Фиолетовый
                const t = (value - 0.15) / 0.15;
                return `rgb(${Math.floor(180 * t)}, 0, ${Math.floor(180 + 75 * t)})`;
            } else if (value < 0.5) {
                // Фиолетовый -> Красный
                const t = (value - 0.3) / 0.2;
                return `rgb(${Math.floor(180 + 75 * t)}, 0, ${Math.floor(255 - 255 * t)})`;
            } else if (value < 0.65) {
                // Красный -> Оранжевый
                const t = (value - 0.5) / 0.15;
                return `rgb(255, ${Math.floor(140 * t)}, 0)`;
            } else if (value < 0.8) {
                // Оранжевый -> Жёлтый
                const t = (value - 0.65) / 0.15;
                return `rgb(255, ${Math.floor(140 + 115 * t)}, 0)`;
            } else {
                // Жёлтый -> Белый
                const t = (value - 0.8) / 0.2;
                return `rgb(255, 255, ${Math.floor(255 * t)})`;
            }
        }

        // Неоновый эффект
        function getNeonColor(hue, alive) {
            if (!alive) return 'rgba(0, 0, 0, 0.9)';
            return `hsl(${hue}, 100%, 50%)`;
        }

        // Матрица стиль
        function getMatrixColor(alive, age) {
            if (!alive) return '#000';
            const brightness = Math.max(30, 100 - age * 2);
            return `hsl(120, 100%, ${brightness}%)`;
        }

        // Ретро стиль (CRT монитор)
        function getRetroColor(alive) {
            return alive ? '#00ff00' : '#001100';
        }

        // Случайные цвета для живых ячеек
        function getRandomColor(alive) {
            if (!alive) return 'rgba(0, 0, 0, 0.9)';
            // Используем hue клетки как основу для стабильности между кадрами
            // Но делаем яркие насыщенные случайные цвета
            const hue = Math.random() * 360;
            const saturation = 80 + Math.random() * 20; // 80-100%
            const lightness = 45 + Math.random() * 20; // 45-65%
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        // Обновление карты плотности
        function updateDensityMap() {
            const radius = 3;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    let count = 0;
                    let total = 0;
                    
                    for (let di = -radius; di <= radius; di++) {
                        for (let dj = -radius; dj <= radius; dj++) {
                            const ni = i + di;
                            const nj = j + dj;
                            
                            if (ni >= 0 && ni < rows && nj >= 0 && nj < cols) {
                                if (grid[ni][nj].alive) count++;
                                total++;
                            }
                        }
                    }
                    
                    densityMap[i][j] = count / total;
                }
            }
        }

        // Создание частиц
        function createParticle(x, y, hue) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                life: 1.0,
                hue: hue,
                size: Math.random() * 3 + 1
            });
        }

        // Обновление частиц
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                p.vy += 0.1; // Гравитация
                return p.life > 0;
            });
        }

        // Отрисовка частиц
        function drawParticles() {
            if (!particleEffects || particles.length === 0) return;
            
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoomLevel, zoomLevel);
            
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = `hsl(${p.hue}, 100%, 50%)`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.restore();
        }

        // Игровой цикл
        function gameLoop() {
            updateGrid();
            drawGrid();
            
            if (minimapVisible) {
                    updateMinimap();
                }

            // Дополнительная отрисовка частиц между кадрами
            if (particleEffects && particles.length > 0) {
                updateParticles();
                drawGrid();

            }

            if (minimapVisible) {
                    updateMinimap();
            }

            // Обновление визуализатора
            if (musicEnabled) {
                updateAudioVisualizer();
            }
        }

        // Эффект пульсации для неонового режима
        let pulsePhase = 0;

        function applyNeonPulse() {
            if (visualizationMode !== 'neon') return;
            
            pulsePhase += 0.05;
            const brightness = 1 + Math.sin(pulsePhase) * 0.2;
            canvas.style.filter = `brightness(${brightness})`;
        }

        // Вызывать в gameLoop если режим neon
        if (visualizationMode === 'neon') {
            applyNeonPulse();
        }

        // Эффект "мерцания" для матрицы
        function applyMatrixFlicker() {
            if (visualizationMode !== 'matrix' || Math.random() > 0.98) return;
            
            canvas.style.opacity = '0.95';
            setTimeout(() => {
                canvas.style.opacity = '1';
            }, 50);
        }

        // Эффект искажения для ретро режима
        function applyRetroDistortion() {
            if (visualizationMode !== 'retro') return;
            
            const distortion = Math.sin(Date.now() * 0.01) * 2;
            canvas.style.transform = `translateX(${distortion}px)`;
        }

        // Обновление индикатора состояния
        function updateStateIndicator() {
            const indicator = document.getElementById('stateIndicator');
            if (running) {
                indicator.textContent = '▶ Выполняется';
                indicator.className = 'state-indicator running';
            } else {
                indicator.textContent = '⏸ Пауза';
                indicator.className = 'state-indicator paused';
            }
        }
        
        // Установка цветового режима
        function setColorMode(mode, buttonElement) {
            currentColorMode = mode;
            document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
            if (buttonElement) {
                buttonElement.classList.add('active');
            }
            
            // Обновляем описание режима
            const descElement = document.getElementById('currentColorDescription');
            if (descElement && colorModes[mode]) {
                descElement.textContent = colorModes[mode].description;
            }
            
            drawGrid();
        }

        // Установка набора правил
        function setRuleSet(ruleSetName, buttonElement) {
            currentRules = ruleSets[ruleSetName];
            document.querySelectorAll('.rule-btn').forEach(btn => btn.classList.remove('active'));
            if (buttonElement) {
                buttonElement.classList.add('active');
            }
            
            // Обновляем описание правил
            const descElement = document.getElementById('currentRuleDescription');
            if (descElement) {
                descElement.textContent = currentRules.description;
            }
            
            // Обновляем легенду с правилами
            updateRulesLegend();
        }

        // Обновление описания правил в легенде
        function updateRulesLegend() {
            const legend = document.querySelector('.legend ul');
            if (!legend) return;
            
            let rulesText = '';
            
            if (currentRule === 'briansbrain') {
                rulesText = `
                    <li> Мёртвая клетка → Живая (при 2 живых соседях)</li>
                    <li> Живая клетка → Умирающая (всегда)</li>
                    <li> Умирающая → Мёртвая (всегда)</li>
                `;
            } else if (currentRule === 'wireworld') {
                rulesText = `
                    <li>⚫ Пусто остаётся пустым</li>
                    <li> Проводник → Голова (при 1-2 головах рядом)</li>
                    <li> Голова → Хвост (всегда)</li>
                    <li> Хвост → Проводник (всегда)</li>
                `;
            } else if (currentRule === 'langton') {
                rulesText = `
                    <li> На белой клетке: поворот направо, клетка чернеет</li>
                    <li> На чёрной клетке: поворот налево, клетка белеет</li>
                    <li> После поворота: движение вперёд</li>
                `;
            } else {
                const rule = gameRules[currentRule] || gameRules.conway;
                rulesText = `
                    <li><strong>Рождение:</strong> ${rule.birth.length > 0 ? rule.birth.join(', ') : 'никогда'} соседей</li>
                    <li><strong>Выживание:</strong> ${rule.survive.length > 0 ? rule.survive.join(', ') : 'никогда'} соседей</li>
                    <li><strong>Нотация:</strong> B${rule.birth.join('')}/S${rule.survive.join('')}</li>
                `;
            }
            
            legend.innerHTML = rulesText;
        }

        // Установка текущего инструмента
        function setTool(tool) {
            currentTool = tool;
            
            // Сброс штампа при смене инструмента
            if (tool !== 'stamp') {
                stampData = null;
                stampSelecting = false;
                removeStampInfo();
            }
            
            // Обновление активной кнопки
            document.querySelectorAll('.tool-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const toolButtons = {
                'brush': 'brushBtn',
                'eraser': 'eraserBtn',
                'line': 'lineBtn',
                'fill': 'fillBtn',
                'rectangle': 'rectBtn',
                'circle': 'circleBtn',
                'stamp': 'stampBtn'
            };
            
            if (toolButtons[tool]) {
                document.getElementById(toolButtons[tool]).classList.add('active');
            }
            
            // Показать информацию для штампа
            if (tool === 'stamp' && !stampData) {
                showStampInfo('Выделите область для копирования (зажмите и протяните мышь)');
            }

            vibrate(10);
            playUISound('click');
        }

        // Зеркальный режим
        function toggleMirrorMode() {
            mirrorMode = !mirrorMode;
            const btn = document.getElementById('mirrorBtn');
            const options = document.getElementById('mirrorOptions');
            
            btn.textContent = mirrorMode ? '爵 Зеркало: ВКЛ' : '爵 Зеркало: ВЫКЛ';
            btn.classList.toggle('active', mirrorMode);
            options.style.display = mirrorMode ? 'block' : 'none';
        }

        function setMirrorType(type) {
            mirrorType = type;
            
            // Обновление кнопок
            document.querySelectorAll('.mirror-options button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const buttons = {
                'horizontal': 'mirrorH',
                'vertical': 'mirrorV',
                'both': 'mirrorB',
                'radial': 'mirrorR'
            };
            
            if (buttons[type]) {
                document.getElementById(buttons[type]).classList.add('active');
            }
        }

        // Заливка области
        function floodFill(startRow, startCol, fillAlive, fillHue) {
            if (startRow < 0 || startRow >= rows || startCol < 0 || startCol >= cols) return;
            
            const targetAlive = grid[startRow][startCol].alive;
            const targetHue = grid[startRow][startCol].hue;
            
            // Если уже нужный цвет/состояние, ничего не делаем
            if (targetAlive === fillAlive && Math.abs(targetHue - fillHue) < 5) return;
            
            const stack = [[startRow, startCol]];
            const visited = new Set();
            
            while (stack.length > 0) {
                const [row, col] = stack.pop();
                const key = `${row},${col}`;
                
                if (visited.has(key)) continue;
                if (row < 0 || row >= rows || col < 0 || col >= cols) continue;
                
                const cell = grid[row][col];
                
                // Проверка: клетка должна быть того же типа, что и начальная
                if (cell.alive !== targetAlive) continue;
                if (targetAlive && Math.abs(cell.hue - targetHue) > 30) continue;
                
                visited.add(key);
                cell.alive = fillAlive;
                cell.hue = fillHue;
                
                // Добавляем соседей
                stack.push([row - 1, col], [row + 1, col], [row, col - 1], [row, col + 1]);
            }
            
            drawGrid();
            updateStats();
        }

        // Рисование прямоугольника
        function drawRectangle(startRow, startCol, endRow, endCol, alive, hue) {
            const minRow = Math.min(startRow, endRow);
            const maxRow = Math.max(startRow, endRow);
            const minCol = Math.min(startCol, endCol);
            const maxCol = Math.max(startCol, endCol);
            
            // Получаем цвет в зависимости от режима
            const solidHue = colorMode === 'solid' ? hue : null;
            
            if (shapeMode.rectangle === 'filled') {
                // Сплошной прямоугольник
                for (let i = minRow; i <= maxRow; i++) {
                    for (let j = minCol; j <= maxCol; j++) {
                        if (i >= 0 && i < rows && j >= 0 && j < cols) {
                            const cellHue = colorMode === 'random' ? getDrawColor() : solidHue;
                            grid[i][j].alive = alive;
                            grid[i][j].hue = cellHue;
                        }
                    }
                }
            } else {
                // Контур прямоугольника
                for (let i = minRow; i <= maxRow; i++) {
                    for (let j = minCol; j <= maxCol; j++) {
                        // Рисуем только границы
                        if ((i === minRow || i === maxRow || j === minCol || j === maxCol) &&
                            i >= 0 && i < rows && j >= 0 && j < cols) {
                            const cellHue = colorMode === 'random' ? getDrawColor() : solidHue;
                            grid[i][j].alive = alive;
                            grid[i][j].hue = cellHue;
                        }
                    }
                }
            }
        }

        // Рисование круга
        function drawCircle(centerRow, centerCol, endRow, endCol, alive, hue) {
            const radius = Math.sqrt(Math.pow(endRow - centerRow, 2) + Math.pow(endCol - centerCol, 2));
            
            // Получаем цвет в зависимости от режима
            const solidHue = colorMode === 'solid' ? hue : null;
            
            if (shapeMode.circle === 'filled') {
                // Сплошной круг
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const distance = Math.sqrt(Math.pow(i - centerRow, 2) + Math.pow(j - centerCol, 2));
                        if (distance <= radius) {
                            const cellHue = colorMode === 'random' ? getDrawColor() : solidHue;
                            grid[i][j].alive = alive;
                            grid[i][j].hue = cellHue;
                        }
                    }
                }
            } else {
                // Контур круга (с толщиной 1 ячейка)
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const distance = Math.sqrt(Math.pow(i - centerRow, 2) + Math.pow(j - centerCol, 2));
                        // Рисуем кольцо: расстояние примерно равно радиусу (±0.7 для сглаживания)
                        if (Math.abs(distance - radius) < 0.7) {
                            const cellHue = colorMode === 'random' ? getDrawColor() : solidHue;
                            grid[i][j].alive = alive;
                            grid[i][j].hue = cellHue;
                        }
                    }
                }
            }
        }

        // Копирование области (штамп)
        function copyStamp(startRow, startCol, endRow, endCol) {
            const minRow = Math.min(startRow, endRow);
            const maxRow = Math.max(startRow, endRow);
            const minCol = Math.min(startCol, endCol);
            const maxCol = Math.max(startCol, endCol);
            
            stampData = {
                width: maxCol - minCol + 1,
                height: maxRow - minRow + 1,
                cells: []
            };
            
            for (let i = minRow; i <= maxRow; i++) {
                for (let j = minCol; j <= maxCol; j++) {
                    if (i >= 0 && i < rows && j >= 0 && j < cols) {
                        stampData.cells.push({
                            relRow: i - minRow,
                            relCol: j - minCol,
                            alive: grid[i][j].alive,
                            hue: grid[i][j].hue
                        });
                    }
                }
            }
            
            showStampInfo(`Штамп скопирован (${stampData.width}x${stampData.height}). Кликните для вставки.`);
        }

        // Вставка штампа
        function pasteStamp(targetRow, targetCol) {
            if (!stampData) return;
            
            const centerRow = Math.floor(stampData.height / 2);
            const centerCol = Math.floor(stampData.width / 2);
            
            stampData.cells.forEach(cell => {
                const row = targetRow - centerRow + cell.relRow;
                const col = targetCol - centerCol + cell.relCol;
                
                if (row >= 0 && row < rows && col >= 0 && col < cols) {
                    grid[row][col].alive = cell.alive;
                    grid[row][col].hue = cell.hue;
                }
            });
            
            drawGrid();
            updateStats();
        }

        // Применение зеркального рисования
        function applyMirrorDrawing(row, col, alive, hue) {
            const centerRow = Math.floor(rows / 2);
            const centerCol = Math.floor(cols / 2);
            
            // Основная точка
            setCellWithBrush(row, col, alive, hue);
            
            if (mirrorMode) {
                if (mirrorType === 'horizontal' || mirrorType === 'both') {
                    const mirrorCol = centerCol + (centerCol - col);
                    setCellWithBrush(row, mirrorCol, alive, hue);
                }
                
                if (mirrorType === 'vertical' || mirrorType === 'both') {
                    const mirrorRow = centerRow + (centerRow - row);
                    setCellWithBrush(mirrorRow, col, alive, hue);
                }
                
                if (mirrorType === 'both') {
                    const mirrorRow = centerRow + (centerRow - row);
                    const mirrorCol = centerCol + (centerCol - col);
                    setCellWithBrush(mirrorRow, mirrorCol, alive, hue);
                }
                
                if (mirrorType === 'radial') {
                    // Радиальное отражение (4 точки)
                    const dRow = row - centerRow;
                    const dCol = col - centerCol;
                    
                    setCellWithBrush(centerRow - dRow, centerCol + dCol, alive, hue); // 180°
                    setCellWithBrush(centerRow + dCol, centerCol - dRow, alive, hue); // 90°
                    setCellWithBrush(centerRow - dCol, centerCol + dRow, alive, hue); // 270°
                }
            }
        }

        // Установка клетки с учетом размера кисти
        function setCellWithBrush(row, col, alive, hue) {
            for (let dy = -brushSize + 1; dy < brushSize; dy++) {
                for (let dx = -brushSize + 1; dx < brushSize; dx++) {
                    const ny = row + dy;
                    const nx = col + dx;
                    
                    if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
                        grid[ny][nx].alive = alive;
                        if (alive) {
                            grid[ny][nx].hue = hue;
                            grid[ny][nx].age = 0;
                        }
                    }
                }
            }
        }

        // Информация о штампе
        function showStampInfo(text) {
            removeStampInfo();
            const info = document.createElement('div');
            info.className = 'stamp-info';
            info.id = 'stampInfo';
            info.textContent = text;
            document.body.appendChild(info);
        }

        function removeStampInfo() {
            const info = document.getElementById('stampInfo');
            if (info) info.remove();
        }
        // Установка цвета рисования
        function setDrawColor(color, buttonElement) {
            if (color === null) {
                selectedDrawColor = null;
                document.querySelectorAll('.color-pick-btn').forEach(btn => btn.classList.remove('active'));
                if (buttonElement) {
                    buttonElement.classList.add('active');
                }
            } else {
                selectedDrawColor = color;
                document.querySelectorAll('.color-pick-btn').forEach(btn => btn.classList.remove('active'));
            }
        }

        // Установка режима цвета (разноцветный или однотонный)
        function setColorMode(mode) {
            colorMode = mode;
            
            // Обновление активной кнопки
            document.querySelectorAll('#colorModeRandom, #colorModeSolid').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (mode === 'random') {
                document.getElementById('colorModeRandom').classList.add('active');
            } else {
                document.getElementById('colorModeSolid').classList.add('active');
            }
        }
        
        // Установка режима фигур (сплошные или контуры)
        function setShapeMode(shapeType, mode) {
            if (shapeType === 'rectangle') {
                shapeMode.rectangle = mode;
                shapeMode.circle = mode;  // Применяем к обоим
            }
            
            // Обновление активной кнопки
            document.querySelectorAll('#rectModeFilled, #rectModeOutline').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (mode === 'filled') {
                document.getElementById('rectModeFilled').classList.add('active');
            } else {
                document.getElementById('rectModeOutline').classList.add('active');
            }
        }
        
        // Функция для получения цвета в зависимости от настроек
        function getDrawColor() {
            if (selectedDrawColor === null) {
                // Если выбран случайный - всегда случайный
                return Math.random() * 360;
            } else {
                // Если выбран конкретный цвет - конвертируем его в hue
                const rgb = hexToRgb(selectedDrawColor);
                const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                return hsl.h;
            }
        }
        
        // Функция для получения цвета в режиме solid
        function getSolidColor() {
            if (selectedDrawColor === null) {
                // Если не выбран конкретный цвет - используем случайный, но одинаковый для всей фигуры
                return Math.random() * 360;
            } else {
                // Если выбран конкретный цвет
                const rgb = hexToRgb(selectedDrawColor);
                const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                return hsl.h;
            }
        }

        // Функции рисования
        //let isDrawing = false;
        //let lastPos = null;

        function getCellPos(e) {
            const rect = canvas.getBoundingClientRect();
            
            // Шаг 1: Получаем координаты мыши относительно canvas
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Шаг 2: Учитываем CSS-масштабирование (визуальный размер vs внутренний размер canvas)
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const canvasX = x * scaleX;
            const canvasY = y * scaleY;
            
            // Шаг 3: Учитываем zoom и pan (если эти переменные определены)
            const worldX = (canvasX - offsetX) / zoomLevel;
            const worldY = (canvasY - offsetY) / zoomLevel;
            
            // Шаг 4: Преобразуем в координаты ячеек
            return {
                col: Math.floor(worldX / cellSize),
                row: Math.floor(worldY / cellSize)
            };
        }
        
        function handleDrawing(e) {
            const pos = getCellPos(e);
            if (pos.row < 0 || pos.row >= rows || pos.col < 0 || pos.col >= cols) return;
            
            const isEraser = currentTool === 'eraser';
            const hue = isEraser ? 0 : getDrawColor();
            
            // Обработка различных инструментов
            switch (currentTool) {
                case 'brush':
                case 'eraser':
                    applyMirrorDrawing(pos.row, pos.col, !isEraser, hue);
                    drawGrid();
                    break;
                    
                case 'fill':
                    if (!isDrawing) return;
                    isDrawing = false;
                    floodFill(pos.row, pos.col, true, hue);
                    drawGrid();
                    break;
                    
                case 'line':
                    if (isDrawing && shapeStart) {
                        // Рисуем временную линию для предпросмотра
                        drawGrid();
                        drawTemporaryLine(shapeStart.row, shapeStart.col, pos.row, pos.col);
                    }
                    break;
                    
                case 'rectangle':
                    if (isDrawing && shapeStart) {
                        drawGrid();
                        drawTemporaryRectangle(shapeStart.row, shapeStart.col, pos.row, pos.col);
                    }
                    break;
                    
                case 'circle':
                    if (isDrawing && shapeStart) {
                        drawGrid();
                        drawTemporaryCircle(shapeStart.row, shapeStart.col, pos.row, pos.col);
                    }
                    break;
                    
                case 'stamp':
                    if (stampData && !stampSelecting) {
                        // Вставка штампа
                        pasteStamp(pos.row, pos.col);
                    } else if (isDrawing && stampStart) {
                        // Выделение области для штампа
                        drawGrid();
                        drawTemporaryRectangle(stampStart.row, stampStart.col, pos.row, pos.col);
                    }
                    break;
            }
            
            lastPos = pos;
            updateStats();
        }

        // Временное рисование линии (предпросмотр)
        function drawTemporaryLine(startRow, startCol, endRow, endCol) {
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startCol * cellSize + cellSize / 2, startRow * cellSize + cellSize / 2);
            ctx.lineTo(endCol * cellSize + cellSize / 2, endRow * cellSize + cellSize / 2);
            ctx.stroke();
        }

        // Временное рисование прямоугольника (предпросмотр)
        function drawTemporaryRectangle(startRow, startCol, endRow, endCol) {
            const minRow = Math.min(startRow, endRow);
            const maxRow = Math.max(startRow, endRow);
            const minCol = Math.min(startCol, endCol);
            const maxCol = Math.max(startCol, endCol);
            
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
            ctx.lineWidth = 2;
            ctx.strokeRect(minCol * cellSize, minRow * cellSize, 
                           (maxCol - minCol + 1) * cellSize, 
                           (maxRow - minRow + 1) * cellSize);
        }

        // Временное рисование круга (предпросмотр)
        function drawTemporaryCircle(centerRow, centerCol, endRow, endCol) {
            const radius = Math.sqrt(Math.pow(endRow - centerRow, 2) + Math.pow(endCol - centerCol, 2)) * cellSize;
            
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerCol * cellSize + cellSize / 2, 
                    centerRow * cellSize + cellSize / 2, 
                    radius, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Рисование линии с использованием алгоритма Брезенхема
        function drawLine(startRow, startCol, endRow, endCol) {
            // Получаем цвет в зависимости от режима
            const solidHue = colorMode === 'solid' ? getSolidColor() : null;
            
            let x0 = startCol, y0 = startRow;
            let x1 = endCol, y1 = endRow;
            
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                // В режиме random - каждая ячейка своего цвета, в solid - одинаковый
                const hue = colorMode === 'random' ? getDrawColor() : solidHue;
                applyMirrorDrawing(y0, x0, true, hue);
                
                if (x0 === x1 && y0 === y1) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
            
            drawGrid();
        }

        // Конвертация hex в RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r: 255, g: 0, b: 0};
        }

        // Конвертация RGB в HSL
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            
            return {
                h: h * 360,
                s: s * 100,
                l: l * 100
            };
        }

        // Система сохранений
        function saveCurrentState() {
            const state = {
                name: `Состояние ${new Date().toLocaleTimeString()}`,
                timestamp: new Date().toISOString(),
                grid: JSON.parse(JSON.stringify(grid)),
                generation: generation,
                settings: {
                    cellSize: cellSize,
                    colorMode: currentColorMode,
                    rules: currentRules
                }
            };
            
            savedStates.unshift(state);
            if (savedStates.length > 20) savedStates.pop();
            
            localStorage.setItem('gameOfLifeSaves', JSON.stringify(savedStates));
            updateSaveList();
        }
        
        function loadState(index) {
            const state = savedStates[index];
            if (!state) return;
            
            running = false;
            clearInterval(intervalId);
            
            grid = JSON.parse(JSON.stringify(state.grid));
            generation = state.generation;
            
            if (state.settings) {
                cellSize = state.settings.cellSize;
                currentColorMode = state.settings.colorMode || 'inheritance';
                if (state.settings.rules) {
                    currentRules = state.settings.rules;
                }
            }
            
            drawGrid();
            updateStats();
            updateStateIndicator();
        }
        
        function deleteSave(index) {
            savedStates.splice(index, 1);
            localStorage.setItem('gameOfLifeSaves', JSON.stringify(savedStates));
            updateSaveList();
        }
        
        function clearSaves() {
            if (confirm('Удалить все сохранённые состояния?')) {
                savedStates = [];
                localStorage.setItem('gameOfLifeSaves', JSON.stringify(savedStates));
                updateSaveList();
            }
        }
        
        function updateSaveList() {
            const saveList = document.getElementById('saveList');
            if (!saveList) return;
            
            if (savedStates.length === 0) {
                saveList.innerHTML = '<p style="text-align:center; color:#666; padding:10px;">Нет сохранённых состояний</p>';
                return;
            }
            
            saveList.innerHTML = savedStates.map((state, index) => `
                <div class="save-item">
                    <span class="save-name">${state.name}</span>
                    <span class="save-time">${new Date(state.timestamp).toLocaleString()}</span>
                    <button onclick="loadState(${index})">🔄 Загрузить</button>
                    <button onclick="deleteSave(${index})" class="danger">🗑️</button>
                </div>
            `).join('');
        }

        function updateStabilityThreshold(value) {
            minStableGenerations = parseInt(value);
            document.getElementById('stabilityThresholdValue').textContent = value;
        }

        // Управление
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!running) {
                running = true;
                intervalId = setInterval(gameLoop, 1000 / speed);
                updateStateIndicator();
                playUISound('enable');
            }
        });

        document.getElementById('stopBtn').addEventListener('click', () => {
            running = false;
            clearInterval(intervalId);
            updateStateIndicator();
            playUISound('click');
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            if (!running) {
                updateGrid();
                drawGrid();
            }
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            running = false;
            clearInterval(intervalId);
            initGrid();
            drawGrid();
            updateStateIndicator();
            
            // Сброс статистики
            generation = 0;
            populationHistory = [];
            stateHistory = [];
            birthsThisGen = 0;
            deathsThisGen = 0;
            
            updateStats();
            if (chartVisible) {
                updateChart();
            }
            playUISound('click');
        });

        document.getElementById('randomBtn').addEventListener('click', () => {
            initGrid();
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (Math.random() < 0.3) {
                        grid[i][j].alive = true;
                        grid[i][j].hue = Math.random() * 360;
                    }
                }
            }
            drawGrid();
            updateStats();
        });

        // Слайдеры
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = speed;
            
            if (running) {
                clearInterval(intervalId);
                intervalId = setInterval(gameLoop, 1000 / speed);
            }
        });

        document.getElementById('cellSizeSlider').addEventListener('input', (e) => {
            cellSize = parseInt(e.target.value);
            document.getElementById('cellSizeValue').textContent = cellSize;
            
            const wasRunning = running;
            running = false;
            clearInterval(intervalId);
            
            initGrid();
            drawGrid();
            
            if (wasRunning) {
                running = true;
                intervalId = setInterval(gameLoop, 1000 / speed);
            }
        });

        document.getElementById('mutationRateSlider').addEventListener('input', (e) => {
            mutationRate = parseInt(e.target.value) / 100;
            document.getElementById('mutationRateValue').textContent = e.target.value + '%';
        });

        document.getElementById('brushSizeSlider').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        // Wheel для zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            zoom(e.deltaY > 0 ? -1 : 1, mouseX, mouseY);
        }, { passive: false });

        // Рисование мышью
        canvas.addEventListener('mousedown', (e) => {
            // Pan с зажатым пробелом или средней кнопкой
            if (spacePressed || e.button === 1) {
                e.preventDefault();
                startPan(e.clientX, e.clientY);
                return;
            }
            
            // Обычное рисование
            isDrawing = true;
            const pos = getCellPos(e);
            lastPos = pos;
            
            if (['line', 'rectangle', 'circle'].includes(currentTool)) {
                shapeStart = pos;
            }
            
            if (currentTool === 'stamp' && !stampData) {
                stampSelecting = true;
                stampStart = pos;
            }
            
            handleDrawing(e);
        });

        canvas.addEventListener('mouseup', (e) => {

            if (isPanning) {
                endPan();
                return;
            }

            if (!isDrawing) return;
            
            const pos = getCellPos(e);
            
            // Завершение рисования линии
            if (currentTool === 'line' && shapeStart) {
                drawLine(shapeStart.row, shapeStart.col, pos.row, pos.col);
                shapeStart = null;
            }
            
            // Завершение рисования прямоугольника
            if (currentTool === 'rectangle' && shapeStart) {
                const hue = getSolidColor();  // Используем функцию для получения цвета
                drawRectangle(shapeStart.row, shapeStart.col, pos.row, pos.col, true, hue);
                drawGrid();
                shapeStart = null;
            }
            
            // Завершение рисования круга
            if (currentTool === 'circle' && shapeStart) {
                const hue = getSolidColor();  // Используем функцию для получения цвета
                drawCircle(shapeStart.row, shapeStart.col, pos.row, pos.col, true, hue);
                drawGrid();
                shapeStart = null;
            }
            
            // Завершение выделения штампа
            if (currentTool === 'stamp' && stampSelecting && stampStart) {
                copyStamp(stampStart.row, stampStart.col, pos.row, pos.col);
                stampSelecting = false;
                stampStart = null;
            }
            
            isDrawing = false;
            lastPos = null;
            updateStats();
        });

        canvas.addEventListener('mousemove', (e) => {
            // Обновление координат
            const pos = getCellPos(e);
            document.getElementById('coordX').textContent = pos.col;
            document.getElementById('coordY').textContent = pos.row;
            
            // Pan
            if (isPanning) {
                updatePan(e.clientX, e.clientY);
                return;
            }
            
            // Рисование
            if (isDrawing) {
                handleDrawing(e);
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            lastPos = null;
        });

        // Показ/скрытие координат
        canvas.addEventListener('mouseenter', () => {
            document.getElementById('coordsIndicator').style.display = 'block';
        });

        canvas.addEventListener('mouseleave', () => {
            document.getElementById('coordsIndicator').style.display = 'none';
            endPan();
            isDrawing = false;
            lastPos = null;
        });

        // Обработчик свечения
        document.getElementById('glowIntensity').addEventListener('input', (e) => {
            glowIntensity = parseInt(e.target.value);
            document.getElementById('glowValue').textContent = glowIntensity;
            drawGrid();
        });

        // Обработчик режима частиц
        document.getElementById('particleMode').addEventListener('input', (e) => {
            const level = parseInt(e.target.value);
            particleEffects = level > 0;
            particleIntensity = level;
            document.getElementById('particleValue').textContent = level;
            
            if (!particleEffects) {
                particles = [];
            }
        });

        // Обработчик насыщенности
       document.getElementById('saturationSlider').addEventListener('input', (e) => {
           colorSaturation = parseInt(e.target.value);
           document.getElementById('saturationValue').textContent = colorSaturation;
           drawGrid();
       });

       // Обработчик яркости
       document.getElementById('brightnessSlider').addEventListener('input', (e) => {
           colorBrightness = parseInt(e.target.value);
           document.getElementById('brightnessValue').textContent = colorBrightness;
           drawGrid();
       });

       document.getElementById('teamsSlider')?.addEventListener('input', (e) => {
            teamCount = parseInt(e.target.value);
            document.getElementById('teamsValue').textContent = teamCount;
        });

        // ========== ГОРЯЧИЕ КЛАВИШИ ==========
        document.addEventListener('keydown', (e) => {
            // Игнорируем, если фокус на input
            if (e.target.tagName === 'INPUT') return;
            
            // Пробел для pan
            if (e.code === 'Space' && !spacePressed) {
                e.preventDefault();
                spacePressed = true;
                if (!running) {
                    // Если не запущена симуляция, Space = пауза/старт
                    if (e.shiftKey) {
                        // Shift+Space = pan mode
                        canvas.style.cursor = 'grab';
                    } else {
                        // Просто Space = старт/стоп
                        const startBtn = document.getElementById('startBtn');
                        const stopBtn = document.getElementById('stopBtn');
                        if (running) {
                            stopBtn.click();
                        } else {
                            startBtn.click();
                        }
                    }
                }
                return;
            }
            
            // Ctrl комбинации
            if (e.ctrlKey || e.metaKey) {
                switch(e.key.toLowerCase()) {
                    case 's':
                        e.preventDefault();
                        document.querySelector('[onclick*="saveState"]').click();
                        break;
                    case 'z':
                        e.preventDefault();
                        // TODO: Undo (будет в следующих частях)
                        console.log('Undo');
                        break;
                    case 'y':
                        e.preventDefault();
                        // TODO: Redo (будет в следующих частях)
                        console.log('Redo');
                        break;
                }
                return;
            }
            
            // Экспорт (Ctrl/Cmd комбинации)
            if (e.ctrlKey || e.metaKey) {
                switch(e.key.toLowerCase()) {
                    case 'e':
                        e.preventDefault();
                        exportToPNG();
                        break;
                    case 'j':
                        e.preventDefault();
                        exportToJSON();
                        break;
                }
            }

            // Быстрое переключение правил (Ctrl + цифры)
            if (e.ctrlKey) {
                const ruleKeys = {
                    '1': 'conway',
                    '2': 'highlife',
                    '3': 'seeds',
                    '4': 'maze',
                    '5': 'replicator',
                    '6': 'daynight',
                    '7': 'briansbrain',
                    '8': 'wireworld',
                    '9': 'langton'
                };
                
                if (ruleKeys[e.key]) {
                    e.preventDefault();
                    setRule(ruleKeys[e.key]);
                }
            }

            // Остальные клавиши
            switch(e.key.toLowerCase()) {
                case 'h':
                    // H = Help/Hotkeys
                    toggleHotkeys();
                    break;
                case 'a':
                    // A = Audio toggle
                    toggleSound();
                    break;

                case 'q':
                    // Q = muSiQ toggle
                    toggleMusic();
                    break;
                case 's':
                    document.getElementById('stepBtn').click();
                    break;
                case 'c':
                    document.getElementById('clearBtn').click();
                    break;
                case 'r':
                    document.getElementById('randomBtn').click();
                    break;
                case 'b':
                    setTool('brush');
                    break;
                case 'e':
                    setTool('eraser');
                    break;
                case 'l':
                    setTool('line');
                    break;
                case 'f':
                    setTool('fill');
                    break;
                case 't':
                    setTool('stamp');
                    break;
                case 'm':
                    toggleMirrorMode();
                    break;
                case 'g':
                    toggleGrid();
                    break;
                case 'n':
                    toggleMinimap();
                    break;
                case 'v':
                    // Переключение между режимами визуализации
                    const modes = ['standard', 'age', 'density', 'speed', 'heat', 'neon', 'matrix', 'retro'];
                    const currentIndex = modes.indexOf(visualizationMode);
                    const nextIndex = (currentIndex + 1) % modes.length;
                    setVisualizationMode(modes[nextIndex]);
                    break;

                case 'p':
                    // Переключение режима частиц
                    particleIntensity = (particleIntensity === 0) ? 5 : 0;
                    particleEffects = !particleEffects;
                    document.getElementById('particleMode').value = particleEffects ? 1 : 0;
                    document.getElementById('particleValue').textContent = particleEffects ? 'ВКЛ' : 'ВЫКЛ';
                    if (!particleEffects) particles = [];
                    break;
                case 'u':
                    // U = UI theme toggle
                    toggleTheme();
                    break;
                case '+':
                case '=':
                    zoom(1);
                    break;
                case '-':
                case '_':
                    zoom(-1);
                    break;
                case '0':
                    resetZoom();
                    break;
                case '1':
                    placePattern('glider');
                    break;
                case '2':
                    placePattern('blinker');
                    break;
                case '3':
                    placePattern('toad');
                    break;
                case '4':
                    placePattern('beacon');
                    break;
                case '5':
                    placePattern('pulsar');
                    break;
                case '6':
                    placePattern('lwss');
                    break;
                case '7':
                    placePattern('gliderGun');
                    break;
                case '8':
                    placePattern('rpentomino');
                    break;
                case '9':
                    placePattern('acorn');
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spacePressed = false;
                canvas.style.cursor = 'crosshair';
            }
        });

        // Функция переключения панели горячих клавиш
        function toggleHotkeys() {
            const list = document.getElementById('hotkeysList');
            if (list.style.display === 'none') {
                list.style.display = 'block';
            } else {
                list.style.display = 'none';
            }
        }

        // ========== ОБРАБОТЧИКИ ЗВУКОВЫХ НАСТРОЕК ==========

        // Громкость звуков
        document.getElementById('soundVolume')?.addEventListener('input', (e) => {
            soundVolume = parseInt(e.target.value) / 100;
            document.getElementById('soundVolumeValue').textContent = e.target.value + '%';
            
            if (sfxGainNode) {
                sfxGainNode.gain.setValueAtTime(soundVolume, audioContext.currentTime);
            }
            
            // Тестовый звук
            if (soundEnabled) {
                playUISound('click');
            }
        });

        // Громкость музыки
        document.getElementById('musicVolume')?.addEventListener('input', (e) => {
            musicVolume = parseInt(e.target.value) / 100;
            document.getElementById('musicVolumeValue').textContent = e.target.value + '%';
            
            if (musicGainNode) {
                musicGainNode.gain.setValueAtTime(musicVolume, audioContext.currentTime);
            }
        });

        // Чекбоксы звуков
        document.getElementById('birthSoundCheck')?.addEventListener('change', (e) => {
            birthSoundEnabled = e.target.checked;
        });

        document.getElementById('deathSoundCheck')?.addEventListener('change', (e) => {
            deathSoundEnabled = e.target.checked;
        });

        document.getElementById('ambientSoundCheck')?.addEventListener('change', (e) => {
            ambientSoundEnabled = e.target.checked;
            
            if (ambientSoundEnabled && musicEnabled) {
                // Запуск амбиентных звуков
                if (!ambientInterval) {
                    ambientInterval = setInterval(() => {
                        playAmbientSound();
                    }, 2000);
                }
            } else {
                // Остановка амбиентных звуков
                if (ambientInterval) {
                    clearInterval(ambientInterval);
                    ambientInterval = null;
                }
            }
        });

        // Очистка аудио при закрытии страницы
        window.addEventListener('beforeunload', () => {
            stopGenerativeMusic();
            if (audioContext) {
                audioContext.close();
            }
        });

        // Остановка музыки при потере фокуса (опционально)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && musicEnabled) {
                stopGenerativeMusic();
            } else if (!document.hidden && musicEnabled) {
                startGenerativeMusic();
            }
        });

        // Готовые паттерны
        function placePattern(patternName) {
            initGrid();
            const centerX = Math.floor(cols / 2);
            const centerY = Math.floor(rows / 2);
            
            const patterns = {
                // ==================== ОСЦИЛЛЯТОРЫ ====================
                // Период 2
                blinker: [
                    [1, 1, 1]
                ],
                toad: [
                    [0, 1, 1, 1],
                    [1, 1, 1, 0]
                ],
                beacon: [
                    [1, 1, 0, 0],
                    [1, 1, 0, 0],
                    [0, 0, 1, 1],
                    [0, 0, 1, 1]
                ],
                clock: [
                    [0, 0, 1, 0],
                    [0, 0, 1, 1],
                    [1, 1, 0, 0],
                    [0, 1, 0, 0]
                ],
                
                // Период 3
                pulsar: [
                    [0,0,1,1,1,0,0,0,1,1,1,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [0,0,1,1,1,0,0,0,1,1,1,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,1,1,1,0,0,0,1,1,1,0,0],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,1,1,1,0,0,0,1,1,1,0,0]
                ],
                
                // Период 15
                pentadecathlon: [
                    [0,0,1,0,0,0,0,1,0,0],
                    [1,1,0,1,1,1,1,0,1,1],
                    [0,0,1,0,0,0,0,1,0,0]
                ],
                
                // ==================== КОСМИЧЕСКИЕ КОРАБЛИ ====================
                glider: [
                    [0, 1, 0],
                    [0, 0, 1],
                    [1, 1, 1]
                ],
                
                // Lightweight Spaceship
                lwss: [
                    [0,1,0,0,1],
                    [1,0,0,0,0],
                    [1,0,0,0,1],
                    [1,1,1,1,0]
                ],
                
                // Middleweight Spaceship
                mwss: [
                    [0,0,0,1,0,0],
                    [0,1,0,0,0,1],
                    [1,0,0,0,0,0],
                    [1,0,0,0,0,1],
                    [1,1,1,1,1,0]
                ],
                
                // Heavyweight Spaceship
                hwss: [
                    [0,0,0,1,1,0,0],
                    [0,1,0,0,0,0,1],
                    [1,0,0,0,0,0,0],
                    [1,0,0,0,0,0,1],
                    [1,1,1,1,1,1,0]
                ],
                
                // Loafer (медленный корабль)
                loafer: [
                    [0,1,1,0,1,1,0,0,0,0,0,0],
                    [1,0,0,0,0,0,1,0,0,0,0,0],
                    [0,1,0,0,0,0,0,1,0,0,0,0],
                    [0,0,1,0,0,0,1,0,0,0,0,0],
                    [0,0,0,1,1,1,0,0,1,0,0,0],
                    [0,0,0,0,0,0,0,0,0,1,0,0],
                    [0,0,0,0,0,0,0,0,0,0,1,1],
                    [0,0,0,0,0,0,0,0,0,0,1,1]
                ],
                
                // ==================== СТАБИЛЬНЫЕ СТРУКТУРЫ ====================
                block: [
                    [1, 1],
                    [1, 1]
                ],
                
                beehive: [
                    [0, 1, 1, 0],
                    [1, 0, 0, 1],
                    [0, 1, 1, 0]
                ],
                
                loaf: [
                    [0, 1, 1, 0],
                    [1, 0, 0, 1],
                    [0, 1, 0, 1],
                    [0, 0, 1, 0]
                ],
                
                boat: [
                    [1, 1, 0],
                    [1, 0, 1],
                    [0, 1, 0]
                ],
                
                tub: [
                    [0, 1, 0],
                    [1, 0, 1],
                    [0, 1, 0]
                ],
                
                pond: [
                    [0, 1, 1, 0],
                    [1, 0, 0, 1],
                    [1, 0, 0, 1],
                    [0, 1, 1, 0]
                ],
                
                // ==================== ГЕНЕРАТОРЫ ====================
                gliderGun: [
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                    [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                    [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                ],
                
                simkinGliderGun: [
                    [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0],
                    [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0]
                ],
                
                // ==================== МЕЗУРАЦЫ (долгоживущие паттерны) ====================
                rpentomino: [
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 1, 0]
                ],
                
                acorn: [
                    [0, 1, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 0, 0, 0],
                    [1, 1, 0, 0, 1, 1, 1]
                ],
                
                diehard: [
                    [0, 0, 0, 0, 0, 0, 1, 0],
                    [1, 1, 0, 0, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0, 1, 1, 1]
                ],
                
                rabbits: [
                    [1, 0, 0, 1, 1, 1, 0],
                    [1, 1, 1, 0, 0, 1, 0],
                    [0, 1, 0, 0, 0, 0, 0]
                ]
            };
            
            if (patternName === 'rainbow') {
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const dx = j - centerX;
                        const dy = i - centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 10 && distance < 20) {
                            grid[i][j].alive = true;
                            grid[i][j].hue = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
                        }
                    }
                }
            } else if (patternName === 'explosion') {
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const dx = j - centerX;
                        const dy = i - centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 25 && Math.random() < 0.4) {
                            grid[i][j].alive = true;
                            grid[i][j].hue = (distance * 15) % 360;
                        }
                    }
                }
            } else if (patternName === 'spiral') {
                    const arms = 5;
                    const maxRadius = Math.min(rows, cols) / 3;
                    
                    for (let angle = 0; angle < 360 * 3; angle += 2) {
                        const radians = angle * Math.PI / 180;
                        const radius = (angle / (360 * 3)) * maxRadius;
                        
                        for (let arm = 0; arm < arms; arm++) {
                            const armAngle = radians + (arm * 2 * Math.PI / arms);
                            const x = centerX + Math.floor(radius * Math.cos(armAngle));
                            const y = centerY + Math.floor(radius * Math.sin(armAngle));
                            
                            if (y >= 0 && y < rows && x >= 0 && x < cols) {
                                grid[y][x].alive = true;
                                grid[y][x].hue = (angle + arm * 72) % 360;
                            }
                        }
                    }
            } else if (patternName === 'galaxy') {
                // Создаём эффект галактики с вращающимися спиралями
                const arms = 4;
                const density = 0.7;
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const dx = j - centerX;
                        const dy = i - centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        
                        // Создаём спиральные рукава
                        const armAngle = (angle + distance / 10) * arms;
                        const armValue = Math.sin(armAngle);
                        
                        // Плотность уменьшается с расстоянием
                        const probability = density * (1 - distance / Math.min(rows, cols)) * (0.5 + 0.5 * armValue);
                        
                        if (distance < Math.min(rows, cols) / 2 && Math.random() < probability) {
                            grid[i][j].alive = true;
                            grid[i][j].hue = ((angle * 180 / Math.PI) + 180 + distance * 5) % 360;
                        }
                    }
                }
            } else {
                const pattern = patterns[patternName];
                if (pattern) {
                    const offsetY = Math.floor(pattern.length / 2);
                    const offsetX = Math.floor(pattern[0].length / 2);
                    
                    for (let i = 0; i < pattern.length; i++) {
                        for (let j = 0; j < pattern[i].length; j++) {
                            if (pattern[i][j] === 1) {
                                const y = centerY - offsetY + i;
                                const x = centerX - offsetX + j;
                                
                                if (y >= 0 && y < rows && x >= 0 && x < cols) {
                                    grid[y][x].alive = true;
                                    grid[y][x].hue = (i * 30 + j * 30) % 360;
                                }
                            }
                        }
                    }
                }
            }
            
            showPatternInfo(patternName);
            drawGrid();
            updateStats();
            vibrate([10, 50, 10]);
            playUISound('success');
        }

        // База данных описаний паттернов
        const patternDescriptions = {
            // Осцилляторы
            blinker: "Простейший осциллятор периода 2. Переключается между горизонтальной и вертикальной линией.",
            toad: "Осциллятор периода 2, напоминающий жабу.",
            beacon: "Осциллятор периода 2, состоящий из двух блоков.",
            clock: "Осциллятор периода 2 в форме часов.",
            pulsar: "Крупный осциллятор периода 3, один из самых известных.",
            pentadecathlon: "Осциллятор периода 15 - достаточно редкий период.",
            
            // Космические корабли
            glider: "Самый маленький и известный космический корабль. Перемещается по диагонали.",
            lwss: "Lightweight Spaceship - легкий космический корабль, движется горизонтально.",
            mwss: "Middleweight Spaceship - средний космический корабль.",
            hwss: "Heavyweight Spaceship - тяжелый космический корабль.",
            loafer: "Медленный космический корабль необычной формы.",
            
            // Стабильные
            block: "Простейшая стабильная структура из 4 клеток.",
            beehive: "Стабильная структура в форме пчелиного улья.",
            loaf: "Стабильная структура в форме буханки хлеба.",
            boat: "Маленькая стабильная структура в форме лодки.",
            tub: "Стабильная структура из 4 клеток в форме ванны.",
            pond: "Стабильная структура, похожая на пруд.",
            
            // Генераторы
            gliderGun: "Gosper Glider Gun - первый найденный генератор глайдеров (1970).",
            simkinGliderGun: "Более компактный генератор глайдеров.",
            
            // Мезурацы
            rpentomino: "Один из самых известных мезурахов. Стабилизируется на 1103-м поколении.",
            acorn: "Маленький паттерн, который эволюционирует более 5000 поколений.",
            diehard: "Исчезает после 130 поколений, оставляя только мусор.",
            rabbits: "Метастабильный паттерн, создающий множество структур.",
            
            // Специальные
            rainbow: "Разноцветное кольцо с градиентом по углу.",
            explosion: "Радиальный взрыв с цветовым градиентом.",
            spiral: "Пятилучевая спираль с вращающимися рукавами.",
            galaxy: "Галактика со спиральными рукавами и звёздами."
        };

        // Показать информацию о паттерне
        function showPatternInfo(patternName) {
            const info = document.getElementById('patternInfo');
            const nameEl = document.getElementById('patternName');
            const descEl = document.getElementById('patternDescription');
            
            if (patternDescriptions[patternName]) {
                nameEl.textContent = patternName.charAt(0).toUpperCase() + patternName.slice(1);
                descEl.textContent = patternDescriptions[patternName];
                info.style.display = 'block';
            } else {
                info.style.display = 'none';
            }
        }

        // Переключение категорий паттернов
        function showPatternCategory(category) {
            // Скрыть все категории
            document.querySelectorAll('.pattern-category').forEach(cat => {
                cat.style.display = 'none';
            });
            
            // Показать выбранную категорию
            document.getElementById(`category-${category}`).style.display = 'block';
            
            // Обновить активную вкладку
            document.querySelectorAll('.category-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function toggleTrails() {
            settings.showTrails = !settings.showTrails;
            const btn = document.getElementById('toggleTrailsBtn');
            btn.textContent = settings.showTrails ? ' Шлейф: ВКЛ' : ' Шлейф: ВЫКЛ';
            drawGrid();
        }

        // ============================================
        // 5. ИНИЦИАЛИЗАЦИЯ ПРИ ЗАГРУЗКЕ (В САМОМ КОНЦЕ!)
        // ============================================
        
        window.addEventListener('load', () => {
            resizeCanvas();
            updateStateIndicator();
            updateSaveList();
            updateRulesLegend();
            initChart();
            initMinimap();
            initTheme();
            updateStats();

            // Мобильная инициализация
            if (isMobileDevice()) {
                optimizeForMobile();
                showNotification(' Мобильный режим активирован');
            }
            
            // Приветственное сообщение
            setTimeout(() => {
                showNotification(' Игра "Жизнь" загружена! Нажмите H для помощи', 5000);
            }, 500);

            // Скрыть индикатор zoom изначально
            document.getElementById('zoomIndicator').classList.add('hidden');
        });
        
        // Обработчик изменения размера окна
        // Увеличен таймаут для мобильных устройств
        let resizeTimeout = null;

        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            // Увеличенная задержка помогает избежать лишних вызовов при прокрутке
            resizeTimeout = setTimeout(resizeCanvas, 300);
        });

        // Дополнительная защита: игнорируем события resize во время прокрутки
        let scrollTimeout = null;
        let isScrolling = false;

        window.addEventListener('scroll', () => {
            isScrolling = true;
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                isScrolling = false;
            }, 150);
        });
    </script>
</body>
</html>