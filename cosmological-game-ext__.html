<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ê—Ä—Ö–∏—Ç–µ–∫—Ç–æ—Ä –í—Å–µ–ª–µ–Ω–Ω–æ–π - –§–∏–∑–∏–∫–æ-–∫–æ—Å–º–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è –∏–≥—Ä–∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: relative;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .control-panel {
            position: absolute;
            background: rgba(10, 10, 30, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            pointer-events: all;
            box-shadow: 0 0 30px rgba(50, 50, 255, 0.3);
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .control-panel::-webkit-scrollbar {
            width: 8px;
        }

        .control-panel::-webkit-scrollbar-track {
            background: rgba(20, 20, 50, 0.5);
            border-radius: 4px;
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(100, 100, 255, 0.5);
            border-radius: 4px;
        }

        .control-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(120, 120, 255, 0.7);
        }

        #cosmology-panel {
            top: 20px;
            left: 20px;
            width: 300px;
        }

        #philosophy-panel {
            top: 20px;
            right: 20px;
            width: 300px;
        }

        #tools-panel {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            padding: 15px 30px;
            flex-wrap: wrap;
            max-width: 90%;
            justify-content: center;
        }

        #info-panel {
            bottom: 20px;
            left: 20px;
            max-width: 400px;
            opacity: 0.8;
        }

        h2 {
            color: #8080ff;
            margin-bottom: 15px;
            font-size: 1.2em;
            text-shadow: 0 0 10px rgba(128, 128, 255, 0.5);
        }

        .model-option {
            background: rgba(40, 40, 80, 0.6);
            border: 1px solid rgba(100, 100, 255, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .model-option:hover {
            background: rgba(60, 60, 120, 0.8);
            border-color: rgba(150, 150, 255, 0.6);
            transform: translateX(5px);
        }

        .model-option.active {
            background: rgba(80, 80, 160, 0.8);
            border-color: rgba(200, 200, 255, 0.8);
            box-shadow: 0 0 15px rgba(100, 100, 255, 0.5);
        }

        .tool-button {
            background: rgba(50, 50, 100, 0.8);
            border: 1px solid rgba(150, 150, 255, 0.5);
            color: #fff;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            text-shadow: 0 0 5px rgba(100, 100, 255, 0.5);
        }

        .tool-button:hover {
            background: rgba(80, 80, 150, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 100, 255, 0.4);
        }

        .tool-button.active {
            background: rgba(100, 100, 200, 0.9);
            box-shadow: 0 0 20px rgba(150, 150, 255, 0.6);
        }

        .parameter-slider {
            margin: 10px 0;
        }

        .parameter-slider label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #a0a0ff;
        }

        .parameter-slider input[type="range"] {
            width: 100%;
            height: 5px;
            background: rgba(50, 50, 100, 0.5);
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }

        .parameter-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #8080ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(128, 128, 255, 0.5);
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-text {
            font-size: 2em;
            color: #8080ff;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }

        .stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }

        /* –≠—Ñ—Ñ–µ–∫—Ç—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–∏—Ö –ø–∞—Ä–∞–¥–∏–≥–º */
        .philosophy-materialism {
            --primary-color: #4080ff;
            --secondary-color: #80a0ff;
            --glow-color: rgba(64, 128, 255, 0.5);
        }

        .philosophy-idealism {
            --primary-color: #ff80ff;
            --secondary-color: #ffb0ff;
            --glow-color: rgba(255, 128, 255, 0.5);
        }

        .philosophy-panpsychism {
            --primary-color: #80ff80;
            --secondary-color: #b0ffb0;
            --glow-color: rgba(128, 255, 128, 0.5);
        }

        .philosophy-holographic {
            --primary-color: #00ffff;
            --secondary-color: #80ffff;
            --glow-color: rgba(0, 255, 255, 0.5);
        }

        .philosophy-emergentism {
            --primary-color: #ffff00;
            --secondary-color: #ffffb0;
            --glow-color: rgba(255, 255, 0, 0.5);
        }

        .philosophy-dualism {
            --primary-color: #ff00ff;
            --secondary-color: #ff80ff;
            --glow-color: rgba(255, 0, 255, 0.5);
        }

        .philosophy-process {
            --primary-color: #ff8000;
            --secondary-color: #ffb080;
            --glow-color: rgba(255, 128, 0, 0.5);
        }

        .philosophy-information {
            --primary-color: #00ff00;
            --secondary-color: #80ff80;
            --glow-color: rgba(0, 255, 0, 0.5);
        }

        /* –ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã */
        @keyframes quantumFlicker {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        @keyframes waveDistortion {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }

        @keyframes glitch {
            0%, 100% { 
                text-shadow: 
                    0.05em 0 0 rgba(255, 0, 0, 0.75),
                    -0.025em -0.05em 0 rgba(0, 255, 0, 0.75),
                    0.025em 0.05em 0 rgba(0, 0, 255, 0.75);
            }
            14% {
                text-shadow: 
                    0.05em 0 0 rgba(255, 0, 0, 0.75),
                    -0.05em -0.025em 0 rgba(0, 255, 0, 0.75),
                    0.025em 0.05em 0 rgba(0, 0, 255, 0.75);
            }
            15% {
                text-shadow: 
                    -0.05em -0.025em 0 rgba(255, 0, 0, 0.75),
                    0.025em 0.025em 0 rgba(0, 255, 0, 0.75),
                    -0.05em -0.05em 0 rgba(0, 0, 255, 0.75);
            }
            49% {
                text-shadow: 
                    -0.05em -0.025em 0 rgba(255, 0, 0, 0.75),
                    0.025em 0.025em 0 rgba(0, 255, 0, 0.75),
                    -0.05em -0.05em 0 rgba(0, 0, 255, 0.75);
            }
            50% {
                text-shadow: 
                    0.025em 0.05em 0 rgba(255, 0, 0, 0.75),
                    0.05em 0 0 rgba(0, 255, 0, 0.75),
                    0 -0.05em 0 rgba(0, 0, 255, 0.75);
            }
            99% {
                text-shadow: 
                    0.025em 0.05em 0 rgba(255, 0, 0, 0.75),
                    0.05em 0 0 rgba(0, 255, 0, 0.75),
                    0 -0.05em 0 rgba(0, 0, 255, 0.75);
            }
        }

        /* Volumetric —ç—Ñ—Ñ–µ–∫—Ç—ã */
        .volumetric-fog {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                transparent 0%, 
                rgba(100, 100, 255, 0.1) 50%, 
                rgba(50, 50, 200, 0.2) 100%);
            pointer-events: none;
            mix-blend-mode: screen;
        }

        @media (max-height: 768px) {
            .control-panel {
                max-height: 70vh;
            }
            
            #cosmology-panel,
            #philosophy-panel {
                width: 250px;
                font-size: 0.9em;
            }
            
            .model-option {
                padding: 8px;
                margin-bottom: 6px;
            }
            
            .parameter-slider {
                margin: 6px 0;
            }
        }

    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="loading-text">–°–æ–∑–¥–∞–Ω–∏–µ –í—Å–µ–ª–µ–Ω–Ω–æ–π...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <div id="cosmology-panel" class="control-panel">
            <h2>–ö–æ—Å–º–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å</h2>
            <div class="model-option active" data-model="bigbang">
                <strong>–ë–æ–ª—å—à–æ–π –≤–∑—Ä—ã–≤</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–†–∞—Å—à–∏—Ä—è—é—â–∞—è—Å—è –≤—Å–µ–ª–µ–Ω–Ω–∞—è –∏–∑ —Å–∏–Ω–≥—É–ª—è—Ä–Ω–æ—Å—Ç–∏</p>
            </div>
            <div class="model-option" data-model="steady">
                <strong>–°—Ç–∞—Ü–∏–æ–Ω–∞—Ä–Ω–∞—è –≤—Å–µ–ª–µ–Ω–Ω–∞—è</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–ù–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –º–∞—Ç–µ—Ä–∏–∏</p>
            </div>
            <div class="model-option" data-model="cyclic">
                <strong>–¶–∏–∫–ª–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–µ —Ü–∏–∫–ª—ã —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –∏ —Å–∂–∞—Ç–∏—è</p>
            </div>
            <div class="model-option" data-model="multiverse">
                <strong>–ú—É–ª—å—Ç–∏–≤—Å–µ–ª–µ–Ω–Ω–∞—è</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–ú–Ω–æ–∂–µ—Å—Ç–≤–æ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –≤—Å–µ–ª–µ–Ω–Ω—ã—Ö</p>
            </div>

            <div class="model-option" data-model="inflation">
                <strong>–ò–Ω—Ñ–ª—è—Ü–∏–æ–Ω–Ω–∞—è –º–æ–¥–µ–ª—å</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –ø–æ—Å–ª–µ –ë–æ–ª—å—à–æ–≥–æ –≤–∑—Ä—ã–≤–∞</p>
            </div>
            <div class="model-option" data-model="darkenergy">
                <strong>–ú–æ–¥–µ–ª—å —Å —Ç–µ–º–Ω–æ–π —ç–Ω–µ—Ä–≥–∏–µ–π</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–£—Å–∫–æ—Ä—è—é—â–µ–µ—Å—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –≤—Å–µ–ª–µ–Ω–Ω–æ–π</p>
            </div>
            <div class="model-option" data-model="branes">
                <strong>–ë—Ä–∞–Ω—ã –∏ –≤—ã—Å—à–∏–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –≤—Å–µ–ª–µ–Ω–Ω—ã—Ö</p>
            </div>
            <div class="model-option" data-model="quantum">
                <strong>–ö–≤–∞–Ω—Ç–æ–≤–∞—è –∫–æ—Å–º–æ–ª–æ–≥–∏—è</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–í—Å–µ–ª–µ–Ω–Ω–∞—è –∏–∑ –∫–≤–∞–Ω—Ç–æ–≤—ã—Ö —Ñ–ª—É–∫—Ç—É–∞—Ü–∏–π</p>
            </div>
            
            <div class="parameter-slider">
                <label>–°–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–µ–º–µ–Ω–∏: <span id="time-speed-value">1.0</span>x</label>
                <input type="range" id="time-speed" min="0" max="10" step="0.1" value="1">
            </div>
            
            <div class="parameter-slider">
                <label>–ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–æ—Å—Ç–æ—è–Ω–Ω–∞—è: <span id="gravity-value">1.0</span></label>
                <input type="range" id="gravity-constant" min="0" max="2" step="0.1" value="1">
            </div>
        </div>

        <div id="philosophy-panel" class="control-panel">
            <h2>–§–∏–ª–æ—Å–æ—Ñ—Å–∫–∞—è –ø–∞—Ä–∞–¥–∏–≥–º–∞</h2>
            <div class="model-option active" data-philosophy="materialism">
                <strong>–ú–∞—Ç–µ—Ä–∏–∞–ª–∏–∑–º</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–¢–æ–ª—å–∫–æ –º–∞—Ç–µ—Ä–∏—è –∏ —Ñ–∏–∑–∏—á–µ—Å–∫–∏–µ –∑–∞–∫–æ–Ω—ã</p>
            </div>
            <div class="model-option" data-philosophy="idealism">
                <strong>–ò–¥–µ–∞–ª–∏–∑–º</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–°–æ–∑–Ω–∞–Ω–∏–µ –ø–µ—Ä–≤–∏—á–Ω–æ, –º–∞—Ç–µ—Ä–∏—è –≤—Ç–æ—Ä–∏—á–Ω–∞</p>
            </div>
            <div class="model-option" data-philosophy="panpsychism">
                <strong>–ü–∞–Ω–ø—Å–∏—Ö–∏–∑–º</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–°–æ–∑–Ω–∞–Ω–∏–µ - —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ</p>
            </div>
            <div class="model-option" data-philosophy="holographic">
                <strong>–ì–æ–ª–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–Ω—Ü–∏–ø</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–†–µ–∞–ª—å–Ω–æ—Å—Ç—å –∫–∞–∫ –ø—Ä–æ–µ–∫—Ü–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏</p>
            </div>

            <div class="model-option" data-philosophy="emergentism">
                <strong>–≠–º–µ—Ä–¥–∂–µ–Ω—Ç–∏–∑–º</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–°–ª–æ–∂–Ω–æ—Å—Ç—å –≤–æ–∑–Ω–∏–∫–∞–µ—Ç –∏–∑ –ø—Ä–æ—Å—Ç—ã—Ö –ø—Ä–∞–≤–∏–ª</p>
            </div>
            <div class="model-option" data-philosophy="dualism">
                <strong>–î—É–∞–ª–∏–∑–º</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –º–∞—Ç–µ—Ä–∏–∏ –∏ —Å–æ–∑–Ω–∞–Ω–∏—è</p>
            </div>
            <div class="model-option" data-philosophy="process">
                <strong>–ü—Ä–æ—Ü–µ—Å—Å—É–∞–ª—å–Ω–∞—è —Ñ–∏–ª–æ—Å–æ—Ñ–∏—è</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–í—Å—ë –µ—Å—Ç—å –ø—Ä–æ—Ü–µ—Å—Å, –Ω–µ —Å—É–±—Å—Ç–∞–Ω—Ü–∏—è</p>
            </div>
            <div class="model-option" data-philosophy="information">
                <strong>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –æ–Ω—Ç–æ–ª–æ–≥–∏—è</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">–í—Å–µ–ª–µ–Ω–Ω–∞—è –∫–∞–∫ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ</p>
            </div>
            
            <div class="parameter-slider">
                <label>–ö–≤–∞–Ω—Ç–æ–≤–∞—è –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ—Å—Ç—å: <span id="quantum-value">0.5</span></label>
                <input type="range" id="quantum-uncertainty" min="0" max="1" step="0.05" value="0.5">
            </div>
            
            <div class="parameter-slider">
                <label>–≠–Ω—Ç—Ä–æ–ø–∏—è: <span id="entropy-value">0.3</span></label>
                <input type="range" id="entropy-level" min="0" max="1" step="0.05" value="0.3">
            </div>

            <div class="parameter-slider">
                <label>–¢–µ–º–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è: <span id="dark-energy-value">0.7</span></label>
                <input type="range" id="dark-energy" min="0" max="1" step="0.05" value="0.7">
            </div>

            <div class="parameter-slider">
                <label>–ò–Ω—Ñ–ª—è—Ü–∏–æ–Ω–Ω–æ–µ –ø–æ–ª–µ: <span id="inflation-field-value">0.0</span></label>
                <input type="range" id="inflation-field" min="0" max="1" step="0.05" value="0">
            </div>

            <div class="parameter-slider">
                <label>–≠–º–µ—Ä–¥–∂–µ–Ω—Ç–Ω–æ—Å—Ç—å: <span id="emergence-value">0.5</span></label>
                <input type="range" id="emergence-level" min="0" max="1" step="0.05" value="0.5">
            </div>

            <div class="parameter-slider">
                <label>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: <span id="information-value">0.5</span></label>
                <input type="range" id="information-complexity" min="0" max="1" step="0.05" value="0.5">
            </div>

        </div>

        <div id="tools-panel" class="control-panel">
            <button class="tool-button active" data-tool="observe">–ù–∞–±–ª—é–¥–∞—Ç—å</button>
            <button class="tool-button" data-tool="create-star">–°–æ–∑–¥–∞—Ç—å –∑–≤–µ–∑–¥—É</button>
            <button class="tool-button" data-tool="create-planet">–°–æ–∑–¥–∞—Ç—å –ø–ª–∞–Ω–µ—Ç—É</button>
            <button class="tool-button" data-tool="create-blackhole">–°–æ–∑–¥–∞—Ç—å —á—ë—Ä–Ω—É—é –¥—ã—Ä—É</button>
            <button class="tool-button" data-tool="create-galaxy">–°–æ–∑–¥–∞—Ç—å –≥–∞–ª–∞–∫—Ç–∏–∫—É</button>
            <button class="tool-button" data-tool="manipulate">–ú–∞–Ω–∏–ø—É–ª–∏—Ä–æ–≤–∞—Ç—å</button>
            <button class="tool-button" data-tool="create-neutronstar">–ù–µ–π—Ç—Ä–æ–Ω–Ω–∞—è –∑–≤–µ–∑–¥–∞</button>
            <button class="tool-button" data-tool="create-quasar">–ö–≤–∞–∑–∞—Ä</button>
            <button class="tool-button" data-tool="create-darkmatter">–¢–µ–º–Ω–∞—è –º–∞—Ç–µ—Ä–∏—è</button>
            <button class="tool-button" data-tool="create-wormhole">–ß–µ—Ä–≤–æ—Ç–æ—á–∏–Ω–∞</button>
            <button class="tool-button" onclick="UniverseSerializer.download()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            <button class="tool-button" onclick="UniverseSerializer.upload()">üìÅ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
        </div>

        <div id="game-modes-panel" class="control-panel" style="top: 10%; left: 20px; max-height: 80vh; overflow-y: auto;">
            <h2>–†–µ–∂–∏–º –∏–≥—Ä—ã</h2>
            <button class="tool-button active" onclick="setGameMode('sandbox')">–ü–µ—Å–æ—á–Ω–∏—Ü–∞</button>
            <button class="tool-button" onclick="setGameMode('scenarios')">–°—Ü–µ–Ω–∞—Ä–∏–∏</button>
            <button class="tool-button" onclick="setGameMode('challenges')">–í—ã–∑–æ–≤—ã</button>
            <button class="tool-button" onclick="setGameMode('research')">–ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ</button>
            
            <div id="mode-content" style="margin-top: 20px;">
                <!-- –ö–æ–Ω—Ç–µ–Ω—Ç —Ä–µ–∂–∏–º–∞ -->
            </div>
        </div>

        <div id="info-panel" class="control-panel">
            <h2>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è</h2>
            <div id="info-content">
                <p>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Å–∏–º—É–ª—è—Ç–æ—Ä –í—Å–µ–ª–µ–Ω–Ω–æ–π!</p>
                <p>–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ—Å–º–æ–ª–æ–≥–∏—á–µ—Å–∫—É—é –º–æ–¥–µ–ª—å –∏ —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫—É—é –ø–∞—Ä–∞–¥–∏–≥–º—É, –∑–∞—Ç–µ–º —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ —Å —Å–æ–∑–¥–∞–Ω–∏–µ–º –∏ –º–∞–Ω–∏–ø—É–ª–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∫–æ—Å–º–∏—á–µ—Å–∫–∏–º–∏ –æ–±—ä–µ–∫—Ç–∞–º–∏.</p>
            </div>
        </div>

        <div class="stats" id="stats">
            FPS: <span id="fps">0</span><br>
            –û–±—ä–µ–∫—Ç–æ–≤: <span id="object-count">0</span><br>
            –í—Ä–µ–º—è: <span id="universe-time">0</span> –º–ª—Ä–¥ –ª–µ—Ç
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let scene, camera, renderer;
        let objects = [];
        let selectedTool = 'observe';
        let cosmologyModel = 'bigbang';
        let philosophyModel = 'materialism';
        let universeTime = 0;
        let timeSpeed = 1;
        let gravityConstant = 1;
        let quantumUncertainty = 0.5;
        let entropyLevel = 0.3;

        let darkEnergy = 0.7;
        let inflationField = 0;
        let emergenceLevel = 0.5;
        let informationComplexity = 0.5;
        let quantumFluctuations = [];
        let braneInteractions = [];
        let inflationEpoch = false;
        let universePhase = 'expansion'; // 'inflation', 'expansion', 'contraction', 'steady'

        let clock = new THREE.Clock();
        let stats = { fps: 0, frameCount: 0, lastTime: 0 };

        let renderOptimizer = null;
        let frustumCulling = null;

        // –ü–∞–ª–∏—Ç—Ä—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–∏—Ö –ø–∞—Ä–∞–¥–∏–≥–º
        const philosophyPalettes = {
            materialism: {
                colors: [0x4080ff, 0x80a0ff, 0x6090ff, 0x40a0ff, 0x8080ff],
                emissive: 0x202040,
                fog: 0x000033
            },
            idealism: {
                colors: [0xff80ff, 0xffb0ff, 0xff90ff, 0xffa0ff, 0xff80ff],
                emissive: 0x402040,
                fog: 0x330033
            },
            panpsychism: {
                colors: [0x80ff80, 0xb0ffb0, 0x90ff90, 0xa0ffa0, 0x80ff80],
                emissive: 0x204020,
                fog: 0x003300
            },
            holographic: {
                colors: [0x00ffff, 0x80ffff, 0x00ffff, 0x40ffff, 0x00ffff],
                emissive: 0x004040,
                fog: 0x003333
            },
            emergentism: {
                colors: [0xffff00, 0xffffb0, 0xffff80, 0xffffa0, 0xffff00],
                emissive: 0x404020,
                fog: 0x333300
            },
            dualism: {
                colors: [0xff00ff, 0xff80ff, 0xff00ff, 0xff40ff, 0xff00ff],
                emissive: 0x400040,
                fog: 0x330033
            },
            process: {
                colors: [0xff8000, 0xffb080, 0xff9040, 0xffa060, 0xff8000],
                emissive: 0x402000,
                fog: 0x331100
            },
            information: {
                colors: [0x00ff00, 0x80ff80, 0x40ff40, 0x60ff60, 0x00ff00],
                emissive: 0x004000,
                fog: 0x003300
            }
        };

        // –°–∏—Å—Ç–µ–º–∞ –∏–≥—Ä–æ–≤—ã—Ö —Ä–µ–∂–∏–º–æ–≤
        let currentGameMode = 'sandbox';
        let currentScenario = null;
        let currentChallenge = null;

        const scenarios = {
            solarSystem: {
                name: '–°–æ–ª–Ω–µ—á–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞',
                description: '–í–æ—Å—Å–æ–∑–¥–∞–π—Ç–µ –Ω–∞—à—É –°–æ–ª–Ω–µ—á–Ω—É—é —Å–∏—Å—Ç–µ–º—É',
                setup: () => {
                    objects = [];
                    scene.children = scene.children.filter(child => 
                        child.type === 'AmbientLight' || 
                        child.type === 'PointLight' || 
                        child.type === 'Points'
                    );
                    
                    // –°–æ–ª–Ω—Ü–µ
                    const sun = createStar(new THREE.Vector3(0, 0, 0));
                    
                    // –ü–ª–∞–Ω–µ—Ç—ã
                    const planets = [
                        { name: '–ú–µ—Ä–∫—É—Ä–∏–π', distance: 10, size: 0.4 },
                        { name: '–í–µ–Ω–µ—Ä–∞', distance: 15, size: 0.9 },
                        { name: '–ó–µ–º–ª—è', distance: 20, size: 1 },
                        { name: '–ú–∞—Ä—Å', distance: 25, size: 0.5 },
                        { name: '–Æ–ø–∏—Ç–µ—Ä', distance: 40, size: 3 },
                        { name: '–°–∞—Ç—É—Ä–Ω', distance: 55, size: 2.5 },
                        { name: '–£—Ä–∞–Ω', distance: 70, size: 1.5 },
                        { name: '–ù–µ–ø—Ç—É–Ω', distance: 85, size: 1.4 }
                    ];
                    
                    planets.forEach(p => {
                        const angle = Math.random() * Math.PI * 2;
                        const position = new THREE.Vector3(
                            Math.cos(angle) * p.distance,
                            0,
                            Math.sin(angle) * p.distance
                        );
                        const velocity = new THREE.Vector3(
                            -Math.sin(angle) * Math.sqrt(10 / p.distance),
                            0,
                            Math.cos(angle) * Math.sqrt(10 / p.distance)
                        );
                        createPlanet(position, velocity);
                    });
                }
            },
            
            binaryStars: {
                name: '–î–≤–æ–π–Ω–∞—è –∑–≤–µ–∑–¥–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞',
                description: '–°–æ–∑–¥–∞–π—Ç–µ —Å—Ç–∞–±–∏–ª—å–Ω—É—é —Å–∏—Å—Ç–µ–º—É –∏–∑ –¥–≤—É—Ö –∑–≤–µ–∑–¥',
                setup: () => {
                    objects = [];
                    scene.children = scene.children.filter(child => 
                        child.type === 'AmbientLight' || 
                        child.type === 'PointLight' || 
                        child.type === 'Points'
                    );
                    
                    const star1 = createStar(new THREE.Vector3(-20, 0, 0));
                    const star2 = createStar(new THREE.Vector3(20, 0, 0));
                    
                    objects[objects.length - 2].velocity = new THREE.Vector3(0, 0, 5);
                    objects[objects.length - 1].velocity = new THREE.Vector3(0, 0, -5);
                }
            },
            
            galaxyCollision: {
                name: '–°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ –≥–∞–ª–∞–∫—Ç–∏–∫',
                description: '–ù–∞–±–ª—é–¥–∞–π—Ç–µ —Å–ª–∏—è–Ω–∏–µ –¥–≤—É—Ö –≥–∞–ª–∞–∫—Ç–∏–∫',
                setup: () => {
                    objects = [];
                    scene.children = scene.children.filter(child => 
                        child.type === 'AmbientLight' || 
                        child.type === 'PointLight' || 
                        child.type === 'Points'
                    );
                    
                    createGalaxy(new THREE.Vector3(-50, 0, 0));
                    createGalaxy(new THREE.Vector3(50, 0, 0));
                    
                    // –ü—Ä–∏–¥–∞–µ–º –≥–∞–ª–∞–∫—Ç–∏–∫–∞–º —Å–∫–æ—Ä–æ—Å—Ç—å –Ω–∞–≤—Å—Ç—Ä–µ—á—É –¥—Ä—É–≥ –¥—Ä—É–≥—É
                    objects[objects.length - 2].velocity = new THREE.Vector3(5, 0, 0);
                    objects[objects.length - 1].velocity = new THREE.Vector3(-5, 0, 0);
                }
            }
        };

        const challenges = {
            stableOrbit: {
                name: '–°—Ç–∞–±–∏–ª—å–Ω–∞—è –æ—Ä–±–∏—Ç–∞',
                description: '–°–æ–∑–¥–∞–π—Ç–µ –ø–ª–∞–Ω–µ—Ç—É —Å–æ —Å—Ç–∞–±–∏–ª—å–Ω–æ–π –∫—Ä—É–≥–æ–≤–æ–π –æ—Ä–±–∏—Ç–æ–π –≤–æ–∫—Ä—É–≥ –∑–≤–µ–∑–¥—ã',
                checkCondition: () => {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∑–≤–µ–∑–¥—ã –∏ –ø–ª–∞–Ω–µ—Ç—ã
                    const stars = objects.filter(o => o.type === 'star');
                    const planets = objects.filter(o => o.type === 'planet');
                    
                    if (stars.length === 0 || planets.length === 0) return false;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å –æ—Ä–±–∏—Ç—ã
                    const star = stars[0];
                    const planet = planets[0];
                    const distance = star.position.distanceTo(planet.position);
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ç–æ—Ä–∏—é —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π
                    if (!window.orbitHistory) window.orbitHistory = [];
                    window.orbitHistory.push(distance);
                    
                    if (window.orbitHistory.length > 100) {
                        window.orbitHistory.shift();
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ—Ä–±–∏—Ç–∞ –∫—Ä—É–≥–æ–≤–∞—è (–º–∞–ª–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è)
                        const avgDistance = window.orbitHistory.reduce((a, b) => a + b) / window.orbitHistory.length;
                        const variance = window.orbitHistory.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / window.orbitHistory.length;
                        
                        if (variance < 1) {
                            updateInfo('–í—ã–∑–æ–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω! –°–æ–∑–¥–∞–Ω–∞ —Å—Ç–∞–±–∏–ª—å–Ω–∞—è –æ—Ä–±–∏—Ç–∞!');
                            return true;
                        }
                    }
                    
                    return false;
                }
            },
            
            createLife: {
                name: '–ó–∞—Ä–æ–∂–¥–µ–Ω–∏–µ –∂–∏–∑–Ω–∏',
                description: '–°–æ–∑–¥–∞–π—Ç–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –≤–æ–∑–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏—è –∂–∏–∑–Ω–∏ –Ω–∞ –ø–ª–∞–Ω–µ—Ç–µ',
                checkCondition: () => {
                    const livingPlanets = objects.filter(o => o.type === 'planet' && o.hasLife);
                    if (livingPlanets.length > 0) {
                        updateInfo('–í—ã–∑–æ–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω! –ñ–∏–∑–Ω—å –∑–∞—Ä–æ–¥–∏–ª–∞—Å—å!');
                        return true;
                    }
                    return false;
                }
            },
            
            supernovaEvent: {
                name: '–°–≤–µ—Ä—Ö–Ω–æ–≤–∞—è',
                description: '–î–æ–≤–µ–¥–∏—Ç–µ –∑–≤–µ–∑–¥—É –¥–æ –≤–∑—Ä—ã–≤–∞ —Å–≤–µ—Ä—Ö–Ω–æ–≤–æ–π',
                checkCondition: () => {
                    // –≠—Ç–æ—Ç –≤—ã–∑–æ–≤ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ –≤–∑—Ä—ã–≤–µ —Å–≤–µ—Ä—Ö–Ω–æ–≤–æ–π
                    return false;
                }
            }
        };

        function setGameMode(mode) {
            currentGameMode = mode;
            document.querySelectorAll('#game-modes-panel button').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            
            const modeContent = document.getElementById('mode-content');
            
            switch(mode) {
                case 'sandbox':
                    modeContent.innerHTML = '<p>–°–≤–æ–±–æ–¥–Ω–æ–µ —Ç–≤–æ—Ä—á–µ—Å—Ç–≤–æ –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π</p>';
                    break;
                    
                case 'scenarios':
                    let scenariosHtml = '<h3>–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ü–µ–Ω–∞—Ä–∏–π:</h3>';
                    for (let key in scenarios) {
                        scenariosHtml += `
                            <div class="model-option" onclick="loadScenario('${key}')">
                                <strong>${scenarios[key].name}</strong>
                                <p style="font-size: 0.85em; margin-top: 5px;">${scenarios[key].description}</p>
                            </div>
                        `;
                    }
                    modeContent.innerHTML = scenariosHtml;
                    break;
                    
                case 'challenges':
                    let challengesHtml = '<h3>–í—ã–±–µ—Ä–∏—Ç–µ –≤—ã–∑–æ–≤:</h3>';
                    for (let key in challenges) {
                        challengesHtml += `
                            <div class="model-option" onclick="startChallenge('${key}')">
                                <strong>${challenges[key].name}</strong>
                                <p style="font-size: 0.85em; margin-top: 5px;">${challenges[key].description}</p>
                            </div>
                        `;
                    }
                    modeContent.innerHTML = challengesHtml;
                    break;
                    
                case 'research':
                    modeContent.innerHTML = `
                        <h3>–†–µ–∂–∏–º –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è</h3>
                        <p>–≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ —Å –∑–∞–∫–æ–Ω–∞–º–∏ —Ñ–∏–∑–∏–∫–∏ –∏ –æ—Ç–∫—Ä—ã–≤–∞–π—Ç–µ –Ω–æ–≤—ã–µ —è–≤–ª–µ–Ω–∏—è!</p>
                        <div class="parameter-slider">
                            <label>–°–∫–æ—Ä–æ—Å—Ç—å —Å–≤–µ—Ç–∞: <span id="light-speed-value">1.0</span>c</label>
                            <input type="range" id="light-speed" min="0.1" max="10" step="0.1" value="1">
                        </div>
                        <div class="parameter-slider">
                            <label>–ü–ª–∞–Ω–∫–æ–≤—Å–∫–∞—è –ø–æ—Å—Ç–æ—è–Ω–Ω–∞—è: <span id="planck-value">1.0</span>‚Ñè</label>
                            <input type="range" id="planck-constant" min="0.1" max="10" step="0.1" value="1">
                        </div>
                    `;
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
                    setTimeout(() => {
                        document.getElementById('light-speed')?.addEventListener('input', function() {
                            const value = parseFloat(this.value);
                            document.getElementById('light-speed-value').textContent = value.toFixed(1);
                            // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫ —Ñ–∏–∑–∏–∫–µ
                        });
                        
                        document.getElementById('planck-constant')?.addEventListener('input', function() {
                            const value = parseFloat(this.value);
                            document.getElementById('planck-value').textContent = value.toFixed(1);
                            quantumUncertainty = value * 0.5;
                        });
                    }, 100);
                    break;
            }
        }

        function loadScenario(scenarioKey) {
            currentScenario = scenarios[scenarioKey];
            currentScenario.setup();
            updateInfo(`–ó–∞–≥—Ä—É–∂–µ–Ω —Å—Ü–µ–Ω–∞—Ä–∏–π: ${currentScenario.name}`);
        }

        function startChallenge(challengeKey) {
            currentChallenge = challenges[challengeKey];
            updateInfo(`–ù–∞—á–∞—Ç –≤—ã–∑–æ–≤: ${currentChallenge.name}`);
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É —É—Å–ª–æ–≤–∏–π –≤—ã–∑–æ–≤–∞
            const checkInterval = setInterval(() => {
                if (currentChallenge.checkCondition()) {
                    clearInterval(checkInterval);
                    currentChallenge = null;
                }
            }, 1000);
        }

        class UniverseSerializer {
            static save() {
                const saveData = {
                    version: "1.0",
                    timestamp: Date.now(),
                    cosmology: cosmologyModel,
                    philosophy: philosophyModel,
                    parameters: {
                        timeSpeed,
                        gravityConstant,
                        quantumUncertainty,
                        entropyLevel,
                        darkEnergy,
                        inflationField,
                        emergenceLevel,
                        informationComplexity
                    },
                    objects: objects.map(obj => ({
                        type: obj.type,
                        position: obj.position.toArray(),
                        velocity: obj.velocity.toArray(),
                        mass: obj.mass,
                        age: obj.age,
                        temperature: obj.temperature,
                        evolutionStage: obj.evolutionStage,
                        fuelRemaining: obj.fuelRemaining,
                        hasLife: obj.hasLife,
                        lifeStage: obj.lifeStage
                    })),
                    statistics: {
                        totalTime: universeTime,
                        objectsCreated: objects.length
                    },
                    camera: {
                        position: camera.position.toArray(),
                        rotation: camera.rotation.toArray()
                    }
                };
                
                return JSON.stringify(saveData, null, 2);
            }
            
            static load(jsonData) {
                try {
                    const data = JSON.parse(jsonData);
                    
                    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
                    cosmologyModel = data.cosmology;
                    philosophyModel = data.philosophy;
                    
                    timeSpeed = data.parameters.timeSpeed;
                    gravityConstant = data.parameters.gravityConstant;
                    quantumUncertainty = data.parameters.quantumUncertainty;
                    entropyLevel = data.parameters.entropyLevel;
                    darkEnergy = data.parameters.darkEnergy || 0.7;
                    inflationField = data.parameters.inflationField || 0;
                    emergenceLevel = data.parameters.emergenceLevel || 0.5;
                    informationComplexity = data.parameters.informationComplexity || 0.5;
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º UI
                    document.getElementById('time-speed').value = timeSpeed;
                    document.getElementById('time-speed-value').textContent = timeSpeed.toFixed(1);
                    document.getElementById('gravity-constant').value = gravityConstant;
                    document.getElementById('gravity-value').textContent = gravityConstant.toFixed(1);
                    // ... –æ–±–Ω–æ–≤–∏—Ç—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å–ª–∞–π–¥–µ—Ä—ã
                    
                    // –û—á–∏—â–∞–µ–º —Ç–µ–∫—É—â—É—é –≤—Å–µ–ª–µ–Ω–Ω—É—é
                    objects.forEach(obj => obj.destroy());
                    objects = [];
                    
                    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—ä–µ–∫—Ç—ã
                    data.objects.forEach(objData => {
                        const position = new THREE.Vector3(...objData.position);
                        const velocity = new THREE.Vector3(...objData.velocity);
                        
                        let newObj;
                        switch(objData.type) {
                            case 'star':
                                createStar(position, velocity);
                                break;
                            case 'planet':
                                createPlanet(position, velocity);
                                break;
                            case 'blackhole':
                                createBlackHole(position);
                                break;
                            case 'neutronstar':
                                createNeutronStar(position, velocity);
                                break;
                            // ... –¥—Ä—É–≥–∏–µ —Ç–∏–ø—ã
                        }
                        
                        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–∑–¥–∞–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
                        if (objects.length > 0) {
                            newObj = objects[objects.length - 1];
                            newObj.mass = objData.mass;
                            newObj.age = objData.age;
                            newObj.temperature = objData.temperature;
                            newObj.evolutionStage = objData.evolutionStage;
                            newObj.fuelRemaining = objData.fuelRemaining;
                            newObj.hasLife = objData.hasLife;
                            newObj.lifeStage = objData.lifeStage;
                        }
                    });
                    
                    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–∞–º–µ—Ä—É
                    camera.position.fromArray(data.camera.position);
                    camera.rotation.fromArray(data.camera.rotation);
                    
                    universeTime = data.statistics.totalTime;
                    
                    updateInfo('–í—Å–µ–ª–µ–Ω–Ω–∞—è —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞!');
                    
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:', error);
                    updateInfo('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –≤—Å–µ–ª–µ–Ω–Ω–æ–π');
                }
            }
            
            static download() {
                const data = this.save();
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `universe_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            static upload() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            this.load(e.target.result);
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }
        }

        // –ö–ª–∞—Å—Å –¥–ª—è –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤
        class AdvancedMaterials {
            static createStarMaterial(philosophy = 'materialism') {
                const palette = philosophyPalettes[philosophy];
                const color = palette.colors[Math.floor(Math.random() * palette.colors.length)];
                
                if (philosophy === 'holographic') {
                    // –ì–æ–ª–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π —à–µ–π–¥–µ—Ä
                    return new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            color: { value: new THREE.Color(color) }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            varying vec3 vPosition;
                            void main() {
                                vUv = uv;
                                vPosition = position;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform vec3 color;
                            varying vec2 vUv;
                            varying vec3 vPosition;
                            
                            void main() {
                                vec3 finalColor = color;
                                float noise = sin(vPosition.x * 10.0 + time) * 
                                             cos(vPosition.y * 10.0 + time * 0.5) * 
                                             sin(vPosition.z * 10.0 + time * 0.3);
                                
                                finalColor += vec3(noise * 0.2);
                                
                                // –ì–æ–ª–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π —ç—Ñ—Ñ–µ–∫—Ç
                                float hologram = sin(vUv.y * 50.0 + time * 2.0) * 0.5 + 0.5;
                                finalColor *= hologram * 0.5 + 0.5;
                                
                                gl_FragColor = vec4(finalColor, 0.9);
                            }
                        `,
                        transparent: true
                    });
                } else if (philosophy === 'information') {
                    // –¶–∏—Ñ—Ä–æ–≤–æ–π/–º–∞—Ç—Ä–∏—á–Ω—ã–π —à–µ–π–¥–µ—Ä
                    return new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            color: { value: new THREE.Color(color) }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform vec3 color;
                            varying vec2 vUv;
                            
                            float random(vec2 st) {
                                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                            }
                            
                            void main() {
                                vec2 st = vUv * 10.0;
                                float rnd = random(floor(st) + floor(time));
                                
                                vec3 finalColor = color * (0.5 + rnd * 0.5);
                                
                                // –¶–∏—Ñ—Ä–æ–≤—ã–µ –ø–æ–ª–æ—Å—ã
                                float lines = step(0.98, sin(st.y * 50.0 + time * 5.0));
                                finalColor += vec3(0.0, 1.0, 0.0) * lines * 0.5;
                                
                                gl_FragColor = vec4(finalColor, 0.9);
                            }
                        `,
                        transparent: true
                    });
                } else {
                    // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª —Å —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏ –¥–ª—è –¥—Ä—É–≥–∏—Ö —Ñ–∏–ª–æ—Å–æ—Ñ–∏–π
                    const material = new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: palette.emissive,
                        emissiveIntensity: 0.5,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    if (philosophy === 'idealism') {
                        material.opacity = 0.7;
                        material.side = THREE.DoubleSide;
                    } else if (philosophy === 'process') {
                        material.wireframe = Math.random() > 0.5;
                    }
                    
                    return material;
                }
            }
            
            static createPlanetMaterial(philosophy = 'materialism') {
                const palette = philosophyPalettes[philosophy];
                const color = palette.colors[Math.floor(Math.random() * palette.colors.length)];
                
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: palette.emissive,
                    emissiveIntensity: 0.2,
                    shininess: philosophy === 'materialism' ? 100 : 30,
                    transparent: true,
                    opacity: philosophy === 'idealism' ? 0.8 : 0.95
                });
                
                return material;
            }
            
            static createBlackHoleMaterial() {
                return new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                    },
                    vertexShader: `
                        varying vec3 vPosition;
                        void main() {
                            vPosition = position;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform vec2 resolution;
                        varying vec3 vPosition;
                        
                        void main() {
                            vec2 st = gl_FragCoord.xy / resolution.xy;
                            float dist = length(vPosition);
                            
                            // –≠—Ñ—Ñ–µ–∫—Ç –∏—Å–∫–∞–∂–µ–Ω–∏—è –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
                            float distortion = 1.0 / (dist * dist + 0.1);
                            vec3 color = vec3(0.0);
                            
                            // –ê–∫–∫—Ä–µ—Ü–∏–æ–Ω–Ω—ã–π –¥–∏—Å–∫
                            float ring = smoothstep(2.0, 2.1, dist) - smoothstep(5.0, 5.1, dist);
                            color += vec3(1.0, 0.5, 0.0) * ring * distortion;
                            
                            // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–æ–µ –ª–∏–Ω–∑–∏—Ä–æ–≤–∞–Ω–∏–µ
                            float lensing = 1.0 - smoothstep(0.0, 3.0, dist);
                            color = mix(color, vec3(0.0), lensing);
                            
                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                });
            }
        }

        // –ö–ª–∞—Å—Å—ã –¥–ª—è –∫–æ—Å–º–∏—á–µ—Å–∫–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
        class CelestialObject {
            constructor(position, velocity, mass, type) {
                this.position = position.clone();
                this.velocity = velocity.clone();
                this.mass = mass;
                this.type = type;
                this.age = 0;
                this.mesh = null;
                this.consciousness = philosophyModel === 'panpsychism' ? Math.random() : 0;
                
                // –ù–æ–≤—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞
                this.temperature = this.calculateInitialTemperature();
                this.luminosity = type === 'star' ? mass * mass : 0;
                this.metallicity = 0.02; // –°–æ–ª–Ω–µ—á–Ω–∞—è –º–µ—Ç–∞–ª–ª–∏—á–Ω–æ—Å—Ç—å
                this.rotation = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
                
                // –°–≤–æ–π—Å—Ç–≤–∞ –¥–ª—è —ç–≤–æ–ª—é—Ü–∏–∏
                this.evolutionStage = 'main-sequence';
                this.fuelRemaining = 1.0;
                this.hasLife = false;
                this.lifeStage = 'none';
                
                // –†–µ–ª—è—Ç–∏–≤–∏—Å—Ç—Å–∫–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞
                this.properTime = 0;
                this.schwarzschildRadius = 2 * gravityConstant * this.mass / (299792458 * 299792458);
            }
            
            calculateInitialTemperature() {
                switch(this.type) {
                    case 'star': return 5000 + Math.random() * 20000;
                    case 'planet': return 200 + Math.random() * 200;
                    case 'blackhole': return 0;
                    case 'neutronstar': return 1000000;
                    default: return 300;
                }
            }
            
            update(deltaTime, objects) {
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—É—é –ø–æ–∑–∏—Ü–∏—é –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
                const oldPosition = this.position.clone();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–æ–∑—Ä–∞—Å—Ç–∞ —Å —É—á–µ—Ç–æ–º —Ä–µ–ª—è—Ç–∏–≤–∏—Å—Ç—Å–∫–∏—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
                const speed = this.velocity.length();
                const c = 299792458; // —Å–∫–æ—Ä–æ—Å—Ç—å —Å–≤–µ—Ç–∞
                const lorentzFactor = 1 / Math.sqrt(1 - (speed * speed) / (c * c));
                this.properTime += deltaTime * timeSpeed / lorentzFactor;
                this.age += deltaTime * timeSpeed;

                // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–æ–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å —É—á–µ—Ç–æ–º —Ä–µ–ª—è—Ç–∏–≤–∏—Å—Ç—Å–∫–∏—Ö –ø–æ–ø—Ä–∞–≤–æ–∫
                const force = new THREE.Vector3(0, 0, 0);
                let nearestMassiveObject = null;
                let nearestDistance = Infinity;
                
                for (let obj of objects) {
                    if (obj !== this) {
                        const direction = obj.position.clone().sub(this.position);
                        const distance = direction.length();
                        
                        if (distance > 0.1) {
                            // –ù—å—é—Ç–æ–Ω–æ–≤—Å–∫–∞—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è —Å –ø–æ–ø—Ä–∞–≤–∫–æ–π –Ω–∞ —Å–∏–ª—å–Ω—ã–µ –ø–æ–ª—è
                            let magnitude = gravityConstant * this.mass * obj.mass / (distance * distance);
                            
                            // –£—Å–∏–ª–µ–Ω–∏–µ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏ –≤–±–ª–∏–∑–∏ —á–µ—Ä–Ω—ã—Ö –¥—ã—Ä
                            if (obj.type === 'blackhole') {
                                const distanceRatio = obj.schwarzschildRadius / distance;
                                magnitude *= (1 + distanceRatio * distanceRatio);
                                
                                if (distance < nearestDistance) {
                                    nearestMassiveObject = obj;
                                    nearestDistance = distance;
                                }
                            }
                            
                            direction.normalize().multiplyScalar(magnitude);
                            force.add(direction);
                            
                            // –ü—Ä–∏–ª–∏–≤–Ω—ã–µ —Å–∏–ª—ã –¥–ª—è –±–ª–∏–∑–∫–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
                            if (distance < 10 && this.type === 'planet' && obj.type === 'star') {
                                const radius = this.mesh.userData.radius || 1; // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π —Ä–∞–¥–∏—É—Å
                                const tidalForce = 2 * gravityConstant * obj.mass * radius / (distance * distance * distance);
                                this.mesh.scale.x = 1 + tidalForce * 0.1;
                                this.mesh.scale.z = 1 - tidalForce * 0.05;
                            }
                        }
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–≥–ª–æ—â–µ–Ω–∏–µ —á–µ—Ä–Ω–æ–π –¥—ã—Ä–æ–π
                if (nearestMassiveObject && nearestMassiveObject.type === 'blackhole' && 
                    nearestDistance < nearestMassiveObject.schwarzschildRadius * 3) {
                    this.beingAbsorbed = true;
                    // –°–ø–∞–≥–µ—Ç—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
                    if (this.mesh) {
                        const stretchDirection = nearestMassiveObject.position.clone().sub(this.position).normalize();
                        this.mesh.scale.x *= 0.98;
                        this.mesh.scale.z *= 0.98;
                        this.mesh.scale.y *= 1.04;
                        this.mesh.lookAt(nearestMassiveObject.position);
                    }
                }

                // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Å–∏–ª—ã
                const acceleration = force.divideScalar(this.mass);
                this.velocity.add(acceleration.multiplyScalar(deltaTime));

                // –ö–≤–∞–Ω—Ç–æ–≤—ã–µ —Ñ–ª—É–∫—Ç—É–∞—Ü–∏–∏
                if (quantumUncertainty > 0) {
                    this.velocity.x += (Math.random() - 0.5) * quantumUncertainty * 0.01;
                    this.velocity.y += (Math.random() - 0.5) * quantumUncertainty * 0.01;
                    this.velocity.z += (Math.random() - 0.5) * quantumUncertainty * 0.01;
                }

                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));

                // –í—Ä–∞—â–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞
                if (this.mesh) {
                    this.mesh.rotation.x += this.rotation.x * deltaTime;
                    this.mesh.rotation.y += this.rotation.y * deltaTime;
                    this.mesh.rotation.z += this.rotation.z * deltaTime;
                }

                // –≠–≤–æ–ª—é—Ü–∏—è –æ–±—ä–µ–∫—Ç–∞
                this.evolve(deltaTime);

                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—à–∞
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    
                    // –≠—Ñ—Ñ–µ–∫—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–æ–π –º–æ–¥–µ–ª–∏
                    this.updatePhilosophicalEffects();
                }

                // –ò–∑–ª—É—á–µ–Ω–∏–µ –•–æ–∫–∏–Ω–≥–∞ –¥–ª—è —á–µ—Ä–Ω—ã—Ö –¥—ã—Ä
                if (this.type === 'blackhole' && quantumUncertainty > 0) {
                    const hawkingTemperature = 1 / (8 * Math.PI * this.mass);
                    this.mass *= (1 - hawkingTemperature * quantumUncertainty * 0.000001);
                    if (this.mesh) {
                        const scale = Math.cbrt(this.mass / 100);
                        this.mesh.scale.setScalar(scale);
                    }
                }
            }
            
            evolve(deltaTime) {
                if (this.type === 'star') {
                    // –ó–≤–µ–∑–¥–Ω–∞—è —ç–≤–æ–ª—é—Ü–∏—è
                    this.fuelRemaining -= deltaTime * 0.0001 / this.mass; // –ú–∞—Å—Å–∏–≤–Ω—ã–µ –∑–≤–µ–∑–¥—ã —Å–≥–æ—Ä–∞—é—Ç –±—ã—Å—Ç—Ä–µ–µ
                    
                    if (this.evolutionStage === 'main-sequence' && this.fuelRemaining < 0.2) {
                        this.evolutionStage = 'red-giant';
                        this.expandToRedGiant();
                    } else if (this.evolutionStage === 'red-giant' && this.fuelRemaining <= 0) {
                        if (this.mass > 8) {
                            this.explodeAsSupernova();
                        } else {
                            this.becomeWhiteDwarf();
                        }
                    }
                    
                    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã
                    if (this.mesh && this.mesh.material) {
                        const temp = this.temperature * (this.fuelRemaining + 0.1);
                        const color = this.blackbodyColor(temp);
                        this.mesh.material.color = color;
                    }
                } else if (this.type === 'planet') {
                    // –ü–ª–∞–Ω–µ—Ç–∞—Ä–Ω–∞—è —ç–≤–æ–ª—é—Ü–∏—è
                    this.checkHabitability(objects);
                    if (this.hasLife) {
                        this.evolveLife(deltaTime);
                    }
                }
            }
            
            blackbodyColor(temperature) {
                // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –º–æ–¥–µ–ª—å —Ü–≤–µ—Ç–∞ —á–µ—Ä–Ω–æ–≥–æ —Ç–µ–ª–∞
                let r, g, b;
                const temp = temperature / 100;
                
                if (temp <= 66) {
                    r = 255;
                    g = temp;
                    g = 99.4708025861 * Math.log(g) - 161.1195681661;
                    if (temp <= 19) {
                        b = 0;
                    } else {
                        b = temp - 10;
                        b = 138.5177312231 * Math.log(b) - 305.0447927307;
                    }
                } else {
                    r = temp - 60;
                    r = 329.698727446 * Math.pow(r, -0.1332047592);
                    g = temp - 60;
                    g = 288.1221695283 * Math.pow(g, -0.0755148492);
                    b = 255;
                }
                
                return new THREE.Color(
                    Math.max(0, Math.min(1, r / 255)),
                    Math.max(0, Math.min(1, g / 255)),
                    Math.max(0, Math.min(1, b / 255))
                );
            }
            
            expandToRedGiant() {
                if (this.mesh) {
                    // –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è
                    const targetScale = 5 + this.mass / 5;
                    const expandAnimation = setInterval(() => {
                        this.mesh.scale.multiplyScalar(1.02);
                        if (this.mesh.scale.x >= targetScale) {
                            clearInterval(expandAnimation);
                        }
                    }, 50);
                    
                    this.temperature *= 0.5;
                    updateInfo(`–ó–≤–µ–∑–¥–∞ –ø—Ä–µ–≤—Ä–∞—Ç–∏–ª–∞—Å—å –≤ –∫—Ä–∞—Å–Ω–æ–≥–æ –≥–∏–≥–∞–Ω—Ç–∞!`);
                }
            }
            
            explodeAsSupernova() {
                if (visualEffects) {
                    visualEffects.createSupernova(this.position);
                }
                
                // –°–æ–∑–¥–∞–µ–º –Ω–µ–π—Ç—Ä–æ–Ω–Ω—É—é –∑–≤–µ–∑–¥—É –∏–ª–∏ —á–µ—Ä–Ω—É—é –¥—ã—Ä—É
                if (this.mass > 20) {
                    createBlackHole(this.position);
                } else {
                    createNeutronStar(this.position);
                }
                
                // –£–¥–∞–ª—è–µ–º –∑–≤–µ–∑–¥—É
                this.destroy();
                updateInfo(`–ü—Ä–æ–∏–∑–æ—à–µ–ª –≤–∑—Ä—ã–≤ —Å–≤–µ—Ä—Ö–Ω–æ–≤–æ–π!`);
            }
            
            becomeWhiteDwarf() {
                this.type = 'whitedwarf';
                this.temperature = 10000;
                if (this.mesh) {
                    this.mesh.scale.setScalar(0.1);
                    this.mesh.material.color = new THREE.Color(0.9, 0.9, 1);
                }
                updateInfo(`–ó–≤–µ–∑–¥–∞ —Å—Ç–∞–ª–∞ –±–µ–ª—ã–º –∫–∞—Ä–ª–∏–∫–æ–º`);
            }
            
            checkHabitability(objects) {
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –¥–ª—è –∂–∏–∑–Ω–∏
                let nearestStar = null;
                let starDistance = Infinity;
                
                for (let obj of objects) {
                    if (obj.type === 'star' && obj.evolutionStage === 'main-sequence') {
                        const distance = this.position.distanceTo(obj.position);
                        if (distance < starDistance) {
                            nearestStar = obj;
                            starDistance = distance;
                        }
                    }
                }
                
                if (nearestStar) {
                    // –ó–æ–Ω–∞ –æ–±–∏—Ç–∞–µ–º–æ—Å—Ç–∏
                    const habitableZoneInner = Math.sqrt(nearestStar.luminosity) * 0.95;
                    const habitableZoneOuter = Math.sqrt(nearestStar.luminosity) * 1.37;
                    
                    if (starDistance >= habitableZoneInner && starDistance <= habitableZoneOuter) {
                        this.temperature = 288; // –ó–µ–º–Ω–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞
                        if (!this.hasLife && Math.random() < 0.001) {
                            this.hasLife = true;
                            this.lifeStage = 'microbial';
                            updateInfo(`–ó–∞—Ä–æ–¥–∏–ª–∞—Å—å –∂–∏–∑–Ω—å –Ω–∞ –ø–ª–∞–Ω–µ—Ç–µ!`);
                            
                            // –í–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∂–∏–∑–Ω–∏
                            if (this.mesh) {
                                const radius = this.mesh.userData.radius || 1; // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π —Ä–∞–¥–∏—É—Å
                                const lifeGlow = new THREE.Mesh(
                                    new THREE.SphereGeometry(
                                        radius * 1.2, 
                                        16, 16
                                    ),
                                    new THREE.MeshBasicMaterial({
                                        color: 0x00ff00,
                                        transparent: true,
                                        opacity: 0.3
                                    })
                                );
                                this.mesh.add(lifeGlow);
                                this.mesh.userData.lifeGlow = lifeGlow;
                            }
                        }
                    }
                }
            }
            
            evolveLife(deltaTime) {
                if (!this.hasLife) return;
                
                const evolutionSpeed = 0.00001;
                const evolutionChance = Math.random();
                
                if (this.lifeStage === 'microbial' && evolutionChance < evolutionSpeed) {
                    this.lifeStage = 'complex';
                    updateInfo(`–ñ–∏–∑–Ω—å —ç–≤–æ–ª—é—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–ª–∞ –≤ —Å–ª–æ–∂–Ω—ã–µ —Ñ–æ—Ä–º—ã!`);
                } else if (this.lifeStage === 'complex' && evolutionChance < evolutionSpeed * 0.1) {
                    this.lifeStage = 'intelligent';
                    updateInfo(`–ü–æ—è–≤–∏–ª–∞—Å—å —Ä–∞–∑—É–º–Ω–∞—è –∂–∏–∑–Ω—å!`);
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º —Ä–∞–¥–∏–æ—Å–∏–≥–Ω–∞–ª—ã –æ—Ç —Ü–∏–≤–∏–ª–∏–∑–∞—Ü–∏–∏
                    if (this.mesh) {
                        const signalGeometry = new THREE.RingGeometry(0.1, 30, 32);
                        const signalMaterial = new THREE.MeshBasicMaterial({
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.5,
                            side: THREE.DoubleSide
                        });
                        const signal = new THREE.Mesh(signalGeometry, signalMaterial);
                        this.mesh.add(signal);
                        
                        // –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞
                        const animateSignal = () => {
                            signal.scale.multiplyScalar(1.01);
                            signal.material.opacity *= 0.99;
                            if (signal.material.opacity > 0.01) {
                                requestAnimationFrame(animateSignal);
                            } else {
                                this.mesh.remove(signal);
                            }
                        };
                        animateSignal();
                    }
                } else if (this.lifeStage === 'intelligent' && evolutionChance < evolutionSpeed * 0.01) {
                    this.lifeStage = 'spacefaring';
                    updateInfo(`–¶–∏–≤–∏–ª–∏–∑–∞—Ü–∏—è –≤—ã—à–ª–∞ –≤ –∫–æ—Å–º–æ—Å!`);
                    
                    // –°–æ–∑–¥–∞–µ–º –∫–æ—Å–º–∏—á–µ—Å–∫–∏–µ –∫–æ—Ä–∞–±–ª–∏
                    this.launchSpaceships();
                }
            }
            
            launchSpaceships() {
                for (let i = 0; i < 3; i++) {
                    const shipGeometry = new THREE.ConeGeometry(0.1, 0.3, 4);
                    const shipMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        emissive: 0x004444
                    });
                    const ship = new THREE.Mesh(shipGeometry, shipMaterial);
                    
                    const angle = (i / 3) * Math.PI * 2;
                    const distance = (this.mesh.userData.radius || 1) * 2;
                    ship.position.set(
                        Math.cos(angle) * distance,
                        0,
                        Math.sin(angle) * distance
                    );
                    
                    const shipObject = new CelestialObject(
                        this.position.clone().add(ship.position),
                        new THREE.Vector3(
                            Math.cos(angle) * 5,
                            (Math.random() - 0.5) * 2,
                            Math.sin(angle) * 5
                        ),
                        0.001,
                        'spaceship'
                    );
                    shipObject.mesh = ship;
                    scene.add(ship);
                    objects.push(shipObject);
                }
            }
            
            updatePhilosophicalEffects() {
                if (philosophyModel === 'idealism' && this.mesh.material) {
                    this.mesh.material.opacity = 0.5 + 0.5 * Math.sin(universeTime * 0.001);
                } else if (philosophyModel === 'panpsychism' && this.mesh.material.color) {
                    const hue = (this.consciousness * 360 + universeTime * 10) % 360;
                    this.mesh.material.color.setHSL(hue / 360, 0.8, 0.5);
                } else if (philosophyModel === 'holographic' && this.mesh) {
                    this.mesh.scale.setScalar(
                        this.mesh.scale.x * (1 + 0.01 * Math.sin(universeTime * 0.002 + this.age))
                    );
                }
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    if (this.mesh.geometry) this.mesh.geometry.dispose();
                    if (this.mesh.material) this.mesh.material.dispose();
                }
                const index = objects.indexOf(this);
                if (index > -1) {
                    objects.splice(index, 1);
                }
            }
        }

        // Octree –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
        class Octree {
            constructor(bounds, maxObjects = 10, maxLevels = 5, level = 0) {
                this.bounds = bounds;
                this.objects = [];
                this.nodes = [];
                this.maxObjects = maxObjects;
                this.maxLevels = maxLevels;
                this.level = level;
            }
            
            clear() {
                this.objects = [];
                for (let node of this.nodes) {
                    node.clear();
                }
                this.nodes = [];
            }
            
            split() {
                const subWidth = this.bounds.width / 2;
                const subHeight = this.bounds.height / 2;
                const subDepth = this.bounds.depth / 2;
                const x = this.bounds.x;
                const y = this.bounds.y;
                const z = this.bounds.z;
                
                // 8 –ø–æ–¥—É–∑–ª–æ–≤ –¥–ª—è 3D –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
                this.nodes[0] = new Octree({
                    x: x - subWidth/2, y: y + subHeight/2, z: z - subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[1] = new Octree({
                    x: x + subWidth/2, y: y + subHeight/2, z: z - subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[2] = new Octree({
                    x: x - subWidth/2, y: y - subHeight/2, z: z - subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[3] = new Octree({
                    x: x + subWidth/2, y: y - subHeight/2, z: z - subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[4] = new Octree({
                    x: x - subWidth/2, y: y + subHeight/2, z: z + subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[5] = new Octree({
                    x: x + subWidth/2, y: y + subHeight/2, z: z + subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[6] = new Octree({
                    x: x - subWidth/2, y: y - subHeight/2, z: z + subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[7] = new Octree({
                    x: x + subWidth/2, y: y - subHeight/2, z: z + subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
            }
            
            getIndex(object) {
                const indexes = [];
                const verticalMidpoint = this.bounds.x;
                const horizontalMidpoint = this.bounds.y;
                const depthMidpoint = this.bounds.z;
                
                const topQuadrant = object.position.y > horizontalMidpoint;
                const bottomQuadrant = object.position.y < horizontalMidpoint;
                const leftQuadrant = object.position.x < verticalMidpoint;
                const rightQuadrant = object.position.x > verticalMidpoint;
                const frontQuadrant = object.position.z < depthMidpoint;
                const backQuadrant = object.position.z > depthMidpoint;
                
                if (leftQuadrant) {
                    if (topQuadrant) {
                        if (frontQuadrant) indexes.push(0);
                        if (backQuadrant) indexes.push(4);
                    }
                    if (bottomQuadrant) {
                        if (frontQuadrant) indexes.push(2);
                        if (backQuadrant) indexes.push(6);
                    }
                }
                if (rightQuadrant) {
                    if (topQuadrant) {
                        if (frontQuadrant) indexes.push(1);
                        if (backQuadrant) indexes.push(5);
                    }
                    if (bottomQuadrant) {
                        if (frontQuadrant) indexes.push(3);
                        if (backQuadrant) indexes.push(7);
                    }
                }
                
                return indexes;
            }
            
            insert(object) {
                if (this.nodes.length > 0) {
                    const indexes = this.getIndex(object);
                    for (let index of indexes) {
                        this.nodes[index].insert(object);
                    }
                    return;
                }
                
                this.objects.push(object);
                
                if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
                    if (this.nodes.length === 0) {
                        this.split();
                    }
                    
                    let i = 0;
                    while (i < this.objects.length) {
                        const indexes = this.getIndex(this.objects[i]);
                        for (let index of indexes) {
                            this.nodes[index].insert(this.objects[i]);
                        }
                        this.objects.splice(i, 1);
                    }
                }
            }
            
            retrieve(object) {
                const returnObjects = [];
                
                if (this.nodes.length > 0) {
                    const indexes = this.getIndex(object);
                    for (let index of indexes) {
                        returnObjects.push(...this.nodes[index].retrieve(object));
                    }
                }
                
                returnObjects.push(...this.objects);
                
                return returnObjects;
            }
        }

        // –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è octree
        let octree;

        class LODSystem {
            constructor() {
                this.lodGeometries = {
                    star: {
                        high: new THREE.SphereGeometry(1, 32, 32),
                        medium: new THREE.SphereGeometry(1, 16, 16),
                        low: new THREE.SphereGeometry(1, 8, 8),
                        veryLow: new THREE.BoxGeometry(1, 1, 1)
                    },
                    planet: {
                        high: new THREE.SphereGeometry(1, 32, 32),
                        medium: new THREE.SphereGeometry(1, 16, 16),
                        low: new THREE.SphereGeometry(1, 8, 8),
                        veryLow: new THREE.BoxGeometry(1, 1, 1)
                    }
                };
                
                this.distanceThresholds = {
                    high: 50,
                    medium: 150,
                    low: 300,
                    veryLow: 500
                };
            }
            
            update(camera, objects) {
                const cameraPosition = camera.position;
                
                for (let obj of objects) {
                    if (!obj.mesh || !obj.mesh.geometry) continue;
                    
                    const distance = cameraPosition.distanceTo(obj.position);
                    const originalRadius = obj.mesh.userData.originalRadius || 1;
                    
                    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏
                    let lodLevel = 'high';
                    if (distance > this.distanceThresholds.veryLow) {
                        lodLevel = 'veryLow';
                    } else if (distance > this.distanceThresholds.low) {
                        lodLevel = 'low';
                    } else if (distance > this.distanceThresholds.medium) {
                        lodLevel = 'medium';
                    }
                    
                    // –ú–µ–Ω—è–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                    if (obj.mesh.userData.currentLOD !== lodLevel) {
                        const geometryType = obj.type === 'star' ? 'star' : 'planet';
                        if (this.lodGeometries[geometryType] && this.lodGeometries[geometryType][lodLevel]) {
                            const newGeometry = this.lodGeometries[geometryType][lodLevel].clone();
                            newGeometry.scale(originalRadius, originalRadius, originalRadius);
                            
                            obj.mesh.geometry.dispose();
                            obj.mesh.geometry = newGeometry;
                            obj.mesh.userData.currentLOD = lodLevel;
                        }
                    }
                    
                    // –°–∫—Ä—ã–≤–∞–µ–º –æ—á–µ–Ω—å –¥–∞–ª–µ–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã
                    obj.mesh.visible = distance < 1000;
                    
                    // –£–ø—Ä–æ—â–∞–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª—ã –¥–ª—è –¥–∞–ª–µ–∫–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
                    if (distance > this.distanceThresholds.medium && obj.mesh.material) {
                        if (!obj.mesh.userData.simpleMaterial) {
                            obj.mesh.userData.originalMaterial = obj.mesh.material;
                            obj.mesh.userData.simpleMaterial = new THREE.MeshBasicMaterial({
                                color: obj.mesh.material.color || 0xffffff
                            });
                        }
                        obj.mesh.material = obj.mesh.userData.simpleMaterial;
                    } else if (obj.mesh.userData.originalMaterial) {
                        obj.mesh.material = obj.mesh.userData.originalMaterial;
                    }
                }
            }
        }

        // –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä LOD —Å–∏—Å—Ç–µ–º—ã
        let lodSystem;

        class PluginSystem {
            constructor() {
                this.plugins = new Map();
                this.hooks = {
                    'preUpdate': [],
                    'postUpdate': [],
                    'objectCreated': [],
                    'objectDestroyed': [],
                    'render': []
                };
            }
            
            register(name, plugin) {
                if (this.plugins.has(name)) {
                    console.warn(`Plugin ${name} already registered`);
                    return;
                }
                
                this.plugins.set(name, plugin);
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–ª–∞–≥–∏–Ω–∞
                if (plugin.initialize) {
                    plugin.initialize({
                        scene,
                        camera,
                        renderer,
                        objects,
                        addHook: (hookName, callback) => this.addHook(hookName, callback),
                        removeHook: (hookName, callback) => this.removeHook(hookName, callback)
                    });
                }
                
                console.log(`Plugin ${name} registered successfully`);
            }
            
            unregister(name) {
                const plugin = this.plugins.get(name);
                if (plugin) {
                    if (plugin.destroy) {
                        plugin.destroy();
                    }
                    this.plugins.delete(name);
                    
                    // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Ö—É–∫–∏ –ø–ª–∞–≥–∏–Ω–∞
                    for (let hookName in this.hooks) {
                        this.hooks[hookName] = this.hooks[hookName].filter(
                            hook => hook.plugin !== name
                        );
                    }
                }
            }
            
            addHook(hookName, callback, pluginName) {
                if (this.hooks[hookName]) {
                    this.hooks[hookName].push({ callback, plugin: pluginName });
                }
            }
            
            removeHook(hookName, callback) {
                if (this.hooks[hookName]) {
                    this.hooks[hookName] = this.hooks[hookName].filter(
                        hook => hook.callback !== callback
                    );
                }
            }
            
            executeHooks(hookName, ...args) {
                if (this.hooks[hookName]) {
                    for (let hook of this.hooks[hookName]) {
                        hook.callback(...args);
                    }
                }
            }
            
            update(deltaTime) {
                this.executeHooks('preUpdate', deltaTime);
                
                for (let [name, plugin] of this.plugins) {
                    if (plugin.update) {
                        plugin.update(deltaTime);
                    }
                }
                
                this.executeHooks('postUpdate', deltaTime);
            }
        }

        // –ü—Ä–∏–º–µ—Ä –ø–ª–∞–≥–∏–Ω–∞: –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω—ã–µ –≤–æ–ª–Ω—ã
        class GravitationalWavesPlugin {
            initialize(context) {
                this.context = context;
                this.waveEmitters = [];
                
                // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å–æ–±—ã—Ç–∏—è
                context.addHook('objectDestroyed', (obj) => {
                    if (obj.type === 'star' && obj.mass > 8) {
                        this.createGravitationalWave(obj.position, obj.mass);
                    }
                });
            }
            
            update(deltaTime) {
                // –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Å–ª–∏—è–Ω–∏–π –º–∞—Å—Å–∏–≤–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
                const massiveObjects = this.context.objects.filter(
                    obj => obj.type === 'blackhole' || obj.type === 'neutronstar'
                );
                
                for (let i = 0; i < massiveObjects.length - 1; i++) {
                    for (let j = i + 1; j < massiveObjects.length; j++) {
                        const distance = massiveObjects[i].position.distanceTo(
                            massiveObjects[j].position
                        );
                        
                        if (distance < 10 && !this.isWaveEmitted(i, j)) {
                            this.createGravitationalWave(
                                massiveObjects[i].position.clone().add(massiveObjects[j].position).multiplyScalar(0.5),
                                massiveObjects[i].mass + massiveObjects[j].mass
                            );
                            this.markWaveEmitted(i, j);
                        }
                    }
                }
            }
            
            createGravitationalWave(position, mass) {
                if (visualEffects) {
                    visualEffects.createGravitationalWave(position, mass * 5);
                }
            }
            
            isWaveEmitted(i, j) {
                return this.waveEmitters.some(e => 
                    (e.i === i && e.j === j) || (e.i === j && e.j === i)
                );
            }
            
            markWaveEmitted(i, j) {
                this.waveEmitters.push({ i, j, time: universeTime });
                
                // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏
                this.waveEmitters = this.waveEmitters.filter(
                    e => universeTime - e.time < 10
                );
            }
        }

        // –°–æ–∑–¥–∞–µ–º —Å–∏—Å—Ç–µ–º—É –ø–ª–∞–≥–∏–Ω–æ–≤
        let pluginSystem;

            // –û–±–Ω–æ–≤–ª—è–µ–º —Ç—É–º–∞–Ω –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ñ–∏–ª–æ—Å–æ—Ñ–∏–∏
            function updateFog() {
                const palette = philosophyPalettes[philosophyModel];
                scene.fog = new THREE.FogExp2(palette.fog, 0.00005);
            }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js
        function init() {
            // –°—Ü–µ–Ω–∞
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000033, 0.00005);

            // –ö–∞–º–µ—Ä–∞
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 50, 100);
            camera.lookAt(0, 0, 0);

            // –†–µ–Ω–¥–µ—Ä–µ—Ä
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
            octree = new Octree({
                x: 0, y: 0, z: 0,
                width: 2000, height: 2000, depth: 2000
            });

            lodSystem = new LODSystem();
            pluginSystem = new PluginSystem();
            performanceMonitor = new PerformanceMonitor();

            // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–ª–∞–≥–∏–Ω–æ–≤
            pluginSystem.register('gravitationalWaves', new GravitationalWavesPlugin());

            // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
            const renderOptimizer = new RenderOptimizer(renderer, scene, camera);
            //const frustumCulling = renderOptimizer.enableFrustumCulling();
            window.renderOptimizer = renderOptimizer;

            // –î–æ–±–∞–≤–ª—è–µ–º UI –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∫–∞—á–µ—Å—Ç–≤–∞
            const qualityPanel = document.createElement('div');
            qualityPanel.className = 'control-panel';
            qualityPanel.style.cssText = `
                position: absolute;
                top: 20px;
                right: 340px;
                padding: 10px;
            `;
            qualityPanel.innerHTML = `
                <h3 style="margin: 0 0 10px 0; font-size: 14px;">–ö–∞—á–µ—Å—Ç–≤–æ –≥—Ä–∞—Ñ–∏–∫–∏</h3>
                <select id="quality-select" style="width: 100%; padding: 5px; background: rgba(40, 40, 80, 0.8); color: white; border: 1px solid rgba(100, 100, 255, 0.5);">
                    <option value="low">–ù–∏–∑–∫–æ–µ</option>
                    <option value="medium">–°—Ä–µ–¥–Ω–µ–µ</option>
                    <option value="high" selected>–í—ã—Å–æ–∫–æ–µ</option>
                    <option value="ultra">–£–ª—å—Ç—Ä–∞</option>
                </select>
                <label style="display: block; margin-top: 10px; font-size: 12px;">
                    <input type="checkbox" id="auto-quality" checked> –ê–≤—Ç–æ-–Ω–∞—Å—Ç—Ä–æ–π–∫–∞
                </label>
            `;
            document.getElementById('ui-overlay').appendChild(qualityPanel);

            document.getElementById('quality-select').addEventListener('change', (e) => {
                renderOptimizer.setQuality(e.target.value);
            });

            document.getElementById('auto-quality').addEventListener('change', (e) => {
                renderOptimizer.autoAdjust = e.target.checked;
            });

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
            visualEffects = new VisualEffects(scene);

            updateFog();

            // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫—É –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Ñ–∏–ª–æ—Å–æ—Ñ–∏–π
            if (philosophyModel === 'holographic' || philosophyModel === 'information') {
                // –î–æ–±–∞–≤–ª—è–µ–º —Å–∫–∞–Ω–ª–∏–Ω–∏–∏ –¥–ª—è —Ü–∏—Ñ—Ä–æ–≤–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
                const scanlines = document.createElement('div');
                scanlines.className = 'scanlines';
                scanlines.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: repeating-linear-gradient(
                        0deg,
                        rgba(0, 255, 0, 0.03),
                        rgba(0, 255, 0, 0.03) 1px,
                        transparent 1px,
                        transparent 2px
                    );
                    pointer-events: none;
                    z-index: 5;
                    animation: scanlines 8s linear infinite;
                `;
                document.getElementById('ui-overlay').appendChild(scanlines);
            }

            // CSS –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è —Å–∫–∞–Ω–ª–∏–Ω–∏–π
            const style = document.createElement('style');
            style.textContent = `
                @keyframes scanlines {
                    0% { transform: translateY(0); }
                    100% { transform: translateY(10px); }
                }
            `;
            document.head.appendChild(style);

            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1, 1000);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // –ó–≤–µ–∑–¥–Ω–æ–µ –Ω–µ–±–æ
            createStarfield();

            // –ù–∞—á–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –º–æ–¥–µ–ª–∏
            initializeUniverse();

            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä–æ–π
            setupCameraControls();

            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
            setupEventHandlers();

            // –°–∫—Ä—ã—Ç—å —ç–∫—Ä–∞–Ω –∑–∞–≥—Ä—É–∑–∫–∏
            document.getElementById('loading-screen').style.display = 'none';

            // –ó–∞–ø—É—Å–∫ –∞–Ω–∏–º–∞—Ü–∏–∏
            animate();
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∑–≤–µ–∑–¥–Ω–æ–≥–æ –ø–æ–ª—è
        function createStarfield() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                map: createStarTexture()
            });

            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –∑–≤–µ–∑–¥—ã
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.4, 'rgba(255,255,200,0.5)');
            gradient.addColorStop(1, 'rgba(255,255,200,0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            
            return new THREE.CanvasTexture(canvas);
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ–ª–µ–Ω–Ω–æ–π
        function initializeUniverse() {
            objects = [];
            
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –æ–±—ä–µ–∫—Ç—ã
            scene.children = scene.children.filter(child => 
                child.type === 'AmbientLight' || 
                child.type === 'PointLight' || 
                child.type === 'Points'
            );

            switch (cosmologyModel) {
                case 'bigbang':
                    // –°–æ–∑–¥–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é —Å–∏–Ω–≥—É–ª—è—Ä–Ω–æ—Å—Ç—å
                    createExplosion(new THREE.Vector3(0, 0, 0));
                    universePhase = 'expansion';
                    break;
                    
                case 'steady':
                    // –°–æ–∑–¥–∞–µ–º —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
                    for (let i = 0; i < 20; i++) {
                        const position = new THREE.Vector3(
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200
                        );
                        createStar(position);
                    }
                    universePhase = 'steady';
                    break;
                    
                case 'cyclic':
                    // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç—ã –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ —Å–∂–∞—Ç–∏—è
                    for (let i = 0; i < 15; i++) {
                        const angle = (i / 15) * Math.PI * 2;
                        const radius = 30;
                        const position = new THREE.Vector3(
                            Math.cos(angle) * radius,
                            (Math.random() - 0.5) * 20,
                            Math.sin(angle) * radius
                        );
                        const velocity = position.clone().normalize().multiplyScalar(-5);
                        createStar(position, velocity);
                    }
                    universePhase = 'contraction';
                    break;
                    
                case 'multiverse':
                    // –°–æ–∑–¥–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ "–ø—É–∑—ã—Ä–µ–π" –≤—Å–µ–ª–µ–Ω–Ω—ã—Ö
                    for (let i = 0; i < 5; i++) {
                        const center = new THREE.Vector3(
                            (Math.random() - 0.5) * 150,
                            (Math.random() - 0.5) * 150,
                            (Math.random() - 0.5) * 150
                        );
                        for (let j = 0; j < 5; j++) {
                            const offset = new THREE.Vector3(
                                (Math.random() - 0.5) * 30,
                                (Math.random() - 0.5) * 30,
                                (Math.random() - 0.5) * 30
                            );
                            createStar(center.clone().add(offset));
                        }
                    }
                    universePhase = 'expansion';
                    break;
                    
                case 'inflation':
                    // –ò–Ω—Ñ–ª—è—Ü–∏–æ–Ω–Ω–∞—è –º–æ–¥–µ–ª—å - –Ω–∞—á–∏–Ω–∞–µ–º —Å –∫–æ–º–ø–∞–∫—Ç–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏
                    inflationEpoch = true;
                    inflationField = 1.0;
                    for (let i = 0; i < 10; i++) {
                        const position = new THREE.Vector3(
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5
                        );
                        createQuantumFluctuation(position);
                    }
                    universePhase = 'inflation';
                    break;
                    
                case 'darkenergy':
                    // –ú–æ–¥–µ–ª—å —Å —Ç–µ–º–Ω–æ–π —ç–Ω–µ—Ä–≥–∏–µ–π
                    darkEnergy = 0.9;
                    createExplosion(new THREE.Vector3(0, 0, 0));
                    // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–º–Ω—É—é —ç–Ω–µ—Ä–≥–∏—é –∫–∞–∫ —Ñ–æ–Ω–æ–≤–æ–µ –ø–æ–ª–µ
                    createDarkEnergyField();
                    universePhase = 'expansion';
                    break;
                    
                case 'branes':
                    // –ë—Ä–∞–Ω—ã –∏ –≤—ã—Å—à–∏–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è
                    createBraneStructure();
                    universePhase = 'expansion';
                    break;
                    
                case 'quantum':
                    // –ö–≤–∞–Ω—Ç–æ–≤–∞—è –∫–æ—Å–º–æ–ª–æ–≥–∏—è
                    quantumUncertainty = 0.9;
                    createQuantumFoam();
                    universePhase = 'expansion';
                    break;
            }
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –≤–∑—Ä—ã–≤–∞ (–¥–ª—è –º–æ–¥–µ–ª–∏ –ë–æ–ª—å—à–æ–≥–æ –≤–∑—Ä—ã–≤–∞)
        function createExplosion(position) {
            for (let i = 0; i < 30; i++) {
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5),
                    (Math.random() - 0.5),
                    (Math.random() - 0.5)
                ).normalize().multiplyScalar(10 + Math.random() * 20);
                
                const offset = velocity.clone().normalize().multiplyScalar(Math.random() * 5);
                const startPos = position.clone().add(offset);
                
                if (Math.random() > 0.7) {
                    createStar(startPos, velocity);
                } else {
                    createPlanet(startPos, velocity);
                }
            }
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∑–≤–µ–∑–¥—ã
        function createStar(position, velocity = null) {
             const radius = 2 + Math.random() * 3;
             const geometry = new THREE.SphereGeometry(radius, 32, 32);
             const material = AdvancedMaterials.createStarMaterial(philosophyModel);
            
             const mesh = new THREE.Mesh(geometry, material);
             mesh.position.copy(position);
             mesh.userData.radius = radius; // –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£
             mesh.userData.originalRadius = radius; // –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£
             scene.add(mesh);
            
            // –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ —Å–ª–æ—è–º–∏
            const glowLayers = [
                { scale: 1.5, opacity: 0.6 },
                { scale: 2.0, opacity: 0.4 },
                { scale: 3.0, opacity: 0.2 },
                { scale: 4.0, opacity: 0.1 }
            ];
            
            glowLayers.forEach(layer => {
                const glowGeometry = new THREE.SphereGeometry(radius * layer.scale, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: material.color || 0xffffff,
                    transparent: true,
                    opacity: layer.opacity,
                    side: THREE.BackSide
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                mesh.add(glowMesh);
            });
            
            // –î–æ–±–∞–≤–ª—è–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤–æ–∫—Ä—É–≥ –∑–≤–µ–∑–¥—ã –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –∫–æ—Ä–æ–Ω—ã
            if (philosophyModel !== 'materialism') {
                const coronaGeometry = new THREE.BufferGeometry();
                const coronaCount = 100;
                const positions = new Float32Array(coronaCount * 3);
                const colors = new Float32Array(coronaCount * 3);
                
                for (let i = 0; i < coronaCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = radius * (1.5 + Math.random() * 2);
                    
                    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = r * Math.cos(phi);
                    
                    colors[i * 3] = 1;
                    colors[i * 3 + 1] = 0.8;
                    colors[i * 3 + 2] = 0.4;
                }
                
                coronaGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                coronaGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const coronaMaterial = new THREE.PointsMaterial({
                    size: 0.3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                const corona = new THREE.Points(coronaGeometry, coronaMaterial);
                mesh.add(corona);
                mesh.userData.corona = corona;
            }
            
            const star = new CelestialObject(
                position,
                velocity || new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2),
                10 + Math.random() * 20,
                'star'
            );
            star.mesh = mesh;
            objects.push(star);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞–Ω–µ—Ç—ã
        function createPlanet(position, velocity = null) {
            const radius = 0.5 + Math.random() * 1.5;
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = AdvancedMaterials.createPlanetMaterial(philosophyModel);
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.userData.radius = radius; // –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£
            mesh.userData.originalRadius = radius; // –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£
            scene.add(mesh);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∞—Ç–º–æ—Å—Ñ–µ—Ä—É –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –ø–ª–∞–Ω–µ—Ç
            if (Math.random() > 0.5 && philosophyModel !== 'materialism') {
                const atmosphereGeometry = new THREE.SphereGeometry(radius * 1.2, 32, 32);
                const atmosphereMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        planetRadius: { value: radius }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vPosition = position;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float planetRadius;
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        
                        void main() {
                            float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                            vec3 atmosphereColor = vec3(0.3, 0.6, 1.0);
                            
                            // –ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–±–ª–∞–∫–∞
                            float clouds = sin(vPosition.x * 10.0 + time) * 
                                          cos(vPosition.y * 10.0 + time * 0.5) * 0.1;
                            
                            gl_FragColor = vec4(atmosphereColor, intensity * (0.8 + clouds));
                        }
                    `,
                    transparent: true,
                    side: THREE.BackSide
                });
                
                const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                mesh.add(atmosphere);
                mesh.userData.atmosphere = atmosphere;
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª—å—Ü–∞ –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –ø–ª–∞–Ω–µ—Ç
            if (Math.random() > 0.7) {
                const ringGeometry = new THREE.RingGeometry(radius * 1.5, radius * 2.5, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: material.color,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.5;
                mesh.add(ring);
            }
            
            const planet = new CelestialObject(
                position,
                velocity || new THREE.Vector3((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5),
                1 + Math.random() * 5,
                'planet'
            );
            planet.mesh = mesh;
            objects.push(planet);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —á–µ—Ä–Ω–æ–π –¥—ã—Ä—ã
        function createBlackHole(position) {
            const geometry = new THREE.SphereGeometry(3, 32, 32);
            const material = AdvancedMaterials.createBlackHoleMaterial();
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            scene.add(mesh);
            
            // –£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–∫–∫—Ä–µ—Ü–∏–æ–Ω–Ω—ã–π –¥–∏—Å–∫ —Å –≤—Ä–∞—â–µ–Ω–∏–µ–º
            const diskGeometry = new THREE.RingGeometry(5, 20, 128, 8);
            
            // –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é –¥–ª—è —Å–ø–∏—Ä–∞–ª—å–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
            const positions = diskGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const angle = Math.atan2(y, x);
                const radius = Math.sqrt(x * x + y * y);
                
                // –°–ø–∏—Ä–∞–ª—å–Ω–æ–µ –∏—Å–∫–∞–∂–µ–Ω–∏–µ
                const spiralAngle = angle + (20 - radius) * 0.3;
                positions.setX(i, radius * Math.cos(spiralAngle));
                positions.setY(i, radius * Math.sin(spiralAngle));
                
                // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –∏—Å–∫–∞–∂–µ–Ω–∏–µ –¥–ª—è –æ–±—ä–µ–º–∞
                const z = Math.sin((radius - 5) * 0.5) * 2 * Math.exp(-(radius - 12.5) * 0.1);
                positions.setZ(i, z);
            }
            positions.needsUpdate = true;
            diskGeometry.computeVertexNormals();
            
            const diskMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    innerRadius: { value: 5 },
                    outerRadius: { value: 20 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float innerRadius;
                    uniform float outerRadius;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        float radius = length(vPosition.xy);
                        float normalizedRadius = (radius - innerRadius) / (outerRadius - innerRadius);
                        
                        // –¶–≤–µ—Ç –æ—Ç –≥–æ—Ä—è—á–µ–≥–æ –∫ —Ö–æ–ª–æ–¥–Ω–æ–º—É
                        vec3 hotColor = vec3(1.0, 0.8, 0.0);
                        vec3 coldColor = vec3(0.8, 0.2, 0.0);
                        vec3 color = mix(hotColor, coldColor, normalizedRadius);
                        
                        // –í—Ä–∞—â–µ–Ω–∏–µ –∏ —è—Ä–∫–æ—Å—Ç—å
                        float angle = atan(vPosition.y, vPosition.x);
                        float brightness = 0.5 + 0.5 * sin(angle * 3.0 - time * 2.0 + radius * 0.5);
                        
                        // –ó–∞—Ç—É—Ö–∞–Ω–∏–µ –∫ –∫—Ä–∞—è–º
                        float falloff = 1.0 - normalizedRadius;
                        
                        gl_FragColor = vec4(color * brightness, falloff * 0.8);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const diskMesh = new THREE.Mesh(diskGeometry, diskMaterial);
            mesh.add(diskMesh);
            mesh.userData.disk = diskMesh;
            
            // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–æ–µ –∏—Å–∫–∞–∂–µ–Ω–∏–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
            const distortionGeometry = new THREE.SphereGeometry(30, 32, 32);
            const distortionMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vPosition;
                    
                    void main() {
                        float dist = length(vPosition);
                        float wave = sin(dist * 0.5 - time * 2.0) * 0.5 + 0.5;
                        gl_FragColor = vec4(0.5, 0.3, 1.0, wave * 0.1);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                depthWrite: false
            });
            
            const distortion = new THREE.Mesh(distortionGeometry, distortionMaterial);
            mesh.add(distortion);
            
            const blackHole = new CelestialObject(
                position,
                new THREE.Vector3(0, 0, 0),
                100,
                'blackhole'
            );
            blackHole.mesh = mesh;
            objects.push(blackHole);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –≥–∞–ª–∞–∫—Ç–∏–∫–∏
        function createGalaxy(position) {
            const galaxyGroup = new THREE.Group();
            galaxyGroup.position.copy(position);
            
            // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —á–µ—Ä–Ω–∞—è –¥—ã—Ä–∞
            const centerGeometry = new THREE.SphereGeometry(2, 16, 16);
            const centerMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const centerMesh = new THREE.Mesh(centerGeometry, centerMaterial);
            galaxyGroup.add(centerMesh);
            
            // –°–ø–∏—Ä–∞–ª—å–Ω—ã–µ —Ä—É–∫–∞–≤–∞
            for (let arm = 0; arm < 3; arm++) {
                const armAngle = (arm / 3) * Math.PI * 2;
                
                for (let i = 0; i < 20; i++) {
                    const angle = armAngle + (i / 20) * Math.PI;
                    const radius = 10 + i * 2;
                    const height = (Math.random() - 0.5) * 5;
                    
                    const starPos = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        height,
                        Math.sin(angle) * radius
                    );
                    
                    const starGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                    const starMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.15 * Math.random(), 0.8, 0.8)
                    });
                    const starMesh = new THREE.Mesh(starGeometry, starMaterial);
                    starMesh.position.copy(starPos);
                    galaxyGroup.add(starMesh);
                }
            }
            
            scene.add(galaxyGroup);
            
            const galaxy = new CelestialObject(
                position,
                new THREE.Vector3((Math.random() - 0.5) * 0.5, 0, (Math.random() - 0.5) * 0.5),
                1000,
                'galaxy'
            );
            galaxy.mesh = galaxyGroup;
            objects.push(galaxy);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–π—Ç—Ä–æ–Ω–Ω–æ–π –∑–≤–µ–∑–¥—ã
        function createNeutronStar(position, velocity = null) {
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pulseRate: { value: 1 + Math.random() * 10 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float pulseRate;
                    varying vec3 vNormal;
                    
                    void main() {
                        // –ü—É–ª—å—Å–∏—Ä—É—é—â–µ–µ –∏–∑–ª—É—á–µ–Ω–∏–µ
                        float pulse = sin(time * pulseRate) * 0.5 + 0.5;
                        
                        // –ú–∞–≥–Ω–∏—Ç–Ω—ã–µ –ø–æ–ª—é—Å–∞
                        float pole = abs(dot(vNormal, vec3(0.0, 1.0, 0.0)));
                        pole = pow(pole, 4.0);
                        
                        vec3 color = vec3(0.8, 0.8, 1.0);
                        color += vec3(0.2, 0.5, 1.0) * pole * pulse;
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            scene.add(mesh);
            
            // –ú–∞–≥–Ω–∏—Ç–Ω–æ–µ –ø–æ–ª–µ
            const fieldGeometry = new THREE.TorusGeometry(3, 0.1, 8, 32);
            const fieldMaterial = new THREE.MeshBasicMaterial({
                color: 0x4040ff,
                transparent: true,
                opacity: 0.3
            });
            const magneticField = new THREE.Mesh(fieldGeometry, fieldMaterial);
            magneticField.rotation.x = Math.PI / 2;
            mesh.add(magneticField);
            
            // –î–∂–µ—Ç—ã
            const jetGeometry = new THREE.ConeGeometry(0.2, 5, 8);
            const jetMaterial = new THREE.MeshBasicMaterial({
                color: 0x8080ff,
                transparent: true,
                opacity: 0.6
            });
            
            const jetTop = new THREE.Mesh(jetGeometry, jetMaterial);
            jetTop.position.y = 2.5;
            mesh.add(jetTop);
            
            const jetBottom = new THREE.Mesh(jetGeometry, jetMaterial);
            jetBottom.position.y = -2.5;
            jetBottom.rotation.z = Math.PI;
            mesh.add(jetBottom);
            
            const neutronStar = new CelestialObject(
                position,
                velocity || new THREE.Vector3((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10),
                1.4, // –ú–∞—Å—Å–∞ –ß–∞–Ω–¥—Ä–∞—Å–µ–∫–∞—Ä–∞
                'neutronstar'
            );
            neutronStar.mesh = mesh;
            neutronStar.rotation = new THREE.Vector3(0, 1, 0); // –ë—ã—Å—Ç—Ä–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
            objects.push(neutronStar);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∫–≤–∞–∑–∞—Ä–∞
        function createQuasar(position) {
            const coreGeometry = new THREE.SphereGeometry(1, 32, 32);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 2
            });
            
            const mesh = new THREE.Mesh(coreGeometry, coreMaterial);
            mesh.position.copy(position);
            scene.add(mesh);
            
            // –ê–∫–∫—Ä–µ—Ü–∏–æ–Ω–Ω—ã–π –¥–∏—Å–∫
            const diskGeometry = new THREE.RingGeometry(2, 15, 64, 8);
            const diskMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 center = vec2(0.5);
                        float dist = length(vUv - center);
                        
                        vec3 color = mix(
                            vec3(1.0, 1.0, 0.0),
                            vec3(1.0, 0.0, 0.0),
                            dist * 2.0
                        );
                        
                        float brightness = 1.0 - dist * 2.0;
                        brightness *= sin(dist * 20.0 - time * 5.0) * 0.2 + 0.8;
                        
                        gl_FragColor = vec4(color * brightness, brightness);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const disk = new THREE.Mesh(diskGeometry, diskMaterial);
            disk.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.2;
            mesh.add(disk);
            
            // –†–µ–ª—è—Ç–∏–≤–∏—Å—Ç—Å–∫–∏–µ –¥–∂–µ—Ç—ã
            const jetLength = 50;
            const jetGeometry = new THREE.CylinderGeometry(0.5, 2, jetLength, 16);
            const jetMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vPosition;
                    
                    void main() {
                        float height = (vPosition.y + 25.0) / 50.0;
                        vec3 color = vec3(0.5, 0.5, 1.0);
                        
                        float pulse = sin(height * 10.0 - time * 10.0) * 0.5 + 0.5;
                        float opacity = (1.0 - height) * pulse;
                        
                        gl_FragColor = vec4(color, opacity);
                    }
                `,
                transparent: true
            });
            
            const jetTop = new THREE.Mesh(jetGeometry, jetMaterial);
            jetTop.position.y = jetLength / 2;
            mesh.add(jetTop);
            
            const jetBottom = new THREE.Mesh(jetGeometry, jetMaterial);
            jetBottom.position.y = -jetLength / 2;
            jetBottom.rotation.z = Math.PI;
            mesh.add(jetBottom);
            
            const quasar = new CelestialObject(
                position,
                new THREE.Vector3(0, 0, 0),
                1000,
                'quasar'
            );
            quasar.mesh = mesh;
            objects.push(quasar);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –º–æ—â–Ω–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ
            const glowGeometry = new THREE.SphereGeometry(20, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x8080ff,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            mesh.add(glow);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ–º–Ω–æ–π –º–∞—Ç–µ—Ä–∏–∏
        function createDarkMatter(position, radius = 30) {
            // –¢–µ–º–Ω–∞—è –º–∞—Ç–µ—Ä–∏—è –Ω–µ–≤–∏–¥–∏–º–∞, –Ω–æ —Å–æ–∑–¥–∞–µ—Ç –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–æ–µ –∏—Å–∫–∞–∂–µ–Ω–∏–µ
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vPosition;
                    
                    void main() {
                        float dist = length(vPosition);
                        float distortion = sin(dist * 0.1 + time) * 0.5 + 0.5;
                        
                        // –ü–æ—á—Ç–∏ –Ω–µ–≤–∏–¥–∏–º–æ–µ –∏—Å–∫–∞–∂–µ–Ω–∏–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
                        gl_FragColor = vec4(0.5, 0.3, 1.0, distortion * 0.05);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                depthWrite: false
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            scene.add(mesh);
            
            // –ß–∞—Å—Ç–∏—Ü—ã –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ –≤–ª–∏—è–Ω–∏—è
            const particleCount = 1000;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = radius * (0.8 + Math.random() * 0.4);
                
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x4040ff,
                size: 0.5,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            mesh.add(particles);
            mesh.userData.particles = particles;
            
            const darkMatter = new CelestialObject(
                position,
                new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2),
                500, // –ë–æ–ª—å—à–∞—è –º–∞—Å—Å–∞
                'darkmatter'
            );
            darkMatter.mesh = mesh;
            objects.push(darkMatter);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —á–µ—Ä–≤–æ—Ç–æ—á–∏–Ω—ã
        function createWormhole(position1, position2 = null) {
            // –ï—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–∞ –≤—Ç–æ—Ä–∞—è –ø–æ–∑–∏—Ü–∏—è, —Å–æ–∑–¥–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é
            if (!position2) {
                position2 = new THREE.Vector3(
                    position1.x + (Math.random() - 0.5) * 200,
                    position1.y + (Math.random() - 0.5) * 200,
                    position1.z + (Math.random() - 0.5) * 200
                );
            }
            
            // –ü–µ—Ä–≤—ã–π –∫–æ–Ω–µ—Ü —á–µ—Ä–≤–æ—Ç–æ—á–∏–Ω—ã
            const end1Geometry = new THREE.TorusGeometry(5, 2, 16, 32);
            const end1Material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        vec2 center = vec2(0.5);
                        float dist = length(vUv - center);
                        
                        // –í—Ä–∞—â–∞—é—â–∏–π—Å—è –ø–æ—Ä—Ç–∞–ª
                        float angle = atan(vUv.y - 0.5, vUv.x - 0.5);
                        float spiral = sin(angle * 5.0 + time * 3.0 - dist * 10.0);
                        
                        vec3 color = mix(
                            vec3(1.0, 0.0, 1.0),
                            vec3(0.0, 1.0, 1.0),
                            spiral * 0.5 + 0.5
                        );
                        
                        gl_FragColor = vec4(color, 0.8);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const end1 = new THREE.Mesh(end1Geometry, end1Material);
            end1.position.copy(position1);
            scene.add(end1);
            
            // –í—Ç–æ—Ä–æ–π –∫–æ–Ω–µ—Ü —á–µ—Ä–≤–æ—Ç–æ—á–∏–Ω—ã
            const end2 = new THREE.Mesh(end1Geometry, end1Material.clone());
            end2.position.copy(position2);
            scene.add(end2);
            
            // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Å–≤—è–∑–∏ –º–µ–∂–¥—É –∫–æ–Ω—Ü–∞–º–∏
            const connectionGeometry = new THREE.BufferGeometry();
            const connectionMaterial = new THREE.LineBasicMaterial({
                color: 0xff00ff,
                transparent: true,
                opacity: 0.3
            });
            
            // –°–æ–∑–¥–∞–µ–º –∏—Å–∫—Ä–∏–≤–ª–µ–Ω–Ω—É—é –ª–∏–Ω–∏—é –º–µ–∂–¥—É –∫–æ–Ω—Ü–∞–º–∏
            const points = [];
            const segments = 50;
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const midPoint = position1.clone().lerp(position2, t);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∏—Å–∫—Ä–∏–≤–ª–µ–Ω–∏–µ
                const offset = new THREE.Vector3(
                    Math.sin(t * Math.PI) * 20,
                    Math.cos(t * Math.PI * 2) * 10,
                    Math.sin(t * Math.PI * 3) * 15
                );
                midPoint.add(offset);
                
                points.push(midPoint);
            }
            
            connectionGeometry.setFromPoints(points);
            const connection = new THREE.Line(connectionGeometry, connectionMaterial);
            scene.add(connection);
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —á–µ—Ä–≤–æ—Ç–æ—á–∏–Ω–µ
            const wormhole = {
                end1: end1,
                end2: end2,
                connection: connection,
                position1: position1,
                position2: position2,
                active: true
            };
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏
            if (!window.wormholes) window.wormholes = [];
            window.wormholes.push(wormhole);
            
            updateInfo(`–°–æ–∑–¥–∞–Ω–∞ —á–µ—Ä–≤–æ—Ç–æ—á–∏–Ω–∞, —Å–æ–µ–¥–∏–Ω—è—é—â–∞—è –¥–≤–µ —Ç–æ—á–∫–∏ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞!`);
            
            return wormhole;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ—Å–º–∏—á–µ—Å–∫–æ–π —Å—Ç—Ä—É–Ω—ã
        function createCosmicString(startPos, endPos) {
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float phase;
                    varying float vPhase;
                    uniform float time;
                    
                    void main() {
                        vPhase = phase;
                        vec3 newPosition = position;
                        
                        // –í–∏–±—Ä–∞—Ü–∏—è —Å—Ç—Ä—É–Ω—ã
                        float vibration = sin(phase * 10.0 + time * 5.0) * 2.0;
                        newPosition.x += vibration;
                        newPosition.y += cos(phase * 8.0 + time * 4.0) * 2.0;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying float vPhase;
                    
                    void main() {
                        vec3 color = vec3(0.0, 1.0, 1.0);
                        float brightness = sin(vPhase * 20.0 + time * 10.0) * 0.5 + 0.5;
                        
                        gl_FragColor = vec4(color * brightness, 0.8);
                    }
                `,
                transparent: true,
                linewidth: 3
            });
            
            // –°–æ–∑–¥–∞–µ–º —Ç–æ—á–∫–∏ –≤–¥–æ–ª—å —Å—Ç—Ä—É–Ω—ã
            const points = [];
            const phases = [];
            const segments = 100;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const point = startPos.clone().lerp(endPos, t);
                points.push(point.x, point.y, point.z);
                phases.push(t);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            geometry.setAttribute('phase', new THREE.Float32BufferAttribute(phases, 1));
            
            const cosmicString = new THREE.Line(geometry, material);
            scene.add(cosmicString);
            
            // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–æ–µ –∏—Å–∫–∞–∂–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ —Å—Ç—Ä—É–Ω—ã
            const distortionGeometry = new THREE.CylinderGeometry(
                5, 5, 
                startPos.distanceTo(endPos), 
                16, 1, true
            );
            const distortionMaterial = new THREE.MeshBasicMaterial({
                color: 0x0080ff,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            
            const distortion = new THREE.Mesh(distortionGeometry, distortionMaterial);
            distortion.position.copy(startPos.clone().add(endPos).multiplyScalar(0.5));
            distortion.lookAt(endPos);
            distortion.rotateX(Math.PI / 2);
            scene.add(distortion);
            
            return {
                string: cosmicString,
                distortion: distortion,
                material: material
            };
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∫–≤–∞–Ω—Ç–æ–≤–æ–π —Ñ–ª—É–∫—Ç—É–∞—Ü–∏–∏
        function createQuantumFluctuation(position) {
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.5
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            scene.add(mesh);
            
            const fluctuation = {
                mesh: mesh,
                position: position.clone(),
                energy: Math.random(),
                phase: Math.random() * Math.PI * 2
            };
            
            quantumFluctuations.push(fluctuation);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –º–µ—Ä—Ü–∞–Ω–∏—è
            const animate = () => {
                if (fluctuation.mesh) {
                    fluctuation.phase += 0.1;
                    fluctuation.mesh.scale.setScalar(1 + 0.5 * Math.sin(fluctuation.phase));
                    fluctuation.mesh.material.opacity = 0.3 + 0.3 * Math.sin(fluctuation.phase * 2);
                }
            };
            
            fluctuation.animate = animate;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—è —Ç–µ–º–Ω–æ–π —ç–Ω–µ—Ä–≥–∏–∏
        function createDarkEnergyField() {
            const geometry = new THREE.BoxGeometry(500, 500, 500);
            const material = new THREE.MeshBasicMaterial({
                color: 0x000066,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            
            const darkEnergyMesh = new THREE.Mesh(geometry, material);
            scene.add(darkEnergyMesh);
            
            // –ü—É–ª—å—Å–∞—Ü–∏—è —Ç–µ–º–Ω–æ–π —ç–Ω–µ—Ä–≥–∏–∏
            darkEnergyMesh.userData.update = (time) => {
                darkEnergyMesh.scale.setScalar(1 + 0.05 * Math.sin(time * 0.5));
                darkEnergyMesh.material.opacity = 0.1 + 0.05 * Math.sin(time * 0.3);
            };
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –±—Ä–∞–Ω
        function createBraneStructure() {
            // –°–æ–∑–¥–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –±—Ä–∞–Ω
            for (let i = 0; i < 3; i++) {
                const braneGeometry = new THREE.PlaneGeometry(300, 300, 50, 50);
                const braneMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(i / 3, 0.7, 0.5),
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide,
                    wireframe: true
                });
                
                const braneMesh = new THREE.Mesh(braneGeometry, braneMaterial);
                braneMesh.position.y = (i - 1) * 100;
                braneMesh.rotation.x = Math.PI / 2;
                scene.add(braneMesh);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –≤–æ–ª–Ω–æ–≤—ã–µ –∏—Å–∫–∞–∂–µ–Ω–∏—è –Ω–∞ –±—Ä–∞–Ω–µ
                braneMesh.userData.update = (time) => {
                    const positions = braneMesh.geometry.attributes.position;
                    for (let j = 0; j < positions.count; j++) {
                        const x = positions.getX(j);
                        const y = positions.getY(j);
                        const waveZ = Math.sin(x * 0.02 + time) * Math.cos(y * 0.02 + time) * 5;
                        positions.setZ(j, waveZ);
                    }
                    positions.needsUpdate = true;
                };
                
                // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç—ã –Ω–∞ –∫–∞–∂–¥–æ–π –±—Ä–∞–Ω–µ
                for (let j = 0; j < 10; j++) {
                    const position = new THREE.Vector3(
                        (Math.random() - 0.5) * 200,
                        (i - 1) * 100,
                        (Math.random() - 0.5) * 200
                    );
                    createStar(position);
                }
            }
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∫–≤–∞–Ω—Ç–æ–≤–æ–π –ø–µ–Ω—ã
        function createQuantumFoam() {
            const foamParticles = new THREE.BufferGeometry();
            const foamMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.2,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < 5000; i++) {
                positions.push(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
                colors.push(Math.random(), Math.random(), Math.random());
            }
            
            foamParticles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            foamParticles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const foam = new THREE.Points(foamParticles, foamMaterial);
            scene.add(foam);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –∫–≤–∞–Ω—Ç–æ–≤–æ–π –ø–µ–Ω—ã
            foam.userData.update = (time) => {
                const positions = foam.geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    
                    positions.setX(i, x + (Math.random() - 0.5) * 0.5);
                    positions.setY(i, y + (Math.random() - 0.5) * 0.5);
                    positions.setZ(i, z + (Math.random() - 0.5) * 0.5);
                    
                    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤ –≥—Ä–∞–Ω–∏—Ü—ã
                    if (Math.abs(positions.getX(i)) > 50) positions.setX(i, x);
                    if (Math.abs(positions.getY(i)) > 50) positions.setY(i, y);
                    if (Math.abs(positions.getZ(i)) > 50) positions.setZ(i, z);
                }
                positions.needsUpdate = true;
            };
        }

        function showObjectInfo(obj) {
            let info = `<h3>${obj.type.charAt(0).toUpperCase() + obj.type.slice(1)}</h3>`;
            info += `<p><strong>–ú–∞—Å—Å–∞:</strong> ${obj.mass.toFixed(2)} M‚òâ</p>`;
            info += `<p><strong>–í–æ–∑—Ä–∞—Å—Ç:</strong> ${(obj.age / 1000000).toFixed(2)} –º–ª–Ω –ª–µ—Ç</p>`;
            info += `<p><strong>–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞:</strong> ${obj.temperature.toFixed(0)} K</p>`;
            info += `<p><strong>–°–∫–æ—Ä–æ—Å—Ç—å:</strong> ${obj.velocity.length().toFixed(2)} –∫–º/—Å</p>`;
            
            if (obj.type === 'star') {
                info += `<p><strong>–°—Ç–∞–¥–∏—è:</strong> ${obj.evolutionStage}</p>`;
                info += `<p><strong>–¢–æ–ø–ª–∏–≤–æ:</strong> ${(obj.fuelRemaining * 100).toFixed(1)}%</p>`;
                info += `<p><strong>–°–≤–µ—Ç–∏–º–æ—Å—Ç—å:</strong> ${obj.luminosity.toFixed(2)} L‚òâ</p>`;
            }
            
            if (obj.type === 'planet' && obj.hasLife) {
                info += `<p><strong>–ñ–∏–∑–Ω—å:</strong> ${obj.lifeStage}</p>`;
            }
            
            if (obj.type === 'blackhole') {
                info += `<p><strong>–†–∞–¥–∏—É—Å –®–≤–∞—Ä—Ü—à–∏–ª—å–¥–∞:</strong> ${obj.schwarzschildRadius.toFixed(3)} –∫–º</p>`;
            }
            
            document.getElementById('info-content').innerHTML = info;
        }

        function showObjectProperties(obj) {
            // –°–æ–∑–¥–∞–µ–º –ø–∞–Ω–µ–ª—å —Å–≤–æ–π—Å—Ç–≤ –¥–ª—è –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏ –æ–±—ä–µ–∫—Ç–æ–º
            const panel = document.createElement('div');
            panel.className = 'control-panel';
            panel.style.cssText = `
                position: absolute;
                top: 50%;
                right: 20px;
                transform: translateY(-50%);
                width: 250px;
            `;
            
            panel.innerHTML = `
                <h3>–°–≤–æ–π—Å—Ç–≤–∞ –æ–±—ä–µ–∫—Ç–∞</h3>
                <div class="parameter-slider">
                    <label>–ú–∞—Å—Å–∞: <span id="obj-mass-value">${obj.mass.toFixed(2)}</span></label>
                    <input type="range" id="obj-mass" min="0.1" max="100" step="0.1" value="${obj.mass}">
                </div>
                <div class="parameter-slider">
                    <label>–°–∫–æ—Ä–æ—Å—Ç—å X: <span id="obj-vx-value">${obj.velocity.x.toFixed(2)}</span></label>
                    <input type="range" id="obj-vx" min="-50" max="50" step="0.1" value="${obj.velocity.x}">
                </div>
                <div class="parameter-slider">
                    <label>–°–∫–æ—Ä–æ—Å—Ç—å Y: <span id="obj-vy-value">${obj.velocity.y.toFixed(2)}</span></label>
                    <input type="range" id="obj-vy" min="-50" max="50" step="0.1" value="${obj.velocity.y}">
                </div>
                <div class="parameter-slider">
                    <label>–°–∫–æ—Ä–æ—Å—Ç—å Z: <span id="obj-vz-value">${obj.velocity.z.toFixed(2)}</span></label>
                    <input type="range" id="obj-vz" min="-50" max="50" step="0.1" value="${obj.velocity.z}">
                </div>
                <button class="tool-button" onclick="this.parentElement.remove()">–ó–∞–∫—Ä—ã—Ç—å</button>
            `;
            
            document.getElementById('ui-overlay').appendChild(panel);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
            document.getElementById('obj-mass').addEventListener('input', function() {
                obj.mass = parseFloat(this.value);
                document.getElementById('obj-mass-value').textContent = obj.mass.toFixed(2);
                if (obj.mesh) {
                    const scale = Math.cbrt(obj.mass / 10);
                    obj.mesh.scale.setScalar(scale);
                }
            });
            
            document.getElementById('obj-vx').addEventListener('input', function() {
                obj.velocity.x = parseFloat(this.value);
                document.getElementById('obj-vx-value').textContent = obj.velocity.x.toFixed(2);
            });
            
            document.getElementById('obj-vy').addEventListener('input', function() {
                obj.velocity.y = parseFloat(this.value);
                document.getElementById('obj-vy-value').textContent = obj.velocity.y.toFixed(2);
            });
            
            document.getElementById('obj-vz').addEventListener('input', function() {
                obj.velocity.z = parseFloat(this.value);
                document.getElementById('obj-vz-value').textContent = obj.velocity.z.toFixed(2);
            });
        }

        // –ö–ª–∞—Å—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–∏–∑—É–∞–ª—å–Ω—ã–º–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏
        class VisualEffects {
            constructor(scene) {
                this.scene = scene;
                this.activeEffects = [];
            }
            
            createNebula(position, size = 50, color = 0x8080ff) {
                const geometry = new THREE.BufferGeometry();
                const particles = 5000;
                const positions = new Float32Array(particles * 3);
                const colors = new Float32Array(particles * 3);
                const sizes = new Float32Array(particles);
                
                const baseColor = new THREE.Color(color);
                
                for (let i = 0; i < particles; i++) {
                    // –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –≤ —Å—Ñ–µ—Ä–∏—á–µ—Å–∫–æ–º –æ–±—ä–µ–º–µ
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.pow(Math.random(), 0.5) * size;
                    
                    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = r * Math.cos(phi);
                    
                    // –í–∞—Ä–∏–∞—Ü–∏–∏ —Ü–≤–µ—Ç–∞
                    const colorVariation = 0.2;
                    colors[i * 3] = baseColor.r + (Math.random() - 0.5) * colorVariation;
                    colors[i * 3 + 1] = baseColor.g + (Math.random() - 0.5) * colorVariation;
                    colors[i * 3 + 2] = baseColor.b + (Math.random() - 0.5) * colorVariation;
                    
                    sizes[i] = Math.random() * 3 + 1;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        texture: { value: this.createNebulaTexture() }
                    },
                    vertexShader: `
                        attribute float size;
                        varying vec3 vColor;
                        uniform float time;
                        
                        void main() {
                            vColor = color;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            
                            // –ü—É–ª—å—Å–∞—Ü–∏—è —Ä–∞–∑–º–µ—Ä–∞
                            float pulse = sin(time * 2.0 + position.x * 0.1) * 0.1 + 1.0;
                            gl_PointSize = size * pulse * (300.0 / -mvPosition.z);
                            
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D texture;
                        varying vec3 vColor;
                        
                        void main() {
                            vec4 texColor = texture2D(texture, gl_PointCoord);
                            gl_FragColor = vec4(vColor, 1.0) * texColor;
                        }
                    `,
                    vertexColors: true,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const nebula = new THREE.Points(geometry, material);
                nebula.position.copy(position);
                this.scene.add(nebula);
                
                this.activeEffects.push({
                    type: 'nebula',
                    mesh: nebula,
                    material: material
                });
                
                return nebula;
            }
            
            createNebulaTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
                gradient.addColorStop(0.4, 'rgba(255,200,200,0.6)');
                gradient.addColorStop(0.7, 'rgba(255,150,150,0.3)');
                gradient.addColorStop(1, 'rgba(255,100,100,0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 64);
                
                return new THREE.CanvasTexture(canvas);
            }
            
            createGravitationalWave(center, radius = 100) {
                const geometry = new THREE.RingGeometry(0, radius, 64, 8);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        waveSpeed: { value: 50 },
                        maxRadius: { value: radius }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        varying float vRadius;
                        void main() {
                            vUv = uv;
                            vRadius = length(position.xy);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float waveSpeed;
                        uniform float maxRadius;
                        varying vec2 vUv;
                        varying float vRadius;
                        
                        void main() {
                            float waveRadius = time * waveSpeed;
                            float waveFront = 1.0 - abs(vRadius - waveRadius) / 10.0;
                            waveFront = clamp(waveFront, 0.0, 1.0);
                            
                            // –ó–∞—Ç—É—Ö–∞–Ω–∏–µ –≤–æ–ª–Ω—ã
                            float decay = 1.0 - (waveRadius / maxRadius);
                            decay = clamp(decay, 0.0, 1.0);
                            
                            vec3 color = vec3(0.5, 0.3, 1.0);
                            gl_FragColor = vec4(color, waveFront * decay * 0.5);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                const wave = new THREE.Mesh(geometry, material);
                wave.position.copy(center);
                this.scene.add(wave);
                
                this.activeEffects.push({
                    type: 'gravitationalWave',
                    mesh: wave,
                    material: material,
                    startTime: universeTime,
                    duration: radius / 50
                });
                
                return wave;
            }
            
            createSupernova(position) {
                // –í—Å–ø—ã—à–∫–∞
                const flashGeometry = new THREE.SphereGeometry(5, 32, 32);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 1
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.copy(position);
                this.scene.add(flash);
                
                // –£–¥–∞—Ä–Ω–∞—è –≤–æ–ª–Ω–∞
                const shockwaveGeometry = new THREE.SphereGeometry(1, 32, 32);
                const shockwaveMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        uniform float time;
                        void main() {
                            vNormal = normal;
                            vec3 newPosition = position * (1.0 + time * 20.0);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vNormal;
                        uniform float time;
                        void main() {
                            float intensity = pow(0.8 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0);
                            vec3 color = mix(vec3(1.0, 0.8, 0.0), vec3(1.0, 0.0, 0.0), time);
                            float opacity = (1.0 - time) * intensity;
                            gl_FragColor = vec4(color, opacity);
                        }
                    `,
                    transparent: true,
                    side: THREE.BackSide,
                    depthWrite: false
                });
                const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                shockwave.position.copy(position);
                this.scene.add(shockwave);
                
                // –ß–∞—Å—Ç–∏—Ü—ã –≤–∑—Ä—ã–≤–∞
                const debrisCount = 200;
                const debris = [];
                for (let i = 0; i < debrisCount; i++) {
                    const debrisGeometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.3, 8, 8);
                    const debrisMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.1 * Math.random(), 1, 0.5),
                        transparent: true
                    });
                    const debrisMesh = new THREE.Mesh(debrisGeometry, debrisMaterial);
                    debrisMesh.position.copy(position);
                    
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5),
                        (Math.random() - 0.5),
                        (Math.random() - 0.5)
                    ).normalize().multiplyScalar(20 + Math.random() * 30);
                    
                    debrisMesh.userData.velocity = velocity;
                    this.scene.add(debrisMesh);
                    debris.push(debrisMesh);
                }
                
                this.activeEffects.push({
                    type: 'supernova',
                    flash: flash,
                    shockwave: shockwave,
                    shockwaveMaterial: shockwaveMaterial,
                    debris: debris,
                    startTime: universeTime,
                    duration: 3
                });
                
                // –°–æ–∑–¥–∞–µ–º —Ç—É–º–∞–Ω–Ω–æ—Å—Ç—å –Ω–∞ –º–µ—Å—Ç–µ –≤–∑—Ä—ã–≤–∞
                setTimeout(() => {
                    this.createNebula(position, 30, 0xff4400);
                }, 2000);
            }
            
            update(deltaTime) {
                // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
                this.activeEffects = this.activeEffects.filter(effect => {
                    if (effect.material && effect.material.uniforms.time) {
                        effect.material.uniforms.time.value += deltaTime;
                    }
                    
                    if (effect.type === 'gravitationalWave') {
                        const elapsed = universeTime - effect.startTime;
                        if (elapsed > effect.duration) {
                            this.scene.remove(effect.mesh);
                            effect.mesh.geometry.dispose();
                            effect.material.dispose();
                            return false;
                        }
                    } else if (effect.type === 'supernova') {
                        const elapsed = universeTime - effect.startTime;
                        const progress = elapsed / effect.duration;
                        
                        if (progress < 1) {
                            // –ê–Ω–∏–º–∞—Ü–∏—è –≤—Å–ø—ã—à–∫–∏
                            effect.flash.scale.setScalar(1 + progress * 10);
                            effect.flash.material.opacity = 1 - progress;
                            
                            // –ê–Ω–∏–º–∞—Ü–∏—è —É–¥–∞—Ä–Ω–æ–π –≤–æ–ª–Ω—ã
                            effect.shockwaveMaterial.uniforms.time.value = progress;
                            
                            // –ê–Ω–∏–º–∞—Ü–∏—è –æ–±–ª–æ–º–∫–æ–≤
                            effect.debris.forEach(debris => {
                                debris.position.add(debris.userData.velocity.clone().multiplyScalar(deltaTime));
                                debris.material.opacity = 1 - progress;
                            });
                        } else {
                            // –£–¥–∞–ª—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç
                            this.scene.remove(effect.flash);
                            this.scene.remove(effect.shockwave);
                            effect.debris.forEach(debris => this.scene.remove(debris));
                            return false;
                        }
                    }
                    
                    return true;
                });
            }
        }

        // –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä —Å–∏—Å—Ç–µ–º—ã —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
        let visualEffects;

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —ç–º–µ—Ä–¥–∂–µ–Ω—Ç–Ω—ã—Ö —Å–≤–æ–π—Å—Ç–≤
        function checkEmergentProperties() {
            const clusters = findClusters(objects, 50); // –†–∞–¥–∏—É—Å –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏
            
            for (let cluster of clusters) {
                if (cluster.length > 5 && Math.random() < emergenceLevel * 0.01) {
                    // –°–æ–∑–¥–∞–µ–º —ç–º–µ—Ä–¥–∂–µ–Ω—Ç–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
                    const center = calculateCenterOfMass(cluster);
                    const emergentGeometry = new THREE.TorusGeometry(10, 3, 16, 100);
                    const emergentMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.3,
                        wireframe: true
                    });
                    const emergentMesh = new THREE.Mesh(emergentGeometry, emergentMaterial);
                    emergentMesh.position.copy(center);
                    scene.add(emergentMesh);
                    
                    // –£–¥–∞–ª—è–µ–º —á–µ—Ä–µ–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è
                    setTimeout(() => scene.remove(emergentMesh), 5000);
                }
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥—É–∞–ª–∏—Å—Ç–∏—á–µ—Å–∫–∏—Ö —Å–≤–æ–π—Å—Ç–≤
        function updateDualisticProperties() {
            for (let obj of objects) {
                if (!obj.spirit) {
                    // –°–æ–∑–¥–∞–µ–º "–¥—É—Ö–æ–≤–Ω—É—é" –∫–æ–ø–∏—é
                    const spiritGeometry = obj.mesh.geometry.clone();
                    const spiritMaterial = new THREE.MeshBasicMaterial({
                        color: 0x8080ff,
                        transparent: true,
                        opacity: 0.3,
                        wireframe: true
                    });
                    const spiritMesh = new THREE.Mesh(spiritGeometry, spiritMaterial);
                    obj.mesh.add(spiritMesh);
                    obj.spirit = spiritMesh;
                }
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –¥—É—Ö–æ–≤–Ω–æ–π —Å–æ—Å—Ç–∞–≤–ª—è—é—â–µ–π
                obj.spirit.rotation.x += 0.01;
                obj.spirit.rotation.y += 0.02;
                obj.spirit.scale.setScalar(1 + 0.2 * Math.sin(universeTime * 0.01));
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å—É–∞–ª—å–Ω–æ–π —Ñ–∏–ª–æ—Å–æ—Ñ–∏–∏
        function updateProcessPhilosophy() {
            for (let obj of objects) {
                // –ü–æ—Å—Ç–æ—è–Ω–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ñ–æ—Ä–º—ã
                if (obj.mesh && obj.mesh.geometry) {
                    const scale = 1 + 0.1 * Math.sin(universeTime * 0.01 + obj.age);
                    obj.mesh.scale.x = scale;
                    obj.mesh.scale.y = scale * (1 + 0.1 * Math.sin(universeTime * 0.02));
                    obj.mesh.scale.z = scale * (1 + 0.1 * Math.cos(universeTime * 0.02));
                }
                
                // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ –∫–∞–∫ –ø—Ä–æ—Ü–µ—Å—Å
                if (obj.mesh && obj.mesh.material) {
                    const hue = (universeTime * 0.001 + obj.age * 0.01) % 1;
                    obj.mesh.material.color.setHSL(hue, 0.7, 0.5);
                }
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –æ–Ω—Ç–æ–ª–æ–≥–∏–∏
        function updateInformationOntology() {
            // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö –ø–æ—Ç–æ–∫–æ–≤
            for (let i = 0; i < objects.length - 1; i++) {
                for (let j = i + 1; j < objects.length; j++) {
                    const distance = objects[i].position.distanceTo(objects[j].position);
                    
                    if (distance < 50 && Math.random() < informationComplexity * 0.01) {
                        // –°–æ–∑–¥–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—É—é —Å–≤—è–∑—å
                        const geometry = new THREE.BufferGeometry();
                        const material = new THREE.LineBasicMaterial({
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.5
                        });
                        
                        const positions = new Float32Array(6);
                        positions[0] = objects[i].position.x;
                        positions[1] = objects[i].position.y;
                        positions[2] = objects[i].position.z;
                        positions[3] = objects[j].position.x;
                        positions[4] = objects[j].position.y;
                        positions[5] = objects[j].position.z;
                        
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                        
                        // –£–¥–∞–ª—è–µ–º —á–µ—Ä–µ–∑ –∫–æ—Ä–æ—Ç–∫–æ–µ –≤—Ä–µ–º—è
                        setTimeout(() => scene.remove(line), 1000);
                    }
                }
            }
        }

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        function findClusters(objects, radius) {
            const clusters = [];
            const visited = new Set();
            
            for (let obj of objects) {
                if (!visited.has(obj)) {
                    const cluster = [];
                    const queue = [obj];
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        if (!visited.has(current)) {
                            visited.add(current);
                            cluster.push(current);
                            
                            for (let other of objects) {
                                if (!visited.has(other) && 
                                    current.position.distanceTo(other.position) < radius) {
                                    queue.push(other);
                                }
                            }
                        }
                    }
                    
                    clusters.push(cluster);
                }
            }
            
            return clusters;
        }

        function calculateCenterOfMass(objects) {
            const center = new THREE.Vector3();
            let totalMass = 0;
            
            for (let obj of objects) {
                center.add(obj.position.clone().multiplyScalar(obj.mass));
                totalMass += obj.mass;
            }
            
            return center.divideScalar(totalMass);
        }

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä–æ–π
        class CameraController {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                
                // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                this.rotateSpeed = 0.005;
                this.zoomSpeed = 0.1;
                this.panSpeed = 0.5;
                this.dampingFactor = 0.95;
                
                // –°–æ—Å—Ç–æ—è–Ω–∏–µ
                this.isRotating = false;
                this.isPanning = false;
                this.mouseStart = new THREE.Vector2();
                this.mouseEnd = new THREE.Vector2();
                this.rotateVelocity = new THREE.Vector2();
                this.panVelocity = new THREE.Vector3();
                this.target = new THREE.Vector3(0, 0, 0);
                this.spherical = new THREE.Spherical();
                this.spherical.setFromVector3(camera.position);
                
                // –†–µ–∂–∏–º—ã –∫–∞–º–µ—Ä—ã
                this.mode = 'orbit'; // 'orbit', 'free', 'follow'
                this.followTarget = null;
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                this.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.domElement.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.domElement.addEventListener('wheel', (e) => this.onWheel(e));
                
                // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
            }
            
            onMouseDown(event) {
                if (event.button === 0) { // –õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞
                    this.isRotating = true;
                } else if (event.button === 2) { // –ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞
                    this.isPanning = true;
                }
                
                this.mouseStart.set(event.clientX, event.clientY);
                this.mouseEnd.set(event.clientX, event.clientY);
            }
            
            onMouseMove(event) {
                this.mouseEnd.set(event.clientX, event.clientY);
                
                const deltaX = this.mouseEnd.x - this.mouseStart.x;
                const deltaY = this.mouseEnd.y - this.mouseStart.y;
                
                if (this.isRotating && this.mode === 'orbit') {
                    this.rotateVelocity.x = deltaX * this.rotateSpeed;
                    this.rotateVelocity.y = deltaY * this.rotateSpeed;
                } else if (this.isPanning) {
                    const distance = this.camera.position.length();
                    this.panVelocity.x = -deltaX * this.panSpeed * distance * 0.001;
                    this.panVelocity.y = deltaY * this.panSpeed * distance * 0.001;
                }
                
                this.mouseStart.copy(this.mouseEnd);
            }
            
            onMouseUp(event) {
                this.isRotating = false;
                this.isPanning = false;
            }
            
            onWheel(event) {
                event.preventDefault();
                const delta = event.deltaY * this.zoomSpeed;
                
                if (this.mode === 'orbit') {
                    this.spherical.radius *= 1 + delta * 0.001;
                    this.spherical.radius = Math.max(10, Math.min(1000, this.spherical.radius));
                } else {
                    this.camera.position.multiplyScalar(1 + delta * 0.001);
                }
            }
            
            onKeyDown(event) {
                switch(event.key) {
                    case 'f': // –°–ª–µ–¥–æ–≤–∞—Ç—å –∑–∞ –æ–±—ä–µ–∫—Ç–æ–º
                        this.toggleFollowMode();
                        break;
                    case 'o': // –û—Ä–±–∏—Ç–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º
                        this.setMode('orbit');
                        break;
                    case 'p': // –°–≤–æ–±–æ–¥–Ω—ã–π —Ä–µ–∂–∏–º
                        this.setMode('free');
                        break;
                    case 'r': // –°–±—Ä–æ—Å –∫–∞–º–µ—Ä—ã
                        this.reset();
                        break;
                }
            }
            
            setMode(mode) {
                this.mode = mode;
                updateInfo(`–†–µ–∂–∏–º –∫–∞–º–µ—Ä—ã: ${mode}`);
            }
            
            toggleFollowMode() {
                if (this.mode === 'follow') {
                    this.setMode('orbit');
                    this.followTarget = null;
                } else {
                    // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à–∏–π –æ–±—ä–µ–∫—Ç
                    let nearestObj = null;
                    let nearestDist = Infinity;
                    
                    for (let obj of objects) {
                        const dist = this.camera.position.distanceTo(obj.position);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestObj = obj;
                        }
                    }
                    
                    if (nearestObj) {
                        this.followTarget = nearestObj;
                        this.setMode('follow');
                        updateInfo(`–°–ª–µ–¥–∏–º –∑–∞ –æ–±—ä–µ–∫—Ç–æ–º: ${nearestObj.type}`);
                    }
                }
            }
            
            reset() {
                this.camera.position.set(0, 50, 100);
                this.camera.lookAt(0, 0, 0);
                this.target.set(0, 0, 0);
                this.spherical.setFromVector3(this.camera.position);
                this.rotateVelocity.set(0, 0);
                this.panVelocity.set(0, 0, 0);
            }
            
            update(deltaTime) {
                if (this.mode === 'orbit') {
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ
                    this.spherical.theta -= this.rotateVelocity.x;
                    this.spherical.phi += this.rotateVelocity.y;
                    this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
                    const offset = new THREE.Vector3();
                    const quat = new THREE.Quaternion().setFromUnitVectors(
                        this.camera.up, 
                        new THREE.Vector3(0, 1, 0)
                    );
                    offset.copy(this.panVelocity).applyQuaternion(quat);
                    this.target.add(offset);
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã
                    const position = new THREE.Vector3().setFromSpherical(this.spherical);
                    position.add(this.target);
                    this.camera.position.copy(position);
                    this.camera.lookAt(this.target);
                    
                } else if (this.mode === 'follow' && this.followTarget) {
                    // –°–ª–µ–¥—É–µ–º –∑–∞ –æ–±—ä–µ–∫—Ç–æ–º
                    const offset = new THREE.Vector3(30, 20, 30);
                    const desiredPosition = this.followTarget.position.clone().add(offset);
                    this.camera.position.lerp(desiredPosition, deltaTime * 2);
                    this.camera.lookAt(this.followTarget.position);
                    
                    // –ï—Å–ª–∏ –æ–±—ä–µ–∫—Ç —É–Ω–∏—á—Ç–æ–∂–µ–Ω, –≤—ã—Ö–æ–¥–∏–º –∏–∑ —Ä–µ–∂–∏–º–∞ —Å–ª–µ–¥–æ–≤–∞–Ω–∏—è
                    if (!objects.includes(this.followTarget)) {
                        this.setMode('orbit');
                        this.followTarget = null;
                    }
                }
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –∑–∞—Ç—É—Ö–∞–Ω–∏–µ
                this.rotateVelocity.multiplyScalar(this.dampingFactor);
                this.panVelocity.multiplyScalar(this.dampingFactor);
            }
        }

        function setupCameraControls() {
            window.cameraController = new CameraController(camera, renderer.domElement);
            
            // –û—Ç–∫–ª—é—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é –Ω–∞ –ø—Ä–∞–≤—ã–π –∫–ª–∏–∫
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        class PerformanceMonitor {
            constructor() {
                this.stats = {
                    fps: 0,
                    frameTime: 0,
                    drawCalls: 0,
                    triangles: 0,
                    objects: 0,
                    memory: 0
                };
                
                this.history = {
                    fps: [],
                    frameTime: [],
                    memory: []
                };
                
                this.maxHistoryLength = 100;
                this.lastTime = performance.now();
                this.frames = 0;
                
                this.createUI();
            }
            
            createUI() {
                const monitorDiv = document.createElement('div');
                monitorDiv.id = 'performance-monitor';
                monitorDiv.style.cssText = `
                    position: absolute;
                    bottom: 20px;
                    right: 20px;
                    background: rgba(0, 0, 0, 0.8);
                    color: #0f0;
                    font-family: monospace;
                    font-size: 12px;
                    padding: 10px;
                    border: 1px solid #0f0;
                    border-radius: 5px;
                    min-width: 200px;
                    z-index: 1000;
                `;
                
                monitorDiv.innerHTML = `
                    <div style="margin-bottom: 5px; color: #0f0; border-bottom: 1px solid #0f0;">Performance Monitor</div>
                    <div>FPS: <span id="mon-fps">0</span></div>
                    <div>Frame Time: <span id="mon-frametime">0</span>ms</div>
                    <div>Draw Calls: <span id="mon-drawcalls">0</span></div>
                    <div>Triangles: <span id="mon-triangles">0</span></div>
                    <div>Objects: <span id="mon-objects">0</span></div>
                    <div>Memory: <span id="mon-memory">0</span>MB</div>
                    <canvas id="fps-graph" width="180" height="50" style="margin-top: 10px; border: 1px solid #0f0;"></canvas>
                `;
                
                document.body.appendChild(monitorDiv);
                
                this.graphCanvas = document.getElementById('fps-graph');
                this.graphCtx = this.graphCanvas.getContext('2d');
            }
            
            update() {
                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastTime;
                this.frames++;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
                if (deltaTime >= 1000) {
                    this.stats.fps = Math.round((this.frames * 1000) / deltaTime);
                    this.stats.frameTime = Math.round(deltaTime / this.frames);
                    this.frames = 0;
                    this.lastTime = currentTime;
                    
                    // –ü–æ–¥—Å—á–µ—Ç draw calls –∏ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤
                    this.stats.drawCalls = 0;
                    this.stats.triangles = 0;
                    
                    scene.traverse((child) => {
                        if (child.isMesh) {
                            this.stats.drawCalls++;
                            if (child.geometry) {
                                const geometry = child.geometry;
                                if (geometry.index) {
                                    this.stats.triangles += geometry.index.count / 3;
                                } else if (geometry.attributes.position) {
                                    this.stats.triangles += geometry.attributes.position.count / 3;
                                }
                            }
                        }
                    });
                    
                    this.stats.objects = objects.length;
                    
                    // –ü–∞–º—è—Ç—å (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ)
                    if (performance.memory) {
                        this.stats.memory = Math.round(performance.memory.usedJSHeapSize / 1048576);
                    }
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é
                    this.history.fps.push(this.stats.fps);
                    this.history.frameTime.push(this.stats.frameTime);
                    this.history.memory.push(this.stats.memory);
                    
                    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –∏—Å—Ç–æ—Ä–∏–∏
                    if (this.history.fps.length > this.maxHistoryLength) {
                        this.history.fps.shift();
                        this.history.frameTime.shift();
                        this.history.memory.shift();
                    }
                    
                    this.updateUI();
                    this.drawGraph();
                }
            }
            
            updateUI() {
                document.getElementById('mon-fps').textContent = this.stats.fps;
                document.getElementById('mon-frametime').textContent = this.stats.frameTime;
                document.getElementById('mon-drawcalls').textContent = this.stats.drawCalls;
                document.getElementById('mon-triangles').textContent = this.formatNumber(this.stats.triangles);
                document.getElementById('mon-objects').textContent = this.stats.objects;
                document.getElementById('mon-memory').textContent = this.stats.memory;
                
                // –¶–≤–µ—Ç–æ–≤–∞—è –∏–Ω–¥–∏–∫–∞—Ü–∏—è FPS
                const fpsElement = document.getElementById('mon-fps');
                if (this.stats.fps >= 50) {
                    fpsElement.style.color = '#0f0';
                } else if (this.stats.fps >= 30) {
                    fpsElement.style.color = '#ff0';
                } else {
                    fpsElement.style.color = '#f00';
                }
            }
            
            drawGraph() {
                const ctx = this.graphCtx;
                const width = this.graphCanvas.width;
                const height = this.graphCanvas.height;
                
                // –û—á–∏—â–∞–µ–º –∫–∞–Ω–≤–∞—Å
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É
                ctx.strokeStyle = '#030';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const y = (height / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // –†–∏—Å—É–µ–º –≥—Ä–∞—Ñ–∏–∫ FPS
                if (this.history.fps.length > 1) {
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let i = 0; i < this.history.fps.length; i++) {
                        const x = (i / (this.maxHistoryLength - 1)) * width;
                        const y = height - (this.history.fps[i] / 60) * height;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.stroke();
                }
            }
            
            formatNumber(num) {
                if (num >= 1000000) {
                    return (num / 1000000).toFixed(1) + 'M';
                } else if (num >= 1000) {
                    return (num / 1000).toFixed(1) + 'K';
                }
                return num.toString();
            }
        }

        // –°–æ–∑–¥–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        let performanceMonitor;

        class RenderOptimizer {
            constructor(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                
                // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞
                this.qualityLevels = {
                    ultra: {
                        shadowMapSize: 2048,
                        antialias: true,
                        pixelRatio: window.devicePixelRatio,
                        postProcessing: true
                    },
                    high: {
                        shadowMapSize: 1024,
                        antialias: true,
                        pixelRatio: Math.min(window.devicePixelRatio, 2),
                        postProcessing: true
                    },
                    medium: {
                        shadowMapSize: 512,
                        antialias: false,
                        pixelRatio: 1,
                        postProcessing: false
                    },
                    low: {
                        shadowMapSize: 256,
                        antialias: false,
                        pixelRatio: 0.75,
                        postProcessing: false
                    }
                };
                
                this.currentQuality = 'high';
                this.autoAdjust = true;
                this.targetFPS = 30;
                
                this.applyQualitySettings();
            }
            
            applyQualitySettings() {
                const settings = this.qualityLevels[this.currentQuality];
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞
                this.renderer.setPixelRatio(settings.pixelRatio);
                this.renderer.shadowMap.enabled = settings.shadowMapSize > 0;
                
                if (this.renderer.shadowMap.enabled) {
                    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–∑–º–µ—Ä —Ç–µ–Ω–µ–≤—ã—Ö –∫–∞—Ä—Ç –¥–ª—è –≤—Å–µ—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å–≤–µ—Ç–∞
                    this.scene.traverse((child) => {
                        if (child.isLight && child.castShadow) {
                            child.shadow.mapSize.width = settings.shadowMapSize;
                            child.shadow.mapSize.height = settings.shadowMapSize;
                        }
                    });
                }
                
                updateInfo(`–ö–∞—á–µ—Å—Ç–≤–æ –≥—Ä–∞—Ñ–∏–∫–∏: ${this.currentQuality}`);
            }
            
            setQuality(level) {
                if (this.qualityLevels[level]) {
                    this.currentQuality = level;
                    this.applyQualitySettings();
                }
            }
            
            autoAdjustQuality(currentFPS) {
                if (!this.autoAdjust) return;
                
                if (currentFPS < this.targetFPS - 5) {
                    // –ü–æ–Ω–∏–∂–∞–µ–º –∫–∞—á–µ—Å—Ç–≤–æ
                    if (this.currentQuality === 'ultra') {
                        this.setQuality('high');
                    } else if (this.currentQuality === 'high') {
                        this.setQuality('medium');
                    } else if (this.currentQuality === 'medium') {
                        this.setQuality('low');
                    }
                } else if (currentFPS > this.targetFPS + 10) {
                    // –ü–æ–≤—ã—à–∞–µ–º –∫–∞—á–µ—Å—Ç–≤–æ
                    if (this.currentQuality === 'low') {
                        this.setQuality('medium');
                    } else if (this.currentQuality === 'medium') {
                        this.setQuality('high');
                    } else if (this.currentQuality === 'high') {
                        this.setQuality('ultra');
                    }
                }
            }
            
            enableFrustumCulling() {
                const frustum = new THREE.Frustum();
                const cameraMatrix = new THREE.Matrix4();
                
                return () => {
                    cameraMatrix.multiplyMatrices(
                        this.camera.projectionMatrix,
                        this.camera.matrixWorldInverse
                    );
                    frustum.setFromProjectionMatrix(cameraMatrix);
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∏–¥–∏–º–æ—Å—Ç—å –æ–±—ä–µ–∫—Ç–æ–≤
                    for (let obj of objects) {
                        if (obj.mesh) {
                            obj.mesh.visible = frustum.intersectsObject(obj.mesh);
                        }
                    }
                };
            }
        }

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
        function setupEventHandlers() {
            // –°–æ–∑–¥–∞–µ–º –ø–∞–Ω–µ–ª—å –ø–æ–º–æ—â–∏ –≤ –Ω–∞—á–∞–ª–µ
            const helpPanel = document.createElement('div');
            helpPanel.className = 'control-panel';
            helpPanel.style.cssText = `
                position: absolute;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                display: none;
                max-width: 400px;
                z-index: 1001;
            `;
            helpPanel.innerHTML = `
                <h3>–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏</h3>
                <table style="font-size: 12px;">
                    <tr><td>–ü—Ä–æ–±–µ–ª</td><td>–ü–∞—É–∑–∞</td></tr>
                    <tr><td>H</td><td>–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å</td></tr>
                    <tr><td>M</td><td>–ú–æ–Ω–∏—Ç–æ—Ä –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏</td></tr>
                    <tr><td>G</td><td>–°–µ—Ç–∫–∞</td></tr>
                    <tr><td>F</td><td>–°–ª–µ–¥–æ–≤–∞—Ç—å –∑–∞ –æ–±—ä–µ–∫—Ç–æ–º</td></tr>
                    <tr><td>O</td><td>–û—Ä–±–∏—Ç–∞–ª—å–Ω–∞—è –∫–∞–º–µ—Ä–∞</td></tr>
                    <tr><td>P</td><td>–°–≤–æ–±–æ–¥–Ω–∞—è –∫–∞–º–µ—Ä–∞</td></tr>
                    <tr><td>R</td><td>–°–±—Ä–æ—Å –∫–∞–º–µ—Ä—ã</td></tr>
                    <tr><td>1-9</td><td>–ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤</td></tr>
                    <tr><td>Delete</td><td>–£–¥–∞–ª–∏—Ç—å –±–ª–∏–∂–∞–π—à–∏–π –æ–±—ä–µ–∫—Ç</td></tr>
                </table>
            `;
            document.getElementById('ui-overlay').appendChild(helpPanel);
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –≥–ª–æ–±–∞–ª—å–Ω–æ
            window.helpPanel = helpPanel;

            // –í—ã–±–æ—Ä –∫–æ—Å–º–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–π –º–æ–¥–µ–ª–∏
            document.querySelectorAll('#cosmology-panel .model-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('#cosmology-panel .model-option').forEach(o => o.classList.remove('active'));
                    this.classList.add('active');
                    cosmologyModel = this.dataset.model;
                    initializeUniverse();
                    updateInfo(`–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞ –º–æ–¥–µ–ª—å: ${this.querySelector('strong').textContent}`);
                });
            });

            // –í—ã–±–æ—Ä —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–æ–π –ø–∞—Ä–∞–¥–∏–≥–º—ã
            document.querySelectorAll('#philosophy-panel .model-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('#philosophy-panel .model-option').forEach(o => o.classList.remove('active'));
                    this.classList.add('active');
                    philosophyModel = this.dataset.philosophy;
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —Å—Ç–∏–ª—å
                    document.body.className = `philosophy-${philosophyModel}`;
                    updateFog();
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª—ã —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
                    objects.forEach(obj => {
                        if (obj.mesh && obj.type === 'star') {
                            const oldMaterial = obj.mesh.material;
                            obj.mesh.material = AdvancedMaterials.createStarMaterial(philosophyModel);
                            if (oldMaterial.dispose) oldMaterial.dispose();
                        } else if (obj.mesh && obj.type === 'planet') {
                            const oldMaterial = obj.mesh.material;
                            obj.mesh.material = AdvancedMaterials.createPlanetMaterial(philosophyModel);
                            if (oldMaterial.dispose) oldMaterial.dispose();
                        }
                    });
                    
                    updateInfo(`–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞ –ø–∞—Ä–∞–¥–∏–≥–º–∞: ${this.querySelector('strong').textContent}`);
                });
            });

            // –í—ã–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
            document.querySelectorAll('.tool-button').forEach(button => {
                button.addEventListener('click', function() {
                    document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    selectedTool = this.dataset.tool;
                    updateInfo(`–í—ã–±—Ä–∞–Ω –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: ${this.textContent}`);
                });
            });

            // –°–ª–∞–π–¥–µ—Ä—ã –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
            document.getElementById('time-speed').addEventListener('input', function() {
                timeSpeed = parseFloat(this.value);
                document.getElementById('time-speed-value').textContent = timeSpeed.toFixed(1);
            });

            document.getElementById('gravity-constant').addEventListener('input', function() {
                gravityConstant = parseFloat(this.value);
                document.getElementById('gravity-value').textContent = gravityConstant.toFixed(1);
            });

            document.getElementById('quantum-uncertainty').addEventListener('input', function() {
                quantumUncertainty = parseFloat(this.value);
                document.getElementById('quantum-value').textContent = quantumUncertainty.toFixed(2);
            });

            document.getElementById('entropy-level').addEventListener('input', function() {
                entropyLevel = parseFloat(this.value);
                document.getElementById('entropy-value').textContent = entropyLevel.toFixed(2);
            });

            document.getElementById('dark-energy').addEventListener('input', function() {
                darkEnergy = parseFloat(this.value);
                document.getElementById('dark-energy-value').textContent = darkEnergy.toFixed(2);
            });

            document.getElementById('inflation-field').addEventListener('input', function() {
                inflationField = parseFloat(this.value);
                document.getElementById('inflation-field-value').textContent = inflationField.toFixed(2);
            });

            document.getElementById('emergence-level').addEventListener('input', function() {
                emergenceLevel = parseFloat(this.value);
                document.getElementById('emergence-value').textContent = emergenceLevel.toFixed(2);
            });

            document.getElementById('information-complexity').addEventListener('input', function() {
                informationComplexity = parseFloat(this.value);
                document.getElementById('information-value').textContent = informationComplexity.toFixed(2);
            });

            // –ö–ª–∏–∫–∏ –ø–æ –∫–∞–Ω–≤–∞—Å—É
            renderer.domElement.addEventListener('click', handleCanvasClick);

            // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
            window.addEventListener('resize', onWindowResize);
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–æ–≤ –ø–æ –∫–∞–Ω–≤–∞—Å—É
        function handleCanvasClick(event) {
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // –°–æ–∑–¥–∞–µ–º –ø–ª–æ—Å–∫–æ—Å—Ç—å –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –∫–ª–∏–∫–∞ –≤ 3D –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersection);

            switch (selectedTool) {
                case 'create-star':
                    createStar(intersection);
                    updateInfo('–°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –∑–≤–µ–∑–¥–∞');
                    break;
                case 'create-planet':
                    createPlanet(intersection);
                    updateInfo('–°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –ø–ª–∞–Ω–µ—Ç–∞');
                    break;
                case 'create-blackhole':
                    createBlackHole(intersection);
                    updateInfo('–°–æ–∑–¥–∞–Ω–∞ —á–µ—Ä–Ω–∞—è –¥—ã—Ä–∞');
                    break;
                case 'create-galaxy':
                    createGalaxy(intersection);
                    updateInfo('–°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –≥–∞–ª–∞–∫—Ç–∏–∫–∞');
                    break;
                case 'create-neutronstar':
                    createNeutronStar(intersection);
                    updateInfo('–°–æ–∑–¥–∞–Ω–∞ –Ω–µ–π—Ç—Ä–æ–Ω–Ω–∞—è –∑–≤–µ–∑–¥–∞');
                    break;
                case 'create-quasar':
                    createQuasar(intersection);
                    updateInfo('–°–æ–∑–¥–∞–Ω –∫–≤–∞–∑–∞—Ä - —Å–∞–º—ã–π —è—Ä–∫–∏–π –æ–±—ä–µ–∫—Ç –≤–æ –≤—Å–µ–ª–µ–Ω–Ω–æ–π!');
                    break;
                case 'create-darkmatter':
                    createDarkMatter(intersection);
                    updateInfo('–°–æ–∑–¥–∞–Ω–æ –æ–±–ª–∞–∫–æ —Ç–µ–º–Ω–æ–π –º–∞—Ç–µ—Ä–∏–∏');
                    break;
                case 'create-wormhole':
                    if (!window.wormholeStart) {
                        window.wormholeStart = intersection.clone();
                        updateInfo('–í—ã–±–µ—Ä–∏—Ç–µ –≤—Ç–æ—Ä–æ–π –∫–æ–Ω–µ—Ü —á–µ—Ä–≤–æ—Ç–æ—á–∏–Ω—ã');
                    } else {
                        createWormhole(window.wormholeStart, intersection);
                        window.wormholeStart = null;
                    }
                    break;
                case 'manipulate':
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å –æ–±—ä–µ–∫—Ç–∞–º–∏
                    const intersects = raycaster.intersectObjects(scene.children, true);
                    if (intersects.length > 0) {
                        const obj = objects.find(o => o.mesh === intersects[0].object || o.mesh === intersects[0].object.parent);
                        if (obj) {
                            // –û—Ç–∫—Ä—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å —Å–≤–æ–π—Å—Ç–≤ –æ–±—ä–µ–∫—Ç–∞
                            showObjectProperties(obj);
                        }
                    }
                    break;
                case 'observe':
                    // –†–µ–∂–∏–º –Ω–∞–±–ª—é–¥–µ–Ω–∏—è - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–±—ä–µ–∫—Ç–µ
                    const observeIntersects = raycaster.intersectObjects(scene.children, true);
                    if (observeIntersects.length > 0) {
                        const obj = objects.find(o => o.mesh === observeIntersects[0].object || o.mesh === observeIntersects[0].object.parent);
                        if (obj) {
                            showObjectInfo(obj);
                        }
                    }
                    break;
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –ø–∞–Ω–µ–ª–∏
        function updateInfo(message) {
            const infoContent = document.getElementById('info-content');
            infoContent.innerHTML = `<p>${message}</p>` + infoContent.innerHTML;
            if (infoContent.children.length > 5) {
                infoContent.removeChild(infoContent.lastChild);
            }
        }

        // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // –ê–Ω–∏–º–∞—Ü–∏—è
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            universeTime += deltaTime * timeSpeed;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º octree
            octree.clear();
            for (let obj of objects) {
                octree.insert(obj);
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º octree –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
            for (let obj of objects) {
                // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ª—å–∫–æ –±–ª–∏–∑–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–π
                const nearbyObjects = octree.retrieve(obj);
                obj.update(deltaTime, nearbyObjects);
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º LOD
            lodSystem.update(camera, objects);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–º–µ—Ä—É
            if (window.cameraController) {
                window.cameraController.update(deltaTime);
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–∏—Å—Ç–µ–º—É –ø–ª–∞–≥–∏–Ω–æ–≤
            pluginSystem.update(deltaTime);
            
            // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –¥–ª—è –∫–æ—Å–º–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –º–æ–¥–µ–ª–µ–π
            updateCosmologicalEffects(deltaTime);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
            if (visualEffects) {
                visualEffects.update(deltaTime);
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∞–Ω–∏–º–∞—Ü–∏–∏ –æ–±—ä–µ–∫—Ç–æ–≤
            updateObjectAnimations(deltaTime);
            
            // Frustum culling
            //if (frustumCulling) {
            //    frustumCulling();
            //}
            // Frustum culling —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤ LODSystem
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            updateStats();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–æ–Ω–∏—Ç–æ—Ä –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            performanceMonitor.update();
            
            // –ê–≤—Ç–æ-–Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞
            if (renderOptimizer && performanceMonitor.stats.fps > 0) {
                renderOptimizer.autoAdjustQuality(performanceMonitor.stats.fps);
            }
            
            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
            renderer.render(scene, camera);
            
            // –í—ã–ø–æ–ª–Ω—è–µ–º —Ö—É–∫–∏ –ø–æ—Å–ª–µ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
            pluginSystem.executeHooks('render');
        }

        // –í—ã–Ω–µ—Å–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ª—É—á—à–µ–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
        function updateCosmologicalEffects(deltaTime) {
            if (cosmologyModel === 'bigbang' && universeTime < 10) {
                // –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ –≤—Å–µ–ª–µ–Ω–Ω–æ–π
                for (let obj of objects) {
                    obj.position.multiplyScalar(1 + deltaTime * 0.1);
                }
            } else if (cosmologyModel === 'steady' && Math.random() < 0.001) {
                // –°–ø–æ–Ω—Ç–∞–Ω–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –º–∞—Ç–µ—Ä–∏–∏
                const position = new THREE.Vector3(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200
                );
                createPlanet(position);
            } else if (cosmologyModel === 'cyclic') {
                // –¶–∏–∫–ª–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∏ —Å–∂–∞—Ç–∏–µ
                const scale = 1 + 0.3 * Math.sin(universeTime * 0.1);
                for (let obj of objects) {
                    obj.position.multiplyScalar(scale / (scale - 0.001));
                }
            }
            // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
        }

        function updateObjectAnimations(deltaTime) {
            scene.traverse((child) => {
                if (child.material && child.material.uniforms && child.material.uniforms.time) {
                    child.material.uniforms.time.value = universeTime;
                }
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –∫–æ—Ä–æ–Ω –∑–≤–µ–∑–¥
                if (child.userData.corona) {
                    child.userData.corona.rotation.y += deltaTime * 0.5;
                    child.userData.corona.rotation.z += deltaTime * 0.3;
                }
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –∞—Ç–º–æ—Å—Ñ–µ—Ä –ø–ª–∞–Ω–µ—Ç
                if (child.userData.atmosphere && child.userData.atmosphere.material.uniforms) {
                    child.userData.atmosphere.material.uniforms.time.value = universeTime;
                }
                
                // –í—Ä–∞—â–µ–Ω–∏–µ –∞–∫–∫—Ä–µ—Ü–∏–æ–Ω–Ω—ã—Ö –¥–∏—Å–∫–æ–≤
                if (child.userData.disk) {
                    child.userData.disk.rotation.z += deltaTime * 0.5;
                    if (child.userData.disk.material.uniforms && child.userData.disk.material.uniforms.time) {
                        child.userData.disk.material.uniforms.time.value = universeTime;
                    }
                }
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –∞–Ω–∏–º–∞—Ü–∏–π
                if (child.userData.update) {
                    child.userData.update(universeTime);
                }
            });
        }

        function updateStats() {
            stats.frameCount++;
            const currentTime = performance.now();
            if (currentTime >= stats.lastTime + 1000) {
                stats.fps = Math.round((stats.frameCount * 1000) / (currentTime - stats.lastTime));
                stats.lastTime = currentTime;
                stats.frameCount = 0;
                
                document.getElementById('fps').textContent = stats.fps;
                document.getElementById('object-count').textContent = objects.length;
                document.getElementById('universe-time').textContent = (universeTime / 10).toFixed(2);
            }
        }

        // –°–∏—Å—Ç–µ–º–∞ –≥–æ—Ä—è—á–∏—Ö –∫–ª–∞–≤–∏—à
        document.addEventListener('keydown', (event) => {
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –¥–µ–π—Å—Ç–≤–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –∫–ª–∞–≤–∏—à
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'F1'].includes(event.code)) {
                event.preventDefault();
            }
            
            switch(event.code) {
                case 'Space':
                    // –ü–∞—É–∑–∞
                    timeSpeed = timeSpeed > 0 ? 0 : 1;
                    document.getElementById('time-speed').value = timeSpeed;
                    document.getElementById('time-speed-value').textContent = timeSpeed.toFixed(1);
                    updateInfo(timeSpeed > 0 ? '–í—Ä–µ–º—è –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–æ' : '–ü–∞—É–∑–∞');
                    break;
                    
                case 'KeyH':
                    // –ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å UI
                    const uiOverlay = document.getElementById('ui-overlay');
                    uiOverlay.style.display = uiOverlay.style.display === 'none' ? 'block' : 'none';
                    break;

                case 'F1':
                    event.preventDefault();
                    if (window.helpPanel) {
                        window.helpPanel.style.display = window.helpPanel.style.display === 'none' ? 'block' : 'none';
                    }
                    break;
                    
                case 'KeyM':
                    // –ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –º–æ–Ω–∏—Ç–æ—Ä –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
                    const perfMon = document.getElementById('performance-monitor');
                    perfMon.style.display = perfMon.style.display === 'none' ? 'block' : 'none';
                    break;
                    
                case 'KeyG':
                    // –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Å–µ—Ç–∫—É
                    if (!window.gridHelper) {
                        window.gridHelper = new THREE.GridHelper(1000, 50, 0x444444, 0x222222);
                        scene.add(window.gridHelper);
                    } else {
                        window.gridHelper.visible = !window.gridHelper.visible;
                    }
                    break;
                    
                case 'Digit1':
                case 'Digit2':
                case 'Digit3':
                case 'Digit4':
                case 'Digit5':
                case 'Digit6':
                case 'Digit7':
                case 'Digit8':
                case 'Digit9':
                    // –ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
                    const toolIndex = parseInt(event.code.replace('Digit', '')) - 1;
                    const toolButtons = document.querySelectorAll('#tools-panel .tool-button');
                    if (toolButtons[toolIndex]) {
                        toolButtons[toolIndex].click();
                    }
                    break;
                    
                case 'Delete':
                    // –£–¥–∞–ª–∏—Ç—å –±–ª–∏–∂–∞–π—à–∏–π –æ–±—ä–µ–∫—Ç –∫ –∫–∞–º–µ—Ä–µ
                    let nearestObj = null;
                    let nearestDist = Infinity;
                    for (let obj of objects) {
                        const dist = camera.position.distanceTo(obj.position);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestObj = obj;
                        }
                    }
                    if (nearestObj) {
                        nearestObj.destroy();
                        updateInfo(`–£–¥–∞–ª–µ–Ω –æ–±—ä–µ–∫—Ç: ${nearestObj.type}`);
                    }
                    break;
            }
        });

        // –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫–∏ –ø–æ –≥–æ—Ä—è—á–∏–º –∫–ª–∞–≤–∏—à–∞–º
        const helpPanel = document.createElement('div');
        helpPanel.className = 'control-panel';
        helpPanel.style.cssText = `
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            max-width: 400px;
        `;
        helpPanel.innerHTML = `
            <h3>–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏</h3>
            <table style="font-size: 12px;">
                <tr><td>–ü—Ä–æ–±–µ–ª</td><td>–ü–∞—É–∑–∞</td></tr>
                <tr><td>H</td><td>–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å</td></tr>
                <tr><td>M</td><td>–ú–æ–Ω–∏—Ç–æ—Ä –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏</td></tr>
                <tr><td>G</td><td>–°–µ—Ç–∫–∞</td></tr>
                <tr><td>F</td><td>–°–ª–µ–¥–æ–≤–∞—Ç—å –∑–∞ –æ–±—ä–µ–∫—Ç–æ–º</td></tr>
                <tr><td>O</td><td>–û—Ä–±–∏—Ç–∞–ª—å–Ω–∞—è –∫–∞–º–µ—Ä–∞</td></tr>
                <tr><td>P</td><td>–°–≤–æ–±–æ–¥–Ω–∞—è –∫–∞–º–µ—Ä–∞</td></tr>
                <tr><td>R</td><td>–°–±—Ä–æ—Å –∫–∞–º–µ—Ä—ã</td></tr>
                <tr><td>1-9</td><td>–ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤</td></tr>
                <tr><td>Delete</td><td>–£–¥–∞–ª–∏—Ç—å –±–ª–∏–∂–∞–π—à–∏–π –æ–±—ä–µ–∫—Ç</td></tr>
            </table>
        `;
        document.getElementById('ui-overlay').appendChild(helpPanel);

        // –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫–∏ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ F1
        //document.addEventListener('keydown', (event) => {
        //    if (event.code === 'F1') {
        //        event.preventDefault();
        //        helpPanel.style.display = helpPanel.style.display === 'none' ? 'block' : 'none';
        //    }
        // });

        // –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π —ç–∫—Ä–∞–Ω
        function createWelcomeScreen() {
            const welcomeDiv = document.createElement('div');
            welcomeDiv.id = 'welcome-screen';
            welcomeDiv.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 20, 0.95);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                backdrop-filter: blur(10px);
            `;
            
            welcomeDiv.innerHTML = `
                <div style="text-align: center; max-width: 600px; padding: 40px;">
                    <h1 style="color: #8080ff; font-size: 3em; margin-bottom: 20px; text-shadow: 0 0 20px rgba(128, 128, 255, 0.5);">
                        –ê—Ä—Ö–∏—Ç–µ–∫—Ç–æ—Ä –í—Å–µ–ª–µ–Ω–Ω–æ–π
                    </h1>
                    <p style="color: #a0a0ff; font-size: 1.2em; margin-bottom: 30px; line-height: 1.6;">
                        –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Å–∏–º—É–ª—è—Ç–æ—Ä –≤—Å–µ–ª–µ–Ω–Ω–æ–π!<br>
                        –°–æ–∑–¥–∞–≤–∞–π—Ç–µ –∑–≤–µ–∑–¥—ã, –ø–ª–∞–Ω–µ—Ç—ã –∏ –≥–∞–ª–∞–∫—Ç–∏–∫–∏.<br>
                        –ò—Å—Å–ª–µ–¥—É–π—Ç–µ —Ä–∞–∑–ª–∏—á–Ω—ã–µ –∫–æ—Å–º–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –º–æ–¥–µ–ª–∏ –∏ —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–∏–µ –ø–∞—Ä–∞–¥–∏–≥–º—ã.<br>
                        –ù–∞–±–ª—é–¥–∞–π—Ç–µ –∑–∞ —ç–≤–æ–ª—é—Ü–∏–µ–π –∫–æ—Å–º–æ—Å–∞ –∏ –∑–∞—Ä–æ–∂–¥–µ–Ω–∏–µ–º –∂–∏–∑–Ω–∏.
                    </p>
                    <button onclick="document.getElementById('welcome-screen').style.display='none'" 
                            style="background: rgba(80, 80, 160, 0.8); color: white; border: 1px solid rgba(150, 150, 255, 0.5); 
                                   padding: 15px 30px; font-size: 1.1em; cursor: pointer; border-radius: 25px;
                                   transition: all 0.3s; box-shadow: 0 0 20px rgba(100, 100, 255, 0.3);"
                            onmouseover="this.style.background='rgba(100, 100, 200, 0.9)'"
                            onmouseout="this.style.background='rgba(80, 80, 160, 0.8)'">
                        –ù–∞—á–∞—Ç—å –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ
                    </button>
                    <p style="color: #606090; font-size: 0.9em; margin-top: 30px;">
                        –ù–∞–∂–º–∏—Ç–µ F1 –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≥–æ—Ä—è—á–∏—Ö –∫–ª–∞–≤–∏—à
                    </p>
                </div>
            `;
            
            document.body.appendChild(welcomeDiv);
        }

        // –í—ã–∑—ã–≤–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.addEventListener('load', () => {
            createWelcomeScreen();
        });

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.addEventListener('load', () => {
            const autoSave = localStorage.getItem('universe_autosave');
            if (autoSave) {
                const loadAutoSave = confirm('–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ. –ó–∞–≥—Ä—É–∑–∏—Ç—å?');
                if (loadAutoSave) {
                    setTimeout(() => {
                        UniverseSerializer.load(autoSave);
                    }, 1000);
                }
            }
        });

        // –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        window.addEventListener('load', init);
    </script>
</body>
</html>