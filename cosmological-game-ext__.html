<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Архитектор Вселенной - Физико-космологическая игра</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: relative;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .control-panel {
            position: absolute;
            background: rgba(10, 10, 30, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            pointer-events: all;
            box-shadow: 0 0 30px rgba(50, 50, 255, 0.3);
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .control-panel::-webkit-scrollbar {
            width: 8px;
        }

        .control-panel::-webkit-scrollbar-track {
            background: rgba(20, 20, 50, 0.5);
            border-radius: 4px;
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(100, 100, 255, 0.5);
            border-radius: 4px;
        }

        .control-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(120, 120, 255, 0.7);
        }

        #cosmology-panel {
            top: 20px;
            left: 20px;
            width: 300px;
        }

        #philosophy-panel {
            top: 20px;
            right: 20px;
            width: 300px;
        }

        #tools-panel {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            padding: 15px 30px;
            flex-wrap: wrap;
            max-width: 90%;
            justify-content: center;
        }

        #info-panel {
            bottom: 20px;
            left: 20px;
            max-width: 400px;
            opacity: 0.8;
        }

        h2 {
            color: #8080ff;
            margin-bottom: 15px;
            font-size: 1.2em;
            text-shadow: 0 0 10px rgba(128, 128, 255, 0.5);
        }

        .model-option {
            background: rgba(40, 40, 80, 0.6);
            border: 1px solid rgba(100, 100, 255, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .model-option:hover {
            background: rgba(60, 60, 120, 0.8);
            border-color: rgba(150, 150, 255, 0.6);
            transform: translateX(5px);
        }

        .model-option.active {
            background: rgba(80, 80, 160, 0.8);
            border-color: rgba(200, 200, 255, 0.8);
            box-shadow: 0 0 15px rgba(100, 100, 255, 0.5);
        }

        .tool-button {
            background: rgba(50, 50, 100, 0.8);
            border: 1px solid rgba(150, 150, 255, 0.5);
            color: #fff;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            text-shadow: 0 0 5px rgba(100, 100, 255, 0.5);
        }

        .tool-button:hover {
            background: rgba(80, 80, 150, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 100, 255, 0.4);
        }

        .tool-button.active {
            background: rgba(100, 100, 200, 0.9);
            box-shadow: 0 0 20px rgba(150, 150, 255, 0.6);
        }

        .parameter-slider {
            margin: 10px 0;
        }

        .parameter-slider label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #a0a0ff;
        }

        .parameter-slider input[type="range"] {
            width: 100%;
            height: 5px;
            background: rgba(50, 50, 100, 0.5);
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }

        .parameter-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #8080ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(128, 128, 255, 0.5);
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-text {
            font-size: 2em;
            color: #8080ff;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }

        .stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }

        /* Эффекты для разных философских парадигм */
        .philosophy-materialism {
            --primary-color: #4080ff;
            --secondary-color: #80a0ff;
            --glow-color: rgba(64, 128, 255, 0.5);
        }

        .philosophy-idealism {
            --primary-color: #ff80ff;
            --secondary-color: #ffb0ff;
            --glow-color: rgba(255, 128, 255, 0.5);
        }

        .philosophy-panpsychism {
            --primary-color: #80ff80;
            --secondary-color: #b0ffb0;
            --glow-color: rgba(128, 255, 128, 0.5);
        }

        .philosophy-holographic {
            --primary-color: #00ffff;
            --secondary-color: #80ffff;
            --glow-color: rgba(0, 255, 255, 0.5);
        }

        .philosophy-emergentism {
            --primary-color: #ffff00;
            --secondary-color: #ffffb0;
            --glow-color: rgba(255, 255, 0, 0.5);
        }

        .philosophy-dualism {
            --primary-color: #ff00ff;
            --secondary-color: #ff80ff;
            --glow-color: rgba(255, 0, 255, 0.5);
        }

        .philosophy-process {
            --primary-color: #ff8000;
            --secondary-color: #ffb080;
            --glow-color: rgba(255, 128, 0, 0.5);
        }

        .philosophy-information {
            --primary-color: #00ff00;
            --secondary-color: #80ff80;
            --glow-color: rgba(0, 255, 0, 0.5);
        }

        /* Анимированные эффекты */
        @keyframes quantumFlicker {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        @keyframes waveDistortion {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }

        @keyframes glitch {
            0%, 100% { 
                text-shadow: 
                    0.05em 0 0 rgba(255, 0, 0, 0.75),
                    -0.025em -0.05em 0 rgba(0, 255, 0, 0.75),
                    0.025em 0.05em 0 rgba(0, 0, 255, 0.75);
            }
            14% {
                text-shadow: 
                    0.05em 0 0 rgba(255, 0, 0, 0.75),
                    -0.05em -0.025em 0 rgba(0, 255, 0, 0.75),
                    0.025em 0.05em 0 rgba(0, 0, 255, 0.75);
            }
            15% {
                text-shadow: 
                    -0.05em -0.025em 0 rgba(255, 0, 0, 0.75),
                    0.025em 0.025em 0 rgba(0, 255, 0, 0.75),
                    -0.05em -0.05em 0 rgba(0, 0, 255, 0.75);
            }
            49% {
                text-shadow: 
                    -0.05em -0.025em 0 rgba(255, 0, 0, 0.75),
                    0.025em 0.025em 0 rgba(0, 255, 0, 0.75),
                    -0.05em -0.05em 0 rgba(0, 0, 255, 0.75);
            }
            50% {
                text-shadow: 
                    0.025em 0.05em 0 rgba(255, 0, 0, 0.75),
                    0.05em 0 0 rgba(0, 255, 0, 0.75),
                    0 -0.05em 0 rgba(0, 0, 255, 0.75);
            }
            99% {
                text-shadow: 
                    0.025em 0.05em 0 rgba(255, 0, 0, 0.75),
                    0.05em 0 0 rgba(0, 255, 0, 0.75),
                    0 -0.05em 0 rgba(0, 0, 255, 0.75);
            }
        }

        /* Volumetric эффекты */
        .volumetric-fog {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                transparent 0%, 
                rgba(100, 100, 255, 0.1) 50%, 
                rgba(50, 50, 200, 0.2) 100%);
            pointer-events: none;
            mix-blend-mode: screen;
        }

        @media (max-height: 768px) {
            .control-panel {
                max-height: 70vh;
            }
            
            #cosmology-panel,
            #philosophy-panel {
                width: 250px;
                font-size: 0.9em;
            }
            
            .model-option {
                padding: 8px;
                margin-bottom: 6px;
            }
            
            .parameter-slider {
                margin: 6px 0;
            }
        }

    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="loading-text">Создание Вселенной...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <div id="cosmology-panel" class="control-panel">
            <h2>Космологическая модель</h2>
            <div class="model-option active" data-model="bigbang">
                <strong>Большой взрыв</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Расширяющаяся вселенная из сингулярности</p>
            </div>
            <div class="model-option" data-model="steady">
                <strong>Стационарная вселенная</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Непрерывное создание материи</p>
            </div>
            <div class="model-option" data-model="cyclic">
                <strong>Циклическая модель</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Бесконечные циклы расширения и сжатия</p>
            </div>
            <div class="model-option" data-model="multiverse">
                <strong>Мультивселенная</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Множество параллельных вселенных</p>
            </div>

            <div class="model-option" data-model="inflation">
                <strong>Инфляционная модель</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Экспоненциальное расширение после Большого взрыва</p>
            </div>
            <div class="model-option" data-model="darkenergy">
                <strong>Модель с темной энергией</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Ускоряющееся расширение вселенной</p>
            </div>
            <div class="model-option" data-model="branes">
                <strong>Браны и высшие измерения</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Взаимодействие параллельных вселенных</p>
            </div>
            <div class="model-option" data-model="quantum">
                <strong>Квантовая космология</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Вселенная из квантовых флуктуаций</p>
            </div>
            
            <div class="parameter-slider">
                <label>Скорость времени: <span id="time-speed-value">1.0</span>x</label>
                <input type="range" id="time-speed" min="0" max="10" step="0.1" value="1">
            </div>
            
            <div class="parameter-slider">
                <label>Гравитационная постоянная: <span id="gravity-value">1.0</span></label>
                <input type="range" id="gravity-constant" min="0" max="2" step="0.1" value="1">
            </div>
        </div>

        <div id="philosophy-panel" class="control-panel">
            <h2>Философская парадигма</h2>
            <div class="model-option active" data-philosophy="materialism">
                <strong>Материализм</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Только материя и физические законы</p>
            </div>
            <div class="model-option" data-philosophy="idealism">
                <strong>Идеализм</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Сознание первично, материя вторична</p>
            </div>
            <div class="model-option" data-philosophy="panpsychism">
                <strong>Панпсихизм</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Сознание - фундаментальное свойство</p>
            </div>
            <div class="model-option" data-philosophy="holographic">
                <strong>Голографический принцип</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Реальность как проекция информации</p>
            </div>

            <div class="model-option" data-philosophy="emergentism">
                <strong>Эмерджентизм</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Сложность возникает из простых правил</p>
            </div>
            <div class="model-option" data-philosophy="dualism">
                <strong>Дуализм</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Разделение материи и сознания</p>
            </div>
            <div class="model-option" data-philosophy="process">
                <strong>Процессуальная философия</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Всё есть процесс, не субстанция</p>
            </div>
            <div class="model-option" data-philosophy="information">
                <strong>Информационная онтология</strong>
                <p style="font-size: 0.85em; margin-top: 5px;">Вселенная как вычисление</p>
            </div>
            
            <div class="parameter-slider">
                <label>Квантовая неопределенность: <span id="quantum-value">0.5</span></label>
                <input type="range" id="quantum-uncertainty" min="0" max="1" step="0.05" value="0.5">
            </div>
            
            <div class="parameter-slider">
                <label>Энтропия: <span id="entropy-value">0.3</span></label>
                <input type="range" id="entropy-level" min="0" max="1" step="0.05" value="0.3">
            </div>

            <div class="parameter-slider">
                <label>Темная энергия: <span id="dark-energy-value">0.7</span></label>
                <input type="range" id="dark-energy" min="0" max="1" step="0.05" value="0.7">
            </div>

            <div class="parameter-slider">
                <label>Инфляционное поле: <span id="inflation-field-value">0.0</span></label>
                <input type="range" id="inflation-field" min="0" max="1" step="0.05" value="0">
            </div>

            <div class="parameter-slider">
                <label>Эмерджентность: <span id="emergence-value">0.5</span></label>
                <input type="range" id="emergence-level" min="0" max="1" step="0.05" value="0.5">
            </div>

            <div class="parameter-slider">
                <label>Информационная сложность: <span id="information-value">0.5</span></label>
                <input type="range" id="information-complexity" min="0" max="1" step="0.05" value="0.5">
            </div>

        </div>

        <div id="tools-panel" class="control-panel">
            <button class="tool-button active" data-tool="observe">Наблюдать</button>
            <button class="tool-button" data-tool="create-star">Создать звезду</button>
            <button class="tool-button" data-tool="create-planet">Создать планету</button>
            <button class="tool-button" data-tool="create-blackhole">Создать чёрную дыру</button>
            <button class="tool-button" data-tool="create-galaxy">Создать галактику</button>
            <button class="tool-button" data-tool="manipulate">Манипулировать</button>
            <button class="tool-button" data-tool="create-neutronstar">Нейтронная звезда</button>
            <button class="tool-button" data-tool="create-quasar">Квазар</button>
            <button class="tool-button" data-tool="create-darkmatter">Темная материя</button>
            <button class="tool-button" data-tool="create-wormhole">Червоточина</button>
            <button class="tool-button" onclick="UniverseSerializer.download()">💾 Сохранить</button>
            <button class="tool-button" onclick="UniverseSerializer.upload()">📁 Загрузить</button>
        </div>

        <div id="game-modes-panel" class="control-panel" style="top: 10%; left: 20px; max-height: 80vh; overflow-y: auto;">
            <h2>Режим игры</h2>
            <button class="tool-button active" onclick="setGameMode('sandbox')">Песочница</button>
            <button class="tool-button" onclick="setGameMode('scenarios')">Сценарии</button>
            <button class="tool-button" onclick="setGameMode('challenges')">Вызовы</button>
            <button class="tool-button" onclick="setGameMode('research')">Исследование</button>
            
            <div id="mode-content" style="margin-top: 20px;">
                <!-- Контент режима -->
            </div>
        </div>

        <div id="info-panel" class="control-panel">
            <h2>Информация</h2>
            <div id="info-content">
                <p>Добро пожаловать в симулятор Вселенной!</p>
                <p>Выберите космологическую модель и философскую парадигму, затем экспериментируйте с созданием и манипулированием космическими объектами.</p>
            </div>
        </div>

        <div class="stats" id="stats">
            FPS: <span id="fps">0</span><br>
            Объектов: <span id="object-count">0</span><br>
            Время: <span id="universe-time">0</span> млрд лет
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Глобальные переменные
        let scene, camera, renderer;
        let objects = [];
        let selectedTool = 'observe';
        let cosmologyModel = 'bigbang';
        let philosophyModel = 'materialism';
        let universeTime = 0;
        let timeSpeed = 1;
        let gravityConstant = 1;
        let quantumUncertainty = 0.5;
        let entropyLevel = 0.3;

        let darkEnergy = 0.7;
        let inflationField = 0;
        let emergenceLevel = 0.5;
        let informationComplexity = 0.5;
        let quantumFluctuations = [];
        let braneInteractions = [];
        let inflationEpoch = false;
        let universePhase = 'expansion'; // 'inflation', 'expansion', 'contraction', 'steady'

        let clock = new THREE.Clock();
        let stats = { fps: 0, frameCount: 0, lastTime: 0 };

        let renderOptimizer = null;
        let frustumCulling = null;

        // Палитры для разных философских парадигм
        const philosophyPalettes = {
            materialism: {
                colors: [0x4080ff, 0x80a0ff, 0x6090ff, 0x40a0ff, 0x8080ff],
                emissive: 0x202040,
                fog: 0x000033
            },
            idealism: {
                colors: [0xff80ff, 0xffb0ff, 0xff90ff, 0xffa0ff, 0xff80ff],
                emissive: 0x402040,
                fog: 0x330033
            },
            panpsychism: {
                colors: [0x80ff80, 0xb0ffb0, 0x90ff90, 0xa0ffa0, 0x80ff80],
                emissive: 0x204020,
                fog: 0x003300
            },
            holographic: {
                colors: [0x00ffff, 0x80ffff, 0x00ffff, 0x40ffff, 0x00ffff],
                emissive: 0x004040,
                fog: 0x003333
            },
            emergentism: {
                colors: [0xffff00, 0xffffb0, 0xffff80, 0xffffa0, 0xffff00],
                emissive: 0x404020,
                fog: 0x333300
            },
            dualism: {
                colors: [0xff00ff, 0xff80ff, 0xff00ff, 0xff40ff, 0xff00ff],
                emissive: 0x400040,
                fog: 0x330033
            },
            process: {
                colors: [0xff8000, 0xffb080, 0xff9040, 0xffa060, 0xff8000],
                emissive: 0x402000,
                fog: 0x331100
            },
            information: {
                colors: [0x00ff00, 0x80ff80, 0x40ff40, 0x60ff60, 0x00ff00],
                emissive: 0x004000,
                fog: 0x003300
            }
        };

        // Система игровых режимов
        let currentGameMode = 'sandbox';
        let currentScenario = null;
        let currentChallenge = null;

        const scenarios = {
            solarSystem: {
                name: 'Солнечная система',
                description: 'Воссоздайте нашу Солнечную систему',
                setup: () => {
                    objects = [];
                    scene.children = scene.children.filter(child => 
                        child.type === 'AmbientLight' || 
                        child.type === 'PointLight' || 
                        child.type === 'Points'
                    );
                    
                    // Солнце
                    const sun = createStar(new THREE.Vector3(0, 0, 0));
                    
                    // Планеты
                    const planets = [
                        { name: 'Меркурий', distance: 10, size: 0.4 },
                        { name: 'Венера', distance: 15, size: 0.9 },
                        { name: 'Земля', distance: 20, size: 1 },
                        { name: 'Марс', distance: 25, size: 0.5 },
                        { name: 'Юпитер', distance: 40, size: 3 },
                        { name: 'Сатурн', distance: 55, size: 2.5 },
                        { name: 'Уран', distance: 70, size: 1.5 },
                        { name: 'Нептун', distance: 85, size: 1.4 }
                    ];
                    
                    planets.forEach(p => {
                        const angle = Math.random() * Math.PI * 2;
                        const position = new THREE.Vector3(
                            Math.cos(angle) * p.distance,
                            0,
                            Math.sin(angle) * p.distance
                        );
                        const velocity = new THREE.Vector3(
                            -Math.sin(angle) * Math.sqrt(10 / p.distance),
                            0,
                            Math.cos(angle) * Math.sqrt(10 / p.distance)
                        );
                        createPlanet(position, velocity);
                    });
                }
            },
            
            binaryStars: {
                name: 'Двойная звездная система',
                description: 'Создайте стабильную систему из двух звезд',
                setup: () => {
                    objects = [];
                    scene.children = scene.children.filter(child => 
                        child.type === 'AmbientLight' || 
                        child.type === 'PointLight' || 
                        child.type === 'Points'
                    );
                    
                    const star1 = createStar(new THREE.Vector3(-20, 0, 0));
                    const star2 = createStar(new THREE.Vector3(20, 0, 0));
                    
                    objects[objects.length - 2].velocity = new THREE.Vector3(0, 0, 5);
                    objects[objects.length - 1].velocity = new THREE.Vector3(0, 0, -5);
                }
            },
            
            galaxyCollision: {
                name: 'Столкновение галактик',
                description: 'Наблюдайте слияние двух галактик',
                setup: () => {
                    objects = [];
                    scene.children = scene.children.filter(child => 
                        child.type === 'AmbientLight' || 
                        child.type === 'PointLight' || 
                        child.type === 'Points'
                    );
                    
                    createGalaxy(new THREE.Vector3(-50, 0, 0));
                    createGalaxy(new THREE.Vector3(50, 0, 0));
                    
                    // Придаем галактикам скорость навстречу друг другу
                    objects[objects.length - 2].velocity = new THREE.Vector3(5, 0, 0);
                    objects[objects.length - 1].velocity = new THREE.Vector3(-5, 0, 0);
                }
            }
        };

        const challenges = {
            stableOrbit: {
                name: 'Стабильная орбита',
                description: 'Создайте планету со стабильной круговой орбитой вокруг звезды',
                checkCondition: () => {
                    // Проверяем наличие звезды и планеты
                    const stars = objects.filter(o => o.type === 'star');
                    const planets = objects.filter(o => o.type === 'planet');
                    
                    if (stars.length === 0 || planets.length === 0) return false;
                    
                    // Проверяем стабильность орбиты
                    const star = stars[0];
                    const planet = planets[0];
                    const distance = star.position.distanceTo(planet.position);
                    
                    // Сохраняем историю расстояний
                    if (!window.orbitHistory) window.orbitHistory = [];
                    window.orbitHistory.push(distance);
                    
                    if (window.orbitHistory.length > 100) {
                        window.orbitHistory.shift();
                        
                        // Проверяем, что орбита круговая (малая вариация расстояния)
                        const avgDistance = window.orbitHistory.reduce((a, b) => a + b) / window.orbitHistory.length;
                        const variance = window.orbitHistory.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / window.orbitHistory.length;
                        
                        if (variance < 1) {
                            updateInfo('Вызов выполнен! Создана стабильная орбита!');
                            return true;
                        }
                    }
                    
                    return false;
                }
            },
            
            createLife: {
                name: 'Зарождение жизни',
                description: 'Создайте условия для возникновения жизни на планете',
                checkCondition: () => {
                    const livingPlanets = objects.filter(o => o.type === 'planet' && o.hasLife);
                    if (livingPlanets.length > 0) {
                        updateInfo('Вызов выполнен! Жизнь зародилась!');
                        return true;
                    }
                    return false;
                }
            },
            
            supernovaEvent: {
                name: 'Сверхновая',
                description: 'Доведите звезду до взрыва сверхновой',
                checkCondition: () => {
                    // Этот вызов выполняется автоматически при взрыве сверхновой
                    return false;
                }
            }
        };

        function setGameMode(mode) {
            currentGameMode = mode;
            document.querySelectorAll('#game-modes-panel button').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            
            const modeContent = document.getElementById('mode-content');
            
            switch(mode) {
                case 'sandbox':
                    modeContent.innerHTML = '<p>Свободное творчество без ограничений</p>';
                    break;
                    
                case 'scenarios':
                    let scenariosHtml = '<h3>Выберите сценарий:</h3>';
                    for (let key in scenarios) {
                        scenariosHtml += `
                            <div class="model-option" onclick="loadScenario('${key}')">
                                <strong>${scenarios[key].name}</strong>
                                <p style="font-size: 0.85em; margin-top: 5px;">${scenarios[key].description}</p>
                            </div>
                        `;
                    }
                    modeContent.innerHTML = scenariosHtml;
                    break;
                    
                case 'challenges':
                    let challengesHtml = '<h3>Выберите вызов:</h3>';
                    for (let key in challenges) {
                        challengesHtml += `
                            <div class="model-option" onclick="startChallenge('${key}')">
                                <strong>${challenges[key].name}</strong>
                                <p style="font-size: 0.85em; margin-top: 5px;">${challenges[key].description}</p>
                            </div>
                        `;
                    }
                    modeContent.innerHTML = challengesHtml;
                    break;
                    
                case 'research':
                    modeContent.innerHTML = `
                        <h3>Режим исследования</h3>
                        <p>Экспериментируйте с законами физики и открывайте новые явления!</p>
                        <div class="parameter-slider">
                            <label>Скорость света: <span id="light-speed-value">1.0</span>c</label>
                            <input type="range" id="light-speed" min="0.1" max="10" step="0.1" value="1">
                        </div>
                        <div class="parameter-slider">
                            <label>Планковская постоянная: <span id="planck-value">1.0</span>ℏ</label>
                            <input type="range" id="planck-constant" min="0.1" max="10" step="0.1" value="1">
                        </div>
                    `;
                    
                    // Добавляем обработчики для исследовательских параметров
                    setTimeout(() => {
                        document.getElementById('light-speed')?.addEventListener('input', function() {
                            const value = parseFloat(this.value);
                            document.getElementById('light-speed-value').textContent = value.toFixed(1);
                            // Применяем изменения к физике
                        });
                        
                        document.getElementById('planck-constant')?.addEventListener('input', function() {
                            const value = parseFloat(this.value);
                            document.getElementById('planck-value').textContent = value.toFixed(1);
                            quantumUncertainty = value * 0.5;
                        });
                    }, 100);
                    break;
            }
        }

        function loadScenario(scenarioKey) {
            currentScenario = scenarios[scenarioKey];
            currentScenario.setup();
            updateInfo(`Загружен сценарий: ${currentScenario.name}`);
        }

        function startChallenge(challengeKey) {
            currentChallenge = challenges[challengeKey];
            updateInfo(`Начат вызов: ${currentChallenge.name}`);
            
            // Запускаем проверку условий вызова
            const checkInterval = setInterval(() => {
                if (currentChallenge.checkCondition()) {
                    clearInterval(checkInterval);
                    currentChallenge = null;
                }
            }, 1000);
        }

        class UniverseSerializer {
            static save() {
                const saveData = {
                    version: "1.0",
                    timestamp: Date.now(),
                    cosmology: cosmologyModel,
                    philosophy: philosophyModel,
                    parameters: {
                        timeSpeed,
                        gravityConstant,
                        quantumUncertainty,
                        entropyLevel,
                        darkEnergy,
                        inflationField,
                        emergenceLevel,
                        informationComplexity
                    },
                    objects: objects.map(obj => ({
                        type: obj.type,
                        position: obj.position.toArray(),
                        velocity: obj.velocity.toArray(),
                        mass: obj.mass,
                        age: obj.age,
                        temperature: obj.temperature,
                        evolutionStage: obj.evolutionStage,
                        fuelRemaining: obj.fuelRemaining,
                        hasLife: obj.hasLife,
                        lifeStage: obj.lifeStage
                    })),
                    statistics: {
                        totalTime: universeTime,
                        objectsCreated: objects.length
                    },
                    camera: {
                        position: camera.position.toArray(),
                        rotation: camera.rotation.toArray()
                    }
                };
                
                return JSON.stringify(saveData, null, 2);
            }
            
            static load(jsonData) {
                try {
                    const data = JSON.parse(jsonData);
                    
                    // Восстанавливаем параметры
                    cosmologyModel = data.cosmology;
                    philosophyModel = data.philosophy;
                    
                    timeSpeed = data.parameters.timeSpeed;
                    gravityConstant = data.parameters.gravityConstant;
                    quantumUncertainty = data.parameters.quantumUncertainty;
                    entropyLevel = data.parameters.entropyLevel;
                    darkEnergy = data.parameters.darkEnergy || 0.7;
                    inflationField = data.parameters.inflationField || 0;
                    emergenceLevel = data.parameters.emergenceLevel || 0.5;
                    informationComplexity = data.parameters.informationComplexity || 0.5;
                    
                    // Обновляем UI
                    document.getElementById('time-speed').value = timeSpeed;
                    document.getElementById('time-speed-value').textContent = timeSpeed.toFixed(1);
                    document.getElementById('gravity-constant').value = gravityConstant;
                    document.getElementById('gravity-value').textContent = gravityConstant.toFixed(1);
                    // ... обновить остальные слайдеры
                    
                    // Очищаем текущую вселенную
                    objects.forEach(obj => obj.destroy());
                    objects = [];
                    
                    // Восстанавливаем объекты
                    data.objects.forEach(objData => {
                        const position = new THREE.Vector3(...objData.position);
                        const velocity = new THREE.Vector3(...objData.velocity);
                        
                        let newObj;
                        switch(objData.type) {
                            case 'star':
                                createStar(position, velocity);
                                break;
                            case 'planet':
                                createPlanet(position, velocity);
                                break;
                            case 'blackhole':
                                createBlackHole(position);
                                break;
                            case 'neutronstar':
                                createNeutronStar(position, velocity);
                                break;
                            // ... другие типы
                        }
                        
                        // Восстанавливаем свойства последнего созданного объекта
                        if (objects.length > 0) {
                            newObj = objects[objects.length - 1];
                            newObj.mass = objData.mass;
                            newObj.age = objData.age;
                            newObj.temperature = objData.temperature;
                            newObj.evolutionStage = objData.evolutionStage;
                            newObj.fuelRemaining = objData.fuelRemaining;
                            newObj.hasLife = objData.hasLife;
                            newObj.lifeStage = objData.lifeStage;
                        }
                    });
                    
                    // Восстанавливаем камеру
                    camera.position.fromArray(data.camera.position);
                    camera.rotation.fromArray(data.camera.rotation);
                    
                    universeTime = data.statistics.totalTime;
                    
                    updateInfo('Вселенная успешно загружена!');
                    
                } catch (error) {
                    console.error('Ошибка загрузки:', error);
                    updateInfo('Ошибка при загрузке вселенной');
                }
            }
            
            static download() {
                const data = this.save();
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `universe_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            static upload() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            this.load(e.target.result);
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }
        }

        // Класс для продвинутых материалов
        class AdvancedMaterials {
            static createStarMaterial(philosophy = 'materialism') {
                const palette = philosophyPalettes[philosophy];
                const color = palette.colors[Math.floor(Math.random() * palette.colors.length)];
                
                if (philosophy === 'holographic') {
                    // Голографический шейдер
                    return new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            color: { value: new THREE.Color(color) }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            varying vec3 vPosition;
                            void main() {
                                vUv = uv;
                                vPosition = position;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform vec3 color;
                            varying vec2 vUv;
                            varying vec3 vPosition;
                            
                            void main() {
                                vec3 finalColor = color;
                                float noise = sin(vPosition.x * 10.0 + time) * 
                                             cos(vPosition.y * 10.0 + time * 0.5) * 
                                             sin(vPosition.z * 10.0 + time * 0.3);
                                
                                finalColor += vec3(noise * 0.2);
                                
                                // Голографический эффект
                                float hologram = sin(vUv.y * 50.0 + time * 2.0) * 0.5 + 0.5;
                                finalColor *= hologram * 0.5 + 0.5;
                                
                                gl_FragColor = vec4(finalColor, 0.9);
                            }
                        `,
                        transparent: true
                    });
                } else if (philosophy === 'information') {
                    // Цифровой/матричный шейдер
                    return new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            color: { value: new THREE.Color(color) }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform vec3 color;
                            varying vec2 vUv;
                            
                            float random(vec2 st) {
                                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                            }
                            
                            void main() {
                                vec2 st = vUv * 10.0;
                                float rnd = random(floor(st) + floor(time));
                                
                                vec3 finalColor = color * (0.5 + rnd * 0.5);
                                
                                // Цифровые полосы
                                float lines = step(0.98, sin(st.y * 50.0 + time * 5.0));
                                finalColor += vec3(0.0, 1.0, 0.0) * lines * 0.5;
                                
                                gl_FragColor = vec4(finalColor, 0.9);
                            }
                        `,
                        transparent: true
                    });
                } else {
                    // Стандартный материал с эффектами для других философий
                    const material = new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: palette.emissive,
                        emissiveIntensity: 0.5,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    if (philosophy === 'idealism') {
                        material.opacity = 0.7;
                        material.side = THREE.DoubleSide;
                    } else if (philosophy === 'process') {
                        material.wireframe = Math.random() > 0.5;
                    }
                    
                    return material;
                }
            }
            
            static createPlanetMaterial(philosophy = 'materialism') {
                const palette = philosophyPalettes[philosophy];
                const color = palette.colors[Math.floor(Math.random() * palette.colors.length)];
                
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: palette.emissive,
                    emissiveIntensity: 0.2,
                    shininess: philosophy === 'materialism' ? 100 : 30,
                    transparent: true,
                    opacity: philosophy === 'idealism' ? 0.8 : 0.95
                });
                
                return material;
            }
            
            static createBlackHoleMaterial() {
                return new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                    },
                    vertexShader: `
                        varying vec3 vPosition;
                        void main() {
                            vPosition = position;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform vec2 resolution;
                        varying vec3 vPosition;
                        
                        void main() {
                            vec2 st = gl_FragCoord.xy / resolution.xy;
                            float dist = length(vPosition);
                            
                            // Эффект искажения пространства
                            float distortion = 1.0 / (dist * dist + 0.1);
                            vec3 color = vec3(0.0);
                            
                            // Аккреционный диск
                            float ring = smoothstep(2.0, 2.1, dist) - smoothstep(5.0, 5.1, dist);
                            color += vec3(1.0, 0.5, 0.0) * ring * distortion;
                            
                            // Гравитационное линзирование
                            float lensing = 1.0 - smoothstep(0.0, 3.0, dist);
                            color = mix(color, vec3(0.0), lensing);
                            
                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                });
            }
        }

        // Классы для космических объектов
        class CelestialObject {
            constructor(position, velocity, mass, type) {
                this.position = position.clone();
                this.velocity = velocity.clone();
                this.mass = mass;
                this.type = type;
                this.age = 0;
                this.mesh = null;
                this.consciousness = philosophyModel === 'panpsychism' ? Math.random() : 0;
                
                // Новые свойства
                this.temperature = this.calculateInitialTemperature();
                this.luminosity = type === 'star' ? mass * mass : 0;
                this.metallicity = 0.02; // Солнечная металличность
                this.rotation = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
                
                // Свойства для эволюции
                this.evolutionStage = 'main-sequence';
                this.fuelRemaining = 1.0;
                this.hasLife = false;
                this.lifeStage = 'none';
                
                // Релятивистские свойства
                this.properTime = 0;
                this.schwarzschildRadius = 2 * gravityConstant * this.mass / (299792458 * 299792458);
            }
            
            calculateInitialTemperature() {
                switch(this.type) {
                    case 'star': return 5000 + Math.random() * 20000;
                    case 'planet': return 200 + Math.random() * 200;
                    case 'blackhole': return 0;
                    case 'neutronstar': return 1000000;
                    default: return 300;
                }
            }
            
            update(deltaTime, objects) {
                // Сохраняем старую позицию для расчета траектории
                const oldPosition = this.position.clone();
                
                // Обновление возраста с учетом релятивистских эффектов
                const speed = this.velocity.length();
                const c = 299792458; // скорость света
                const lorentzFactor = 1 / Math.sqrt(1 - (speed * speed) / (c * c));
                this.properTime += deltaTime * timeSpeed / lorentzFactor;
                this.age += deltaTime * timeSpeed;

                // Гравитационное взаимодействие с учетом релятивистских поправок
                const force = new THREE.Vector3(0, 0, 0);
                let nearestMassiveObject = null;
                let nearestDistance = Infinity;
                
                for (let obj of objects) {
                    if (obj !== this) {
                        const direction = obj.position.clone().sub(this.position);
                        const distance = direction.length();
                        
                        if (distance > 0.1) {
                            // Ньютоновская гравитация с поправкой на сильные поля
                            let magnitude = gravityConstant * this.mass * obj.mass / (distance * distance);
                            
                            // Усиление гравитации вблизи черных дыр
                            if (obj.type === 'blackhole') {
                                const distanceRatio = obj.schwarzschildRadius / distance;
                                magnitude *= (1 + distanceRatio * distanceRatio);
                                
                                if (distance < nearestDistance) {
                                    nearestMassiveObject = obj;
                                    nearestDistance = distance;
                                }
                            }
                            
                            direction.normalize().multiplyScalar(magnitude);
                            force.add(direction);
                            
                            // Приливные силы для близких объектов
                            if (distance < 10 && this.type === 'planet' && obj.type === 'star') {
                                const radius = this.mesh.userData.radius || 1; // Используем сохраненный радиус
                                const tidalForce = 2 * gravityConstant * obj.mass * radius / (distance * distance * distance);
                                this.mesh.scale.x = 1 + tidalForce * 0.1;
                                this.mesh.scale.z = 1 - tidalForce * 0.05;
                            }
                        }
                    }
                }
                
                // Проверка на поглощение черной дырой
                if (nearestMassiveObject && nearestMassiveObject.type === 'blackhole' && 
                    nearestDistance < nearestMassiveObject.schwarzschildRadius * 3) {
                    this.beingAbsorbed = true;
                    // Спагеттификация
                    if (this.mesh) {
                        const stretchDirection = nearestMassiveObject.position.clone().sub(this.position).normalize();
                        this.mesh.scale.x *= 0.98;
                        this.mesh.scale.z *= 0.98;
                        this.mesh.scale.y *= 1.04;
                        this.mesh.lookAt(nearestMassiveObject.position);
                    }
                }

                // Применение силы
                const acceleration = force.divideScalar(this.mass);
                this.velocity.add(acceleration.multiplyScalar(deltaTime));

                // Квантовые флуктуации
                if (quantumUncertainty > 0) {
                    this.velocity.x += (Math.random() - 0.5) * quantumUncertainty * 0.01;
                    this.velocity.y += (Math.random() - 0.5) * quantumUncertainty * 0.01;
                    this.velocity.z += (Math.random() - 0.5) * quantumUncertainty * 0.01;
                }

                // Обновление позиции
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));

                // Вращение объекта
                if (this.mesh) {
                    this.mesh.rotation.x += this.rotation.x * deltaTime;
                    this.mesh.rotation.y += this.rotation.y * deltaTime;
                    this.mesh.rotation.z += this.rotation.z * deltaTime;
                }

                // Эволюция объекта
                this.evolve(deltaTime);

                // Обновление меша
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    
                    // Эффекты в зависимости от философской модели
                    this.updatePhilosophicalEffects();
                }

                // Излучение Хокинга для черных дыр
                if (this.type === 'blackhole' && quantumUncertainty > 0) {
                    const hawkingTemperature = 1 / (8 * Math.PI * this.mass);
                    this.mass *= (1 - hawkingTemperature * quantumUncertainty * 0.000001);
                    if (this.mesh) {
                        const scale = Math.cbrt(this.mass / 100);
                        this.mesh.scale.setScalar(scale);
                    }
                }
            }
            
            evolve(deltaTime) {
                if (this.type === 'star') {
                    // Звездная эволюция
                    this.fuelRemaining -= deltaTime * 0.0001 / this.mass; // Массивные звезды сгорают быстрее
                    
                    if (this.evolutionStage === 'main-sequence' && this.fuelRemaining < 0.2) {
                        this.evolutionStage = 'red-giant';
                        this.expandToRedGiant();
                    } else if (this.evolutionStage === 'red-giant' && this.fuelRemaining <= 0) {
                        if (this.mass > 8) {
                            this.explodeAsSupernova();
                        } else {
                            this.becomeWhiteDwarf();
                        }
                    }
                    
                    // Обновление цвета в зависимости от температуры
                    if (this.mesh && this.mesh.material) {
                        const temp = this.temperature * (this.fuelRemaining + 0.1);
                        const color = this.blackbodyColor(temp);
                        this.mesh.material.color = color;
                    }
                } else if (this.type === 'planet') {
                    // Планетарная эволюция
                    this.checkHabitability(objects);
                    if (this.hasLife) {
                        this.evolveLife(deltaTime);
                    }
                }
            }
            
            blackbodyColor(temperature) {
                // Упрощенная модель цвета черного тела
                let r, g, b;
                const temp = temperature / 100;
                
                if (temp <= 66) {
                    r = 255;
                    g = temp;
                    g = 99.4708025861 * Math.log(g) - 161.1195681661;
                    if (temp <= 19) {
                        b = 0;
                    } else {
                        b = temp - 10;
                        b = 138.5177312231 * Math.log(b) - 305.0447927307;
                    }
                } else {
                    r = temp - 60;
                    r = 329.698727446 * Math.pow(r, -0.1332047592);
                    g = temp - 60;
                    g = 288.1221695283 * Math.pow(g, -0.0755148492);
                    b = 255;
                }
                
                return new THREE.Color(
                    Math.max(0, Math.min(1, r / 255)),
                    Math.max(0, Math.min(1, g / 255)),
                    Math.max(0, Math.min(1, b / 255))
                );
            }
            
            expandToRedGiant() {
                if (this.mesh) {
                    // Анимация расширения
                    const targetScale = 5 + this.mass / 5;
                    const expandAnimation = setInterval(() => {
                        this.mesh.scale.multiplyScalar(1.02);
                        if (this.mesh.scale.x >= targetScale) {
                            clearInterval(expandAnimation);
                        }
                    }, 50);
                    
                    this.temperature *= 0.5;
                    updateInfo(`Звезда превратилась в красного гиганта!`);
                }
            }
            
            explodeAsSupernova() {
                if (visualEffects) {
                    visualEffects.createSupernova(this.position);
                }
                
                // Создаем нейтронную звезду или черную дыру
                if (this.mass > 20) {
                    createBlackHole(this.position);
                } else {
                    createNeutronStar(this.position);
                }
                
                // Удаляем звезду
                this.destroy();
                updateInfo(`Произошел взрыв сверхновой!`);
            }
            
            becomeWhiteDwarf() {
                this.type = 'whitedwarf';
                this.temperature = 10000;
                if (this.mesh) {
                    this.mesh.scale.setScalar(0.1);
                    this.mesh.material.color = new THREE.Color(0.9, 0.9, 1);
                }
                updateInfo(`Звезда стала белым карликом`);
            }
            
            checkHabitability(objects) {
                // Проверка условий для жизни
                let nearestStar = null;
                let starDistance = Infinity;
                
                for (let obj of objects) {
                    if (obj.type === 'star' && obj.evolutionStage === 'main-sequence') {
                        const distance = this.position.distanceTo(obj.position);
                        if (distance < starDistance) {
                            nearestStar = obj;
                            starDistance = distance;
                        }
                    }
                }
                
                if (nearestStar) {
                    // Зона обитаемости
                    const habitableZoneInner = Math.sqrt(nearestStar.luminosity) * 0.95;
                    const habitableZoneOuter = Math.sqrt(nearestStar.luminosity) * 1.37;
                    
                    if (starDistance >= habitableZoneInner && starDistance <= habitableZoneOuter) {
                        this.temperature = 288; // Земная температура
                        if (!this.hasLife && Math.random() < 0.001) {
                            this.hasLife = true;
                            this.lifeStage = 'microbial';
                            updateInfo(`Зародилась жизнь на планете!`);
                            
                            // Визуальный индикатор жизни
                            if (this.mesh) {
                                const radius = this.mesh.userData.radius || 1; // Используем сохраненный радиус
                                const lifeGlow = new THREE.Mesh(
                                    new THREE.SphereGeometry(
                                        radius * 1.2, 
                                        16, 16
                                    ),
                                    new THREE.MeshBasicMaterial({
                                        color: 0x00ff00,
                                        transparent: true,
                                        opacity: 0.3
                                    })
                                );
                                this.mesh.add(lifeGlow);
                                this.mesh.userData.lifeGlow = lifeGlow;
                            }
                        }
                    }
                }
            }
            
            evolveLife(deltaTime) {
                if (!this.hasLife) return;
                
                const evolutionSpeed = 0.00001;
                const evolutionChance = Math.random();
                
                if (this.lifeStage === 'microbial' && evolutionChance < evolutionSpeed) {
                    this.lifeStage = 'complex';
                    updateInfo(`Жизнь эволюционировала в сложные формы!`);
                } else if (this.lifeStage === 'complex' && evolutionChance < evolutionSpeed * 0.1) {
                    this.lifeStage = 'intelligent';
                    updateInfo(`Появилась разумная жизнь!`);
                    
                    // Добавляем радиосигналы от цивилизации
                    if (this.mesh) {
                        const signalGeometry = new THREE.RingGeometry(0.1, 30, 32);
                        const signalMaterial = new THREE.MeshBasicMaterial({
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.5,
                            side: THREE.DoubleSide
                        });
                        const signal = new THREE.Mesh(signalGeometry, signalMaterial);
                        this.mesh.add(signal);
                        
                        // Анимация распространения сигнала
                        const animateSignal = () => {
                            signal.scale.multiplyScalar(1.01);
                            signal.material.opacity *= 0.99;
                            if (signal.material.opacity > 0.01) {
                                requestAnimationFrame(animateSignal);
                            } else {
                                this.mesh.remove(signal);
                            }
                        };
                        animateSignal();
                    }
                } else if (this.lifeStage === 'intelligent' && evolutionChance < evolutionSpeed * 0.01) {
                    this.lifeStage = 'spacefaring';
                    updateInfo(`Цивилизация вышла в космос!`);
                    
                    // Создаем космические корабли
                    this.launchSpaceships();
                }
            }
            
            launchSpaceships() {
                for (let i = 0; i < 3; i++) {
                    const shipGeometry = new THREE.ConeGeometry(0.1, 0.3, 4);
                    const shipMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        emissive: 0x004444
                    });
                    const ship = new THREE.Mesh(shipGeometry, shipMaterial);
                    
                    const angle = (i / 3) * Math.PI * 2;
                    const distance = (this.mesh.userData.radius || 1) * 2;
                    ship.position.set(
                        Math.cos(angle) * distance,
                        0,
                        Math.sin(angle) * distance
                    );
                    
                    const shipObject = new CelestialObject(
                        this.position.clone().add(ship.position),
                        new THREE.Vector3(
                            Math.cos(angle) * 5,
                            (Math.random() - 0.5) * 2,
                            Math.sin(angle) * 5
                        ),
                        0.001,
                        'spaceship'
                    );
                    shipObject.mesh = ship;
                    scene.add(ship);
                    objects.push(shipObject);
                }
            }
            
            updatePhilosophicalEffects() {
                if (philosophyModel === 'idealism' && this.mesh.material) {
                    this.mesh.material.opacity = 0.5 + 0.5 * Math.sin(universeTime * 0.001);
                } else if (philosophyModel === 'panpsychism' && this.mesh.material.color) {
                    const hue = (this.consciousness * 360 + universeTime * 10) % 360;
                    this.mesh.material.color.setHSL(hue / 360, 0.8, 0.5);
                } else if (philosophyModel === 'holographic' && this.mesh) {
                    this.mesh.scale.setScalar(
                        this.mesh.scale.x * (1 + 0.01 * Math.sin(universeTime * 0.002 + this.age))
                    );
                }
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    if (this.mesh.geometry) this.mesh.geometry.dispose();
                    if (this.mesh.material) this.mesh.material.dispose();
                }
                const index = objects.indexOf(this);
                if (index > -1) {
                    objects.splice(index, 1);
                }
            }
        }

        // Octree для оптимизации пространственных запросов
        class Octree {
            constructor(bounds, maxObjects = 10, maxLevels = 5, level = 0) {
                this.bounds = bounds;
                this.objects = [];
                this.nodes = [];
                this.maxObjects = maxObjects;
                this.maxLevels = maxLevels;
                this.level = level;
            }
            
            clear() {
                this.objects = [];
                for (let node of this.nodes) {
                    node.clear();
                }
                this.nodes = [];
            }
            
            split() {
                const subWidth = this.bounds.width / 2;
                const subHeight = this.bounds.height / 2;
                const subDepth = this.bounds.depth / 2;
                const x = this.bounds.x;
                const y = this.bounds.y;
                const z = this.bounds.z;
                
                // 8 подузлов для 3D пространства
                this.nodes[0] = new Octree({
                    x: x - subWidth/2, y: y + subHeight/2, z: z - subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[1] = new Octree({
                    x: x + subWidth/2, y: y + subHeight/2, z: z - subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[2] = new Octree({
                    x: x - subWidth/2, y: y - subHeight/2, z: z - subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[3] = new Octree({
                    x: x + subWidth/2, y: y - subHeight/2, z: z - subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[4] = new Octree({
                    x: x - subWidth/2, y: y + subHeight/2, z: z + subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[5] = new Octree({
                    x: x + subWidth/2, y: y + subHeight/2, z: z + subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[6] = new Octree({
                    x: x - subWidth/2, y: y - subHeight/2, z: z + subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
                
                this.nodes[7] = new Octree({
                    x: x + subWidth/2, y: y - subHeight/2, z: z + subDepth/2,
                    width: subWidth, height: subHeight, depth: subDepth
                }, this.maxObjects, this.maxLevels, this.level + 1);
            }
            
            getIndex(object) {
                const indexes = [];
                const verticalMidpoint = this.bounds.x;
                const horizontalMidpoint = this.bounds.y;
                const depthMidpoint = this.bounds.z;
                
                const topQuadrant = object.position.y > horizontalMidpoint;
                const bottomQuadrant = object.position.y < horizontalMidpoint;
                const leftQuadrant = object.position.x < verticalMidpoint;
                const rightQuadrant = object.position.x > verticalMidpoint;
                const frontQuadrant = object.position.z < depthMidpoint;
                const backQuadrant = object.position.z > depthMidpoint;
                
                if (leftQuadrant) {
                    if (topQuadrant) {
                        if (frontQuadrant) indexes.push(0);
                        if (backQuadrant) indexes.push(4);
                    }
                    if (bottomQuadrant) {
                        if (frontQuadrant) indexes.push(2);
                        if (backQuadrant) indexes.push(6);
                    }
                }
                if (rightQuadrant) {
                    if (topQuadrant) {
                        if (frontQuadrant) indexes.push(1);
                        if (backQuadrant) indexes.push(5);
                    }
                    if (bottomQuadrant) {
                        if (frontQuadrant) indexes.push(3);
                        if (backQuadrant) indexes.push(7);
                    }
                }
                
                return indexes;
            }
            
            insert(object) {
                if (this.nodes.length > 0) {
                    const indexes = this.getIndex(object);
                    for (let index of indexes) {
                        this.nodes[index].insert(object);
                    }
                    return;
                }
                
                this.objects.push(object);
                
                if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
                    if (this.nodes.length === 0) {
                        this.split();
                    }
                    
                    let i = 0;
                    while (i < this.objects.length) {
                        const indexes = this.getIndex(this.objects[i]);
                        for (let index of indexes) {
                            this.nodes[index].insert(this.objects[i]);
                        }
                        this.objects.splice(i, 1);
                    }
                }
            }
            
            retrieve(object) {
                const returnObjects = [];
                
                if (this.nodes.length > 0) {
                    const indexes = this.getIndex(object);
                    for (let index of indexes) {
                        returnObjects.push(...this.nodes[index].retrieve(object));
                    }
                }
                
                returnObjects.push(...this.objects);
                
                return returnObjects;
            }
        }

        // Глобальная переменная для octree
        let octree;

        class LODSystem {
            constructor() {
                this.lodGeometries = {
                    star: {
                        high: new THREE.SphereGeometry(1, 32, 32),
                        medium: new THREE.SphereGeometry(1, 16, 16),
                        low: new THREE.SphereGeometry(1, 8, 8),
                        veryLow: new THREE.BoxGeometry(1, 1, 1)
                    },
                    planet: {
                        high: new THREE.SphereGeometry(1, 32, 32),
                        medium: new THREE.SphereGeometry(1, 16, 16),
                        low: new THREE.SphereGeometry(1, 8, 8),
                        veryLow: new THREE.BoxGeometry(1, 1, 1)
                    }
                };
                
                this.distanceThresholds = {
                    high: 50,
                    medium: 150,
                    low: 300,
                    veryLow: 500
                };
            }
            
            update(camera, objects) {
                const cameraPosition = camera.position;
                
                for (let obj of objects) {
                    if (!obj.mesh || !obj.mesh.geometry) continue;
                    
                    const distance = cameraPosition.distanceTo(obj.position);
                    const originalRadius = obj.mesh.userData.originalRadius || 1;
                    
                    // Определяем уровень детализации
                    let lodLevel = 'high';
                    if (distance > this.distanceThresholds.veryLow) {
                        lodLevel = 'veryLow';
                    } else if (distance > this.distanceThresholds.low) {
                        lodLevel = 'low';
                    } else if (distance > this.distanceThresholds.medium) {
                        lodLevel = 'medium';
                    }
                    
                    // Меняем геометрию если нужно
                    if (obj.mesh.userData.currentLOD !== lodLevel) {
                        const geometryType = obj.type === 'star' ? 'star' : 'planet';
                        if (this.lodGeometries[geometryType] && this.lodGeometries[geometryType][lodLevel]) {
                            const newGeometry = this.lodGeometries[geometryType][lodLevel].clone();
                            newGeometry.scale(originalRadius, originalRadius, originalRadius);
                            
                            obj.mesh.geometry.dispose();
                            obj.mesh.geometry = newGeometry;
                            obj.mesh.userData.currentLOD = lodLevel;
                        }
                    }
                    
                    // Скрываем очень далекие объекты
                    obj.mesh.visible = distance < 1000;
                    
                    // Упрощаем материалы для далеких объектов
                    if (distance > this.distanceThresholds.medium && obj.mesh.material) {
                        if (!obj.mesh.userData.simpleMaterial) {
                            obj.mesh.userData.originalMaterial = obj.mesh.material;
                            obj.mesh.userData.simpleMaterial = new THREE.MeshBasicMaterial({
                                color: obj.mesh.material.color || 0xffffff
                            });
                        }
                        obj.mesh.material = obj.mesh.userData.simpleMaterial;
                    } else if (obj.mesh.userData.originalMaterial) {
                        obj.mesh.material = obj.mesh.userData.originalMaterial;
                    }
                }
            }
        }

        // Создаем экземпляр LOD системы
        let lodSystem;

        class PluginSystem {
            constructor() {
                this.plugins = new Map();
                this.hooks = {
                    'preUpdate': [],
                    'postUpdate': [],
                    'objectCreated': [],
                    'objectDestroyed': [],
                    'render': []
                };
            }
            
            register(name, plugin) {
                if (this.plugins.has(name)) {
                    console.warn(`Plugin ${name} already registered`);
                    return;
                }
                
                this.plugins.set(name, plugin);
                
                // Инициализация плагина
                if (plugin.initialize) {
                    plugin.initialize({
                        scene,
                        camera,
                        renderer,
                        objects,
                        addHook: (hookName, callback) => this.addHook(hookName, callback),
                        removeHook: (hookName, callback) => this.removeHook(hookName, callback)
                    });
                }
                
                console.log(`Plugin ${name} registered successfully`);
            }
            
            unregister(name) {
                const plugin = this.plugins.get(name);
                if (plugin) {
                    if (plugin.destroy) {
                        plugin.destroy();
                    }
                    this.plugins.delete(name);
                    
                    // Удаляем все хуки плагина
                    for (let hookName in this.hooks) {
                        this.hooks[hookName] = this.hooks[hookName].filter(
                            hook => hook.plugin !== name
                        );
                    }
                }
            }
            
            addHook(hookName, callback, pluginName) {
                if (this.hooks[hookName]) {
                    this.hooks[hookName].push({ callback, plugin: pluginName });
                }
            }
            
            removeHook(hookName, callback) {
                if (this.hooks[hookName]) {
                    this.hooks[hookName] = this.hooks[hookName].filter(
                        hook => hook.callback !== callback
                    );
                }
            }
            
            executeHooks(hookName, ...args) {
                if (this.hooks[hookName]) {
                    for (let hook of this.hooks[hookName]) {
                        hook.callback(...args);
                    }
                }
            }
            
            update(deltaTime) {
                this.executeHooks('preUpdate', deltaTime);
                
                for (let [name, plugin] of this.plugins) {
                    if (plugin.update) {
                        plugin.update(deltaTime);
                    }
                }
                
                this.executeHooks('postUpdate', deltaTime);
            }
        }

        // Пример плагина: Гравитационные волны
        class GravitationalWavesPlugin {
            initialize(context) {
                this.context = context;
                this.waveEmitters = [];
                
                // Подписываемся на события
                context.addHook('objectDestroyed', (obj) => {
                    if (obj.type === 'star' && obj.mass > 8) {
                        this.createGravitationalWave(obj.position, obj.mass);
                    }
                });
            }
            
            update(deltaTime) {
                // Обнаружение слияний массивных объектов
                const massiveObjects = this.context.objects.filter(
                    obj => obj.type === 'blackhole' || obj.type === 'neutronstar'
                );
                
                for (let i = 0; i < massiveObjects.length - 1; i++) {
                    for (let j = i + 1; j < massiveObjects.length; j++) {
                        const distance = massiveObjects[i].position.distanceTo(
                            massiveObjects[j].position
                        );
                        
                        if (distance < 10 && !this.isWaveEmitted(i, j)) {
                            this.createGravitationalWave(
                                massiveObjects[i].position.clone().add(massiveObjects[j].position).multiplyScalar(0.5),
                                massiveObjects[i].mass + massiveObjects[j].mass
                            );
                            this.markWaveEmitted(i, j);
                        }
                    }
                }
            }
            
            createGravitationalWave(position, mass) {
                if (visualEffects) {
                    visualEffects.createGravitationalWave(position, mass * 5);
                }
            }
            
            isWaveEmitted(i, j) {
                return this.waveEmitters.some(e => 
                    (e.i === i && e.j === j) || (e.i === j && e.j === i)
                );
            }
            
            markWaveEmitted(i, j) {
                this.waveEmitters.push({ i, j, time: universeTime });
                
                // Очищаем старые записи
                this.waveEmitters = this.waveEmitters.filter(
                    e => universeTime - e.time < 10
                );
            }
        }

        // Создаем систему плагинов
        let pluginSystem;

            // Обновляем туман в зависимости от философии
            function updateFog() {
                const palette = philosophyPalettes[philosophyModel];
                scene.fog = new THREE.FogExp2(palette.fog, 0.00005);
            }

        // Инициализация Three.js
        function init() {
            // Сцена
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000033, 0.00005);

            // Камера
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 50, 100);
            camera.lookAt(0, 0, 0);

            // Рендерер
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Инициализация систем оптимизации
            octree = new Octree({
                x: 0, y: 0, z: 0,
                width: 2000, height: 2000, depth: 2000
            });

            lodSystem = new LODSystem();
            pluginSystem = new PluginSystem();
            performanceMonitor = new PerformanceMonitor();

            // Регистрация плагинов
            pluginSystem.register('gravitationalWaves', new GravitationalWavesPlugin());

            // Оптимизация рендеринга
            const renderOptimizer = new RenderOptimizer(renderer, scene, camera);
            //const frustumCulling = renderOptimizer.enableFrustumCulling();
            window.renderOptimizer = renderOptimizer;

            // Добавляем UI для настроек качества
            const qualityPanel = document.createElement('div');
            qualityPanel.className = 'control-panel';
            qualityPanel.style.cssText = `
                position: absolute;
                top: 20px;
                right: 340px;
                padding: 10px;
            `;
            qualityPanel.innerHTML = `
                <h3 style="margin: 0 0 10px 0; font-size: 14px;">Качество графики</h3>
                <select id="quality-select" style="width: 100%; padding: 5px; background: rgba(40, 40, 80, 0.8); color: white; border: 1px solid rgba(100, 100, 255, 0.5);">
                    <option value="low">Низкое</option>
                    <option value="medium">Среднее</option>
                    <option value="high" selected>Высокое</option>
                    <option value="ultra">Ультра</option>
                </select>
                <label style="display: block; margin-top: 10px; font-size: 12px;">
                    <input type="checkbox" id="auto-quality" checked> Авто-настройка
                </label>
            `;
            document.getElementById('ui-overlay').appendChild(qualityPanel);

            document.getElementById('quality-select').addEventListener('change', (e) => {
                renderOptimizer.setQuality(e.target.value);
            });

            document.getElementById('auto-quality').addEventListener('change', (e) => {
                renderOptimizer.autoAdjust = e.target.checked;
            });

            // Инициализация системы эффектов
            visualEffects = new VisualEffects(scene);

            updateFog();

            // Добавляем постобработку для некоторых философий
            if (philosophyModel === 'holographic' || philosophyModel === 'information') {
                // Добавляем сканлинии для цифрового эффекта
                const scanlines = document.createElement('div');
                scanlines.className = 'scanlines';
                scanlines.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: repeating-linear-gradient(
                        0deg,
                        rgba(0, 255, 0, 0.03),
                        rgba(0, 255, 0, 0.03) 1px,
                        transparent 1px,
                        transparent 2px
                    );
                    pointer-events: none;
                    z-index: 5;
                    animation: scanlines 8s linear infinite;
                `;
                document.getElementById('ui-overlay').appendChild(scanlines);
            }

            // CSS анимация для сканлиний
            const style = document.createElement('style');
            style.textContent = `
                @keyframes scanlines {
                    0% { transform: translateY(0); }
                    100% { transform: translateY(10px); }
                }
            `;
            document.head.appendChild(style);

            // Освещение
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1, 1000);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Звездное небо
            createStarfield();

            // Начальные объекты в зависимости от модели
            initializeUniverse();

            // Управление камерой
            setupCameraControls();

            // Обработчики событий
            setupEventHandlers();

            // Скрыть экран загрузки
            document.getElementById('loading-screen').style.display = 'none';

            // Запуск анимации
            animate();
        }

        // Создание звездного поля
        function createStarfield() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                map: createStarTexture()
            });

            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
        }

        // Создание текстуры звезды
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.4, 'rgba(255,255,200,0.5)');
            gradient.addColorStop(1, 'rgba(255,255,200,0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            
            return new THREE.CanvasTexture(canvas);
        }

        // Инициализация вселенной
        function initializeUniverse() {
            objects = [];
            
            // Удаляем старые объекты
            scene.children = scene.children.filter(child => 
                child.type === 'AmbientLight' || 
                child.type === 'PointLight' || 
                child.type === 'Points'
            );

            switch (cosmologyModel) {
                case 'bigbang':
                    // Создаем начальную сингулярность
                    createExplosion(new THREE.Vector3(0, 0, 0));
                    universePhase = 'expansion';
                    break;
                    
                case 'steady':
                    // Создаем равномерно распределенные объекты
                    for (let i = 0; i < 20; i++) {
                        const position = new THREE.Vector3(
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200
                        );
                        createStar(position);
                    }
                    universePhase = 'steady';
                    break;
                    
                case 'cyclic':
                    // Создаем объекты в состоянии сжатия
                    for (let i = 0; i < 15; i++) {
                        const angle = (i / 15) * Math.PI * 2;
                        const radius = 30;
                        const position = new THREE.Vector3(
                            Math.cos(angle) * radius,
                            (Math.random() - 0.5) * 20,
                            Math.sin(angle) * radius
                        );
                        const velocity = position.clone().normalize().multiplyScalar(-5);
                        createStar(position, velocity);
                    }
                    universePhase = 'contraction';
                    break;
                    
                case 'multiverse':
                    // Создаем несколько "пузырей" вселенных
                    for (let i = 0; i < 5; i++) {
                        const center = new THREE.Vector3(
                            (Math.random() - 0.5) * 150,
                            (Math.random() - 0.5) * 150,
                            (Math.random() - 0.5) * 150
                        );
                        for (let j = 0; j < 5; j++) {
                            const offset = new THREE.Vector3(
                                (Math.random() - 0.5) * 30,
                                (Math.random() - 0.5) * 30,
                                (Math.random() - 0.5) * 30
                            );
                            createStar(center.clone().add(offset));
                        }
                    }
                    universePhase = 'expansion';
                    break;
                    
                case 'inflation':
                    // Инфляционная модель - начинаем с компактной области
                    inflationEpoch = true;
                    inflationField = 1.0;
                    for (let i = 0; i < 10; i++) {
                        const position = new THREE.Vector3(
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5
                        );
                        createQuantumFluctuation(position);
                    }
                    universePhase = 'inflation';
                    break;
                    
                case 'darkenergy':
                    // Модель с темной энергией
                    darkEnergy = 0.9;
                    createExplosion(new THREE.Vector3(0, 0, 0));
                    // Добавляем темную энергию как фоновое поле
                    createDarkEnergyField();
                    universePhase = 'expansion';
                    break;
                    
                case 'branes':
                    // Браны и высшие измерения
                    createBraneStructure();
                    universePhase = 'expansion';
                    break;
                    
                case 'quantum':
                    // Квантовая космология
                    quantumUncertainty = 0.9;
                    createQuantumFoam();
                    universePhase = 'expansion';
                    break;
            }
        }

        // Создание взрыва (для модели Большого взрыва)
        function createExplosion(position) {
            for (let i = 0; i < 30; i++) {
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5),
                    (Math.random() - 0.5),
                    (Math.random() - 0.5)
                ).normalize().multiplyScalar(10 + Math.random() * 20);
                
                const offset = velocity.clone().normalize().multiplyScalar(Math.random() * 5);
                const startPos = position.clone().add(offset);
                
                if (Math.random() > 0.7) {
                    createStar(startPos, velocity);
                } else {
                    createPlanet(startPos, velocity);
                }
            }
        }

        // Создание звезды
        function createStar(position, velocity = null) {
             const radius = 2 + Math.random() * 3;
             const geometry = new THREE.SphereGeometry(radius, 32, 32);
             const material = AdvancedMaterials.createStarMaterial(philosophyModel);
            
             const mesh = new THREE.Mesh(geometry, material);
             mesh.position.copy(position);
             mesh.userData.radius = radius; // ДОБАВИТЬ ЭТУ СТРОКУ
             mesh.userData.originalRadius = radius; // ДОБАВИТЬ ЭТУ СТРОКУ
             scene.add(mesh);
            
            // Улучшенное свечение с несколькими слоями
            const glowLayers = [
                { scale: 1.5, opacity: 0.6 },
                { scale: 2.0, opacity: 0.4 },
                { scale: 3.0, opacity: 0.2 },
                { scale: 4.0, opacity: 0.1 }
            ];
            
            glowLayers.forEach(layer => {
                const glowGeometry = new THREE.SphereGeometry(radius * layer.scale, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: material.color || 0xffffff,
                    transparent: true,
                    opacity: layer.opacity,
                    side: THREE.BackSide
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                mesh.add(glowMesh);
            });
            
            // Добавляем частицы вокруг звезды для эффекта короны
            if (philosophyModel !== 'materialism') {
                const coronaGeometry = new THREE.BufferGeometry();
                const coronaCount = 100;
                const positions = new Float32Array(coronaCount * 3);
                const colors = new Float32Array(coronaCount * 3);
                
                for (let i = 0; i < coronaCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = radius * (1.5 + Math.random() * 2);
                    
                    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = r * Math.cos(phi);
                    
                    colors[i * 3] = 1;
                    colors[i * 3 + 1] = 0.8;
                    colors[i * 3 + 2] = 0.4;
                }
                
                coronaGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                coronaGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const coronaMaterial = new THREE.PointsMaterial({
                    size: 0.3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                const corona = new THREE.Points(coronaGeometry, coronaMaterial);
                mesh.add(corona);
                mesh.userData.corona = corona;
            }
            
            const star = new CelestialObject(
                position,
                velocity || new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2),
                10 + Math.random() * 20,
                'star'
            );
            star.mesh = mesh;
            objects.push(star);
        }

        // Создание планеты
        function createPlanet(position, velocity = null) {
            const radius = 0.5 + Math.random() * 1.5;
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = AdvancedMaterials.createPlanetMaterial(philosophyModel);
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.userData.radius = radius; // ДОБАВИТЬ ЭТУ СТРОКУ
            mesh.userData.originalRadius = radius; // ДОБАВИТЬ ЭТУ СТРОКУ
            scene.add(mesh);
            
            // Добавляем атмосферу для некоторых планет
            if (Math.random() > 0.5 && philosophyModel !== 'materialism') {
                const atmosphereGeometry = new THREE.SphereGeometry(radius * 1.2, 32, 32);
                const atmosphereMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        planetRadius: { value: radius }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vPosition = position;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float planetRadius;
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        
                        void main() {
                            float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                            vec3 atmosphereColor = vec3(0.3, 0.6, 1.0);
                            
                            // Анимированные облака
                            float clouds = sin(vPosition.x * 10.0 + time) * 
                                          cos(vPosition.y * 10.0 + time * 0.5) * 0.1;
                            
                            gl_FragColor = vec4(atmosphereColor, intensity * (0.8 + clouds));
                        }
                    `,
                    transparent: true,
                    side: THREE.BackSide
                });
                
                const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                mesh.add(atmosphere);
                mesh.userData.atmosphere = atmosphere;
            }
            
            // Добавляем кольца для некоторых планет
            if (Math.random() > 0.7) {
                const ringGeometry = new THREE.RingGeometry(radius * 1.5, radius * 2.5, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: material.color,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.5;
                mesh.add(ring);
            }
            
            const planet = new CelestialObject(
                position,
                velocity || new THREE.Vector3((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5),
                1 + Math.random() * 5,
                'planet'
            );
            planet.mesh = mesh;
            objects.push(planet);
        }

        // Создание черной дыры
        function createBlackHole(position) {
            const geometry = new THREE.SphereGeometry(3, 32, 32);
            const material = AdvancedMaterials.createBlackHoleMaterial();
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            scene.add(mesh);
            
            // Улучшенный аккреционный диск с вращением
            const diskGeometry = new THREE.RingGeometry(5, 20, 128, 8);
            
            // Модифицируем геометрию для спирального эффекта
            const positions = diskGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const angle = Math.atan2(y, x);
                const radius = Math.sqrt(x * x + y * y);
                
                // Спиральное искажение
                const spiralAngle = angle + (20 - radius) * 0.3;
                positions.setX(i, radius * Math.cos(spiralAngle));
                positions.setY(i, radius * Math.sin(spiralAngle));
                
                // Вертикальное искажение для объема
                const z = Math.sin((radius - 5) * 0.5) * 2 * Math.exp(-(radius - 12.5) * 0.1);
                positions.setZ(i, z);
            }
            positions.needsUpdate = true;
            diskGeometry.computeVertexNormals();
            
            const diskMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    innerRadius: { value: 5 },
                    outerRadius: { value: 20 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float innerRadius;
                    uniform float outerRadius;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        float radius = length(vPosition.xy);
                        float normalizedRadius = (radius - innerRadius) / (outerRadius - innerRadius);
                        
                        // Цвет от горячего к холодному
                        vec3 hotColor = vec3(1.0, 0.8, 0.0);
                        vec3 coldColor = vec3(0.8, 0.2, 0.0);
                        vec3 color = mix(hotColor, coldColor, normalizedRadius);
                        
                        // Вращение и яркость
                        float angle = atan(vPosition.y, vPosition.x);
                        float brightness = 0.5 + 0.5 * sin(angle * 3.0 - time * 2.0 + radius * 0.5);
                        
                        // Затухание к краям
                        float falloff = 1.0 - normalizedRadius;
                        
                        gl_FragColor = vec4(color * brightness, falloff * 0.8);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const diskMesh = new THREE.Mesh(diskGeometry, diskMaterial);
            mesh.add(diskMesh);
            mesh.userData.disk = diskMesh;
            
            // Гравитационное искажение пространства
            const distortionGeometry = new THREE.SphereGeometry(30, 32, 32);
            const distortionMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vPosition;
                    
                    void main() {
                        float dist = length(vPosition);
                        float wave = sin(dist * 0.5 - time * 2.0) * 0.5 + 0.5;
                        gl_FragColor = vec4(0.5, 0.3, 1.0, wave * 0.1);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                depthWrite: false
            });
            
            const distortion = new THREE.Mesh(distortionGeometry, distortionMaterial);
            mesh.add(distortion);
            
            const blackHole = new CelestialObject(
                position,
                new THREE.Vector3(0, 0, 0),
                100,
                'blackhole'
            );
            blackHole.mesh = mesh;
            objects.push(blackHole);
        }

        // Создание галактики
        function createGalaxy(position) {
            const galaxyGroup = new THREE.Group();
            galaxyGroup.position.copy(position);
            
            // Центральная черная дыра
            const centerGeometry = new THREE.SphereGeometry(2, 16, 16);
            const centerMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const centerMesh = new THREE.Mesh(centerGeometry, centerMaterial);
            galaxyGroup.add(centerMesh);
            
            // Спиральные рукава
            for (let arm = 0; arm < 3; arm++) {
                const armAngle = (arm / 3) * Math.PI * 2;
                
                for (let i = 0; i < 20; i++) {
                    const angle = armAngle + (i / 20) * Math.PI;
                    const radius = 10 + i * 2;
                    const height = (Math.random() - 0.5) * 5;
                    
                    const starPos = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        height,
                        Math.sin(angle) * radius
                    );
                    
                    const starGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                    const starMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.15 * Math.random(), 0.8, 0.8)
                    });
                    const starMesh = new THREE.Mesh(starGeometry, starMaterial);
                    starMesh.position.copy(starPos);
                    galaxyGroup.add(starMesh);
                }
            }
            
            scene.add(galaxyGroup);
            
            const galaxy = new CelestialObject(
                position,
                new THREE.Vector3((Math.random() - 0.5) * 0.5, 0, (Math.random() - 0.5) * 0.5),
                1000,
                'galaxy'
            );
            galaxy.mesh = galaxyGroup;
            objects.push(galaxy);
        }

        // Создание нейтронной звезды
        function createNeutronStar(position, velocity = null) {
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pulseRate: { value: 1 + Math.random() * 10 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float pulseRate;
                    varying vec3 vNormal;
                    
                    void main() {
                        // Пульсирующее излучение
                        float pulse = sin(time * pulseRate) * 0.5 + 0.5;
                        
                        // Магнитные полюса
                        float pole = abs(dot(vNormal, vec3(0.0, 1.0, 0.0)));
                        pole = pow(pole, 4.0);
                        
                        vec3 color = vec3(0.8, 0.8, 1.0);
                        color += vec3(0.2, 0.5, 1.0) * pole * pulse;
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            scene.add(mesh);
            
            // Магнитное поле
            const fieldGeometry = new THREE.TorusGeometry(3, 0.1, 8, 32);
            const fieldMaterial = new THREE.MeshBasicMaterial({
                color: 0x4040ff,
                transparent: true,
                opacity: 0.3
            });
            const magneticField = new THREE.Mesh(fieldGeometry, fieldMaterial);
            magneticField.rotation.x = Math.PI / 2;
            mesh.add(magneticField);
            
            // Джеты
            const jetGeometry = new THREE.ConeGeometry(0.2, 5, 8);
            const jetMaterial = new THREE.MeshBasicMaterial({
                color: 0x8080ff,
                transparent: true,
                opacity: 0.6
            });
            
            const jetTop = new THREE.Mesh(jetGeometry, jetMaterial);
            jetTop.position.y = 2.5;
            mesh.add(jetTop);
            
            const jetBottom = new THREE.Mesh(jetGeometry, jetMaterial);
            jetBottom.position.y = -2.5;
            jetBottom.rotation.z = Math.PI;
            mesh.add(jetBottom);
            
            const neutronStar = new CelestialObject(
                position,
                velocity || new THREE.Vector3((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10),
                1.4, // Масса Чандрасекара
                'neutronstar'
            );
            neutronStar.mesh = mesh;
            neutronStar.rotation = new THREE.Vector3(0, 1, 0); // Быстрое вращение
            objects.push(neutronStar);
        }

        // Создание квазара
        function createQuasar(position) {
            const coreGeometry = new THREE.SphereGeometry(1, 32, 32);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 2
            });
            
            const mesh = new THREE.Mesh(coreGeometry, coreMaterial);
            mesh.position.copy(position);
            scene.add(mesh);
            
            // Аккреционный диск
            const diskGeometry = new THREE.RingGeometry(2, 15, 64, 8);
            const diskMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 center = vec2(0.5);
                        float dist = length(vUv - center);
                        
                        vec3 color = mix(
                            vec3(1.0, 1.0, 0.0),
                            vec3(1.0, 0.0, 0.0),
                            dist * 2.0
                        );
                        
                        float brightness = 1.0 - dist * 2.0;
                        brightness *= sin(dist * 20.0 - time * 5.0) * 0.2 + 0.8;
                        
                        gl_FragColor = vec4(color * brightness, brightness);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const disk = new THREE.Mesh(diskGeometry, diskMaterial);
            disk.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.2;
            mesh.add(disk);
            
            // Релятивистские джеты
            const jetLength = 50;
            const jetGeometry = new THREE.CylinderGeometry(0.5, 2, jetLength, 16);
            const jetMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vPosition;
                    
                    void main() {
                        float height = (vPosition.y + 25.0) / 50.0;
                        vec3 color = vec3(0.5, 0.5, 1.0);
                        
                        float pulse = sin(height * 10.0 - time * 10.0) * 0.5 + 0.5;
                        float opacity = (1.0 - height) * pulse;
                        
                        gl_FragColor = vec4(color, opacity);
                    }
                `,
                transparent: true
            });
            
            const jetTop = new THREE.Mesh(jetGeometry, jetMaterial);
            jetTop.position.y = jetLength / 2;
            mesh.add(jetTop);
            
            const jetBottom = new THREE.Mesh(jetGeometry, jetMaterial);
            jetBottom.position.y = -jetLength / 2;
            jetBottom.rotation.z = Math.PI;
            mesh.add(jetBottom);
            
            const quasar = new CelestialObject(
                position,
                new THREE.Vector3(0, 0, 0),
                1000,
                'quasar'
            );
            quasar.mesh = mesh;
            objects.push(quasar);
            
            // Добавляем мощное свечение
            const glowGeometry = new THREE.SphereGeometry(20, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x8080ff,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            mesh.add(glow);
        }

        // Создание темной материи
        function createDarkMatter(position, radius = 30) {
            // Темная материя невидима, но создает гравитационное искажение
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vPosition;
                    
                    void main() {
                        float dist = length(vPosition);
                        float distortion = sin(dist * 0.1 + time) * 0.5 + 0.5;
                        
                        // Почти невидимое искажение пространства
                        gl_FragColor = vec4(0.5, 0.3, 1.0, distortion * 0.05);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                depthWrite: false
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            scene.add(mesh);
            
            // Частицы для визуализации гравитационного влияния
            const particleCount = 1000;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = radius * (0.8 + Math.random() * 0.4);
                
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x4040ff,
                size: 0.5,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            mesh.add(particles);
            mesh.userData.particles = particles;
            
            const darkMatter = new CelestialObject(
                position,
                new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2),
                500, // Большая масса
                'darkmatter'
            );
            darkMatter.mesh = mesh;
            objects.push(darkMatter);
        }

        // Создание червоточины
        function createWormhole(position1, position2 = null) {
            // Если не указана вторая позиция, создаем случайную
            if (!position2) {
                position2 = new THREE.Vector3(
                    position1.x + (Math.random() - 0.5) * 200,
                    position1.y + (Math.random() - 0.5) * 200,
                    position1.z + (Math.random() - 0.5) * 200
                );
            }
            
            // Первый конец червоточины
            const end1Geometry = new THREE.TorusGeometry(5, 2, 16, 32);
            const end1Material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        vec2 center = vec2(0.5);
                        float dist = length(vUv - center);
                        
                        // Вращающийся портал
                        float angle = atan(vUv.y - 0.5, vUv.x - 0.5);
                        float spiral = sin(angle * 5.0 + time * 3.0 - dist * 10.0);
                        
                        vec3 color = mix(
                            vec3(1.0, 0.0, 1.0),
                            vec3(0.0, 1.0, 1.0),
                            spiral * 0.5 + 0.5
                        );
                        
                        gl_FragColor = vec4(color, 0.8);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const end1 = new THREE.Mesh(end1Geometry, end1Material);
            end1.position.copy(position1);
            scene.add(end1);
            
            // Второй конец червоточины
            const end2 = new THREE.Mesh(end1Geometry, end1Material.clone());
            end2.position.copy(position2);
            scene.add(end2);
            
            // Визуализация связи между концами
            const connectionGeometry = new THREE.BufferGeometry();
            const connectionMaterial = new THREE.LineBasicMaterial({
                color: 0xff00ff,
                transparent: true,
                opacity: 0.3
            });
            
            // Создаем искривленную линию между концами
            const points = [];
            const segments = 50;
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const midPoint = position1.clone().lerp(position2, t);
                
                // Добавляем искривление
                const offset = new THREE.Vector3(
                    Math.sin(t * Math.PI) * 20,
                    Math.cos(t * Math.PI * 2) * 10,
                    Math.sin(t * Math.PI * 3) * 15
                );
                midPoint.add(offset);
                
                points.push(midPoint);
            }
            
            connectionGeometry.setFromPoints(points);
            const connection = new THREE.Line(connectionGeometry, connectionMaterial);
            scene.add(connection);
            
            // Сохраняем информацию о червоточине
            const wormhole = {
                end1: end1,
                end2: end2,
                connection: connection,
                position1: position1,
                position2: position2,
                active: true
            };
            
            // Добавляем в специальный массив для обработки телепортации
            if (!window.wormholes) window.wormholes = [];
            window.wormholes.push(wormhole);
            
            updateInfo(`Создана червоточина, соединяющая две точки пространства!`);
            
            return wormhole;
        }

        // Создание космической струны
        function createCosmicString(startPos, endPos) {
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float phase;
                    varying float vPhase;
                    uniform float time;
                    
                    void main() {
                        vPhase = phase;
                        vec3 newPosition = position;
                        
                        // Вибрация струны
                        float vibration = sin(phase * 10.0 + time * 5.0) * 2.0;
                        newPosition.x += vibration;
                        newPosition.y += cos(phase * 8.0 + time * 4.0) * 2.0;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying float vPhase;
                    
                    void main() {
                        vec3 color = vec3(0.0, 1.0, 1.0);
                        float brightness = sin(vPhase * 20.0 + time * 10.0) * 0.5 + 0.5;
                        
                        gl_FragColor = vec4(color * brightness, 0.8);
                    }
                `,
                transparent: true,
                linewidth: 3
            });
            
            // Создаем точки вдоль струны
            const points = [];
            const phases = [];
            const segments = 100;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const point = startPos.clone().lerp(endPos, t);
                points.push(point.x, point.y, point.z);
                phases.push(t);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            geometry.setAttribute('phase', new THREE.Float32BufferAttribute(phases, 1));
            
            const cosmicString = new THREE.Line(geometry, material);
            scene.add(cosmicString);
            
            // Гравитационное искажение вокруг струны
            const distortionGeometry = new THREE.CylinderGeometry(
                5, 5, 
                startPos.distanceTo(endPos), 
                16, 1, true
            );
            const distortionMaterial = new THREE.MeshBasicMaterial({
                color: 0x0080ff,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            
            const distortion = new THREE.Mesh(distortionGeometry, distortionMaterial);
            distortion.position.copy(startPos.clone().add(endPos).multiplyScalar(0.5));
            distortion.lookAt(endPos);
            distortion.rotateX(Math.PI / 2);
            scene.add(distortion);
            
            return {
                string: cosmicString,
                distortion: distortion,
                material: material
            };
        }

        // Создание квантовой флуктуации
        function createQuantumFluctuation(position) {
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.5
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            scene.add(mesh);
            
            const fluctuation = {
                mesh: mesh,
                position: position.clone(),
                energy: Math.random(),
                phase: Math.random() * Math.PI * 2
            };
            
            quantumFluctuations.push(fluctuation);
            
            // Анимация мерцания
            const animate = () => {
                if (fluctuation.mesh) {
                    fluctuation.phase += 0.1;
                    fluctuation.mesh.scale.setScalar(1 + 0.5 * Math.sin(fluctuation.phase));
                    fluctuation.mesh.material.opacity = 0.3 + 0.3 * Math.sin(fluctuation.phase * 2);
                }
            };
            
            fluctuation.animate = animate;
        }

        // Создание поля темной энергии
        function createDarkEnergyField() {
            const geometry = new THREE.BoxGeometry(500, 500, 500);
            const material = new THREE.MeshBasicMaterial({
                color: 0x000066,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            
            const darkEnergyMesh = new THREE.Mesh(geometry, material);
            scene.add(darkEnergyMesh);
            
            // Пульсация темной энергии
            darkEnergyMesh.userData.update = (time) => {
                darkEnergyMesh.scale.setScalar(1 + 0.05 * Math.sin(time * 0.5));
                darkEnergyMesh.material.opacity = 0.1 + 0.05 * Math.sin(time * 0.3);
            };
        }

        // Создание структуры бран
        function createBraneStructure() {
            // Создаем несколько параллельных бран
            for (let i = 0; i < 3; i++) {
                const braneGeometry = new THREE.PlaneGeometry(300, 300, 50, 50);
                const braneMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(i / 3, 0.7, 0.5),
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide,
                    wireframe: true
                });
                
                const braneMesh = new THREE.Mesh(braneGeometry, braneMaterial);
                braneMesh.position.y = (i - 1) * 100;
                braneMesh.rotation.x = Math.PI / 2;
                scene.add(braneMesh);
                
                // Добавляем волновые искажения на бране
                braneMesh.userData.update = (time) => {
                    const positions = braneMesh.geometry.attributes.position;
                    for (let j = 0; j < positions.count; j++) {
                        const x = positions.getX(j);
                        const y = positions.getY(j);
                        const waveZ = Math.sin(x * 0.02 + time) * Math.cos(y * 0.02 + time) * 5;
                        positions.setZ(j, waveZ);
                    }
                    positions.needsUpdate = true;
                };
                
                // Создаем объекты на каждой бране
                for (let j = 0; j < 10; j++) {
                    const position = new THREE.Vector3(
                        (Math.random() - 0.5) * 200,
                        (i - 1) * 100,
                        (Math.random() - 0.5) * 200
                    );
                    createStar(position);
                }
            }
        }

        // Создание квантовой пены
        function createQuantumFoam() {
            const foamParticles = new THREE.BufferGeometry();
            const foamMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.2,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < 5000; i++) {
                positions.push(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
                colors.push(Math.random(), Math.random(), Math.random());
            }
            
            foamParticles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            foamParticles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const foam = new THREE.Points(foamParticles, foamMaterial);
            scene.add(foam);
            
            // Анимация квантовой пены
            foam.userData.update = (time) => {
                const positions = foam.geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    
                    positions.setX(i, x + (Math.random() - 0.5) * 0.5);
                    positions.setY(i, y + (Math.random() - 0.5) * 0.5);
                    positions.setZ(i, z + (Math.random() - 0.5) * 0.5);
                    
                    // Возвращаем частицы в границы
                    if (Math.abs(positions.getX(i)) > 50) positions.setX(i, x);
                    if (Math.abs(positions.getY(i)) > 50) positions.setY(i, y);
                    if (Math.abs(positions.getZ(i)) > 50) positions.setZ(i, z);
                }
                positions.needsUpdate = true;
            };
        }

        function showObjectInfo(obj) {
            let info = `<h3>${obj.type.charAt(0).toUpperCase() + obj.type.slice(1)}</h3>`;
            info += `<p><strong>Масса:</strong> ${obj.mass.toFixed(2)} M☉</p>`;
            info += `<p><strong>Возраст:</strong> ${(obj.age / 1000000).toFixed(2)} млн лет</p>`;
            info += `<p><strong>Температура:</strong> ${obj.temperature.toFixed(0)} K</p>`;
            info += `<p><strong>Скорость:</strong> ${obj.velocity.length().toFixed(2)} км/с</p>`;
            
            if (obj.type === 'star') {
                info += `<p><strong>Стадия:</strong> ${obj.evolutionStage}</p>`;
                info += `<p><strong>Топливо:</strong> ${(obj.fuelRemaining * 100).toFixed(1)}%</p>`;
                info += `<p><strong>Светимость:</strong> ${obj.luminosity.toFixed(2)} L☉</p>`;
            }
            
            if (obj.type === 'planet' && obj.hasLife) {
                info += `<p><strong>Жизнь:</strong> ${obj.lifeStage}</p>`;
            }
            
            if (obj.type === 'blackhole') {
                info += `<p><strong>Радиус Шварцшильда:</strong> ${obj.schwarzschildRadius.toFixed(3)} км</p>`;
            }
            
            document.getElementById('info-content').innerHTML = info;
        }

        function showObjectProperties(obj) {
            // Создаем панель свойств для манипуляции объектом
            const panel = document.createElement('div');
            panel.className = 'control-panel';
            panel.style.cssText = `
                position: absolute;
                top: 50%;
                right: 20px;
                transform: translateY(-50%);
                width: 250px;
            `;
            
            panel.innerHTML = `
                <h3>Свойства объекта</h3>
                <div class="parameter-slider">
                    <label>Масса: <span id="obj-mass-value">${obj.mass.toFixed(2)}</span></label>
                    <input type="range" id="obj-mass" min="0.1" max="100" step="0.1" value="${obj.mass}">
                </div>
                <div class="parameter-slider">
                    <label>Скорость X: <span id="obj-vx-value">${obj.velocity.x.toFixed(2)}</span></label>
                    <input type="range" id="obj-vx" min="-50" max="50" step="0.1" value="${obj.velocity.x}">
                </div>
                <div class="parameter-slider">
                    <label>Скорость Y: <span id="obj-vy-value">${obj.velocity.y.toFixed(2)}</span></label>
                    <input type="range" id="obj-vy" min="-50" max="50" step="0.1" value="${obj.velocity.y}">
                </div>
                <div class="parameter-slider">
                    <label>Скорость Z: <span id="obj-vz-value">${obj.velocity.z.toFixed(2)}</span></label>
                    <input type="range" id="obj-vz" min="-50" max="50" step="0.1" value="${obj.velocity.z}">
                </div>
                <button class="tool-button" onclick="this.parentElement.remove()">Закрыть</button>
            `;
            
            document.getElementById('ui-overlay').appendChild(panel);
            
            // Добавляем обработчики
            document.getElementById('obj-mass').addEventListener('input', function() {
                obj.mass = parseFloat(this.value);
                document.getElementById('obj-mass-value').textContent = obj.mass.toFixed(2);
                if (obj.mesh) {
                    const scale = Math.cbrt(obj.mass / 10);
                    obj.mesh.scale.setScalar(scale);
                }
            });
            
            document.getElementById('obj-vx').addEventListener('input', function() {
                obj.velocity.x = parseFloat(this.value);
                document.getElementById('obj-vx-value').textContent = obj.velocity.x.toFixed(2);
            });
            
            document.getElementById('obj-vy').addEventListener('input', function() {
                obj.velocity.y = parseFloat(this.value);
                document.getElementById('obj-vy-value').textContent = obj.velocity.y.toFixed(2);
            });
            
            document.getElementById('obj-vz').addEventListener('input', function() {
                obj.velocity.z = parseFloat(this.value);
                document.getElementById('obj-vz-value').textContent = obj.velocity.z.toFixed(2);
            });
        }

        // Класс для управления визуальными эффектами
        class VisualEffects {
            constructor(scene) {
                this.scene = scene;
                this.activeEffects = [];
            }
            
            createNebula(position, size = 50, color = 0x8080ff) {
                const geometry = new THREE.BufferGeometry();
                const particles = 5000;
                const positions = new Float32Array(particles * 3);
                const colors = new Float32Array(particles * 3);
                const sizes = new Float32Array(particles);
                
                const baseColor = new THREE.Color(color);
                
                for (let i = 0; i < particles; i++) {
                    // Распределение частиц в сферическом объеме
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.pow(Math.random(), 0.5) * size;
                    
                    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = r * Math.cos(phi);
                    
                    // Вариации цвета
                    const colorVariation = 0.2;
                    colors[i * 3] = baseColor.r + (Math.random() - 0.5) * colorVariation;
                    colors[i * 3 + 1] = baseColor.g + (Math.random() - 0.5) * colorVariation;
                    colors[i * 3 + 2] = baseColor.b + (Math.random() - 0.5) * colorVariation;
                    
                    sizes[i] = Math.random() * 3 + 1;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        texture: { value: this.createNebulaTexture() }
                    },
                    vertexShader: `
                        attribute float size;
                        varying vec3 vColor;
                        uniform float time;
                        
                        void main() {
                            vColor = color;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            
                            // Пульсация размера
                            float pulse = sin(time * 2.0 + position.x * 0.1) * 0.1 + 1.0;
                            gl_PointSize = size * pulse * (300.0 / -mvPosition.z);
                            
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D texture;
                        varying vec3 vColor;
                        
                        void main() {
                            vec4 texColor = texture2D(texture, gl_PointCoord);
                            gl_FragColor = vec4(vColor, 1.0) * texColor;
                        }
                    `,
                    vertexColors: true,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const nebula = new THREE.Points(geometry, material);
                nebula.position.copy(position);
                this.scene.add(nebula);
                
                this.activeEffects.push({
                    type: 'nebula',
                    mesh: nebula,
                    material: material
                });
                
                return nebula;
            }
            
            createNebulaTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
                gradient.addColorStop(0.4, 'rgba(255,200,200,0.6)');
                gradient.addColorStop(0.7, 'rgba(255,150,150,0.3)');
                gradient.addColorStop(1, 'rgba(255,100,100,0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 64);
                
                return new THREE.CanvasTexture(canvas);
            }
            
            createGravitationalWave(center, radius = 100) {
                const geometry = new THREE.RingGeometry(0, radius, 64, 8);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        waveSpeed: { value: 50 },
                        maxRadius: { value: radius }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        varying float vRadius;
                        void main() {
                            vUv = uv;
                            vRadius = length(position.xy);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float waveSpeed;
                        uniform float maxRadius;
                        varying vec2 vUv;
                        varying float vRadius;
                        
                        void main() {
                            float waveRadius = time * waveSpeed;
                            float waveFront = 1.0 - abs(vRadius - waveRadius) / 10.0;
                            waveFront = clamp(waveFront, 0.0, 1.0);
                            
                            // Затухание волны
                            float decay = 1.0 - (waveRadius / maxRadius);
                            decay = clamp(decay, 0.0, 1.0);
                            
                            vec3 color = vec3(0.5, 0.3, 1.0);
                            gl_FragColor = vec4(color, waveFront * decay * 0.5);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                const wave = new THREE.Mesh(geometry, material);
                wave.position.copy(center);
                this.scene.add(wave);
                
                this.activeEffects.push({
                    type: 'gravitationalWave',
                    mesh: wave,
                    material: material,
                    startTime: universeTime,
                    duration: radius / 50
                });
                
                return wave;
            }
            
            createSupernova(position) {
                // Вспышка
                const flashGeometry = new THREE.SphereGeometry(5, 32, 32);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 1
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.copy(position);
                this.scene.add(flash);
                
                // Ударная волна
                const shockwaveGeometry = new THREE.SphereGeometry(1, 32, 32);
                const shockwaveMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        uniform float time;
                        void main() {
                            vNormal = normal;
                            vec3 newPosition = position * (1.0 + time * 20.0);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vNormal;
                        uniform float time;
                        void main() {
                            float intensity = pow(0.8 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0);
                            vec3 color = mix(vec3(1.0, 0.8, 0.0), vec3(1.0, 0.0, 0.0), time);
                            float opacity = (1.0 - time) * intensity;
                            gl_FragColor = vec4(color, opacity);
                        }
                    `,
                    transparent: true,
                    side: THREE.BackSide,
                    depthWrite: false
                });
                const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                shockwave.position.copy(position);
                this.scene.add(shockwave);
                
                // Частицы взрыва
                const debrisCount = 200;
                const debris = [];
                for (let i = 0; i < debrisCount; i++) {
                    const debrisGeometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.3, 8, 8);
                    const debrisMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.1 * Math.random(), 1, 0.5),
                        transparent: true
                    });
                    const debrisMesh = new THREE.Mesh(debrisGeometry, debrisMaterial);
                    debrisMesh.position.copy(position);
                    
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5),
                        (Math.random() - 0.5),
                        (Math.random() - 0.5)
                    ).normalize().multiplyScalar(20 + Math.random() * 30);
                    
                    debrisMesh.userData.velocity = velocity;
                    this.scene.add(debrisMesh);
                    debris.push(debrisMesh);
                }
                
                this.activeEffects.push({
                    type: 'supernova',
                    flash: flash,
                    shockwave: shockwave,
                    shockwaveMaterial: shockwaveMaterial,
                    debris: debris,
                    startTime: universeTime,
                    duration: 3
                });
                
                // Создаем туманность на месте взрыва
                setTimeout(() => {
                    this.createNebula(position, 30, 0xff4400);
                }, 2000);
            }
            
            update(deltaTime) {
                // Обновляем все активные эффекты
                this.activeEffects = this.activeEffects.filter(effect => {
                    if (effect.material && effect.material.uniforms.time) {
                        effect.material.uniforms.time.value += deltaTime;
                    }
                    
                    if (effect.type === 'gravitationalWave') {
                        const elapsed = universeTime - effect.startTime;
                        if (elapsed > effect.duration) {
                            this.scene.remove(effect.mesh);
                            effect.mesh.geometry.dispose();
                            effect.material.dispose();
                            return false;
                        }
                    } else if (effect.type === 'supernova') {
                        const elapsed = universeTime - effect.startTime;
                        const progress = elapsed / effect.duration;
                        
                        if (progress < 1) {
                            // Анимация вспышки
                            effect.flash.scale.setScalar(1 + progress * 10);
                            effect.flash.material.opacity = 1 - progress;
                            
                            // Анимация ударной волны
                            effect.shockwaveMaterial.uniforms.time.value = progress;
                            
                            // Анимация обломков
                            effect.debris.forEach(debris => {
                                debris.position.add(debris.userData.velocity.clone().multiplyScalar(deltaTime));
                                debris.material.opacity = 1 - progress;
                            });
                        } else {
                            // Удаляем эффект
                            this.scene.remove(effect.flash);
                            this.scene.remove(effect.shockwave);
                            effect.debris.forEach(debris => this.scene.remove(debris));
                            return false;
                        }
                    }
                    
                    return true;
                });
            }
        }

        // Создаем экземпляр системы эффектов
        let visualEffects;

        // Проверка эмерджентных свойств
        function checkEmergentProperties() {
            const clusters = findClusters(objects, 50); // Радиус кластеризации
            
            for (let cluster of clusters) {
                if (cluster.length > 5 && Math.random() < emergenceLevel * 0.01) {
                    // Создаем эмерджентную структуру
                    const center = calculateCenterOfMass(cluster);
                    const emergentGeometry = new THREE.TorusGeometry(10, 3, 16, 100);
                    const emergentMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.3,
                        wireframe: true
                    });
                    const emergentMesh = new THREE.Mesh(emergentGeometry, emergentMaterial);
                    emergentMesh.position.copy(center);
                    scene.add(emergentMesh);
                    
                    // Удаляем через некоторое время
                    setTimeout(() => scene.remove(emergentMesh), 5000);
                }
            }
        }

        // Обновление дуалистических свойств
        function updateDualisticProperties() {
            for (let obj of objects) {
                if (!obj.spirit) {
                    // Создаем "духовную" копию
                    const spiritGeometry = obj.mesh.geometry.clone();
                    const spiritMaterial = new THREE.MeshBasicMaterial({
                        color: 0x8080ff,
                        transparent: true,
                        opacity: 0.3,
                        wireframe: true
                    });
                    const spiritMesh = new THREE.Mesh(spiritGeometry, spiritMaterial);
                    obj.mesh.add(spiritMesh);
                    obj.spirit = spiritMesh;
                }
                
                // Анимация духовной составляющей
                obj.spirit.rotation.x += 0.01;
                obj.spirit.rotation.y += 0.02;
                obj.spirit.scale.setScalar(1 + 0.2 * Math.sin(universeTime * 0.01));
            }
        }

        // Обновление для процессуальной философии
        function updateProcessPhilosophy() {
            for (let obj of objects) {
                // Постоянное изменение формы
                if (obj.mesh && obj.mesh.geometry) {
                    const scale = 1 + 0.1 * Math.sin(universeTime * 0.01 + obj.age);
                    obj.mesh.scale.x = scale;
                    obj.mesh.scale.y = scale * (1 + 0.1 * Math.sin(universeTime * 0.02));
                    obj.mesh.scale.z = scale * (1 + 0.1 * Math.cos(universeTime * 0.02));
                }
                
                // Изменение цвета как процесс
                if (obj.mesh && obj.mesh.material) {
                    const hue = (universeTime * 0.001 + obj.age * 0.01) % 1;
                    obj.mesh.material.color.setHSL(hue, 0.7, 0.5);
                }
            }
        }

        // Обновление информационной онтологии
        function updateInformationOntology() {
            // Визуализация информационных потоков
            for (let i = 0; i < objects.length - 1; i++) {
                for (let j = i + 1; j < objects.length; j++) {
                    const distance = objects[i].position.distanceTo(objects[j].position);
                    
                    if (distance < 50 && Math.random() < informationComplexity * 0.01) {
                        // Создаем информационную связь
                        const geometry = new THREE.BufferGeometry();
                        const material = new THREE.LineBasicMaterial({
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.5
                        });
                        
                        const positions = new Float32Array(6);
                        positions[0] = objects[i].position.x;
                        positions[1] = objects[i].position.y;
                        positions[2] = objects[i].position.z;
                        positions[3] = objects[j].position.x;
                        positions[4] = objects[j].position.y;
                        positions[5] = objects[j].position.z;
                        
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                        
                        // Удаляем через короткое время
                        setTimeout(() => scene.remove(line), 1000);
                    }
                }
            }
        }

        // Вспомогательные функции
        function findClusters(objects, radius) {
            const clusters = [];
            const visited = new Set();
            
            for (let obj of objects) {
                if (!visited.has(obj)) {
                    const cluster = [];
                    const queue = [obj];
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        if (!visited.has(current)) {
                            visited.add(current);
                            cluster.push(current);
                            
                            for (let other of objects) {
                                if (!visited.has(other) && 
                                    current.position.distanceTo(other.position) < radius) {
                                    queue.push(other);
                                }
                            }
                        }
                    }
                    
                    clusters.push(cluster);
                }
            }
            
            return clusters;
        }

        function calculateCenterOfMass(objects) {
            const center = new THREE.Vector3();
            let totalMass = 0;
            
            for (let obj of objects) {
                center.add(obj.position.clone().multiplyScalar(obj.mass));
                totalMass += obj.mass;
            }
            
            return center.divideScalar(totalMass);
        }

        // Управление камерой
        class CameraController {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                
                // Параметры управления
                this.rotateSpeed = 0.005;
                this.zoomSpeed = 0.1;
                this.panSpeed = 0.5;
                this.dampingFactor = 0.95;
                
                // Состояние
                this.isRotating = false;
                this.isPanning = false;
                this.mouseStart = new THREE.Vector2();
                this.mouseEnd = new THREE.Vector2();
                this.rotateVelocity = new THREE.Vector2();
                this.panVelocity = new THREE.Vector3();
                this.target = new THREE.Vector3(0, 0, 0);
                this.spherical = new THREE.Spherical();
                this.spherical.setFromVector3(camera.position);
                
                // Режимы камеры
                this.mode = 'orbit'; // 'orbit', 'free', 'follow'
                this.followTarget = null;
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                this.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.domElement.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.domElement.addEventListener('wheel', (e) => this.onWheel(e));
                
                // Клавиатурное управление
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
            }
            
            onMouseDown(event) {
                if (event.button === 0) { // Левая кнопка
                    this.isRotating = true;
                } else if (event.button === 2) { // Правая кнопка
                    this.isPanning = true;
                }
                
                this.mouseStart.set(event.clientX, event.clientY);
                this.mouseEnd.set(event.clientX, event.clientY);
            }
            
            onMouseMove(event) {
                this.mouseEnd.set(event.clientX, event.clientY);
                
                const deltaX = this.mouseEnd.x - this.mouseStart.x;
                const deltaY = this.mouseEnd.y - this.mouseStart.y;
                
                if (this.isRotating && this.mode === 'orbit') {
                    this.rotateVelocity.x = deltaX * this.rotateSpeed;
                    this.rotateVelocity.y = deltaY * this.rotateSpeed;
                } else if (this.isPanning) {
                    const distance = this.camera.position.length();
                    this.panVelocity.x = -deltaX * this.panSpeed * distance * 0.001;
                    this.panVelocity.y = deltaY * this.panSpeed * distance * 0.001;
                }
                
                this.mouseStart.copy(this.mouseEnd);
            }
            
            onMouseUp(event) {
                this.isRotating = false;
                this.isPanning = false;
            }
            
            onWheel(event) {
                event.preventDefault();
                const delta = event.deltaY * this.zoomSpeed;
                
                if (this.mode === 'orbit') {
                    this.spherical.radius *= 1 + delta * 0.001;
                    this.spherical.radius = Math.max(10, Math.min(1000, this.spherical.radius));
                } else {
                    this.camera.position.multiplyScalar(1 + delta * 0.001);
                }
            }
            
            onKeyDown(event) {
                switch(event.key) {
                    case 'f': // Следовать за объектом
                        this.toggleFollowMode();
                        break;
                    case 'o': // Орбитальный режим
                        this.setMode('orbit');
                        break;
                    case 'p': // Свободный режим
                        this.setMode('free');
                        break;
                    case 'r': // Сброс камеры
                        this.reset();
                        break;
                }
            }
            
            setMode(mode) {
                this.mode = mode;
                updateInfo(`Режим камеры: ${mode}`);
            }
            
            toggleFollowMode() {
                if (this.mode === 'follow') {
                    this.setMode('orbit');
                    this.followTarget = null;
                } else {
                    // Находим ближайший объект
                    let nearestObj = null;
                    let nearestDist = Infinity;
                    
                    for (let obj of objects) {
                        const dist = this.camera.position.distanceTo(obj.position);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestObj = obj;
                        }
                    }
                    
                    if (nearestObj) {
                        this.followTarget = nearestObj;
                        this.setMode('follow');
                        updateInfo(`Следим за объектом: ${nearestObj.type}`);
                    }
                }
            }
            
            reset() {
                this.camera.position.set(0, 50, 100);
                this.camera.lookAt(0, 0, 0);
                this.target.set(0, 0, 0);
                this.spherical.setFromVector3(this.camera.position);
                this.rotateVelocity.set(0, 0);
                this.panVelocity.set(0, 0, 0);
            }
            
            update(deltaTime) {
                if (this.mode === 'orbit') {
                    // Применяем вращение
                    this.spherical.theta -= this.rotateVelocity.x;
                    this.spherical.phi += this.rotateVelocity.y;
                    this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));
                    
                    // Применяем панорамирование
                    const offset = new THREE.Vector3();
                    const quat = new THREE.Quaternion().setFromUnitVectors(
                        this.camera.up, 
                        new THREE.Vector3(0, 1, 0)
                    );
                    offset.copy(this.panVelocity).applyQuaternion(quat);
                    this.target.add(offset);
                    
                    // Обновляем позицию камеры
                    const position = new THREE.Vector3().setFromSpherical(this.spherical);
                    position.add(this.target);
                    this.camera.position.copy(position);
                    this.camera.lookAt(this.target);
                    
                } else if (this.mode === 'follow' && this.followTarget) {
                    // Следуем за объектом
                    const offset = new THREE.Vector3(30, 20, 30);
                    const desiredPosition = this.followTarget.position.clone().add(offset);
                    this.camera.position.lerp(desiredPosition, deltaTime * 2);
                    this.camera.lookAt(this.followTarget.position);
                    
                    // Если объект уничтожен, выходим из режима следования
                    if (!objects.includes(this.followTarget)) {
                        this.setMode('orbit');
                        this.followTarget = null;
                    }
                }
                
                // Применяем затухание
                this.rotateVelocity.multiplyScalar(this.dampingFactor);
                this.panVelocity.multiplyScalar(this.dampingFactor);
            }
        }

        function setupCameraControls() {
            window.cameraController = new CameraController(camera, renderer.domElement);
            
            // Отключаем контекстное меню на правый клик
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        class PerformanceMonitor {
            constructor() {
                this.stats = {
                    fps: 0,
                    frameTime: 0,
                    drawCalls: 0,
                    triangles: 0,
                    objects: 0,
                    memory: 0
                };
                
                this.history = {
                    fps: [],
                    frameTime: [],
                    memory: []
                };
                
                this.maxHistoryLength = 100;
                this.lastTime = performance.now();
                this.frames = 0;
                
                this.createUI();
            }
            
            createUI() {
                const monitorDiv = document.createElement('div');
                monitorDiv.id = 'performance-monitor';
                monitorDiv.style.cssText = `
                    position: absolute;
                    bottom: 20px;
                    right: 20px;
                    background: rgba(0, 0, 0, 0.8);
                    color: #0f0;
                    font-family: monospace;
                    font-size: 12px;
                    padding: 10px;
                    border: 1px solid #0f0;
                    border-radius: 5px;
                    min-width: 200px;
                    z-index: 1000;
                `;
                
                monitorDiv.innerHTML = `
                    <div style="margin-bottom: 5px; color: #0f0; border-bottom: 1px solid #0f0;">Performance Monitor</div>
                    <div>FPS: <span id="mon-fps">0</span></div>
                    <div>Frame Time: <span id="mon-frametime">0</span>ms</div>
                    <div>Draw Calls: <span id="mon-drawcalls">0</span></div>
                    <div>Triangles: <span id="mon-triangles">0</span></div>
                    <div>Objects: <span id="mon-objects">0</span></div>
                    <div>Memory: <span id="mon-memory">0</span>MB</div>
                    <canvas id="fps-graph" width="180" height="50" style="margin-top: 10px; border: 1px solid #0f0;"></canvas>
                `;
                
                document.body.appendChild(monitorDiv);
                
                this.graphCanvas = document.getElementById('fps-graph');
                this.graphCtx = this.graphCanvas.getContext('2d');
            }
            
            update() {
                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastTime;
                this.frames++;
                
                // Обновляем статистику каждую секунду
                if (deltaTime >= 1000) {
                    this.stats.fps = Math.round((this.frames * 1000) / deltaTime);
                    this.stats.frameTime = Math.round(deltaTime / this.frames);
                    this.frames = 0;
                    this.lastTime = currentTime;
                    
                    // Подсчет draw calls и треугольников
                    this.stats.drawCalls = 0;
                    this.stats.triangles = 0;
                    
                    scene.traverse((child) => {
                        if (child.isMesh) {
                            this.stats.drawCalls++;
                            if (child.geometry) {
                                const geometry = child.geometry;
                                if (geometry.index) {
                                    this.stats.triangles += geometry.index.count / 3;
                                } else if (geometry.attributes.position) {
                                    this.stats.triangles += geometry.attributes.position.count / 3;
                                }
                            }
                        }
                    });
                    
                    this.stats.objects = objects.length;
                    
                    // Память (если доступно)
                    if (performance.memory) {
                        this.stats.memory = Math.round(performance.memory.usedJSHeapSize / 1048576);
                    }
                    
                    // Обновляем историю
                    this.history.fps.push(this.stats.fps);
                    this.history.frameTime.push(this.stats.frameTime);
                    this.history.memory.push(this.stats.memory);
                    
                    // Ограничиваем длину истории
                    if (this.history.fps.length > this.maxHistoryLength) {
                        this.history.fps.shift();
                        this.history.frameTime.shift();
                        this.history.memory.shift();
                    }
                    
                    this.updateUI();
                    this.drawGraph();
                }
            }
            
            updateUI() {
                document.getElementById('mon-fps').textContent = this.stats.fps;
                document.getElementById('mon-frametime').textContent = this.stats.frameTime;
                document.getElementById('mon-drawcalls').textContent = this.stats.drawCalls;
                document.getElementById('mon-triangles').textContent = this.formatNumber(this.stats.triangles);
                document.getElementById('mon-objects').textContent = this.stats.objects;
                document.getElementById('mon-memory').textContent = this.stats.memory;
                
                // Цветовая индикация FPS
                const fpsElement = document.getElementById('mon-fps');
                if (this.stats.fps >= 50) {
                    fpsElement.style.color = '#0f0';
                } else if (this.stats.fps >= 30) {
                    fpsElement.style.color = '#ff0';
                } else {
                    fpsElement.style.color = '#f00';
                }
            }
            
            drawGraph() {
                const ctx = this.graphCtx;
                const width = this.graphCanvas.width;
                const height = this.graphCanvas.height;
                
                // Очищаем канвас
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                // Рисуем сетку
                ctx.strokeStyle = '#030';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const y = (height / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // Рисуем график FPS
                if (this.history.fps.length > 1) {
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let i = 0; i < this.history.fps.length; i++) {
                        const x = (i / (this.maxHistoryLength - 1)) * width;
                        const y = height - (this.history.fps[i] / 60) * height;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.stroke();
                }
            }
            
            formatNumber(num) {
                if (num >= 1000000) {
                    return (num / 1000000).toFixed(1) + 'M';
                } else if (num >= 1000) {
                    return (num / 1000).toFixed(1) + 'K';
                }
                return num.toString();
            }
        }

        // Создаем монитор производительности
        let performanceMonitor;

        class RenderOptimizer {
            constructor(renderer, scene, camera) {
                this.renderer = renderer;
                this.scene = scene;
                this.camera = camera;
                
                // Настройки качества
                this.qualityLevels = {
                    ultra: {
                        shadowMapSize: 2048,
                        antialias: true,
                        pixelRatio: window.devicePixelRatio,
                        postProcessing: true
                    },
                    high: {
                        shadowMapSize: 1024,
                        antialias: true,
                        pixelRatio: Math.min(window.devicePixelRatio, 2),
                        postProcessing: true
                    },
                    medium: {
                        shadowMapSize: 512,
                        antialias: false,
                        pixelRatio: 1,
                        postProcessing: false
                    },
                    low: {
                        shadowMapSize: 256,
                        antialias: false,
                        pixelRatio: 0.75,
                        postProcessing: false
                    }
                };
                
                this.currentQuality = 'high';
                this.autoAdjust = true;
                this.targetFPS = 30;
                
                this.applyQualitySettings();
            }
            
            applyQualitySettings() {
                const settings = this.qualityLevels[this.currentQuality];
                
                // Применяем настройки рендерера
                this.renderer.setPixelRatio(settings.pixelRatio);
                this.renderer.shadowMap.enabled = settings.shadowMapSize > 0;
                
                if (this.renderer.shadowMap.enabled) {
                    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    // Обновляем размер теневых карт для всех источников света
                    this.scene.traverse((child) => {
                        if (child.isLight && child.castShadow) {
                            child.shadow.mapSize.width = settings.shadowMapSize;
                            child.shadow.mapSize.height = settings.shadowMapSize;
                        }
                    });
                }
                
                updateInfo(`Качество графики: ${this.currentQuality}`);
            }
            
            setQuality(level) {
                if (this.qualityLevels[level]) {
                    this.currentQuality = level;
                    this.applyQualitySettings();
                }
            }
            
            autoAdjustQuality(currentFPS) {
                if (!this.autoAdjust) return;
                
                if (currentFPS < this.targetFPS - 5) {
                    // Понижаем качество
                    if (this.currentQuality === 'ultra') {
                        this.setQuality('high');
                    } else if (this.currentQuality === 'high') {
                        this.setQuality('medium');
                    } else if (this.currentQuality === 'medium') {
                        this.setQuality('low');
                    }
                } else if (currentFPS > this.targetFPS + 10) {
                    // Повышаем качество
                    if (this.currentQuality === 'low') {
                        this.setQuality('medium');
                    } else if (this.currentQuality === 'medium') {
                        this.setQuality('high');
                    } else if (this.currentQuality === 'high') {
                        this.setQuality('ultra');
                    }
                }
            }
            
            enableFrustumCulling() {
                const frustum = new THREE.Frustum();
                const cameraMatrix = new THREE.Matrix4();
                
                return () => {
                    cameraMatrix.multiplyMatrices(
                        this.camera.projectionMatrix,
                        this.camera.matrixWorldInverse
                    );
                    frustum.setFromProjectionMatrix(cameraMatrix);
                    
                    // Проверяем видимость объектов
                    for (let obj of objects) {
                        if (obj.mesh) {
                            obj.mesh.visible = frustum.intersectsObject(obj.mesh);
                        }
                    }
                };
            }
        }

        // Обработчики событий
        function setupEventHandlers() {
            // Создаем панель помощи в начале
            const helpPanel = document.createElement('div');
            helpPanel.className = 'control-panel';
            helpPanel.style.cssText = `
                position: absolute;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                display: none;
                max-width: 400px;
                z-index: 1001;
            `;
            helpPanel.innerHTML = `
                <h3>Горячие клавиши</h3>
                <table style="font-size: 12px;">
                    <tr><td>Пробел</td><td>Пауза</td></tr>
                    <tr><td>H</td><td>Показать/скрыть интерфейс</td></tr>
                    <tr><td>M</td><td>Монитор производительности</td></tr>
                    <tr><td>G</td><td>Сетка</td></tr>
                    <tr><td>F</td><td>Следовать за объектом</td></tr>
                    <tr><td>O</td><td>Орбитальная камера</td></tr>
                    <tr><td>P</td><td>Свободная камера</td></tr>
                    <tr><td>R</td><td>Сброс камеры</td></tr>
                    <tr><td>1-9</td><td>Быстрый выбор инструментов</td></tr>
                    <tr><td>Delete</td><td>Удалить ближайший объект</td></tr>
                </table>
            `;
            document.getElementById('ui-overlay').appendChild(helpPanel);
            
            // Сохраняем ссылку глобально
            window.helpPanel = helpPanel;

            // Выбор космологической модели
            document.querySelectorAll('#cosmology-panel .model-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('#cosmology-panel .model-option').forEach(o => o.classList.remove('active'));
                    this.classList.add('active');
                    cosmologyModel = this.dataset.model;
                    initializeUniverse();
                    updateInfo(`Активирована модель: ${this.querySelector('strong').textContent}`);
                });
            });

            // Выбор философской парадигмы
            document.querySelectorAll('#philosophy-panel .model-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('#philosophy-panel .model-option').forEach(o => o.classList.remove('active'));
                    this.classList.add('active');
                    philosophyModel = this.dataset.philosophy;
                    
                    // Обновляем визуальный стиль
                    document.body.className = `philosophy-${philosophyModel}`;
                    updateFog();
                    
                    // Обновляем материалы существующих объектов
                    objects.forEach(obj => {
                        if (obj.mesh && obj.type === 'star') {
                            const oldMaterial = obj.mesh.material;
                            obj.mesh.material = AdvancedMaterials.createStarMaterial(philosophyModel);
                            if (oldMaterial.dispose) oldMaterial.dispose();
                        } else if (obj.mesh && obj.type === 'planet') {
                            const oldMaterial = obj.mesh.material;
                            obj.mesh.material = AdvancedMaterials.createPlanetMaterial(philosophyModel);
                            if (oldMaterial.dispose) oldMaterial.dispose();
                        }
                    });
                    
                    updateInfo(`Активирована парадигма: ${this.querySelector('strong').textContent}`);
                });
            });

            // Выбор инструментов
            document.querySelectorAll('.tool-button').forEach(button => {
                button.addEventListener('click', function() {
                    document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    selectedTool = this.dataset.tool;
                    updateInfo(`Выбран инструмент: ${this.textContent}`);
                });
            });

            // Слайдеры параметров
            document.getElementById('time-speed').addEventListener('input', function() {
                timeSpeed = parseFloat(this.value);
                document.getElementById('time-speed-value').textContent = timeSpeed.toFixed(1);
            });

            document.getElementById('gravity-constant').addEventListener('input', function() {
                gravityConstant = parseFloat(this.value);
                document.getElementById('gravity-value').textContent = gravityConstant.toFixed(1);
            });

            document.getElementById('quantum-uncertainty').addEventListener('input', function() {
                quantumUncertainty = parseFloat(this.value);
                document.getElementById('quantum-value').textContent = quantumUncertainty.toFixed(2);
            });

            document.getElementById('entropy-level').addEventListener('input', function() {
                entropyLevel = parseFloat(this.value);
                document.getElementById('entropy-value').textContent = entropyLevel.toFixed(2);
            });

            document.getElementById('dark-energy').addEventListener('input', function() {
                darkEnergy = parseFloat(this.value);
                document.getElementById('dark-energy-value').textContent = darkEnergy.toFixed(2);
            });

            document.getElementById('inflation-field').addEventListener('input', function() {
                inflationField = parseFloat(this.value);
                document.getElementById('inflation-field-value').textContent = inflationField.toFixed(2);
            });

            document.getElementById('emergence-level').addEventListener('input', function() {
                emergenceLevel = parseFloat(this.value);
                document.getElementById('emergence-value').textContent = emergenceLevel.toFixed(2);
            });

            document.getElementById('information-complexity').addEventListener('input', function() {
                informationComplexity = parseFloat(this.value);
                document.getElementById('information-value').textContent = informationComplexity.toFixed(2);
            });

            // Клики по канвасу
            renderer.domElement.addEventListener('click', handleCanvasClick);

            // Изменение размера окна
            window.addEventListener('resize', onWindowResize);
        }

        // Обработка кликов по канвасу
        function handleCanvasClick(event) {
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // Создаем плоскость для определения позиции клика в 3D пространстве
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersection);

            switch (selectedTool) {
                case 'create-star':
                    createStar(intersection);
                    updateInfo('Создана новая звезда');
                    break;
                case 'create-planet':
                    createPlanet(intersection);
                    updateInfo('Создана новая планета');
                    break;
                case 'create-blackhole':
                    createBlackHole(intersection);
                    updateInfo('Создана черная дыра');
                    break;
                case 'create-galaxy':
                    createGalaxy(intersection);
                    updateInfo('Создана новая галактика');
                    break;
                case 'create-neutronstar':
                    createNeutronStar(intersection);
                    updateInfo('Создана нейтронная звезда');
                    break;
                case 'create-quasar':
                    createQuasar(intersection);
                    updateInfo('Создан квазар - самый яркий объект во вселенной!');
                    break;
                case 'create-darkmatter':
                    createDarkMatter(intersection);
                    updateInfo('Создано облако темной материи');
                    break;
                case 'create-wormhole':
                    if (!window.wormholeStart) {
                        window.wormholeStart = intersection.clone();
                        updateInfo('Выберите второй конец червоточины');
                    } else {
                        createWormhole(window.wormholeStart, intersection);
                        window.wormholeStart = null;
                    }
                    break;
                case 'manipulate':
                    // Проверяем пересечение с объектами
                    const intersects = raycaster.intersectObjects(scene.children, true);
                    if (intersects.length > 0) {
                        const obj = objects.find(o => o.mesh === intersects[0].object || o.mesh === intersects[0].object.parent);
                        if (obj) {
                            // Открываем панель свойств объекта
                            showObjectProperties(obj);
                        }
                    }
                    break;
                case 'observe':
                    // Режим наблюдения - показываем информацию об объекте
                    const observeIntersects = raycaster.intersectObjects(scene.children, true);
                    if (observeIntersects.length > 0) {
                        const obj = objects.find(o => o.mesh === observeIntersects[0].object || o.mesh === observeIntersects[0].object.parent);
                        if (obj) {
                            showObjectInfo(obj);
                        }
                    }
                    break;
            }
        }

        // Обновление информационной панели
        function updateInfo(message) {
            const infoContent = document.getElementById('info-content');
            infoContent.innerHTML = `<p>${message}</p>` + infoContent.innerHTML;
            if (infoContent.children.length > 5) {
                infoContent.removeChild(infoContent.lastChild);
            }
        }

        // Изменение размера окна
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Анимация
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            universeTime += deltaTime * timeSpeed;
            
            // Обновляем octree
            octree.clear();
            for (let obj of objects) {
                octree.insert(obj);
            }
            
            // Обновление объектов с использованием octree для оптимизации
            for (let obj of objects) {
                // Получаем только близкие объекты для расчета взаимодействий
                const nearbyObjects = octree.retrieve(obj);
                obj.update(deltaTime, nearbyObjects);
            }
            
            // Обновляем LOD
            lodSystem.update(camera, objects);
            
            // Обновляем камеру
            if (window.cameraController) {
                window.cameraController.update(deltaTime);
            }
            
            // Обновляем систему плагинов
            pluginSystem.update(deltaTime);
            
            // Специальные эффекты для космологических моделей
            updateCosmologicalEffects(deltaTime);
            
            // Обновляем визуальные эффекты
            if (visualEffects) {
                visualEffects.update(deltaTime);
            }
            
            // Обновляем анимации объектов
            updateObjectAnimations(deltaTime);
            
            // Frustum culling
            //if (frustumCulling) {
            //    frustumCulling();
            //}
            // Frustum culling уже выполняется в LODSystem
            
            // Обновление статистики
            updateStats();
            
            // Обновляем монитор производительности
            performanceMonitor.update();
            
            // Авто-настройка качества
            if (renderOptimizer && performanceMonitor.stats.fps > 0) {
                renderOptimizer.autoAdjustQuality(performanceMonitor.stats.fps);
            }
            
            // Рендеринг
            renderer.render(scene, camera);
            
            // Выполняем хуки после рендеринга
            pluginSystem.executeHooks('render');
        }

        // Вынесенные функции для лучшей организации
        function updateCosmologicalEffects(deltaTime) {
            if (cosmologyModel === 'bigbang' && universeTime < 10) {
                // Расширение вселенной
                for (let obj of objects) {
                    obj.position.multiplyScalar(1 + deltaTime * 0.1);
                }
            } else if (cosmologyModel === 'steady' && Math.random() < 0.001) {
                // Спонтанное создание материи
                const position = new THREE.Vector3(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200
                );
                createPlanet(position);
            } else if (cosmologyModel === 'cyclic') {
                // Циклическое расширение и сжатие
                const scale = 1 + 0.3 * Math.sin(universeTime * 0.1);
                for (let obj of objects) {
                    obj.position.multiplyScalar(scale / (scale - 0.001));
                }
            }
            // ... остальные эффекты
        }

        function updateObjectAnimations(deltaTime) {
            scene.traverse((child) => {
                if (child.material && child.material.uniforms && child.material.uniforms.time) {
                    child.material.uniforms.time.value = universeTime;
                }
                
                // Анимация корон звезд
                if (child.userData.corona) {
                    child.userData.corona.rotation.y += deltaTime * 0.5;
                    child.userData.corona.rotation.z += deltaTime * 0.3;
                }
                
                // Анимация атмосфер планет
                if (child.userData.atmosphere && child.userData.atmosphere.material.uniforms) {
                    child.userData.atmosphere.material.uniforms.time.value = universeTime;
                }
                
                // Вращение аккреционных дисков
                if (child.userData.disk) {
                    child.userData.disk.rotation.z += deltaTime * 0.5;
                    if (child.userData.disk.material.uniforms && child.userData.disk.material.uniforms.time) {
                        child.userData.disk.material.uniforms.time.value = universeTime;
                    }
                }
                
                // Обновление пользовательских анимаций
                if (child.userData.update) {
                    child.userData.update(universeTime);
                }
            });
        }

        function updateStats() {
            stats.frameCount++;
            const currentTime = performance.now();
            if (currentTime >= stats.lastTime + 1000) {
                stats.fps = Math.round((stats.frameCount * 1000) / (currentTime - stats.lastTime));
                stats.lastTime = currentTime;
                stats.frameCount = 0;
                
                document.getElementById('fps').textContent = stats.fps;
                document.getElementById('object-count').textContent = objects.length;
                document.getElementById('universe-time').textContent = (universeTime / 10).toFixed(2);
            }
        }

        // Система горячих клавиш
        document.addEventListener('keydown', (event) => {
            // Предотвращаем действия по умолчанию для некоторых клавиш
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'F1'].includes(event.code)) {
                event.preventDefault();
            }
            
            switch(event.code) {
                case 'Space':
                    // Пауза
                    timeSpeed = timeSpeed > 0 ? 0 : 1;
                    document.getElementById('time-speed').value = timeSpeed;
                    document.getElementById('time-speed-value').textContent = timeSpeed.toFixed(1);
                    updateInfo(timeSpeed > 0 ? 'Время возобновлено' : 'Пауза');
                    break;
                    
                case 'KeyH':
                    // Показать/скрыть UI
                    const uiOverlay = document.getElementById('ui-overlay');
                    uiOverlay.style.display = uiOverlay.style.display === 'none' ? 'block' : 'none';
                    break;

                case 'F1':
                    event.preventDefault();
                    if (window.helpPanel) {
                        window.helpPanel.style.display = window.helpPanel.style.display === 'none' ? 'block' : 'none';
                    }
                    break;
                    
                case 'KeyM':
                    // Показать/скрыть монитор производительности
                    const perfMon = document.getElementById('performance-monitor');
                    perfMon.style.display = perfMon.style.display === 'none' ? 'block' : 'none';
                    break;
                    
                case 'KeyG':
                    // Переключить сетку
                    if (!window.gridHelper) {
                        window.gridHelper = new THREE.GridHelper(1000, 50, 0x444444, 0x222222);
                        scene.add(window.gridHelper);
                    } else {
                        window.gridHelper.visible = !window.gridHelper.visible;
                    }
                    break;
                    
                case 'Digit1':
                case 'Digit2':
                case 'Digit3':
                case 'Digit4':
                case 'Digit5':
                case 'Digit6':
                case 'Digit7':
                case 'Digit8':
                case 'Digit9':
                    // Быстрый выбор инструментов
                    const toolIndex = parseInt(event.code.replace('Digit', '')) - 1;
                    const toolButtons = document.querySelectorAll('#tools-panel .tool-button');
                    if (toolButtons[toolIndex]) {
                        toolButtons[toolIndex].click();
                    }
                    break;
                    
                case 'Delete':
                    // Удалить ближайший объект к камере
                    let nearestObj = null;
                    let nearestDist = Infinity;
                    for (let obj of objects) {
                        const dist = camera.position.distanceTo(obj.position);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestObj = obj;
                        }
                    }
                    if (nearestObj) {
                        nearestObj.destroy();
                        updateInfo(`Удален объект: ${nearestObj.type}`);
                    }
                    break;
            }
        });

        // Показать подсказки по горячим клавишам
        const helpPanel = document.createElement('div');
        helpPanel.className = 'control-panel';
        helpPanel.style.cssText = `
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            max-width: 400px;
        `;
        helpPanel.innerHTML = `
            <h3>Горячие клавиши</h3>
            <table style="font-size: 12px;">
                <tr><td>Пробел</td><td>Пауза</td></tr>
                <tr><td>H</td><td>Показать/скрыть интерфейс</td></tr>
                <tr><td>M</td><td>Монитор производительности</td></tr>
                <tr><td>G</td><td>Сетка</td></tr>
                <tr><td>F</td><td>Следовать за объектом</td></tr>
                <tr><td>O</td><td>Орбитальная камера</td></tr>
                <tr><td>P</td><td>Свободная камера</td></tr>
                <tr><td>R</td><td>Сброс камеры</td></tr>
                <tr><td>1-9</td><td>Быстрый выбор инструментов</td></tr>
                <tr><td>Delete</td><td>Удалить ближайший объект</td></tr>
            </table>
        `;
        document.getElementById('ui-overlay').appendChild(helpPanel);

        // Показывать подсказки при нажатии на F1
        //document.addEventListener('keydown', (event) => {
        //    if (event.code === 'F1') {
        //        event.preventDefault();
        //        helpPanel.style.display = helpPanel.style.display === 'none' ? 'block' : 'none';
        //    }
        // });

        // Создаем приветственный экран
        function createWelcomeScreen() {
            const welcomeDiv = document.createElement('div');
            welcomeDiv.id = 'welcome-screen';
            welcomeDiv.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 20, 0.95);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                backdrop-filter: blur(10px);
            `;
            
            welcomeDiv.innerHTML = `
                <div style="text-align: center; max-width: 600px; padding: 40px;">
                    <h1 style="color: #8080ff; font-size: 3em; margin-bottom: 20px; text-shadow: 0 0 20px rgba(128, 128, 255, 0.5);">
                        Архитектор Вселенной
                    </h1>
                    <p style="color: #a0a0ff; font-size: 1.2em; margin-bottom: 30px; line-height: 1.6;">
                        Добро пожаловать в интерактивный симулятор вселенной!<br>
                        Создавайте звезды, планеты и галактики.<br>
                        Исследуйте различные космологические модели и философские парадигмы.<br>
                        Наблюдайте за эволюцией космоса и зарождением жизни.
                    </p>
                    <button onclick="document.getElementById('welcome-screen').style.display='none'" 
                            style="background: rgba(80, 80, 160, 0.8); color: white; border: 1px solid rgba(150, 150, 255, 0.5); 
                                   padding: 15px 30px; font-size: 1.1em; cursor: pointer; border-radius: 25px;
                                   transition: all 0.3s; box-shadow: 0 0 20px rgba(100, 100, 255, 0.3);"
                            onmouseover="this.style.background='rgba(100, 100, 200, 0.9)'"
                            onmouseout="this.style.background='rgba(80, 80, 160, 0.8)'">
                        Начать исследование
                    </button>
                    <p style="color: #606090; font-size: 0.9em; margin-top: 30px;">
                        Нажмите F1 для просмотра горячих клавиш
                    </p>
                </div>
            `;
            
            document.body.appendChild(welcomeDiv);
        }

        // Вызываем создание приветственного экрана при загрузке
        window.addEventListener('load', () => {
            createWelcomeScreen();
        });

        // Проверка автосохранения при загрузке
        window.addEventListener('load', () => {
            const autoSave = localStorage.getItem('universe_autosave');
            if (autoSave) {
                const loadAutoSave = confirm('Обнаружено автосохранение. Загрузить?');
                if (loadAutoSave) {
                    setTimeout(() => {
                        UniverseSerializer.load(autoSave);
                    }, 1000);
                }
            }
        });

        // Запуск приложения
        window.addEventListener('load', init);
    </script>
</body>
</html>