<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Шизография пред-языкового сознания</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        @font-face {
            font-family: 'Glitch';
            src: url('data:application/font-woff;charset=utf-8;base64,') format('woff');
            font-weight: normal;
            font-style: normal;
        }
        
        body {
            background-color: #010108;
            color: #e0e0e0;
            font-family: monospace;
            overflow: hidden;
            cursor: none;
            height: 100vh;
            position: relative;
        }
        
        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            perspective: 800px;
        }
        
                    .consciousness-fragment {
            position: absolute;
            transform-style: preserve-3d;
            font-size: 1.7rem;
            cursor: default;
            user-select: none;
            mix-blend-mode: difference;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55) when-hovering;
            padding: 15px;     /* Увеличиваем область клика */
            background-color: rgba(255, 255, 255, 0.01); /* Почти невидимый фон для расширения области клика */
            border-radius: 10px;
            }
            
            /* Подсветка при приближении курсора */
            .consciousness-fragment:hover {
                background-color: rgba(255, 255, 255, 0);
                box-shadow: 0 0 15px rgba(255, 255, 255, 0);
                z-index: 100;
            }
        
        .primal-symbol {
            position: absolute;
            font-size: 3rem;
            opacity: 0.8;
            transition: transform 1s, opacity 0.7s;
            pointer-events: none;
        }
        
        #thought-stream {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 60px;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
            text-align: justify;
            transform: skew(5deg);
        }
        
        #cartograph {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60vmin;
            height: 60vmin;
            border: 1px dashed rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transition: all 2s;
        }
        
        #cartograph::before {
            content: "";
            position: absolute;
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
            border: 1px dashed rgba(255, 255, 255, 0.15);
            border-radius: 50%;
        }
        
        #cartograph::after {
            content: "";
            position: absolute;
            width: 40%;
            height: 40%;
            top: 30%;
            left: 30%;
            border: 1px dashed rgba(255, 255, 255, 0.1);
            border-radius: 50%;
        }
        
        #custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.5);
            background-color: rgba(255, 255, 255, 0.1);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 9999;
            transition: 0.1s;
            mix-blend-mode: difference;
        }
        
        .noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iMzAwIj48ZmlsdGVyIGlkPSJub2lzZSIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSI+PGZlVHVyYnVsZW5jZSB0eXBlPSJmcmFjdGFsTm9pc2UiIGJhc2VGcmVxdWVuY3k9IjAuNjUiIG51bU9jdGF2ZXM9IjMiIHN0aXRjaFRpbGVzPSJzdGl0Y2giIHJlc3VsdD0ibm9pc2UiLz48ZmVDb2xvck1hdHJpeCB0eXBlPSJzYXR1cmF0ZSIgdmFsdWVzPSIwIiByZXN1bHQ9ImRlc2F0Ii8+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsdGVyPSJ1cmwoI25vaXNlKSIgb3BhY2l0eT0iMC4wNSIvPjwvZmlsdGVyPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbHRlcj0idXJsKCNub2lzZSkiLz48L3N2Zz4=');
            pointer-events: none;
            opacity: 0.05;
            z-index: 1000;
            mix-blend-mode: overlay;
        }
        
        .glitch {
            animation: glitch 1s linear infinite;
            position: relative;
        }
        
        @keyframes glitch {
            2%, 64% {
                transform: translate(2px, 0) skew(0deg);
            }
            4%, 60% {
                transform: translate(-2px, 0) skew(0deg);
            }
            62% {
                transform: translate(0, 0) skew(5deg);
            }
        }
        
        #title {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 1.8rem;
            letter-spacing: 3px;
            opacity: 0.6;
            transition: all 0.5s;
            transform: perspective(500px) rotateX(10deg);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.7);
        }
        
        #title:hover {
            letter-spacing: 8px;
            opacity: 1;
        }
        
        #meta-panel {
            position: absolute;
            right: 20px;
            top: 20px;
            width: 150px;
            height: auto;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.8rem;
            opacity: 0.6;
            backdrop-filter: blur(3px);
            transform: skew(-5deg);
        }
        
        .meta-value {
            margin-bottom: 5px;
            display: block;
        }
        
        #proto-language {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-family: monospace;
            font-size: 1.2rem;
            opacity: 0;
            transition: opacity 2s;
        }

        #audio-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            z-index: 9999;
            opacity: 0.6;
            transition: opacity 0.3s;
        }

        #audio-controls:hover {
            opacity: 1;
        }

        #audio-toggle {
            display: flex;
            align-items: center;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            padding: 5px 10px;
            background: rgba(30, 30, 40, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            backdrop-filter: blur(3px);
            font-family: monospace;
            font-size: 0.8rem;
            transform: skew(-5deg);
            margin-bottom: 5px;
        }

        #audio-toggle:hover {
            background: rgba(40, 40, 50, 0.8);
        }

        .audio-icon {
            margin-right: 8px;
            font-size: 1rem;
        }

        #volume-control {
            padding: 5px 10px;
            background: rgba(30, 30, 40, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            backdrop-filter: blur(3px);
            display: none;
            transform: skew(-5deg);
        }

        #audio-toggle:hover + #volume-control,
        #volume-control:hover {
            display: block;
        }

        #volume-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 80px;
            height: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            cursor: pointer;
        }

        #volume-slider::-moz-range-thumb {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            border: none;
        }

        .sound-visualization {
    position: absolute;
    pointer-events: none;
    border-radius: 50%;
    mix-blend-mode: screen;
    opacity: 0;
    transition: transform 1.5s ease-out, opacity 0.8s ease-in-out;
    filter: blur(2px);

        }
        
       
        }

    </style>
</head>
<body>
    <div id="custom-cursor"></div>
    <div class="noise-overlay"></div>
    
    <div id="container">
        <h1 id="title" class="glitch">Шизография пред-языкового сознания</h1>
        
        <div id="cartograph"></div>
        
        <div id="meta-panel">
            <span class="meta-value">δ: <span id="delta-value">0.3891</span></span>
            <span class="meta-value">φ: <span id="phi-value">1.6180</span></span>
            <span class="meta-value">τ: <span id="tau-value">0.0013</span></span>
            <span class="meta-value">∞: <span id="infinity-value">∞</span></span>
        </div>
        
        <div id="thought-stream"></div>
        
        <div id="proto-language"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {

            // Создаем хранилище для параметров анимации математических элементов
            const mathAnimations = new Map();

            // Запускаем анимацию математических элементов
            animateMathElements();

            // Регулярно создаем новые математические элементы
            setInterval(() => {
                // Устанавливаем ограничение на количество элементов
                if (mathAnimations.size < 20) {
                    createMathElement();
                }
            }, 2000); // Новый элемент каждые 2 секунды
            
            const container = document.getElementById('container');
            const cursor = document.getElementById('custom-cursor');
            const thoughtStream = document.getElementById('thought-stream');
            const cartograph = document.getElementById('cartograph');
            const protoLanguage = document.getElementById('proto-language');
            const metaValues = {
                delta: document.getElementById('delta-value'),
                phi: document.getElementById('phi-value'),
                tau: document.getElementById('tau-value'),
                infinity: document.getElementById('infinity-value')
            };
            
            let mouseX = 0;
            let mouseY = 0;
            let lastInteractionTime = Date.now();
            
            // Store animation parameters for each fragment
            const fragmentAnimations = new Map();
            
            // Pre-linguistic symbol fragments
            const prelingualSymbols = [
                '◯', '△', '□', '☾', '☀', '◬', '⌘', '⚇', '⚉', '⚆', 
                '⧫', '⧇', '⧅', '⧉', '⊛', '⊕', '⊗', '⊙', '⟡', '⟠',
                '⌬', '⍟', '⌖', '⏣', '◉', '◎', '◍', '◌', '◑', '◒',
                '⦿', '⨀', '⚪', '⚫', '⚬', '∞', '⋈', '⋉', '⋊', '⋋'
            ];
            
            // Расширенный массив prelingualWords (пред-языковые слова)
            const prelingualWords = [
                // Существующие элементы
                { word: 'амох', gender: 'муж', isAnim: false },
                { word: 'улу', gender: 'ср', isAnim: false },
                { word: 'нкра', gender: 'жен', isAnim: false },
                { word: 'ытю', gender: 'ср', isAnim: false },
                { word: 'эшь', gender: 'жен', isAnim: false },
                { word: 'юрг', gender: 'муж', isAnim: true },
                { word: 'къяф', gender: 'муж', isAnim: true },
                { word: 'фтал', gender: 'муж', isAnim: false },
                { word: 'бзых', gender: 'муж', isAnim: true },
                { word: 'мрач', gender: 'муж', isAnim: false },
                { word: 'иксуль', gender: 'муж', isAnim: false },
                { word: 'орним', gender: 'муж', isAnim: true },
                { word: 'апхта', gender: 'жен', isAnim: false },
                { word: 'лимш', gender: 'муж', isAnim: false },
                { word: 'ртэк', gender: 'муж', isAnim: false },
                { word: 'зопа', gender: 'жен', isAnim: false },
                { word: 'выхонь', gender: 'жен', isAnim: false },
                { word: 'дрифт', gender: 'муж', isAnim: false },
                { word: 'голум', gender: 'муж', isAnim: true },
                { word: 'шалт', gender: 'муж', isAnim: false },
                { word: 'екси', gender: 'ср', isAnim: false },
                { word: 'нисор', gender: 'муж', isAnim: false },
                { word: 'квант', gender: 'муж', isAnim: false },
                { word: 'плыть', gender: 'жен', isAnim: false },
                { word: 'хрон', gender: 'муж', isAnim: false },
                
                // Новые элементы - мужской род, неодушевленные
                { word: 'нэзл', gender: 'муж', isAnim: false },
                { word: 'плюрх', gender: 'муж', isAnim: false },
                { word: 'шольт', gender: 'муж', isAnim: false },
                { word: 'крамт', gender: 'муж', isAnim: false },
                { word: 'вурф', gender: 'муж', isAnim: false },
                { word: 'зыст', gender: 'муж', isAnim: false },
                { word: 'дющ', gender: 'муж', isAnim: false },
                { word: 'тлеп', gender: 'муж', isAnim: false },
                { word: 'шпур', gender: 'муж', isAnim: false },
                { word: 'чкыр', gender: 'муж', isAnim: false },
                { word: 'флюрп', gender: 'муж', isAnim: false },
                { word: 'хыщ', gender: 'муж', isAnim: false },
                { word: 'мворк', gender: 'муж', isAnim: false },
                { word: 'стых', gender: 'муж', isAnim: false },
                { word: 'кворн', gender: 'муж', isAnim: false },
                
                // Новые элементы - мужской род, одушевленные
                { word: 'зорл', gender: 'муж', isAnim: true },
                { word: 'мюнт', gender: 'муж', isAnim: true },
                { word: 'прых', gender: 'муж', isAnim: true },
                { word: 'клёрф', gender: 'муж', isAnim: true },
                { word: 'гимс', gender: 'муж', isAnim: true },
                { word: 'вырх', gender: 'муж', isAnim: true },
                { word: 'щорп', gender: 'муж', isAnim: true },
                { word: 'нюлб', gender: 'муж', isAnim: true },
                { word: 'трем', gender: 'муж', isAnim: true },
                { word: 'ксыбр', gender: 'муж', isAnim: true },
                
                // Новые элементы - женский род, неодушевленные
                { word: 'зыба', gender: 'жен', isAnim: false },
                { word: 'прялк', gender: 'жен', isAnim: false },
                { word: 'хрема', gender: 'жен', isAnim: false },
                { word: 'флюнь', gender: 'жен', isAnim: false },
                { word: 'цыпта', gender: 'жен', isAnim: false },
                { word: 'дрось', gender: 'жен', isAnim: false },
                { word: 'мёрза', gender: 'жен', isAnim: false },
                { word: 'кряхт', gender: 'жен', isAnim: false },
                { word: 'юрта', gender: 'жен', isAnim: false },
                { word: 'штыль', gender: 'жен', isAnim: false },
                { word: 'чвара', gender: 'жен', isAnim: false },
                { word: 'плым', gender: 'жен', isAnim: false },
                { word: 'скупь', gender: 'жен', isAnim: false },
                { word: 'нась', gender: 'жен', isAnim: false },
                { word: 'врапь', gender: 'жен', isAnim: false },
                
                // Новые элементы - женский род, одушевленные
                { word: 'мыра', gender: 'жен', isAnim: true },
                { word: 'хвоста', gender: 'жен', isAnim: true },
                { word: 'дырпа', gender: 'жен', isAnim: true },
                { word: 'клуня', gender: 'жен', isAnim: true },
                { word: 'шквыря', gender: 'жен', isAnim: true },
                { word: 'флён', gender: 'жен', isAnim: true },
                { word: 'зубра', gender: 'жен', isAnim: true },
                { word: 'смыша', gender: 'жен', isAnim: true },
                
                // Новые элементы - средний род, неодушевленные
                { word: 'знобо', gender: 'ср', isAnim: false },
                { word: 'швыре', gender: 'ср', isAnim: false },
                { word: 'плюке', gender: 'ср', isAnim: false },
                { word: 'трымо', gender: 'ср', isAnim: false },
                { word: 'горшо', gender: 'ср', isAnim: false },
                { word: 'кэпе', gender: 'ср', isAnim: false },
                { word: 'люстё', gender: 'ср', isAnim: false },
                { word: 'праро', gender: 'ср', isAnim: false },
                { word: 'фико', gender: 'ср', isAnim: false },
                { word: 'шлосо', gender: 'ср', isAnim: false },
                { word: 'нюво', gender: 'ср', isAnim: false },
                { word: 'крыто', gender: 'ср', isAnim: false },
                
                // Новые элементы - средний род, одушевленные (редкая категория в русском языке)
                { word: 'мрыло', gender: 'ср', isAnim: true },
                { word: 'дзюбо', gender: 'ср', isAnim: true },
                { word: 'хрыще', gender: 'ср', isAnim: true },
                { word: 'плащё', gender: 'ср', isAnim: true },
                { word: 'глюме', gender: 'ср', isAnim: true }
            ];

            // Расширенный массив prelingualAdjectives (пред-языковые прилагательные)
            const prelingualAdjectives = [
                // Существующие узнаваемые корни с правильными окончаниями
                { stem: 'нев', endings: { муж: 'ый', жен: 'ая', ср: 'ое' } },
                { stem: 'квант', endings: { муж: 'овый', жен: 'овая', ср: 'овое' } },
                { stem: 'люмин', endings: { муж: 'есцентный', жен: 'есцентная', ср: 'есцентное' } },
                { stem: 'трансценд', endings: { муж: 'ентный', жен: 'ентная', ср: 'ентное' } },
                { stem: 'фрактал', endings: { муж: 'ьный', жен: 'ьная', ср: 'ьное' } },
                { stem: 'амбивал', endings: { муж: 'ентный', жен: 'ентная', ср: 'ентное' } },
                { stem: 'хром', endings: { муж: 'атический', жен: 'атическая', ср: 'атическое' } },
                { stem: 'метафиз', endings: { муж: 'ический', жен: 'ическая', ср: 'ическое' } },
                { stem: 'сем', endings: { муж: 'антический', жен: 'антическая', ср: 'антическое' } },
                { stem: 'эфем', endings: { муж: 'ерный', жен: 'ерная', ср: 'ерное' } },
                { stem: 'сюрр', endings: { муж: 'еальный', жен: 'еальная', ср: 'еальное' } },
                { stem: 'астр', endings: { муж: 'альный', жен: 'альная', ср: 'альное' } },
                
                // Существующие бессмысленные корни с правильными окончаниями
                { stem: 'фрум', endings: { муж: 'ный', жен: 'ная', ср: 'ное' } },
                { stem: 'залт', endings: { муж: 'ивый', жен: 'ивая', ср: 'ивое' } },
                { stem: 'мипр', endings: { муж: 'ичный', жен: 'ичная', ср: 'ичное' } },
                { stem: 'кворк', endings: { муж: 'овый', жен: 'овая', ср: 'овое' } },
                { stem: 'шпур', endings: { муж: 'ский', жен: 'ская', ср: 'ское' } },
                { stem: 'тлеп', endings: { муж: 'учий', жен: 'учая', ср: 'учее' } },
                { stem: 'зырк', endings: { муж: 'истый', жен: 'истая', ср: 'истое' } },
                { stem: 'хрюм', endings: { муж: 'озный', жен: 'озная', ср: 'озное' } },
                { stem: 'глыч', endings: { муж: 'ащий', жен: 'ащая', ср: 'ащее' } },
                { stem: 'врап', endings: { муж: 'ильный', жен: 'ильная', ср: 'ильное' } },
                { stem: 'дрюх', endings: { муж: 'атый', жен: 'атая', ср: 'атое' } },
                { stem: 'жвяк', endings: { муж: 'учий', жен: 'учая', ср: 'учее' } },
                { stem: 'мымр', endings: { муж: 'ящий', жен: 'ящая', ср: 'ящее' } },
                { stem: 'фыпч', endings: { муж: 'еский', жен: 'еская', ср: 'еское' } },
                { stem: 'хвурм', endings: { муж: 'ающий', жен: 'ающая', ср: 'ающее' } },
                { stem: 'квяз', endings: { муж: 'иотический', жен: 'иотическая', ср: 'иотическое' } },
                { stem: 'трыщ', endings: { муж: 'авый', жен: 'авая', ср: 'авое' } },
                { stem: 'плюмб', endings: { муж: 'арный', жен: 'арная', ср: 'арное' } },
                
                // Новые узнаваемые корни с правильными окончаниями (философские, научные, психологические термины)
                { stem: 'ноум', endings: { муж: 'енальный', жен: 'енальная', ср: 'енальное' } },
                { stem: 'диссоци', endings: { муж: 'ативный', жен: 'ативная', ср: 'ативное' } },
                { stem: 'когнит', endings: { муж: 'ивный', жен: 'ивная', ср: 'ивное' } },
                { stem: 'энтроп', endings: { муж: 'ийный', жен: 'ийная', ср: 'ийное' } },
                { stem: 'интент', endings: { муж: 'ивный', жен: 'ивная', ср: 'ивное' } },
                { stem: 'нейр', endings: { муж: 'онный', жен: 'онная', ср: 'онное' } },
                { stem: 'танат', endings: { муж: 'ический', жен: 'ическая', ср: 'ическое' } },
                { stem: 'синкрет', endings: { муж: 'ический', жен: 'ическая', ср: 'ическое' } },
                { stem: 'гностиц', endings: { муж: 'истический', жен: 'истическая', ср: 'истическое' } },
                { stem: 'имагин', endings: { муж: 'ативный', жен: 'ативная', ср: 'ативное' } },
                { stem: 'архетип', endings: { муж: 'ический', жен: 'ическая', ср: 'ическое' } },
                { stem: 'диалект', endings: { муж: 'ический', жен: 'ическая', ср: 'ическое' } },
                { stem: 'экзист', endings: { муж: 'енциальный', жен: 'енциальная', ср: 'енциальное' } },
                { stem: 'интер', endings: { муж: 'пассивный', жен: 'пассивная', ср: 'пассивное' } },
                { stem: 'имман', endings: { муж: 'ентный', жен: 'ентная', ср: 'ентное' } },
                
                // Новые бессмысленные корни с правильными окончаниями
                { stem: 'хвыр', endings: { муж: 'евый', жен: 'евая', ср: 'евое' } },
                { stem: 'пладж', endings: { муж: 'утый', жен: 'утая', ср: 'утое' } },
                { stem: 'кнол', endings: { муж: 'ьный', жен: 'ьная', ср: 'ьное' } },
                { stem: 'трукс', endings: { муж: 'ивный', жен: 'ивная', ср: 'ивное' } },
                { stem: 'мылд', endings: { муж: 'ящий', жен: 'ящая', ср: 'ящее' } },
                { stem: 'фрек', endings: { муж: 'тальный', жен: 'тальная', ср: 'тальное' } },
                { stem: 'жикр', endings: { муж: 'онный', жен: 'онная', ср: 'онное' } },
                { stem: 'плёх', endings: { муж: 'овый', жен: 'овая', ср: 'овое' } },
                { stem: 'нюрб', endings: { муж: 'азный', жен: 'азная', ср: 'азное' } },
                { stem: 'сверк', endings: { муж: 'лявый', жен: 'лявая', ср: 'лявое' } },
                { stem: 'кышт', endings: { муж: 'ущий', жен: 'ущая', ср: 'ущее' } },
                { stem: 'брям', endings: { муж: 'чатый', жен: 'чатая', ср: 'чатое' } },
                { stem: 'злог', endings: { муж: 'арный', жен: 'арная', ср: 'арное' } },
                { stem: 'мывр', endings: { муж: 'еватый', жен: 'еватая', ср: 'еватое' } },
                { stem: 'пращ', endings: { муж: 'енный', жен: 'енная', ср: 'енное' } },
                { stem: 'скорл', endings: { муж: 'юкающий', жен: 'юкающая', ср: 'юкающее' } },
                { stem: 'хрещ', endings: { муж: 'атавый', жен: 'атавая', ср: 'атавое' } },
                { stem: 'цвыр', endings: { муж: 'кучий', жен: 'кучая', ср: 'кучее' } },
                { stem: 'пруфл', endings: { муж: 'ёвый', жен: 'ёвая', ср: 'ёвое' } },
                { stem: 'жвыг', endings: { муж: 'лый', жен: 'лая', ср: 'лое' } },
                { stem: 'ключ', endings: { муж: 'коватый', жен: 'коватая', ср: 'коватое' } },
                { stem: 'шквор', endings: { муж: 'чатый', жен: 'чатая', ср: 'чатое' } },
                { stem: 'пырк', endings: { муж: 'альный', жен: 'альная', ср: 'альное' } },
                { stem: 'здрав', endings: { муж: 'ичный', жен: 'ичная', ср: 'ичное' } },
                { stem: 'тлян', endings: { муж: 'достный', жен: 'достная', ср: 'достное' } },
                { stem: 'выбр', endings: { муж: 'енный', жен: 'енная', ср: 'енное' } },
                { stem: 'ждык', endings: { муж: 'остный', жен: 'остная', ср: 'остное' } },
                { stem: 'крым', endings: { муж: 'чатый', жен: 'чатая', ср: 'чатое' } },
                { stem: 'флырд', endings: { муж: 'астый', жен: 'астая', ср: 'астое' } },
                { stem: 'шмёрг', endings: { муж: 'лый', жен: 'лая', ср: 'лое' } }
            ];

            // Расширенный массив prelingualVerbs (пред-языковые глаголы)
            const prelingualVerbs = [
                // Осмысленные глаголы (настоящее время)
                'диссоциирует', 'трансцендирует', 'квантифицирует', 'дематериализует',
                'синтезирует', 'деконструирует', 'фрактализирует', 'осциллирует',
                'левитирует', 'мутирует', 'сублимирует', 'экстраполирует',
                
                // Осмысленные глаголы (прошедшее время)
                'диссоциировал', 'трансцендировал', 'квантифицировал', 'дематериализовал',
                'синтезировал', 'деконструировал', 'фрактализировал', 'осциллировал',
                'левитировал', 'мутировал', 'сублимировал', 'экстраполировал',
                
                // Осмысленные глаголы (будущее время)
                'будет диссоциировать', 'будет трансцендировать', 'будет квантифицировать', 'будет дематериализовать',
                'будет синтезировать', 'будет деконструировать', 'будет фрактализировать', 'будет осциллировать',
                'будет левитировать', 'будет мутировать', 'будет сублимировать', 'будет экстраполировать',
                
                // Осмысленные глаголы (сложные конструкции, повелительное наклонение, возвратные формы)
                'отдиссоциируйся', 'затрансцендируй', 'переквантифицировался', 'продематериализуй', 
                'рассинтезировался', 'задеконструируйся', 'недофрактализировался', 'проосциллируй',
                'перелевитируйся', 'домутировался', 'отсублимируй', 'переэкстраполировался',
                
                // Дополнительные осмысленные глаголы (настоящее время)
                'аннигилирует', 'интерферирует', 'дифференцирует', 'интегрирует', 
                'трансформирует', 'метаморфизирует', 'дезинтегрирует', 'материализует',
                'визуализирует', 'гармонизирует', 'ионизирует', 'нейтрализует',
                'идентифицирует', 'классифицирует', 'вербализует', 'функционирует',
                
                // Дополнительные осмысленные глаголы (прошедшее время)
                'аннигилировал', 'интерферировал', 'дифференцировал', 'интегрировал',
                'трансформировал', 'метаморфизировал', 'дезинтегрировал', 'материализовал',
                'визуализировал', 'гармонизировал', 'ионизировал', 'нейтрализовал',
                'идентифицировал', 'классифицировал', 'вербализовал', 'функционировал',
                
                // Дополнительные осмысленные глаголы (будущее время)
                'будет аннигилировать', 'будет интерферировать', 'будет дифференцировать', 'будет интегрировать',
                'будет трансформировать', 'будет метаморфизировать', 'будет дезинтегрировать', 'будет материализовать',
                'будет визуализировать', 'будет гармонизировать', 'будет ионизировать', 'будет нейтрализовать',
                'будет идентифицировать', 'будет классифицировать', 'будет вербализовать', 'будет функционировать',
                
                // Дополнительные осмысленные глаголы (сложные конструкции)
                'саморегенерировался', 'переидентифицируй', 'недогармонизировался', 'подтрансформируйся',
                'разматериализовался', 'сверхинтегрировал', 'довизуализируйся', 'переаннигилировался',
                'расклассифицируй', 'самодеструктурировался', 'контрметаморфизировал', 'перевербализуйся',
                
                // Бессмысленные глаголы (настоящее время)
                'хвурмит', 'зюршит', 'плямчет', 'трющит', 'кверкает', 'дрыхает',
                'шмыгает', 'бвакает', 'жвякает', 'фычет', 'мырчит', 'скромлит',
                
                // Бессмысленные глаголы (прошедшее время)
                'хвурмил', 'зюршил', 'плямчил', 'трющил', 'кверкал', 'дрыхал',
                'шмыгал', 'бвакал', 'жвякал', 'фычал', 'мырчал', 'скромлил',
                
                // Бессмысленные глаголы (будущее время)
                'будет хвурмить', 'будет зюршить', 'будет плямчить', 'будет трющить',
                'будет кверкать', 'будет дрыхать', 'будет шмыгать', 'будет бвакать',
                'будет жвякать', 'будет фычать', 'будет мырчать', 'будет скромлить',
                
                // Сложные конструкции (повелительное наклонение, возвратные формы)
                'прохрюмкайся', 'отфычивай', 'зашпурься', 'выкверкивай', 'перемырчи',
                'недобвакался', 'отзюршился', 'разжвякался', 'прискромлил', 'дотрющился',
                
                // Дополнительные бессмысленные глаголы (настоящее время)
                'зыбрит', 'швырчит', 'глюмчет', 'прыхтит', 'тлемпает', 'крачет',
                'мыршит', 'нарвает', 'фнюкает', 'щебрит', 'шворкает', 'дремплит',
                'хрюздит', 'плёнчет', 'вюрзит', 'дросчит', 'клюмпает', 'цыкает',
                'гребчет', 'тыхчет', 'мюркает', 'фрюшит', 'слямзит', 'троздит',
                
                // Дополнительные бессмысленные глаголы (прошедшее время)
                'зыбрил', 'швырчил', 'глюмчил', 'прыхтил', 'тлемпал', 'крачил',
                'мыршил', 'нарвал', 'фнюкал', 'щебрил', 'шворкал', 'дремплил',
                'хрюздил', 'плёнчил', 'вюрзил', 'дросчил', 'клюмпал', 'цыкал',
                'гребчил', 'тыхчил', 'мюркал', 'фрюшил', 'слямзил', 'троздил',
                
                // Дополнительные бессмысленные глаголы (будущее время)
                'будет зыбрить', 'будет швырчить', 'будет глюмчить', 'будет прыхтить', 'будет тлемпать', 'будет крачить',
                'будет мыршить', 'будет нарвать', 'будет фнюкать', 'будет щебрить', 'будет шворкать', 'будет дремплить',
                'будет хрюздить', 'будет плёнчить', 'будет вюрзить', 'будет дросчить', 'будет клюмпать', 'будет цыкать',
                'будет гребчить', 'будет тыхчить', 'будет мюркать', 'будет фрюшить', 'будет слямзить', 'будет троздить',
                
                // Дополнительные сложные конструкции бессмысленных глаголов
                'зафыркнись', 'недомюркался', 'отхрямзуйся', 'расшлёпайся', 'переклямчи',
                'выхрюкнул', 'прошвырчись', 'недоглюмчился', 'перефнюкался', 'отщебрись',
                'разнарвался', 'протыхчи', 'вышворкнул', 'переплёнчился', 'недоцыкайся',
                'разгребчись', 'натроздился', 'выфрюшился', 'отслямзься', 'раздрощился',
                'превюрзился', 'захрюздись', 'подклюмпался', 'пошмыгнись', 'надбвакнул'
            ];
            // Расширенный массив thoughtFragmentsWords
            const thoughtFragmentsWords = [
                // Существующие элементы
                ['до-сознательное', 'пространство', 'визуального', 'синтаксиса', 'смысла'],
                ['границы', 'нелинейные', 'проекции', 'структуры', 'архетип'],
                ['аморфные', 'глубинный', 'диссоциативная', 'понимания', 'синтеза'],
                ['временная', 'пертурбация', 'квантовая', 'деконструкция', 'нарратива'],
                ['тактильная', 'грамматика', 'тишины', 'полисемантическая', 'дисперсия'],
                ['образа', 'медитативная', 'картография', 'бессознательного', 'фрактальность'],
                ['нейросемиотическая', 'индуцированная', 'синкретическая', 'амнезия', 'тезаурус'],
                ['топологически', 'инвариантный', 'стохастическая', 'рекурсия', 'первосмыслов'],
                ['синтаксическая', 'экзистенция', 'пустоты', 'когнитивная', 'семиосфера'],
                ['трансцендентальная', 'феноменология', 'гиперреальность', 'метаязыковая', 'перцепция'],
                
                // Философия языка и сознания
                ['протоязыковая', 'схизматичность', 'номинативного', 'спектра', 'апперцепции'],
                ['имплицитная', 'герменевтика', 'онтологической', 'пропасти', 'знака'],
                ['эйдетическая', 'дифференциация', 'невыразимого', 'экзистенциального', 'ужаса'],
                ['интерпассивность', 'воображаемого', 'символического', 'лакановского', 'регистра'],
                ['ноуменальная', 'фрагментация', 'лингвистического', 'горизонта', 'реальности'],
                
                // Психоаналитические концепции
                ['субъектная', 'дислокация', 'психического', 'гомеостаза', 'тревожности'],
                ['архетипическая', 'диссоциация', 'коллективного', 'бессознательного', 'травмы'],
                ['лиминальная', 'деструктурация', 'эго-образов', 'психосоматического', 'ландшафта'],
                ['параноидально', 'шизоидная', 'позиция', 'расщепления', 'идентичности'],
                ['либидинальная', 'картография', 'примордиального', 'желания', 'танатоса'],
                
                // Квантовые и физические концепции
                ['квантовая', 'суперпозиция', 'нейронных', 'состояний', 'сознания'],
                ['нелокальная', 'запутанность', 'мысли', 'хаотического', 'аттрактора'],
                ['волновая', 'редукция', 'ментальных', 'вероятностей', 'интерференции'],
                ['энтропийная', 'детерминация', 'когнитивного', 'диссонанса', 'сингулярности'],
                ['гёделевская', 'неполнота', 'психических', 'аксиом', 'интроспекции'],
                
                // Нейро- и когнитивные науки
                ['нейропластическая', 'конфигурация', 'синаптических', 'сетей', 'подсознания'],
                ['мнемоническая', 'кристаллизация', 'дискретных', 'квалиа', 'апофении'],
                ['глиальная', 'медиация', 'нейротрансмиттерного', 'шума', 'парейдолии'],
                ['метакогнитивная', 'рекурсия', 'саморефлексивной', 'петли', 'субъектности'],
                ['интероцептивная', 'чувствительность', 'телесных', 'симулякров', 'присутствия'],
                
                // Семиотика и структурализм
                ['постструктуралистская', 'деконструкция', 'бинарных', 'оппозиций', 'означающего'],
                ['ризоматическая', 'пролиферация', 'семиотических', 'узлов', 'тела-без-органов'],
                ['паралингвистическая', 'детерриториализация', 'номадической', 'субъективности', 'различания'],
                ['апофатическая', 'семантика', 'невыразимого', 'присутствия', 'отсутствия'],
                ['семиотическая', 'энтропия', 'перцептивного', 'шума', 'сигнификации'],
                
                // Шизоанализ и постмодернизм
                ['шизоаналитическая', 'картография', 'желающего', 'производства', 'складки'],
                ['молекулярная', 'революция', 'машин', 'желания', 'становления-животным'],
                ['номадическая', 'сингулярность', 'плато', 'интенсивности', 'хаосмоса'],
                ['микрополитика', 'желания', 'детерриториализации', 'рефрена', 'фаллогоцентризма'],
                ['гваттарианская', 'хаосмоза', 'трансверсальности', 'экософии', 'шизоидности'],
                
                // Феноменологические концепции
                ['интенциональная', 'направленность', 'феноменального', 'горизонта', 'ноэмы'],
                ['экзистенциальная', 'аналитика', 'здесь-бытия', 'экстатического', 'временения'],
                ['априорная', 'трансцендентальность', 'интерсубъективной', 'феноменологии', 'интенциональности'],
                ['герменевтический', 'круг', 'экзистенциального', 'присутствия', 'заброшенности'],
                ['феноменологическая', 'эпохе', 'интерсубъективного', 'жизненного', 'мира-горизонта'],
                
                // Теории хаоса и сложности
                ['фрактальная', 'размерность', 'когнитивной', 'турбулентности', 'самоорганизации'],
                ['странный', 'аттрактор', 'психической', 'бифуркации', 'детерминированного'],
                ['хаотическая', 'динамика', 'внутреннего', 'времени', 'диссипативных'],
                ['эмерджентная', 'самоорганизация', 'мыслительных', 'паттернов', 'рекурсии'],
                ['автопоэтическая', 'самореференция', 'операциональной', 'замкнутости', 'сложности'],
                
                // Лингвистические трансгрессии
                ['металингвистическая', 'транскрипция', 'невербализуемого', 'присутствия', 'праязыка'],
                ['палеосемантическая', 'археология', 'утраченных', 'корней', 'прасимволов'],
                ['глоссолалическая', 'артикуляция', 'асемической', 'письменности', 'глиф'],
                ['параграмматическая', 'морфология', 'досинтаксических', 'образований', 'праформ'],
                ['иконическая', 'индексальность', 'досимволического', 'мышления', 'прото-речи'],
                
                // Темпоральные аномалии
                ['анахроническая', 'рекурсия', 'ветвящегося', 'настоящего', 'аффекта'],
                ['темпоральная', 'дисперсия', 'памяти', 'хронестезия', 'прошлостного'],
                ['диахроническая', 'асинхронность', 'пережитого', 'ностальгического', 'футуризма'],
                ['сингулярная', 'ахрония', 'психического', 'времени', 'вневременного'],
                ['энтропийная', 'необратимость', 'потока', 'сознания', 'кайроса'],
                
                // Медиативные состояния
                ['дифференциальная', 'медитация', 'пустотности', 'осознанности', 'сатори'],
                ['трансперсональная', 'диссолюция', 'эго-границ', 'надличностного', 'опыта'],
                ['лиминальная', 'иммерсия', 'невыразимого', 'трансцендентного', 'экстаза'],
                ['безобъектная', 'созерцательность', 'онтологического', 'разрыва', 'медитативности'],
                ['интегративная', 'прозрачность', 'пре-рефлексивного', 'осознавания', 'просветления'],
                
                // Перцептивные аномалии
                ['синестетическая', 'контаминация', 'чувственных', 'модальностей', 'галлюцинации'],
                ['многомерная', 'апперцепция', 'альтернативных', 'реальностей', 'симулякра'],
                ['деперсонализационная', 'фрагментация', 'проприоцептивной', 'схемы', 'тела'],
                ['тахипсихическая', 'аккселерация', 'временного', 'восприятия', 'хроносинклазма'],
                ['экстатическая', 'трансмутация', 'сенсорного', 'гомеостаза', 'экстасенсориума']
            ];

            // Расширенный объект thoughtFragmentsCategories
            const thoughtFragmentsCategories = {
                // Прилагательные в разных родах и падежах
                adjectives: {
                    // Именительный падеж
                    nominative: {
                        masculine: [
                            // Существующие
                            'глубинный', 'инвариантный', 'синтаксический', 'трансцендентальный', 'когнитивный', 'метафизический', 'семиотический',
                            // Философия и онтология
                            'ноуменальный', 'имманентный', 'трансверсальный', 'эйдетический', 'онтологический', 'эпистемический', 'апофатический',
                            // Квантовая и хаотическая терминология
                            'квантово-флуктуационный', 'энтропийный', 'стохастический', 'бифуркационный', 'фрактальный', 'гёделевский', 'дивергентный',
                            // Психоаналитические термины
                            'психоделический', 'архетипический', 'шизоаналитический', 'либидинальный', 'танатальный', 'ретентивный', 'эдипальный',
                            // Феноменологические термины
                            'интенциональный', 'экзистенциальный', 'герменевтический', 'феноменальный', 'априорный', 'ноэтический', 'аффективный',
                            // Лингвистические и семиотические термины
                            'металингвистический', 'глоссолалический', 'асемический', 'палеосемантический', 'параграмматический', 'семиотический', 'постструктуралистский',
                            // Темпоральные термины
                            'анахронический', 'диахронический', 'ахронный', 'хронестезический', 'кайротический', 'темпоральный', 'ретроспективный',
                            // Нейрокогнитивные термины
                            'нейропластический', 'интероцептивный', 'метакогнитивный', 'нейросемиотический', 'мнемонический', 'синаптический', 'глиальный',
                            // Шизоидные термины
                            'ризоматический', 'номадический', 'детерриториализированный', 'молекулярный', 'параноидальный', 'шизоидный', 'гваттарианский',
                            // Созерцательные термины
                            'медитативный', 'трансперсональный', 'безобъектный', 'трансцендентный', 'интегративный', 'иммерсивный', 'контемплятивный'
                        ],
                        feminine: [
                            // Существующие
                            'диссоциативная', 'квантовая', 'тактильная', 'полисемантическая', 'метаязыковая', 'синтаксическая', 'стохастическая', 'нейросемиотическая', 'синкретическая',
                            // Философия и онтология
                            'ноуменальная', 'имманентная', 'трансверсальная', 'эйдетическая', 'онтологическая', 'эпистемическая', 'апофатическая',
                            // Квантовая и хаотическая терминология
                            'квантово-флуктуационная', 'энтропийная', 'стохастическая', 'бифуркационная', 'фрактальная', 'гёделевская', 'дивергентная',
                            // Психоаналитические термины
                            'психоделическая', 'архетипическая', 'шизоаналитическая', 'либидинальная', 'танатальная', 'ретентивная', 'эдипальная',
                            // Феноменологические термины
                            'интенциональная', 'экзистенциальная', 'герменевтическая', 'феноменальная', 'априорная', 'ноэтическая', 'аффективная',
                            // Лингвистические и семиотические термины
                            'металингвистическая', 'глоссолалическая', 'асемическая', 'палеосемантическая', 'параграмматическая', 'семиотическая', 'постструктуралистская',
                            // Темпоральные термины
                            'анахроническая', 'диахроническая', 'ахронная', 'хронестезическая', 'кайротическая', 'темпоральная', 'ретроспективная',
                            // Нейрокогнитивные термины
                            'нейропластическая', 'интероцептивная', 'метакогнитивная', 'нейросемиотическая', 'мнемоническая', 'синаптическая', 'глиальная',
                            // Шизоидные термины
                            'ризоматическая', 'номадическая', 'детерриториализированная', 'молекулярная', 'параноидальная', 'шизоидная', 'гваттарианская',
                            // Созерцательные термины
                            'медитативная', 'трансперсональная', 'безобъектная', 'трансцендентная', 'интегративная', 'иммерсивная', 'контемплятивная'
                        ],
                        neutral: [
                            // Существующие
                            'до-сознательное', 'эфемерное', 'абстрактное', 'медитативное', 'архетипическое',
                            // Философия и онтология
                            'ноуменальное', 'имманентное', 'трансверсальное', 'эйдетическое', 'онтологическое', 'эпистемическое', 'апофатическое',
                            // Квантовая и хаотическая терминология
                            'квантово-флуктуационное', 'энтропийное', 'стохастическое', 'бифуркационное', 'фрактальное', 'гёделевское', 'дивергентное',
                            // Психоаналитические термины
                            'психоделическое', 'архетипическое', 'шизоаналитическое', 'либидинальное', 'танатальное', 'ретентивное', 'эдипальное',
                            // Феноменологические термины
                            'интенциональное', 'экзистенциальное', 'герменевтическое', 'феноменальное', 'априорное', 'ноэтическое', 'аффективное',
                            // Лингвистические и семиотические термины
                            'металингвистическое', 'глоссолалическое', 'асемическое', 'палеосемантическое', 'параграмматическое', 'семиотическое', 'постструктуралистское',
                            // Темпоральные термины
                            'анахроническое', 'диахроническое', 'ахронное', 'хронестезическое', 'кайротическое', 'темпоральное', 'ретроспективное',
                            // Нейрокогнитивные термины
                            'нейропластическое', 'интероцептивное', 'метакогнитивное', 'нейросемиотическое', 'мнемоническое', 'синаптическое', 'глиальное',
                            // Шизоидные термины
                            'ризоматическое', 'номадическое', 'детерриториализированное', 'молекулярное', 'параноидальное', 'шизоидное', 'гваттарианское',
                            // Созерцательные термины
                            'медитативное', 'трансперсональное', 'безобъектное', 'трансцендентное', 'интегративное', 'иммерсивное', 'контемплятивное'
                        ]
                    },
                    // Родительный падеж
                    genitive: {
                        masculine: [
                            // Существующие
                            'глубинного', 'инвариантного', 'синтаксического', 'трансцендентального', 'когнитивного', 'метафизического', 'семиотического',
                            // Философия и онтология
                            'ноуменального', 'имманентного', 'трансверсального', 'эйдетического', 'онтологического', 'эпистемического', 'апофатического',
                            // Квантовая и хаотическая терминология
                            'квантово-флуктуационного', 'энтропийного', 'стохастического', 'бифуркационного', 'фрактального', 'гёделевского', 'дивергентного',
                            // Психоаналитические термины
                            'психоделического', 'архетипического', 'шизоаналитического', 'либидинального', 'танатального', 'ретентивного', 'эдипального',
                            // Феноменологические термины
                            'интенционального', 'экзистенциального', 'герменевтического', 'феноменального', 'априорного', 'ноэтического', 'аффективного',
                            // Лингвистические и семиотические термины
                            'металингвистического', 'глоссолалического', 'асемического', 'палеосемантического', 'параграмматического', 'семиотического', 'постструктуралистского',
                            // Темпоральные термины
                            'анахронического', 'диахронического', 'ахронного', 'хронестезического', 'кайротического', 'темпорального', 'ретроспективного',
                            // Нейрокогнитивные термины
                            'нейропластического', 'интероцептивного', 'метакогнитивного', 'нейросемиотического', 'мнемонического', 'синаптического', 'глиального',
                            // Шизоидные термины
                            'ризоматического', 'номадического', 'детерриториализированного', 'молекулярного', 'параноидального', 'шизоидного', 'гваттарианского',
                            // Созерцательные термины
                            'медитативного', 'трансперсонального', 'безобъектного', 'трансцендентного', 'интегративного', 'иммерсивного', 'контемплятивного'
                        ],
                        feminine: [
                            // Существующие
                            'диссоциативной', 'квантовой', 'тактильной', 'полисемантической', 'метаязыковой', 'синтаксической', 'стохастической', 'нейросемиотической', 'синкретической',
                            // Философия и онтология
                            'ноуменальной', 'имманентной', 'трансверсальной', 'эйдетической', 'онтологической', 'эпистемической', 'апофатической',
                            // Квантовая и хаотическая терминология
                            'квантово-флуктуационной', 'энтропийной', 'стохастической', 'бифуркационной', 'фрактальной', 'гёделевской', 'дивергентной',
                            // Психоаналитические термины
                            'психоделической', 'архетипической', 'шизоаналитической', 'либидинальной', 'танатальной', 'ретентивной', 'эдипальной',
                            // Феноменологические термины
                            'интенциональной', 'экзистенциальной', 'герменевтической', 'феноменальной', 'априорной', 'ноэтической', 'аффективной',
                            // Лингвистические и семиотические термины
                            'металингвистической', 'глоссолалической', 'асемической', 'палеосемантической', 'параграмматической', 'семиотической', 'постструктуралистской',
                            // Темпоральные термины
                            'анахронической', 'диахронической', 'ахронной', 'хронестезической', 'кайротической', 'темпоральной', 'ретроспективной',
                            // Нейрокогнитивные термины
                            'нейропластической', 'интероцептивной', 'метакогнитивной', 'нейросемиотической', 'мнемонической', 'синаптической', 'глиальной',
                            // Шизоидные термины
                            'ризоматической', 'номадической', 'детерриториализированной', 'молекулярной', 'параноидальной', 'шизоидной', 'гваттарианской',
                            // Созерцательные термины
                            'медитативной', 'трансперсональной', 'безобъектной', 'трансцендентной', 'интегративной', 'иммерсивной', 'контемплятивной'
                        ],
                        neutral: [
                            // Существующие
                            'до-сознательного', 'эфемерного', 'абстрактного', 'медитативного', 'архетипического',
                            // Философия и онтология
                            'ноуменального', 'имманентного', 'трансверсального', 'эйдетического', 'онтологического', 'эпистемического', 'апофатического',
                            // Квантовая и хаотическая терминология
                            'квантово-флуктуационного', 'энтропийного', 'стохастического', 'бифуркационного', 'фрактального', 'гёделевского', 'дивергентного',
                            // Психоаналитические термины
                            'психоделического', 'архетипического', 'шизоаналитического', 'либидинального', 'танатального', 'ретентивного', 'эдипального',
                            // Феноменологические термины
                            'интенционального', 'экзистенциального', 'герменевтического', 'феноменального', 'априорного', 'ноэтического', 'аффективного',
                            // Лингвистические и семиотические термины
                            'металингвистического', 'глоссолалического', 'асемического', 'палеосемантического', 'параграмматического', 'семиотического', 'постструктуралистского',
                            // Темпоральные термины
                            'анахронического', 'диахронического', 'ахронного', 'хронестезического', 'кайротического', 'темпорального', 'ретроспективного',
                            // Нейрокогнитивные термины
                            'нейропластического', 'интероцептивного', 'метакогнитивного', 'нейросемиотического', 'мнемонического', 'синаптического', 'глиального',
                            // Шизоидные термины
                            'ризоматического', 'номадического', 'детерриториализированного', 'молекулярного', 'параноидального', 'шизоидного', 'гваттарианского',
                            // Созерцательные термины
                            'медитативного', 'трансперсонального', 'безобъектного', 'трансцендентного', 'интегративного', 'иммерсивного', 'контемплятивного'
                        ]
                    }
                },
                // Существительные в разных падежах с указанием рода
                nouns: {
                    // Именительный падеж
                    nominative: [
                        // Существующие
                        { word: 'пространство', gender: 'neutral' },
                        { word: 'граница', gender: 'feminine' },
                        { word: 'проекция', gender: 'feminine' },
                        { word: 'структура', gender: 'feminine' },
                        { word: 'архетип', gender: 'masculine' },
                        { word: 'синтез', gender: 'masculine' },
                        { word: 'пертурбация', gender: 'feminine' },
                        { word: 'деконструкция', gender: 'feminine' },
                        { word: 'нарратив', gender: 'masculine' },
                        { word: 'грамматика', gender: 'feminine' },
                        { word: 'дисперсия', gender: 'feminine' },
                        { word: 'образ', gender: 'masculine' },
                        { word: 'картография', gender: 'feminine' },
                        { word: 'фрактальность', gender: 'feminine' },
                        { word: 'амнезия', gender: 'feminine' },
                        { word: 'тезаурус', gender: 'masculine' },
                        { word: 'рекурсия', gender: 'feminine' },
                        { word: 'экзистенция', gender: 'feminine' },
                        { word: 'пустота', gender: 'feminine' },
                        { word: 'семиосфера', gender: 'feminine' },
                        { word: 'феноменология', gender: 'feminine' },
                        { word: 'гиперреальность', gender: 'feminine' },
                        { word: 'перцепция', gender: 'feminine' },
                        
                        // Философские термины
                        { word: 'эпистема', gender: 'feminine' },
                        { word: 'ноумен', gender: 'masculine' },
                        { word: 'дискурс', gender: 'masculine' },
                        { word: 'имманенция', gender: 'feminine' },
                        { word: 'трансцендентность', gender: 'feminine' },
                        { word: 'апофатика', gender: 'feminine' },
                        { word: 'онтология', gender: 'feminine' },
                        { word: 'диалектика', gender: 'feminine' },
                        { word: 'эйдос', gender: 'masculine' },
                        { word: 'интенция', gender: 'feminine' },
                        { word: 'герменевтика', gender: 'feminine' },
                        
                        // Шизоаналитические термины
                        { word: 'шизопоток', gender: 'masculine' },
                        { word: 'детерриториализация', gender: 'feminine' },
                        { word: 'ризома', gender: 'feminine' },
                        { word: 'плато', gender: 'neutral' },
                        { word: 'хаосмос', gender: 'masculine' },
                        { word: 'тело-без-органов', gender: 'neutral' },
                        { word: 'номадология', gender: 'feminine' },
                        { word: 'молекулярность', gender: 'feminine' },
                        { word: 'складка', gender: 'feminine' },
                        { word: 'трансверсальность', gender: 'feminine' },
                        
                        // Психоаналитические термины
                        { word: 'бессознательное', gender: 'neutral' },
                        { word: 'травма', gender: 'feminine' },
                        { word: 'диссоциация', gender: 'feminine' },
                        { word: 'лакуна', gender: 'feminine' },
                        { word: 'идентичность', gender: 'feminine' },
                        { word: 'либидо', gender: 'neutral' },
                        { word: 'танатос', gender: 'masculine' },
                        { word: 'эрос', gender: 'masculine' },
                        { word: 'интроекция', gender: 'feminine' },
                        { word: 'имаго', gender: 'neutral' },
                        
                        // Квантовые и хаотические термины
                        { word: 'суперпозиция', gender: 'feminine' },
                        { word: 'запутанность', gender: 'feminine' },
                        { word: 'бифуркация', gender: 'feminine' },
                        { word: 'аттрактор', gender: 'masculine' },
                        { word: 'энтропия', gender: 'feminine' },
                        { word: 'фрактал', gender: 'masculine' },
                        { word: 'диссипация', gender: 'feminine' },
                        { word: 'нелинейность', gender: 'feminine' },
                        { word: 'сингулярность', gender: 'feminine' },
                        
                        // Нейрокогнитивные термины
                        { word: 'нейропластичность', gender: 'feminine' },
                        { word: 'интероцепция', gender: 'feminine' },
                        { word: 'квалиа', gender: 'neutral' },
                        { word: 'апофения', gender: 'feminine' },
                        { word: 'парейдолия', gender: 'feminine' },
                        { word: 'синестезия', gender: 'feminine' },
                        { word: 'метакогниция', gender: 'feminine' },
                        { word: 'синапс', gender: 'masculine' },
                        
                        // Лингвистические термины
                        { word: 'семиозис', gender: 'masculine' },
                        { word: 'означающее', gender: 'neutral' },
                        { word: 'означаемое', gender: 'neutral' },
                        { word: 'метаязык', gender: 'masculine' },
                        { word: 'глоссолалия', gender: 'feminine' },
                        { word: 'праязык', gender: 'masculine' },
                        { word: 'палеоглосса', gender: 'feminine' },
                        { word: 'асемия', gender: 'feminine' },
                        { word: 'симулякр', gender: 'masculine' },
                        
                        // Темпоральные термины
                        { word: 'анахронизм', gender: 'masculine' },
                        { word: 'диахрония', gender: 'feminine' },
                        { word: 'синхрония', gender: 'feminine' },
                        { word: 'хронестезия', gender: 'feminine' },
                        { word: 'ахрония', gender: 'feminine' },
                        { word: 'кайрос', gender: 'masculine' },
                        { word: 'хронотоп', gender: 'masculine' },
                        
                        // Медитативные термины
                        { word: 'трансценденция', gender: 'feminine' },
                        { word: 'созерцание', gender: 'neutral' },
                        { word: 'самадхи', gender: 'neutral' },
                        { word: 'сатори', gender: 'neutral' },
                        { word: 'саморефлексия', gender: 'feminine' },
                        { word: 'осознанность', gender: 'feminine' },
                        { word: 'интроспекция', gender: 'feminine' },
                        { word: 'самопрозрачность', gender: 'feminine' }
                    ],
                    // Родительный падеж
                    genitive: [
                        // Существующие
                        { word: 'пространства', gender: 'neutral' },
                        { word: 'границы', gender: 'feminine' },
                        { word: 'проекции', gender: 'feminine' },
                        { word: 'структуры', gender: 'feminine' },
                        { word: 'архетипа', gender: 'masculine' },
                        { word: 'синтеза', gender: 'masculine' },
                        { word: 'пертурбации', gender: 'feminine' },
                        { word: 'деконструкции', gender: 'feminine' },
                        { word: 'нарратива', gender: 'masculine' },
                        { word: 'грамматики', gender: 'feminine' },
                        { word: 'дисперсии', gender: 'feminine' },
                        { word: 'образа', gender: 'masculine' },
                        { word: 'картографии', gender: 'feminine' },
                        { word: 'фрактальности', gender: 'feminine' },
                        { word: 'амнезии', gender: 'feminine' },
                        { word: 'тезауруса', gender: 'masculine' },
                        { word: 'рекурсии', gender: 'feminine' },
                        { word: 'экзистенции', gender: 'feminine' },
                        { word: 'пустоты', gender: 'feminine' },
                        { word: 'семиосферы', gender: 'feminine' },
                        { word: 'феноменологии', gender: 'feminine' },
                        { word: 'гиперреальности', gender: 'feminine' },
                        { word: 'перцепции', gender: 'feminine' },
                        
                        // Философские термины
                        { word: 'эпистемы', gender: 'feminine' },
                        { word: 'ноумена', gender: 'masculine' },
                        { word: 'дискурса', gender: 'masculine' },
                        { word: 'имманенции', gender: 'feminine' },
                        { word: 'трансцендентности', gender: 'feminine' },
                        { word: 'апофатики', gender: 'feminine' },
                        { word: 'онтологии', gender: 'feminine' },
                        { word: 'диалектики', gender: 'feminine' },
                        { word: 'эйдоса', gender: 'masculine' },
                        { word: 'интенции', gender: 'feminine' },
                        { word: 'герменевтики', gender: 'feminine' },
                        
                        // Шизоаналитические термины
                        { word: 'шизопотока', gender: 'masculine' },
                        { word: 'детерриториализации', gender: 'feminine' },
                        { word: 'ризомы', gender: 'feminine' },
                        { word: 'плато', gender: 'neutral' },
                        { word: 'хаосмоса', gender: 'masculine' },
                        { word: 'тела-без-органов', gender: 'neutral' },
                        { word: 'номадологии', gender: 'feminine' },
                        { word: 'молекулярности', gender: 'feminine' },
                        { word: 'складки', gender: 'feminine' },
                        { word: 'трансверсальности', gender: 'feminine' },
                        
                        // Психоаналитические термины
                        { word: 'бессознательного', gender: 'neutral' },
                        { word: 'травмы', gender: 'feminine' },
                        { word: 'диссоциации', gender: 'feminine' },
                        { word: 'лакуны', gender: 'feminine' },
                        { word: 'идентичности', gender: 'feminine' },
                        { word: 'либидо', gender: 'neutral' },
                        { word: 'танатоса', gender: 'masculine' },
                        { word: 'эроса', gender: 'masculine' },
                        { word: 'интроекции', gender: 'feminine' },
                        { word: 'имаго', gender: 'neutral' },
                        
                        // Квантовые и хаотические термины
                        { word: 'суперпозиции', gender: 'feminine' },
                        { word: 'запутанности', gender: 'feminine' },
                        { word: 'бифуркации', gender: 'feminine' },
                        { word: 'аттрактора', gender: 'masculine' },
                        { word: 'энтропии', gender: 'feminine' },
                        { word: 'фрактала', gender: 'masculine' },
                        { word: 'диссипации', gender: 'feminine' },
                        { word: 'нелинейности', gender: 'feminine' },
                        { word: 'сингулярности', gender: 'feminine' },
                        
                        // Нейрокогнитивные термины
                        { word: 'нейропластичности', gender: 'feminine' },
                        { word: 'интероцепции', gender: 'feminine' },
                        { word: 'квалиа', gender: 'neutral' },
                        { word: 'апофении', gender: 'feminine' },
                        { word: 'парейдолии', gender: 'feminine' },
                        { word: 'синестезии', gender: 'feminine' },
                        { word: 'метакогниции', gender: 'feminine' },
                        { word: 'синапса', gender: 'masculine' },
                        
                        // Лингвистические термины
                        { word: 'семиозиса', gender: 'masculine' },
                        { word: 'означающего', gender: 'neutral' },
                        { word: 'означаемого', gender: 'neutral' },
                        { word: 'метаязыка', gender: 'masculine' },
                        { word: 'глоссолалии', gender: 'feminine' },
                        { word: 'праязыка', gender: 'masculine' },
                        { word: 'палеоглоссы', gender: 'feminine' },
                        { word: 'асемии', gender: 'feminine' },
                        { word: 'симулякра', gender: 'masculine' },
                        
                        // Темпоральные термины
                        { word: 'анахронизма', gender: 'masculine' },
                        { word: 'диахронии', gender: 'feminine' },
                        { word: 'синхронии', gender: 'feminine' },
                        { word: 'хронестезии', gender: 'feminine' },
                        { word: 'ахронии', gender: 'feminine' },
                        { word: 'кайроса', gender: 'masculine' },
                        { word: 'хронотопа', gender: 'masculine' },
                        
                        // Медитативные термины
                        { word: 'трансценденции', gender: 'feminine' },
                        { word: 'созерцания', gender: 'neutral' },
                        { word: 'самадхи', gender: 'neutral' },
                        { word: 'сатори', gender: 'neutral' },
                        { word: 'саморефлексии', gender: 'feminine' },
                        { word: 'осознанности', gender: 'feminine' },
                        { word: 'интроспекции', gender: 'feminine' },
                        { word: 'самопрозрачности', gender: 'feminine' }
                    ]
                }
            };

            // Псевдоматематические символы для генерации формул
            const mathSymbols = {
                // Греческие буквы
                greekLetters: [
                    'α', 'β', 'γ', 'δ', 'ε', 'ζ', 'η', 'θ', 'ι', 'κ', 'λ', 'μ', 
                    'ν', 'ξ', 'ο', 'π', 'ρ', 'σ', 'τ', 'υ', 'φ', 'χ', 'ψ', 'ω',
                    'Α', 'Β', 'Γ', 'Δ', 'Ε', 'Ζ', 'Η', 'Θ', 'Ι', 'Κ', 'Λ', 'Μ', 
                    'Ν', 'Ξ', 'Ο', 'Π', 'Ρ', 'Σ', 'Τ', 'Υ', 'Φ', 'Χ', 'Ψ', 'Ω'
                ],
                
                // Математические операторы
                operators: [
                    '+', '-', '×', '÷', '±', '∓', '=', '≠', '≈', '≡', '<', '>', '≤', '≥',
                    '∑', '∏', '∫', '∬', '∭', '∮', '∯', '∰', '∇', '∂', '∆', '√', '∛', '∜',
                    '∝', '∧', '∨', '⊕', '⊗', '⊂', '⊃', '⊄', '⊅', '⊆', '⊇', '∩', '∪', '∈', '∉',
                    '⇒', '⇔', '→', '↔', '↦', '∞', '∼', '∝'
                ],
                
                // Числовые множества и специальные символы
                specialSets: [
                    'ℕ', 'ℤ', 'ℚ', 'ℝ', 'ℂ', 'ℙ', 'ℍ', 'ℵ', '𝔽', '𝕊', 
                    '∅', '∀', '∃', '∄', '∴', '∵', '⋮', '⋯', '…'
                ],
                
                // Скобки и ограничители
                delimiters: [
                    '(', ')', '[', ']', '{', '}', '⟨', '⟩', '|', '‖', '⌊', '⌋', '⌈', '⌉', '⌜', '⌝', '⌞', '⌟'
                ],
                
                // Переменные (latin и script буквы для переменных)
                variables: [
                    'a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
                    'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
                    '𝑎', '𝑏', '𝑐', '𝑑', '𝑓', '𝑔', '𝑥', '𝑦', '𝑧',
                    '𝒂', '𝒃', '𝒄', '𝒙', '𝒚', '𝒛'
                ],
                
                // Индексы, степени и пр.
                indices: [
                    '₀', '₁', '₂', '₃', '₄', '₅', '₆', '₇', '₈', '₉', '₍', '₎', 'ₐ', 'ₑ', 'ₓ',
                    '⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹', '⁽', '⁾', 'ⁿ'
                ],
                
                // Дополнительные математические обозначения и структуры
                structures: [
                    '∑', '∏', '∫', '∬', '∭', '∮', '∯', '∰', '⨌', '⨍', '⨎', '⨏',
                    '⟹', '⟺', '⟻', '⟼', '⟿', '⤇', '⇔', '⇐', '⇑', '⇓', '⇕', '⇖', '⇗', '⇘', '⇙',
                    '↔', '↕', '↖', '↗', '↘', '↙', '↚', '↛', '↮',
                    '⊢', '⊣', '⊤', '⊥', '⊧', '⊨', '⊩', '⊪', '⊫', '⊬', '⊭', '⊮', '⊯',
                    '□', '■', '◊', '○', '●', '△', '▲', '▽', '▼', '◇', '◆', '◁', '◀', '▷', '▶'
                ]
            };

            // Шаблоны для генерации формул
            const mathFormulaPattens = [
                // Простые выражения
                "VAR = EXPR",
                "VAR OPERATOR VAR",
                "FUNC(VAR)",
                "VAR INDICES",
                "VAR = CONST",
                
                // Уравнения
                "VAR_1 OPERATOR_1 VAR_2 = VAR_3 OPERATOR_2 VAR_4",
                "GREEK OPERATOR_1 CONST = EXPR",
                "GREEK(VAR) = EXPR",
                
                // Тригонометрические и другие функции
                "sin(VAR) = EXPR",
                "cos(VAR) = EXPR",
                "tan(VAR) = EXPR",
                "log(VAR) = EXPR",
                "exp(VAR) = EXPR",
                "lim(VAR OPERATOR CONST) = EXPR",
                
                // Производные и интегралы
                "d/d VAR (EXPR) = EXPR",
                "∫ EXPR d VAR = EXPR",
                "∫_CONST^VAR EXPR d VAR = EXPR",
                "∮ EXPR d VAR = CONST",
                
                // Суммы и произведения
                "∑_INDICES^VAR EXPR = EXPR",
                "∏_INDICES^VAR EXPR = EXPR",
                
                // Матрицы и векторы
                "DELIM_L VAR_1, VAR_2, ..., VAR_N DELIM_R",
                "[VAR_1, VAR_2, VAR_3] OPERATOR [VAR_4, VAR_5, VAR_6]",
                
                // Теоретико-множественные 
                "VAR_1 ∈ SET",
                "VAR_1 ∩ VAR_2 = SET",
                "VAR_1 ∪ VAR_2 = SET",
                
                // Логические выражения
                "∀ VAR: EXPR",
                "∃ VAR: EXPR",
                "VAR_1 ⟹ VAR_2",
                "EXPR_1 ⟺ EXPR_2",
                
                // Комбинированные сложные выражения
                "DELIM_L OPERATOR EXPR DELIM_R = CONST",
                "EXPR_1 ⟺ EXPR_2 ⟺ EXPR_3",
                "FUNC(EXPR) = VAR",
                "FUNC(VAR) = FUNC_2(VAR_2)",
                
                // Дифференциальные уравнения
                "∂²GREEK/∂VAR² = EXPR",
                "Δ GREEK = EXPR",
                
                // Тензорные выражения
                "GREEK_INDICES = EXPR",
                "GREEK_INDICES OPERATOR GREEK_INDICES = EXPR",
                
                // Квантовомеханические обозначения
                "⟨GREEK|GREEK⟩ = EXPR",
                "|GREEK⟩ = EXPR |VAR⟩",
                
                // Теоретико-числовые выражения
                "gcd(VAR_1, VAR_2) = CONST",
                "EXPR ≡ EXPR_2 (mod VAR)",
                
                // Абстрактные выражения
                "OPERATOR_STRUCT EXPR",
                "GREEK ∘ GREEK = EXPR",
                
                // Бессмысленные, но правдоподобные
                "GREEK → EXPR_COMPLEX",
                "GREEK ↦ GREEK OPERATOR EXPR",
                "FUNC(VAR; STRUCT) = EXPR"
            ];
            
            // Custom cursor
            document.addEventListener('mousemove', function(e) {
                mouseX = e.clientX;
                mouseY = e.clientY;
                
                cursor.style.left = mouseX + 'px';
                cursor.style.top = mouseY + 'px';
                
                // Change cursor based on position
                const distFromCenter = Math.sqrt(
                    Math.pow(mouseX - window.innerWidth / 2, 2) + 
                    Math.pow(mouseY - window.innerHeight / 2, 2)
                );
                
                cursor.style.backgroundColor = `rgba(255, 255, 255, ${0.1 + (distFromCenter / window.innerWidth) * 0.4})`;
                cursor.style.width = (20 + Math.sin(Date.now() / 1000) * 5) + 'px';
                cursor.style.height = (20 + Math.cos(Date.now() / 1000) * 5) + 'px';
                
                lastInteractionTime = Date.now();
            });
            
            function createConsciousnessFragment() {
                const fragment = document.createElement('div');
                fragment.className = 'consciousness-fragment';
                
                // Generate grammatically correct prelingual phrase
                const phrase = generatePrelingualPhrase();
                fragment.textContent = phrase;
                
                // Random position and rotation
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                const z = Math.random() * 500 - 250;
                const rotX = Math.random() * 360;
                const rotY = Math.random() * 360;
                const rotZ = Math.random() * 360;
                
                // Смещаем позицию с учетом padding для более центрированного размещения элемента
                fragment.style.left = (x - 15) + 'px';
                fragment.style.top = (y - 15) + 'px';
                fragment.style.transform = `translateZ(${z}px) rotateX(${rotX}deg) rotateY(${rotY}deg) rotateZ(${rotZ}deg)`;
                
                // Random color and opacity
                const hue = Math.floor(Math.random() * 360);
                const opacity = 0.4 + Math.random() * 0.6;
                fragment.style.color = `hsla(${hue}, 70%, 70%, ${opacity})`;
                
                container.appendChild(fragment);
                
                // Store animation parameters for this fragment
                fragmentAnimations.set(fragment, {
                    // Position
                    x: x - 15, // учитываем смещение из-за padding
                    y: y - 15,
                    z: z,
                    // Rotation
                    rotX: rotX,
                    rotY: rotY,
                    rotZ: rotZ,
                    // Velocity (position)
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    vz: (Math.random() - 0.5) * 1,
                    // Velocity (rotation)
                    vRotX: (Math.random() - 0.5) * 0.3,
                    vRotY: (Math.random() - 0.5) * 0.3,
                    vRotZ: (Math.random() - 0.5) * 0.3,
                    // Original parameters for hover state
                    originalZ: z,
                    isHovered: false
                });
                
                // Interactive behavior
                fragment.addEventListener('mouseover', function() {
                    const params = fragmentAnimations.get(this);
                    params.isHovered = true;
                    this.style.zIndex = 100;
                    
                    // Emit primal symbol on hover
                    emitPrimalSymbol(params.x, params.y);
                    
                    // Update meta panel
                    updateMetaPanel();
                });
                
                fragment.addEventListener('mouseout', function() {
                    const params = fragmentAnimations.get(this);
                    params.isHovered = false;
                    this.style.zIndex = 0;
                });
                
                fragment.addEventListener('click', function() {
                    // Trigger cartographic state change
                    const stateChange = Math.random();
                    
                    if (stateChange < 0.33) {
                        cartograph.style.transform = `translate(-50%, -50%) rotate(${Math.random() * 360}deg)`;
                        cartograph.style.borderRadius = `${30 + Math.random() * 50}% ${30 + Math.random() * 50}% ${30 + Math.random() * 50}% ${30 + Math.random() * 50}%`;
                    } else if (stateChange < 0.66) {
                        cartograph.style.width = (40 + Math.random() * 40) + 'vmin';
                        cartograph.style.height = (40 + Math.random() * 40) + 'vmin';
                        cartograph.style.border = `${1 + Math.random() * 3}px dashed rgba(255, 255, 255, ${0.1 + Math.random() * 0.4})`;
                    } else {
                        const hue = Math.floor(Math.random() * 360);
                        cartograph.style.boxShadow = `0 0 50px hsla(${hue}, 70%, 50%, 0.3)`;
                        setTimeout(() => {
                            cartograph.style.boxShadow = 'none';
                        }, 2000);
                    }
                    
                    // Generate proto-language
                    generateProtoLanguage();
                });
                
                return fragment;
            }
            
            // Generate grammatically correct prelingual phrase
            function generatePrelingualPhrase() {
                const phraseType = Math.random();
                
                if (phraseType < 0.4) {
                    // Adjective + Noun
                    const nounObj = prelingualWords[Math.floor(Math.random() * prelingualWords.length)];
                    const adjObj = prelingualAdjectives[Math.floor(Math.random() * prelingualAdjectives.length)];
                    
                    return adjObj.stem + adjObj.endings[nounObj.gender] + ' ' + nounObj.word;
                } else if (phraseType < 0.7) {
                    // Noun + Verb
                    const nounObj = prelingualWords[Math.floor(Math.random() * prelingualWords.length)];
                    const verb = prelingualVerbs[Math.floor(Math.random() * prelingualVerbs.length)];
                    
                    return nounObj.word + ' ' + verb;
                } else {
                    // Just return a single noun
                    return prelingualWords[Math.floor(Math.random() * prelingualWords.length)].word;
                }
            }
            
            function emitPrimalSymbol(x, y) {
                const symbol = document.createElement('div');
                symbol.className = 'primal-symbol';
                
                // Select random primal symbol
                symbol.textContent = prelingualSymbols[Math.floor(Math.random() * prelingualSymbols.length)];
                
                // Position near the fragment
                symbol.style.left = (x - 10 + Math.random() * 20) + 'px';
                symbol.style.top = (y - 10 + Math.random() * 20) + 'px';
                
                // Random color
                const hue = Math.floor(Math.random() * 360);
                symbol.style.color = `hsl(${hue}, 70%, 70%)`;
                
                container.appendChild(symbol);
                
                // Animate and remove
                setTimeout(() => {
                    symbol.style.transform = `translate(${Math.random() * 100 - 50}px, ${Math.random() * 100 - 50}px) scale(${0.5 + Math.random()})`;
                    symbol.style.opacity = 0;
                }, 50);
                
                setTimeout(() => {
                    container.removeChild(symbol);
                }, 1000);
            }
            
            function updateThoughtStream() {
                // Generate recombined thought fragment
                const fragment = generateRecombinedThought();
                
                if (thoughtStream.textContent.length > 200) {
                    thoughtStream.textContent = thoughtStream.textContent.substring(100) + ' ' + fragment;
                } else {
                    thoughtStream.textContent += ' ' + fragment;
                }
            }
            
            // Generate recombined thought with grammatical structure
            function generateRecombinedThought() {
                const thoughtStructure = Math.random();
                
                if (thoughtStructure < 0.3) {
                    // Прилагательное + существительное (именительный падеж) с согласованием по роду
                    const nounObj = thoughtFragmentsCategories.nouns.nominative[Math.floor(Math.random() * thoughtFragmentsCategories.nouns.nominative.length)];
                    let adj;
                    
                    if (nounObj.gender === 'masculine') {
                        adj = thoughtFragmentsCategories.adjectives.nominative.masculine[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.nominative.masculine.length)];
                    } else if (nounObj.gender === 'feminine') {
                        adj = thoughtFragmentsCategories.adjectives.nominative.feminine[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.nominative.feminine.length)];
                    } else {
                        adj = thoughtFragmentsCategories.adjectives.nominative.neutral[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.nominative.neutral.length)];
                    }
                    
                    return adj + ' ' + nounObj.word + '...';
                } else if (thoughtStructure < 0.6) {
                    // Прилагательное + существительное + существительное в родительном падеже с согласованием
                    const nounObj1 = thoughtFragmentsCategories.nouns.nominative[Math.floor(Math.random() * thoughtFragmentsCategories.nouns.nominative.length)];
                    const nounObj2 = thoughtFragmentsCategories.nouns.genitive[Math.floor(Math.random() * thoughtFragmentsCategories.nouns.genitive.length)];
                    
                    let adj;
                    if (nounObj1.gender === 'masculine') {
                        adj = thoughtFragmentsCategories.adjectives.nominative.masculine[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.nominative.masculine.length)];
                    } else if (nounObj1.gender === 'feminine') {
                        adj = thoughtFragmentsCategories.adjectives.nominative.feminine[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.nominative.feminine.length)];
                    } else {
                        adj = thoughtFragmentsCategories.adjectives.nominative.neutral[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.nominative.neutral.length)];
                    }
                    
                    return adj + ' ' + nounObj1.word + ' ' + nounObj2.word + '...';
                } else if (thoughtStructure < 0.8) {
                    // Существительное + прилагательное в родительном падеже + существительное в родительном падеже
                    const nounObj1 = thoughtFragmentsCategories.nouns.nominative[Math.floor(Math.random() * thoughtFragmentsCategories.nouns.nominative.length)];
                    const nounObj2 = thoughtFragmentsCategories.nouns.genitive[Math.floor(Math.random() * thoughtFragmentsCategories.nouns.genitive.length)];
                    
                    let adj;
                    if (nounObj2.gender === 'masculine') {
                        adj = thoughtFragmentsCategories.adjectives.genitive.masculine[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.genitive.masculine.length)];
                    } else if (nounObj2.gender === 'feminine') {
                        adj = thoughtFragmentsCategories.adjectives.genitive.feminine[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.genitive.feminine.length)];
                    } else {
                        adj = thoughtFragmentsCategories.adjectives.genitive.neutral[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.genitive.neutral.length)];
                    }
                    
                    return nounObj1.word + ' ' + adj + ' ' + nounObj2.word + '...';
                } else {
                    // Двойное прилагательное + существительное с согласованием
                    const nounObj = thoughtFragmentsCategories.nouns.nominative[Math.floor(Math.random() * thoughtFragmentsCategories.nouns.nominative.length)];
                    let adj1, adj2;
                    
                    if (nounObj.gender === 'masculine') {
                        adj1 = thoughtFragmentsCategories.adjectives.nominative.masculine[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.nominative.masculine.length)];
                        // Выбираем другое прилагательное, чтобы не было повторений
                        do {
                            adj2 = thoughtFragmentsCategories.adjectives.nominative.masculine[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.nominative.masculine.length)];
                        } while (adj1 === adj2);
                    } else if (nounObj.gender === 'feminine') {
                        adj1 = thoughtFragmentsCategories.adjectives.nominative.feminine[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.nominative.feminine.length)];
                        do {
                            adj2 = thoughtFragmentsCategories.adjectives.nominative.feminine[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.nominative.feminine.length)];
                        } while (adj1 === adj2);
                    } else {
                        adj1 = thoughtFragmentsCategories.adjectives.nominative.neutral[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.nominative.neutral.length)];
                        do {
                            adj2 = thoughtFragmentsCategories.adjectives.nominative.neutral[Math.floor(Math.random() * thoughtFragmentsCategories.adjectives.nominative.neutral.length)];
                        } while (adj1 === adj2);
                    }
                    
                    return adj1 + ' и ' + adj2 + ' ' + nounObj.word + '...';
                }
            }
            
            function updateMetaPanel() {
                metaValues.delta.textContent = (Math.random() * 0.5 + 0.2).toFixed(4);
                metaValues.phi.textContent = (1.618 + Math.random() * 0.1 - 0.05).toFixed(4);
                metaValues.tau.textContent = (Math.random() * 0.01).toFixed(4);
                
                // Occasionally show infinity as a different symbol
                if (Math.random() < 0.2) {
                    const alternateSymbols = ['∞', '⧞', '⧜', '⧝', '♾️', '∞⃟'];
                    metaValues.infinity.textContent = alternateSymbols[Math.floor(Math.random() * alternateSymbols.length)];
                }
            }
            
            function generateProtoLanguage() {
                // Generate a structured pre-linguistic phrase
                let phrase = '';
                const structureType = Math.random();
                
                if (structureType < 0.2) {
                    // Adjective + Noun + Verb
                    const nounObj = prelingualWords[Math.floor(Math.random() * prelingualWords.length)];
                    const adjObj = prelingualAdjectives[Math.floor(Math.random() * prelingualAdjectives.length)];
                    const verb = prelingualVerbs[Math.floor(Math.random() * prelingualVerbs.length)];
                    
                    phrase = adjObj.stem + adjObj.endings[nounObj.gender] + ' ' + nounObj.word + ' ' + verb;
                } else if (structureType < 0.4) {
                    // Noun + Verb + Adjective + Noun
                    const nounObj1 = prelingualWords[Math.floor(Math.random() * prelingualWords.length)];
                    const nounObj2 = prelingualWords[Math.floor(Math.random() * prelingualWords.length)];
                    const adjObj = prelingualAdjectives[Math.floor(Math.random() * prelingualAdjectives.length)];
                    const verb = prelingualVerbs[Math.floor(Math.random() * prelingualVerbs.length)];
                    
                    phrase = nounObj1.word + ' ' + verb + ' ' + adjObj.stem + adjObj.endings[nounObj2.gender] + ' ' + nounObj2.word;
                } else if (structureType < 0.6) {
                    // Two adjective-noun pairs
                    const nounObj1 = prelingualWords[Math.floor(Math.random() * prelingualWords.length)];
                    const nounObj2 = prelingualWords[Math.floor(Math.random() * prelingualWords.length)];
                    const adjObj1 = prelingualAdjectives[Math.floor(Math.random() * prelingualAdjectives.length)];
                    const adjObj2 = prelingualAdjectives[Math.floor(Math.random() * prelingualAdjectives.length)];
                    
                    phrase = adjObj1.stem + adjObj1.endings[nounObj1.gender] + ' ' + nounObj1.word + ' и ' +
                             adjObj2.stem + adjObj2.endings[nounObj2.gender] + ' ' + nounObj2.word;
                } else if (structureType < 0.8) {
                    // Сложное именное сказуемое: существительное + есть + существительное
                    const nounObj1 = prelingualWords[Math.floor(Math.random() * prelingualWords.length)];
                    const nounObj2 = prelingualWords[Math.floor(Math.random() * prelingualWords.length)];
                    
                    phrase = nounObj1.word + ' есть ' + nounObj2.word;
                } else {
                    // Распространенное наречное предложение: наречие + глагол + существительное
                    const nounObj = prelingualWords[Math.floor(Math.random() * prelingualWords.length)];
                    const verb = prelingualVerbs[Math.floor(Math.random() * prelingualVerbs.length)];
                    
                    // Создаем псевдо-наречия из корней прилагательных
                    const adjBase = prelingualAdjectives[Math.floor(Math.random() * prelingualAdjectives.length)].stem;
                    const adverb = adjBase + 'о'; // Преобразуем в наречие (напр. "быстр -> быстро")
                    
                    phrase = adverb + ' ' + verb + ' ' + nounObj.word;
                }
                
                // Sometimes add symbols
                if (Math.random() < 0.3) {
                    phrase += ' ' + prelingualSymbols[Math.floor(Math.random() * prelingualSymbols.length)];
                }
                
                protoLanguage.textContent = phrase;
                protoLanguage.style.opacity = 1;
                
                setTimeout(() => {
                    protoLanguage.style.opacity = 0;
                }, 3000);
            }
            
            function animateFragments() {
                // Get window boundaries
                const maxX = window.innerWidth;
                const maxY = window.innerHeight;
                const maxZ = 500;
                const minZ = -250;
                
                // Update each fragment's position and rotation
                fragmentAnimations.forEach((params, fragment) => {
                    if (params.isHovered) {
                        // When hovered, show special hover state
                        fragment.style.transform = `translateZ(${params.originalZ + 100}px) rotateX(${params.rotX + 180}deg) rotateY(${params.rotY + 90}deg) rotateZ(${params.rotZ - 45}deg) scale(1.5)`;
                    } else {
                        // Update position
                        params.x += params.vx;
                        params.y += params.vy;
                        params.z += params.vz;
                        
                        // Update rotation
                        params.rotX += params.vRotX;
                        params.rotY += params.vRotY;
                        params.rotZ += params.vRotZ;
                        
                        // Boundary check for position (wrap around)
                        if (params.x < 0) params.x = maxX;
                        if (params.x > maxX) params.x = 0;
                        if (params.y < 0) params.y = maxY;
                        if (params.y > maxY) params.y = 0;
                        
                        // Boundary check for Z (bounce)
                        if (params.z < minZ || params.z > maxZ) {
                            params.vz = -params.vz;
                            params.z += params.vz;
                        }
                        
                        // Update the element style
                        fragment.style.left = params.x + 'px';
                        fragment.style.top = params.y + 'px';
                        fragment.style.transform = `translateZ(${params.z}px) rotateX(${params.rotX}deg) rotateY(${params.rotY}deg) rotateZ(${params.rotZ}deg)`;
                    }
                });
                
                // Continue animation
                requestAnimationFrame(animateFragments);
            }

            // Функция для генерации псевдоматематической формулы
            function generateMathFormula() {
                const pattern = mathFormulaPattens[Math.floor(Math.random() * mathFormulaPattens.length)];
                let formula = pattern;
                
                // Замена шаблонных элементов на настоящие символы
                let iterations = 0;
                while (formula.includes("GREEK") || 
                       formula.includes("VAR") || 
                       formula.includes("OPERATOR") || 
                       formula.includes("CONST") || 
                       formula.includes("EXPR") ||
                       formula.includes("INDICES") ||
                       formula.includes("FUNC") ||
                       formula.includes("SET") ||
                       formula.includes("DELIM") ||
                       formula.includes("STRUCT")) {
                    
                    // Ограничение на количество итераций для предотвращения бесконечного цикла
                    iterations++;
                    if (iterations > 100) break;
                    
                    // Греческие буквы
                    if (formula.includes("GREEK")) {
                        formula = formula.replace(
                            "GREEK", 
                            mathSymbols.greekLetters[Math.floor(Math.random() * mathSymbols.greekLetters.length)]
                        );
                    }
                    
                    // Переменные
                    if (formula.includes("VAR")) {
                        const varRegex = /VAR(_\d+)?/;
                        const match = formula.match(varRegex);
                        if (match) {
                            formula = formula.replace(
                                match[0], 
                                mathSymbols.variables[Math.floor(Math.random() * mathSymbols.variables.length)]
                            );
                        }
                    }
                    
                    // Операторы
                    if (formula.includes("OPERATOR")) {
                        const opRegex = /OPERATOR(_\d+)?/;
                        const match = formula.match(opRegex);
                        if (match) {
                            formula = formula.replace(
                                match[0], 
                                mathSymbols.operators[Math.floor(Math.random() * mathSymbols.operators.length)]
                            );
                        }
                    }
                    
                    // Константы
                    if (formula.includes("CONST")) {
                        formula = formula.replace(
                            "CONST", 
                            Math.random() > 0.5 ? 
                                Math.floor(Math.random() * 10) : 
                                mathSymbols.specialSets[Math.floor(Math.random() * mathSymbols.specialSets.length)]
                        );
                    }
                    
                    // Индексы
                    if (formula.includes("INDICES")) {
                        formula = formula.replace(
                            "INDICES", 
                            mathSymbols.indices[Math.floor(Math.random() * mathSymbols.indices.length)]
                        );
                    }
                    
                    // Функции
                    if (formula.includes("FUNC")) {
                        const funcRegex = /FUNC(_\d+)?/;
                        const match = formula.match(funcRegex);
                        if (match) {
                            const functions = ["f", "g", "h", "F", "G", "H", "sin", "cos", "tan", "log", "exp", "Γ", "ζ", "sup", "inf", "lim"];
                            formula = formula.replace(match[0], functions[Math.floor(Math.random() * functions.length)]);
                        }
                    }
                    
                    // Множества
                    if (formula.includes("SET")) {
                        formula = formula.replace("SET", mathSymbols.specialSets[Math.floor(Math.random() * mathSymbols.specialSets.length)]);
                    }
                    
                    // Ограничители (скобки)
                    if (formula.includes("DELIM")) {
                        const leftDelimiters = ['(', '[', '{', '⟨', '|', '‖', '⌊', '⌈', '⌜', '⌞'];
                        const rightDelimiters = [')', ']', '}', '⟩', '|', '‖', '⌋', '⌉', '⌝', '⌟'];
                        
                        if (formula.includes("DELIM_L")) {
                            const delimIndex = Math.floor(Math.random() * leftDelimiters.length);
                            formula = formula.replace("DELIM_L", leftDelimiters[delimIndex]);
                        }
                        
                        if (formula.includes("DELIM_R")) {
                            const delimIndex = Math.floor(Math.random() * rightDelimiters.length);
                            formula = formula.replace("DELIM_R", rightDelimiters[delimIndex]);
                        }
                    }
                    
                    // Структуры
                    if (formula.includes("STRUCT")) {
                        formula = formula.replace(
                            "STRUCT", 
                            mathSymbols.structures[Math.floor(Math.random() * mathSymbols.structures.length)]
                        );
                    }
                    
                    // Выражения
                    if (formula.includes("EXPR")) {
                        const exprRegex = /EXPR(_\d+)?(_COMPLEX)?/;
                        const match = formula.match(exprRegex);
                        if (match) {
                            let replacement = '';
                            
                            if (match[0].includes("COMPLEX")) {
                                // Сложное выражение
                                const var1 = mathSymbols.variables[Math.floor(Math.random() * mathSymbols.variables.length)];
                                const var2 = mathSymbols.variables[Math.floor(Math.random() * mathSymbols.variables.length)];
                                const op1 = mathSymbols.operators[Math.floor(Math.random() * mathSymbols.operators.length)];
                                const op2 = mathSymbols.operators[Math.floor(Math.random() * mathSymbols.operators.length)];
                                
                                replacement = `${var1} ${op1} ${var2} ${op2} ${Math.floor(Math.random() * 10)}`;
                            } else {
                                // Простое выражение
                                if (Math.random() < 0.4) {
                                    // Константа
                                    replacement = String(Math.floor(Math.random() * 10));
                                } else if (Math.random() < 0.7) {
                                    // Переменная
                                    replacement = mathSymbols.variables[Math.floor(Math.random() * mathSymbols.variables.length)];
                                } else {
                                    // Переменная с операцией
                                    const variable = mathSymbols.variables[Math.floor(Math.random() * mathSymbols.variables.length)];
                                    const operator = mathSymbols.operators[Math.floor(Math.random() * mathSymbols.operators.length)];
                                    
                                    replacement = `${variable} ${operator} ${Math.floor(Math.random() * 10)}`;
                                }
                            }
                            
                            formula = formula.replace(match[0], replacement);
                        }
                    }
                }
                
                return formula;
            }

            // Функция для создания нового псевдоматематического элемента
            function createMathElement() {
                const mathElement = document.createElement('div');
                mathElement.className = 'math-element';
                
                // Генерируем псевдоматематическую формулу
                mathElement.textContent = generateMathFormula();
                
                // Стилизуем элемент
                const hue = Math.floor(Math.random() * 360);
                const opacity = 0.4 + Math.random() * 0.6;
                
                mathElement.style.position = 'absolute';
                mathElement.style.color = `hsla(${hue}, 85%, 75%, ${opacity})`;
                mathElement.style.fontSize = `${1 + Math.random() * 1.5}rem`;
                mathElement.style.fontFamily = 'serif, "Times New Roman", math';
                mathElement.style.whiteSpace = 'nowrap';
                mathElement.style.padding = '10px';
                mathElement.style.zIndex = '50';
                mathElement.style.userSelect = 'none';
                mathElement.style.pointerEvents = 'none';
                mathElement.style.textShadow = `0 0 3px hsla(${hue}, 70%, 60%, 0.5)`;
                
                // Размещаем элемент в случайной позиции
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                mathElement.style.left = `${x}px`;
                mathElement.style.top = `${y}px`;
                
                // Добавляем элемент в контейнер
                const container = document.getElementById('container');
                container.appendChild(mathElement);
                
                // Создаем параметры анимации для этого элемента
                const params = {
                    // Позиция
                    x: x,
                    y: y,
                    // Скорость
                    vx: (Math.random() - 0.5) * 1.5,
                    vy: (Math.random() - 0.5) * 1.5,
                    // Вращение
                    rot: Math.random() * 360,
                    vrot: (Math.random() - 0.5) * 0.8,
                    // Масштаб и прозрачность
                    scale: 0.5 + Math.random() * 1,
                    opacity: opacity,
                    // Время жизни элемента
                    lifetime: 10000 + Math.random() * 20000,
                    birthtime: Date.now()
                };
                
                // Сохраняем параметры анимации
                mathAnimations.set(mathElement, params);
                
                // Возвращаем созданный элемент
                return mathElement;
            }

            // Функция для анимации математических элементов
            function animateMathElements() {
                // Получаем текущее время
                const now = Date.now();
                
                // Обрабатываем каждый элемент
                mathAnimations.forEach((params, element) => {
                    // Проверяем, нужно ли удалить элемент
                    if (now - params.birthtime > params.lifetime) {
                        // Удаляем элемент из DOM и из мапы
                        element.remove();
                        mathAnimations.delete(element);
                        return;
                    }
                    
                    // Рассчитываем прогресс жизни (от 0 до 1)
                    const lifeProgress = (now - params.birthtime) / params.lifetime;
                    
                    // Обновляем позицию
                    params.x += params.vx;
                    params.y += params.vy;
                    params.rot += params.vrot;
                    
                    // Изменяем прозрачность - вначале повышаем, в конце понижаем
                    let currentOpacity = params.opacity;
                    if (lifeProgress < 0.2) {
                        // Нарастающая прозрачность в начале
                        currentOpacity = params.opacity * (lifeProgress / 0.2);
                    } else if (lifeProgress > 0.8) {
                        // Убывающая прозрачность в конце
                        currentOpacity = params.opacity * (1 - (lifeProgress - 0.8) / 0.2);
                    }
                    
                    // Обновляем стили элемента
                    element.style.left = `${params.x}px`;
                    element.style.top = `${params.y}px`;
                    element.style.transform = `rotate(${params.rot}deg) scale(${params.scale})`;
                    element.style.opacity = currentOpacity;
                });
                
                // Продолжаем анимацию
                requestAnimationFrame(animateMathElements);
            }
            
            // Regular updates
            setInterval(updateThoughtStream, 3000);
            setInterval(updateMetaPanel, 5000);
            
            // Automatic cartographic changes when inactive
            setInterval(() => {
                const now = Date.now();
                if (now - lastInteractionTime > 10000) {
                    // Create new consciousness fragment
                    if (document.querySelectorAll('.consciousness-fragment').length < 50) {
                        createConsciousnessFragment();
                    }
                    
                    // Random cartograph change
                    if (Math.random() < 0.3) {
                        cartograph.style.transform = `translate(-50%, -50%) rotate(${Math.random() * 360}deg)`;
                    }
                }
            }, 5000);
            
            // Initial thought stream update
            updateThoughtStream();
            
            // Create initial consciousness fragments
            for (let i = 0; i < 20; i++) {
                createConsciousnessFragment();
            }
            
            // Start animation
            animateFragments();

            // =====================================================
            // Аудио-система для шизографии пред-языкового сознания
            // =====================================================

            // Инициализация аудио-контекста
            let audioContext;
            let masterGainNode;
            let analyser;
            let audioInitialized = false;
            let audioEnabled = true;

            // Библиотека звуков и генераторов
            const soundLibrary = {
                oscillators: [],
                buffers: {},
                noises: {}
            };

            // Хранилище визуализаций звука
            const soundVisualizations = [];

            // Инициализация аудио-системы
            function initAudioSystem() {
                if (audioInitialized) return;
                
                try {
                    // Создаем аудио-контекст
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Создаем мастер-регулятор громкости
                    masterGainNode = audioContext.createGain();
                    masterGainNode.gain.value = 0.5; // Начальная громкость 50%
                    masterGainNode.connect(audioContext.destination);
                    
                    // Создаем анализатор для визуализации
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                    analyser.connect(masterGainNode);
                    
                    // Инициализируем генераторы шума
                    initNoiseGenerators();
                    
                    // Запускаем амбиентный звуковой ландшафт
                    startAmbientSoundscape();
                    
                    // Создаем буферы звуков для интерактивных элементов
                    createSoundBuffers();
                    
                    // Настраиваем интерактивные элементы для работы со звуком
                    setupSoundInteractions();
                    
                    // Добавляем обработчики событий для аудио-контролов
                    setupAudioControls();
                    
                    audioInitialized = true;
                    console.log("Аудио-система инициализирована");
                } catch (e) {
                    console.error("Ошибка при инициализации аудио-системы:", e);
                }
            }

            // Генераторы шума
            function initNoiseGenerators() {
                // Белый шум
                soundLibrary.noises.white = createNoiseBuffer(audioContext, 2, 'white');
                
                // Розовый шум (более насыщенный в низких частотах)
                soundLibrary.noises.pink = createNoiseBuffer(audioContext, 2, 'pink');
                
                // Коричневый/красный шум (еще более насыщенный в низких частотах)
                soundLibrary.noises.brown = createNoiseBuffer(audioContext, 2, 'brown');
                
                // Фиолетовый шум (акцент на высоких частотах)
                soundLibrary.noises.violet = createNoiseBuffer(audioContext, 2, 'violet');
                
                // Серый шум (перцептуально равномерный)
                soundLibrary.noises.grey = createNoiseBuffer(audioContext, 2, 'grey');
                
                // "Бархатный" шум (собственная реализация, приятная текстура)
                soundLibrary.noises.velvet = createNoiseBuffer(audioContext, 3, 'velvet');
            }

            // Функция для создания буфера шума
            function createNoiseBuffer(context, duration, type) {
                const sampleRate = context.sampleRate;
                const bufferSize = duration * sampleRate;
                const buffer = context.createBuffer(1, bufferSize, sampleRate);
                const data = buffer.getChannelData(0);
                
                if (type === 'white') {
                    // Белый шум - равномерное распределение
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                } else if (type === 'pink') {
                    // Розовый шум - более качественная реализация
                    let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                    
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        
                        b0 = 0.99886 * b0 + white * 0.0555179;
                        b1 = 0.99332 * b1 + white * 0.0750759;
                        b2 = 0.96900 * b2 + white * 0.1538520;
                        b3 = 0.86650 * b3 + white * 0.3104856;
                        b4 = 0.55000 * b4 + white * 0.5329522;
                        b5 = -0.7616 * b5 - white * 0.0168980;
                        
                        data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                        data[i] *= 0.11; // Нормализация
                        
                        b6 = white * 0.115926;
                    }
                } else if (type === 'brown') {
                    // Коричневый шум
                    let lastOut = 0.0;
                    
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        data[i] = (lastOut + (0.02 * white)) / 1.02;
                        lastOut = data[i];
                        data[i] *= 3.5; // Нормализация
                    }
                } else if (type === 'violet') {
                    // Фиолетовый шум (акцент на высоких частотах)
                    let lastValue = 0;
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        // Дифференцирование белого шума
                        data[i] = (white - lastValue);
                        lastValue = white;
                        
                        // Нормализация
                        data[i] *= 0.5;
                    }
                } else if (type === 'grey') {
                    // Серый шум (перцептуально равномерный)
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    
                    // Применяем перцептуальную кривую (приблизительная реализация)
                    const tempBuffer = context.createBuffer(1, bufferSize, sampleRate);
                    const tempData = tempBuffer.getChannelData(0);
                    
                    // Копируем исходные данные
                    for (let i = 0; i < bufferSize; i++) {
                        tempData[i] = data[i];
                    }
                    
                    // Применяем фильтрацию
                    for (let i = 3; i < bufferSize - 3; i++) {
                        // Простой перцептуальный фильтр
                        data[i] = 0.125 * tempData[i-3] + 
                                 0.25 * tempData[i-2] + 
                                 0.5 * tempData[i-1] + 
                                 tempData[i] + 
                                 0.5 * tempData[i+1] + 
                                 0.25 * tempData[i+2] + 
                                 0.125 * tempData[i+3];
                        
                        data[i] /= 2.75; // Нормализация
                    }
                } else if (type === 'velvet') {
                    // "Бархатный" шум - собственная реализация, смесь розового и коричневого
                    // с модуляцией для получения приятной текстуры
                    let b0 = 0, b1 = 0, b2 = 0;
                    
                    for (let i = 0; i < bufferSize; i++) {
                        const t = i / sampleRate; // время в секундах
                        const white = Math.random() * 2 - 1;
                        
                        // Базовый фильтрованный шум (между розовым и коричневым)
                        b0 = 0.99765 * b0 + white * 0.0990460;
                        b1 = 0.96300 * b1 + white * 0.2965164;
                        b2 = 0.57000 * b2 + white * 1.0526913;
                        
                        // Основной сигнал
                        let noise = b0 + b1 + b2 + white * 0.1848;
                        
                        // Модуляция сигнала низкочастотными волнами для органического движения
                        const mod1 = 0.2 * Math.sin(2 * Math.PI * 0.1 * t);
                        const mod2 = 0.15 * Math.sin(2 * Math.PI * 0.05 * t + 0.1);
                        const mod3 = 0.1 * Math.sin(2 * Math.PI * 0.02 * t + 0.3);
                        
                        // Применяем модуляцию
                        noise *= (1.0 + mod1 + mod2 + mod3);
                        
                        // Сохраняем результат с нормализацией
                        data[i] = noise * 0.16;
                    }
                }
                
                return buffer;
            }

            // Функция для воспроизведения шума
            function playNoise(type, gainValue, fadeInTime, duration, fadeOutTime) {
                if (!audioContext || !audioEnabled) return null;
                
                const source = audioContext.createBufferSource();
                source.buffer = soundLibrary.noises[type];
                source.loop = true;
                
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0;
                
                source.connect(gainNode);
                gainNode.connect(analyser);
                
                source.start();
                
                // Плавное включение звука
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(gainValue, audioContext.currentTime + fadeInTime);
                
                // Если указана продолжительность, планируем выключение
                if (duration) {
                    gainNode.gain.setValueAtTime(gainValue, audioContext.currentTime + fadeInTime + duration);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + fadeInTime + duration + fadeOutTime);
                    
                    setTimeout(() => {
                        source.stop();
                    }, (fadeInTime + duration + fadeOutTime) * 1000);
                }
                
                return {
                    source: source,
                    gain: gainNode,
                    stop: function(releaseTime = 1) {
                        const stopTime = audioContext.currentTime + releaseTime;
                        gainNode.gain.linearRampToValueAtTime(0, stopTime);
                        
                        setTimeout(() => {
                            source.stop();
                        }, releaseTime * 1000);
                    }
                };
            }

            // Создание звуковых буферов для различных элементов
            function createSoundBuffers() {
                // Создаем буферы для различных интерактивных звуков
                
                // Буфер для символов прото-языка
                soundLibrary.buffers.protoSymbols = [];
                
                // Создаем набор синтезированных звуков для прото-языка
                for (let i = 0; i < 12; i++) {
                    const duration = 0.2 + Math.random() * 0.5;
                    const bufferSize = audioContext.sampleRate * duration;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    // Базовая частота
                    const baseFreq = 150 + i * 50;
                    
                    // Генерируем звук с помощью FM-синтеза
                    for (let j = 0; j < bufferSize; j++) {
                        const t = j / audioContext.sampleRate;
                        
                        // Модуляция частоты
                        const modFreq = baseFreq * (1 + 0.1 * Math.sin(2 * Math.PI * 5 * t));
                        
                        // Основной сигнал
                        data[j] = 0.5 * Math.sin(2 * Math.PI * modFreq * t);
                        
                        // Добавляем гармоники
                        data[j] += 0.25 * Math.sin(2 * Math.PI * modFreq * 2 * t);
                        data[j] += 0.125 * Math.sin(2 * Math.PI * modFreq * 3 * t);
                        
                        // Формируем огибающую (ADSR)
                        let envelope = 1;
                        const attackTime = 0.01;
                        const decayTime = 0.05;
                        const sustainLevel = 0.5;
                        const releaseTime = duration - attackTime - decayTime;
                        
                        if (t < attackTime) {
                            envelope = t / attackTime;
                        } else if (t < attackTime + decayTime) {
                            envelope = 1 - (1 - sustainLevel) * ((t - attackTime) / decayTime);
                        } else if (t < duration - releaseTime) {
                            envelope = sustainLevel;
                        } else {
                            envelope = sustainLevel * (1 - (t - (duration - releaseTime)) / releaseTime);
                        }
                        
                        data[j] *= envelope;
                    }
                    
                    soundLibrary.buffers.protoSymbols.push(buffer);
                }
                
                // Буфер для фрагментов сознания
                soundLibrary.buffers.consciousnessFragments = [];
                
                // Создаем набор звуков для фрагментов сознания
                for (let i = 0; i < 8; i++) {
                    const duration = 0.5 + Math.random() * 1.0;
                    const bufferSize = audioContext.sampleRate * duration;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    // Частота звука зависит от индекса
                    const baseFreq = 80 + i * 40;
                    
                    // Генерируем звук с помощью гранулярного синтеза
                    for (let j = 0; j < bufferSize; j++) {
                        const t = j / audioContext.sampleRate;
                        
                        // Генерирование микрогранул
                        if (Math.random() < 0.1) {
                            const grainDuration = 0.01 + Math.random() * 0.03;
                            const grainFreq = baseFreq * (0.8 + Math.random() * 0.4);
                            
                            for (let k = 0; k < grainDuration * audioContext.sampleRate && j + k < bufferSize; k++) {
                                const gt = k / audioContext.sampleRate;
                                
                                // Форма огибающей гранулы (колоколообразная)
                                const envelope = Math.sin(Math.PI * gt / grainDuration);
                                
                                // Синусоидальный сигнал гранулы
                                data[j + k] += 0.2 * envelope * Math.sin(2 * Math.PI * grainFreq * gt);
                            }
                        }
                    }
                    
                    // Нормализация для предотвращения клиппинга
                    let max = 0;
                    for (let j = 0; j < bufferSize; j++) {
                        max = Math.max(max, Math.abs(data[j]));
                    }
                    
                    if (max > 0) {
                        for (let j = 0; j < bufferSize; j++) {
                            data[j] /= max;
                            
                            // Применяем общую огибающую
                            const t = j / bufferSize;
                            const envelope = Math.sin(Math.PI * t);
                            data[j] *= envelope;
                        }
                    }
                    
                    soundLibrary.buffers.consciousnessFragments.push(buffer);
                }
                
                // Буферы для мысленного потока
                soundLibrary.buffers.thoughtStream = [];
                
                for (let i = 0; i < 5; i++) {
                    const duration = 1.0 + Math.random() * 2.0;
                    const bufferSize = audioContext.sampleRate * duration;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    // Базовая частота зависит от индекса
                    const baseFreq = 40 + i * 20;
                    
                    // Генерируем дрон-подобный звук
                    for (let j = 0; j < bufferSize; j++) {
                        const t = j / audioContext.sampleRate;
                        
                        // Основной тон с модуляцией частоты
                        const modFreq = baseFreq * (1 + 0.02 * Math.sin(2 * Math.PI * 0.1 * t));
                        data[j] = 0.1 * Math.sin(2 * Math.PI * modFreq * t);
                        
                        // Добавляем гармоники
                        for (let harmonic = 2; harmonic <= 8; harmonic++) {
                            const harmonicAmp = 0.1 / harmonic;
                            data[j] += harmonicAmp * Math.sin(2 * Math.PI * modFreq * harmonic * t);
                        }
                        
                        // Формируем общую огибающую
                        const attack = 0.2 * duration;
                        const release = 0.3 * duration;
                        let envelope = 1;
                        
                        if (t < attack) {
                            envelope = t / attack;
                        } else if (t > duration - release) {
                            envelope = (duration - t) / release;
                        }
                        
                        data[j] *= envelope;
                        
                        // Добавляем немного шума для создания текстуры
                        if (Math.random() < 0.05) {
                            data[j] += 0.02 * (Math.random() * 2 - 1);
                        }
                    }
                    
                    soundLibrary.buffers.thoughtStream.push(buffer);
                }
                
                // Буферы для математических элементов
                soundLibrary.buffers.mathElements = [];
                
                for (let i = 0; i < 6; i++) {
                    const duration = 0.3 + Math.random() * 0.5;
                    const bufferSize = audioContext.sampleRate * duration;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    // Высокая частота для математических элементов
                    const baseFreq = 500 + i * 200;
                    
                    // Генерируем "кристаллический" звук
                    for (let j = 0; j < bufferSize; j++) {
                        const t = j / audioContext.sampleRate;
                        
                        // Звук с модуляцией амплитуды и частоты
                        const freqMod = baseFreq * (1 + 0.05 * Math.sin(2 * Math.PI * 8 * t));
                        const ampMod = 0.5 + 0.5 * Math.sin(2 * Math.PI * 4 * t);
                        
                        data[j] = ampMod * Math.sin(2 * Math.PI * freqMod * t);
                        
                        // Добавляем неравномерные клики для кристаллического эффекта
                        if (Math.random() < 0.03) {
                            data[j] += 0.3 * (Math.random() * 2 - 1);
                        }
                        
                        // Огибающая (быстрая атака, экспоненциальное затухание)
                        const decay = Math.exp(-5 * t);
                        data[j] *= decay;
                    }
                    
                    soundLibrary.buffers.mathElements.push(buffer);
                }
                
                // Буферы для картографа
                soundLibrary.buffers.cartograph = [];
                
                for (let i = 0; i < 4; i++) {
                    const duration = 2.0 + Math.random() * 3.0;
                    const bufferSize = audioContext.sampleRate * duration;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    // Низкая частота для картографа
                    const baseFreq = 30 + i * 15;
                    
                    // Генерируем "пространственный" резонансный звук
                    for (let j = 0; j < bufferSize; j++) {
                        const t = j / audioContext.sampleRate;
                        
                        // Основной тон
                        data[j] = 0.2 * Math.sin(2 * Math.PI * baseFreq * t);
                        
                        // Добавляем резонансы
                        for (let res = 1; res <= 5; res++) {
                            const resFreq = baseFreq * (res * 1.5);
                            const resAmp = 0.1 / res;
                            const resPhase = Math.random() * Math.PI * 2;
                            
                            data[j] += resAmp * Math.sin(2 * Math.PI * resFreq * t + resPhase);
                        }
                        
                        // Формируем огибающую (медленная атака, длинное затухание)
                        const attack = 0.4 * duration;
                        const release = 0.6 * duration;
                        let envelope = 1;
                        
                        if (t < attack) {
                            envelope = t / attack;
                        } else if (t > duration - release) {
                            envelope = (duration - t) / release;
                        }
                        
                        data[j] *= envelope;
                        
                        // Добавляем легкую модуляцию амплитуды для эффекта глубины
                        data[j] *= (0.8 + 0.2 * Math.sin(2 * Math.PI * 0.1 * t));
                    }
                    
                    soundLibrary.buffers.cartograph.push(buffer);
                }
            }

            // Воспроизведение звука из буфера с плавным затуханием
            function playSound(bufferArray, pitch = 1, gainValue = 0.3, pan = 0, releaseTime = 1.5) {
                if (!audioContext || !audioEnabled) return null;
                
                // Выбираем случайный буфер из массива
                const buffer = bufferArray[Math.floor(Math.random() * bufferArray.length)];
                
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.playbackRate.value = pitch;
                
                // Создаем регулятор громкости
                const gainNode = audioContext.createGain();
                gainNode.gain.value = gainValue;
                
                // Создаем панорамирование
                const pannerNode = audioContext.createStereoPanner();
                pannerNode.pan.value = pan;
                
                // Соединяем узлы
                source.connect(gainNode);
                gainNode.connect(pannerNode);
                pannerNode.connect(analyser);
                
                // Планируем плавное затухание в конце буфера
                const now = audioContext.currentTime;
                const bufferDuration = buffer.duration / pitch; // С учетом питча
                
                // Устанавливаем начальное значение громкости
                gainNode.gain.setValueAtTime(gainValue, now);
                
                // Планируем плавное затухание в конце буфера
                gainNode.gain.setValueAtTime(gainValue, now + bufferDuration - releaseTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + bufferDuration); // 0.001 вместо 0, т.к. exponentialRamp не работает с 0
                
                // Запускаем воспроизведение
                source.start();
                
                // Планируем остановку с небольшим запасом после окончания затухания
                source.stop(now + bufferDuration + 0.1);
                
                return {
                    source: source,
                    gain: gainNode,
                    panner: pannerNode,
                    // Добавляем метод для преждевременной остановки со своим releaseTime
                    stop: function(customReleaseTime = releaseTime) {
                        const stopTime = audioContext.currentTime;
                        gainNode.gain.cancelScheduledValues(stopTime);
                        gainNode.gain.setValueAtTime(gainNode.gain.value, stopTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, stopTime + customReleaseTime);
                        
                        // Останавливаем источник после затухания
                        source.stop(stopTime + customReleaseTime + 0.1);
                    }
                };
            }

            // Запуск амбиентного звукового ландшафта
            function startAmbientSoundscape() {
                // Сохраняем информацию о движении курсора
                let cursorData = {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2,
                    prevX: window.innerWidth / 2,
                    prevY: window.innerHeight / 2,
                    velocityX: 0,
                    velocityY: 0,
                    lastUpdate: audioContext.currentTime
                };
                
                // Глобальные параметры для контроля скорости изменений звукового ландшафта
                const ambientSettings = {
                    // Общий множитель для времени эволюции (больше = медленнее)
                    evolutionTimeScale: 4.0,
                    
                    // Множитель плотности звуковых событий (меньше = реже)
                    densityScale: 0.5,
                    
                    // Глубина модуляции от движения курсора (меньше = тоньше влияние)
                    cursorInfluenceScale: 0.6,
                    
                    // Множитель скорости переходов (больше = плавнее)
                    transitionTimeScale: 3.0
                };
                
                // Обновляем информацию о движении курсора
                document.addEventListener('mousemove', function(e) {
                    const now = audioContext.currentTime;
                    const deltaTime = now - cursorData.lastUpdate;
                    if (deltaTime > 0) {
                        // Запоминаем предыдущую позицию
                        cursorData.prevX = cursorData.x;
                        cursorData.prevY = cursorData.y;
                        
                        // Обновляем текущую позицию
                        cursorData.x = e.clientX;
                        cursorData.y = e.clientY;
                        
                        // Рассчитываем скорость движения (пикселей в секунду)
                        cursorData.velocityX = (cursorData.x - cursorData.prevX) / deltaTime;
                        cursorData.velocityY = (cursorData.y - cursorData.prevY) / deltaTime;
                        
                        // Обновляем время последнего обновления
                        cursorData.lastUpdate = now;
                    }
                });
                
                // 1. Создаем гранулярный синтезатор ======================================================
                
                // Константы для гранулярного синтеза
                const GRAIN_MIN_SIZE = 0.02 * ambientSettings.transitionTimeScale; // минимальный размер гранулы (сек)
                const GRAIN_MAX_SIZE = 0.1 * ambientSettings.transitionTimeScale; // максимальный размер гранулы (сек)
                const GRAIN_MIN_INTERVAL = 0.02 * ambientSettings.evolutionTimeScale; // минимальный интервал между гранулами (сек)

                const GRAIN_MAX_INTERVAL = 0.08 * ambientSettings.evolutionTimeScale; // максимальный интервал между гранулами (сек)
                
                // Создаем основные наборы звуковых гранул
                const granularSets = [
                    // 1. Набор низких резонансных тонов
                    {
                        baseFreq: 60,
                        freqSpread: 30,
                        attack: 0.01,
                        release: 0.2,
                        panRange: 0.8,
                        volume: 0.03,
                        densityFactor: 1.0,
                        filter: {
                            type: 'lowpass',
                            freq: 800,
                            Q: 2
                        }
                    },
                    // 2. Набор средних рассеянных созвучий
                    {
                        baseFreq: 300,
                        freqSpread: 250,
                        attack: 0.02,
                        release: 0.2,
                        panRange: 0.9,
                        volume: 0.015,
                        densityFactor: 0.8,
                        filter: {
                            type: 'bandpass',
                            freq: 1200,
                            Q: 3
                        }
                    },
                    // 3. Набор высоких "мерцающих" звуков
                    {
                        baseFreq: 2000,
                        freqSpread: 1500,
                        attack: 0.005,
                        release: 0.06,
                        panRange: 1.0,
                        volume: 0.01,
                        densityFactor: 0.6,
                        filter: {
                            type: 'highpass',
                            freq: 3000,
                            Q: 1
                        }
                    }
                ];
                
                // Функция создания звуковой гранулы
                function createGrain(setParams) {
                    // Пропускаем создание гранулы если звук отключен
                    if (!audioEnabled || !audioContext) return;
                    
                    // Создаем осциллятор для гранулы
                    const oscillator = audioContext.createOscillator();
                    const now = audioContext.currentTime;
                    
                    // Вычисляем параметры конкретной гранулы
                    const size = GRAIN_MIN_SIZE + Math.random() * (GRAIN_MAX_SIZE - GRAIN_MIN_SIZE);
                    const freq = setParams.baseFreq + (Math.random() * 2 - 1) * setParams.freqSpread;
                    const pan = (Math.random() * 2 - 1) * setParams.panRange;
                    
                    // Модуляция параметров от положения и скорости курсора
                    // X координата влияет на частоту, Y координата влияет на фильтр
                    const cursorXFactor = cursorData.x / window.innerWidth; // 0 to 1
                    const cursorYFactor = cursorData.y / window.innerHeight; // 0 to 1
                    const velocityFactor = Math.min(1, Math.sqrt(
                        cursorData.velocityX * cursorData.velocityX + 
                        cursorData.velocityY * cursorData.velocityY
                    ) / 2000); // Нормализация скорости, максимум 1
                    
                    // Применяем модуляцию частоты от положения по X
                    const modulatedFreq = freq * (0.8 + cursorXFactor * 0.4);
                    oscillator.frequency.value = modulatedFreq;
                    
                    // Выбираем тип волны случайным образом, с вероятностями:
                    const waveTypes = ['sine', 'triangle', 'sawtooth', 'square'];
                    const waveTypeProbs = [0.4, 0.3, 0.2, 0.1]; // Синусоида чаще всего, квадрат реже всего
                    
                    let waveTypeIndex = 0;
                    const waveTypeRand = Math.random();
                    let probSum = 0;
                    for (let i = 0; i < waveTypeProbs.length; i++) {
                        probSum += waveTypeProbs[i];
                        if (waveTypeRand <= probSum) {
                            waveTypeIndex = i;
                            break;
                        }
                    }
                    oscillator.type = waveTypes[waveTypeIndex];
                    
                    // Создаем усилитель с огибающей ADSR
                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = 0;
                    
                    // Создаем фильтр для формирования тембра
                    const filter = audioContext.createBiquadFilter();
                    filter.type = setParams.filter.type;
                    // Модулируем частоту фильтра от положения по Y
                    filter.frequency.value = setParams.filter.freq * (0.5 + cursorYFactor * 1.5);
                    // Модулируем резонанс от скорости движения
                    filter.Q.value = setParams.filter.Q * (1 + velocityFactor * 3);
                    
                    // Создаем панорамирование
                    const panner = audioContext.createStereoPanner();
                    panner.pan.value = pan;
                    
                    // Соединяем компоненты
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(panner);
                    panner.connect(analyser);
                    
                    // Настраиваем огибающую (attack-release)
                    const attack = setParams.attack * (1 + velocityFactor * 0.5);
                    const release = setParams.release * (1 - velocityFactor * 0.3);
                    // Модулируем громкость от скорости: быстрее движение -> громче звук
                    const volumeMod = setParams.volume * (1 + velocityFactor * 2);
                    
                    // Форма огибающей
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(volumeMod, now + attack);
                    gainNode.gain.setValueAtTime(volumeMod, now + attack);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + attack + release);
                    
                    // Запускаем и останавливаем
                    oscillator.start(now);
                    oscillator.stop(now + attack + release + 0.01);
                    
                    // Удаляем ноду после окончания звучания
                    setTimeout(() => {
                        oscillator.disconnect();
                        filter.disconnect();
                        gainNode.disconnect();
                        panner.disconnect();
                    }, (attack + release + 0.1) * 1000);
                }
                
                // Функция запуска гранулярного потока
                function startGranularStream(setIndex) {
                    const set = granularSets[setIndex];
                    
                    function spawnGrain() {
                        if (!audioContext || !audioEnabled) return;
                        
                        // Создаем гранулу
                        createGrain(set);
                        
                        // Модулируем плотность гранул в зависимости от скорости курсора
                        const velocityFactor = Math.min(1, Math.sqrt(
                            cursorData.velocityX * cursorData.velocityX + 
                            cursorData.velocityY * cursorData.velocityY
                        ) / 2000);
                        
                        // Вычисляем время до следующей гранулы
                        let interval = GRAIN_MIN_INTERVAL + Math.random() * (GRAIN_MAX_INTERVAL - GRAIN_MIN_INTERVAL);
                                    
                        // При более быстром движении - больше гранул, но с учетом настроек медитативности
                        interval = interval * (1 - velocityFactor * 0.7 * ambientSettings.cursorInfluenceScale) / 
                                   (set.densityFactor * ambientSettings.densityScale);
                        
                        // Планируем следующую гранулу
                        setTimeout(spawnGrain, interval * 1000);
                    }
                    
                    spawnGrain();
                }
                
                // Запускаем потоки гранул для всех наборов
                for (let i = 0; i < granularSets.length; i++) {
                    startGranularStream(i);
                }
                
                // 2. Создаем FM-синтезаторные слои ======================================================
                
                // Настройки для FM-синтезаторов (частотная модуляция)
                const fmLayers = [
                    // Низкий фоновый тон
                    {
                        carrier: {
                            freq: 55,
                            type: 'sine'
                        },
                        modulator: {
                            freq: 0.05 / ambientSettings.evolutionTimeScale, // замедляем модуляцию в 4 раза
                            depth: 5,
                            type: 'sine'
                        },
                        volume: 0.08,
                        filter: {
                            type: 'lowpass',
                            freq: 500
                        }
                    },
                    // Средний плавающий тон
                    {
                        carrier: {
                            freq: 144,
                            type: 'sine'
                        },
                        modulator: {
                            freq: 0.03 / ambientSettings.evolutionTimeScale, // замедляем модуляцию
                            depth: 8,
                            type: 'triangle'
                        },
                        volume: 0.05,
                        filter: {
                            type: 'bandpass',
                            freq: 800
                        }
                    },
                    // Высокий "дышащий" тон
                    {
                        carrier: {
                            freq: 288,
                            type: 'sine'
                        },
                        modulator: {
                            freq: 0.02 / ambientSettings.evolutionTimeScale, // замедляем модуляцию
                            depth: 3,
                            type: 'sine'
                        },
                        volume: 0.03,
                        filter: {
                            type: 'highpass',
                            freq: 1200
                        }
                    }
                ];
                
                // Создаем и запускаем FM-синтезаторы
                for (let i = 0; i < fmLayers.length; i++) {
                    const layer = fmLayers[i];
                    
                    // Создаем осциллятор-носитель
                    const carrier = audioContext.createOscillator();
                    carrier.type = layer.carrier.type;
                    carrier.frequency.value = layer.carrier.freq;
                    
                    // Создаем осциллятор-модулятор
                    const modulator = audioContext.createOscillator();
                    modulator.type = layer.modulator.type;
                    modulator.frequency.value = layer.modulator.freq;
                    
                    // Создаем усилитель для модулятора
                    const modulationGain = audioContext.createGain();
                    modulationGain.gain.value = layer.modulator.depth;
                    
                    // Соединяем модулятор с частотой несущей
                    modulator.connect(modulationGain);
                    modulationGain.connect(carrier.frequency);
                    
                    // Создаем фильтр
                    const filter = audioContext.createBiquadFilter();
                    filter.type = layer.filter.type;
                    filter.frequency.value = layer.filter.freq;
                    
                    // Создаем усилитель выходного сигнала
                    const outputGain = audioContext.createGain();
                    outputGain.gain.value = layer.volume;
                    
                    // Соединяем компоненты
                    carrier.connect(filter);
                    filter.connect(outputGain);
                    outputGain.connect(analyser);
                    
                    // Запускаем осцилляторы
                    carrier.start();
                    modulator.start();
                    
                    // Добавляем управление параметрами через движение мыши
                    function updateFMParameters() {
                        if (!audioContext || !audioEnabled) return;
                        
                        const cursorXFactor = cursorData.x / window.innerWidth;
                        const cursorYFactor = cursorData.y / window.innerHeight;
                        const velocityFactor = Math.min(1, Math.sqrt(
                            cursorData.velocityX * cursorData.velocityX + 
                            cursorData.velocityY * cursorData.velocityY
                        ) / 2000);
                        
                        // Модуляция частоты несущей от положения X
                        carrier.frequency.linearRampToValueAtTime(
                            layer.carrier.freq * (0.95 + cursorXFactor * 0.1),
                            audioContext.currentTime + 0.1
                        );
                        
                        // Модуляция глубины модуляции от положения Y
                        modulationGain.gain.linearRampToValueAtTime(
                            layer.modulator.depth * (0.8 + cursorYFactor * 0.4),
                            audioContext.currentTime + 0.1
                        );
                        
                        // Модуляция частоты фильтра от скорости
                        filter.frequency.linearRampToValueAtTime(
                            layer.filter.freq * (1 + velocityFactor * 1.5),
                            audioContext.currentTime + 0.1
                        );
                        
                        // Планируем следующее обновление
                        setTimeout(updateFMParameters, 100 * ambientSettings.transitionTimeScale);
                    }
                    
                    // Запускаем обновление параметров
                    updateFMParameters();
                    
                    // Сохраняем осцилляторы для возможности остановки
                    soundLibrary.oscillators.push({
                        source: carrier,
                        gain: outputGain,
                        stop: function() {
                            carrier.stop();
                            modulator.stop();
                        }
                    });
                    
                    soundLibrary.oscillators.push({
                        source: modulator,
                        stop: function() {
                            // Пустая функция, так как модулятор остановится вместе с несущей
                        }
                    });
                    
                    // Медленная эволюция параметров FM-синтеза
                    function evolveFMLayer() {
                        if (!audioContext || !audioEnabled) return;
                        
                        // Постепенное случайное изменение параметров
                        const modulatorFreqChange = 0.02 * (Math.random() * 2 - 1);
                        const depthChange = layer.modulator.depth * 0.2 * (Math.random() * 2 - 1);
                        const filterFreqChange = layer.filter.freq * 0.3 * (Math.random() * 2 - 1);
                        
                        // Применяем изменения
                        modulator.frequency.exponentialRampToValueAtTime(
                            Math.max(0.01, modulator.frequency.value + modulatorFreqChange),
                            audioContext.currentTime + 5
                        );
                        
                        modulationGain.gain.linearRampToValueAtTime(
                            Math.max(1, modulationGain.gain.value + depthChange),
                            audioContext.currentTime + 5
                        );
                        
                        filter.frequency.exponentialRampToValueAtTime(
                            Math.max(50, Math.min(20000, filter.frequency.value + filterFreqChange)),
                            audioContext.currentTime + 5
                        );
                        
                        // Планируем следующую эволюцию через случайный интервал
                        setTimeout(evolveFMLayer, (10000 + Math.random() * 10000) * ambientSettings.evolutionTimeScale);
                    }
                    
                    // Запускаем эволюцию FM-синтеза
                    evolveFMLayer();
                }
                
                // 3. Создаем слой спектрального процессинга ===========================================
                
                // Создаем источник цветного шума низкой громкости
                const spectralNoiseSource = playNoise('pink', 0.03, 2, null, 2);
                
                // Добавляем гребенчатый фильтр для создания резонансов
                const combFilter = audioContext.createBiquadFilter();
                combFilter.type = 'notch';
                combFilter.frequency.value = 2000;
                combFilter.Q.value = 5;
                
                // Подключаем фильтр
                if (spectralNoiseSource && spectralNoiseSource.gain) {
                    // Отключаем прямое подключение к выходу
                    spectralNoiseSource.gain.disconnect();
                    
                    // Подключаем через фильтр
                    spectralNoiseSource.gain.connect(combFilter);
                    combFilter.connect(analyser);
                }
                
                // Функция для модуляции параметров фильтра
                function modulateCombFilter() {
                    if (!audioContext || !audioEnabled) return;
                    
                    // Получаем параметры от положения и скорости курсора
                    const cursorXFactor = cursorData.x / window.innerWidth;
                    const cursorYFactor = cursorData.y / window.innerHeight;
                    const velocityFactor = Math.min(1, Math.sqrt(
                        cursorData.velocityX * cursorData.velocityX + 
                        cursorData.velocityY * cursorData.velocityY
                    ) / 2000);
                    
                    // Модулируем частоту фильтра от положения X
                    const targetFreq = 1000 + cursorXFactor * 3000;
                    combFilter.frequency.linearRampToValueAtTime(
                        targetFreq,
                        audioContext.currentTime + 0.1 * ambientSettings.transitionTimeScale
                    );
                    
                    // Модулируем Q-фактор от положения Y и скорости
                    const targetQ = 5 + cursorYFactor * 10 + velocityFactor * 20 * ambientSettings.cursorInfluenceScale;
                    combFilter.Q.linearRampToValueAtTime(
                        targetQ,
                        audioContext.currentTime + 0.1 * ambientSettings.transitionTimeScale
                    );
                    
                    // Планируем следующую модуляцию
                    setTimeout(modulateCombFilter, 200 * ambientSettings.transitionTimeScale);
                }
                
                // Запускаем модуляцию
                modulateCombFilter();
                
                // 4. Создаем случайные атмосферные звуки ==============================================
                
                // Функция для создания атмосферного звука
                function createAtmosphericSound() {
                    if (!audioContext || !audioEnabled) return;
                    
                    // Случайно выбираем тип атмосферного звука
                    const soundType = Math.floor(Math.random() * 4);
                    
                    switch (soundType) {
                        case 0:
                            // Резонансный тон
                            createResonantTone();
                            break;
                        case 1:
                            // Эолический шепот
                            createEolicWhisper();
                            break;
                        case 2:
                            // Гармонический обертон
                            createHarmonicOvertone();
                            break;
                        case 3:
                            // Глубокий сдвиг
                            createDeepShift();
                            break;
                    }
                    
                    // Планируем следующий звук через значительно больший случайный интервал
                    const nextInterval = (15000 + Math.random() * 5000) * ambientSettings.evolutionTimeScale; // От 30 сек до 1,5 минут при evolutionTimeScale = 4
                    setTimeout(createAtmosphericSound, nextInterval);
                }
                
                // Функция для создания резонансного тона
                function createResonantTone() {
                    // Создаем осциллятор
                    const osc = audioContext.createOscillator();
                    osc.type = 'sine';
                    
                    // Выбираем частоту из музыкального ряда
                    const baseFreqs = [110, 146.83, 165, 196, 220, 293.66, 329.63];
                    const freq = baseFreqs[Math.floor(Math.random() * baseFreqs.length)];
                    osc.frequency.value = freq;
                    
                    // Создаем усилитель
                    const gain = audioContext.createGain();
                    gain.gain.value = 0;
                    
                    // Создаем фильтр
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = freq;
                    filter.Q.value = 10 + Math.random() * 20;
                    
                    // Соединяем компоненты
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(analyser);
                    
                    // Формируем огибающую
                    const now = audioContext.currentTime;
                    const duration = 5 + Math.random() * 10;
                    const peakGain = 0.03 + Math.random() * 0.04;
                    
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(peakGain, now + duration * 0.3);
                    gain.gain.linearRampToValueAtTime(0, now + duration);
                    
                    // Модуляция частоты
                    osc.frequency.setValueAtTime(freq, now);
                    osc.frequency.exponentialRampToValueAtTime(
                        freq * (0.95 + Math.random() * 0.1),
                        now + duration
                    );
                    
                    // Запускаем и останавливаем
                    osc.start(now);
                    osc.stop(now + duration + 0.1);
                    
                    // Создаем эффект пространственности через стерео-панораму
                    const panner = audioContext.createStereoPanner();
                    panner.pan.value = Math.random() * 2 - 1; // От -1 до 1
                    
                    // Вставляем панорамирование в цепочку
                    filter.disconnect();
                    filter.connect(panner);
                    panner.connect(gain);
                    
                    // Создаем визуализацию звука
                    setTimeout(() => {
                        const randomX = Math.random() * window.innerWidth;
                        const randomY = Math.random() * window.innerHeight;
                        
                        createSoundVisualization(
                            randomX,
                            randomY,
                            `hsl(${Math.floor(Math.random() * 60 + 180)}, 80%, 60%)`,
                            0.5
                        );
                    }, duration * 300);
                }
                
                // Функция для создания "эолического шепота"
                function createEolicWhisper() {
                    // Создаем шумовой источник
                    const bufferSize = audioContext.sampleRate * 2; // 2 секунды буфера
                    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const data = noiseBuffer.getChannelData(0);
                    
                    // Генерируем фильтрованный шум
                    for (let i = 0; i < bufferSize; i++) {
                        // Базовый шум
                        data[i] = Math.random() * 2 - 1;
                        
                        // Применяем низкочастотную фильтрацию (примитивный фильтр)
                        if (i > 0) {
                            data[i] = data[i] * 0.3 + data[i-1] * 0.7;
                        }
                        
                        // Добавляем "пустоты" в шум для создания шепчущего эффекта
                        if (Math.random() < 0.1) {
                            data[i] *= 0.2;
                        }
                    }
                    
                    // Создаем источник буфера
                    const whisperSource = audioContext.createBufferSource();
                    whisperSource.buffer = noiseBuffer;
                    whisperSource.loop = true;
                    
                    // Создаем усилитель
                    const gain = audioContext.createGain();
                    gain.gain.value = 0;
                    
                    // Создаем фильтр
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 3000 + Math.random() * 3000;
                    filter.Q.value = 1 + Math.random() * 2;
                    
                    // Соединяем компоненты
                    whisperSource.connect(filter);
                    filter.connect(gain);
                    gain.connect(analyser);
                    
                    // Формируем огибающую
                    const now = audioContext.currentTime;
                    const duration = 8 + Math.random() * 7;
                    const peakGain = 0.01 + Math.random() * 0.02;
                    
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(peakGain, now + duration * 0.2);
                    gain.gain.linearRampToValueAtTime(peakGain * 0.7, now + duration * 0.7);
                    gain.gain.linearRampToValueAtTime(0, now + duration);
                    
                    // Модуляция фильтра
                    filter.frequency.setValueAtTime(filter.frequency.value, now);
                    filter.frequency.exponentialRampToValueAtTime(
                        filter.frequency.value * (0.7 + Math.random() * 0.6),
                        now + duration
                    );
                    
                    // Запускаем и останавливаем
                    whisperSource.start(now);
                    whisperSource.stop(now + duration + 0.1);
                    
                    // Создаем стерео-эффект
                    const panner = audioContext.createStereoPanner();
                    const panDirection = Math.random() < 0.5 ? -1 : 1;
                    
                    // Пан "путешествует" от одной стороны к другой
                    panner.pan.setValueAtTime(panDirection * -1, now);
                    panner.pan.linearRampToValueAtTime(panDirection, now + duration);
                    
                    // Вставляем панорамирование в цепочку
                    filter.disconnect();
                    filter.connect(panner);
                    panner.connect(gain);
                    
                    // Создаем несколько визуализаций шепота
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const panValue = -1 + (2 * i / 2); // От -1 до 1
                            const visualX = window.innerWidth * (panValue * 0.4 + 0.5); // От 10% до 90% ширины
                            const visualY = window.innerHeight * (0.3 + Math.random() * 0.5);
                            
                            createSoundVisualization(
                                visualX,
                                visualY,
                                `hsl(${Math.floor(Math.random() * 30 + 220)}, 60%, 70%)`,
                                0.3
                            );
                        }, duration * 1000 * (0.3 + i * 0.25));
                    }
                }
                
                // Функция для создания гармонического обертона
                function createHarmonicOvertone() {
                    // Базовая частота
                    const fundamentalFreqs = [55, 65.41, 73.42, 82.41, 87.31, 98];
                    const fundamental = fundamentalFreqs[Math.floor(Math.random() * fundamentalFreqs.length)];
                    
                    // Количество обертонов
                    const numOvertones = 5 + Math.floor(Math.random() * 4);
                    
                    // Общий усилитель
                    const masterGain = audioContext.createGain();
                    masterGain.gain.value = 0;
                    masterGain.connect(analyser);
                    
                    // Создаем пространственный эффект
                    const panner = audioContext.createStereoPanner();
                    panner.pan.value = Math.random() * 1.6 - 0.8; // От -0.8 до 0.8
                    masterGain.connect(panner);
                    panner.connect(analyser);
                    
                    // Массив осцилляторов
                    const oscillators = [];
                    
                    // Создаем каждый обертон
                    for (let i = 1; i <= numOvertones; i++) {
                        const osc = audioContext.createOscillator();
                        
                        // Выбираем тип волны
                        osc.type = i % 2 === 0 ? 'sine' : 'triangle';
                        
                        // Устанавливаем частоту обертона
                        const overtoneFreq = fundamental * i;
                        osc.frequency.value = overtoneFreq;
                        
                        // Создаем усилитель для этого обертона
                        const gain = audioContext.createGain();
                        
                        // Громкость обертона уменьшается с увеличением номера
                        gain.gain.value = 0.15 / i;
                        
                        // Соединяем
                        osc.connect(gain);
                        gain.connect(masterGain);
                        
                        // Сохраняем осциллятор
                        oscillators.push({ osc, gain });
                    }
                    
                    // Время и длительность
                    const now = audioContext.currentTime;
                    const duration = 10 + Math.random() * 15;
                    
                    // Формируем общую огибающую
                    masterGain.gain.setValueAtTime(0, now);
                    masterGain.gain.linearRampToValueAtTime(0.08, now + duration * 0.3);
                    masterGain.gain.linearRampToValueAtTime(0.05, now + duration * 0.7);
                    masterGain.gain.linearRampToValueAtTime(0, now + duration);
                    
                    // Запускаем все осцилляторы
                    for (let i = 0; i < oscillators.length; i++) {
                        const osc = oscillators[i].osc;
                        const gain = oscillators[i].gain;
                        
                        // Слегка расстраиваем обертоны в процессе звучания
                        if (i > 0) {
                            osc.frequency.setValueAtTime(osc.frequency.value, now);
                            osc.frequency.exponentialRampToValueAtTime(
                                osc.frequency.value * (0.99 + Math.random() * 0.02),
                                now + duration
                            );
                            
                            // Модулируем громкость обертонов
                            const initialGain = gain.gain.value;
                            gain.gain.setValueAtTime(initialGain, now);
                            
                            // Создаем волнообразную модуляцию громкости обертона
                            const modSpeed = 0.1 + Math.random() * 0.2;
                            
                            for (let t = 0; t < duration; t += 2) {
                                const modValue = initialGain * (0.7 + 0.3 * Math.sin(t * modSpeed));
                                gain.gain.linearRampToValueAtTime(modValue, now + t);
                                gain.gain.linearRampToValueAtTime(initialGain, now + t + 1);
                            }
                        }
                        
                        osc.start(now);
                        osc.stop(now + duration + 0.1);
                    }
                    
                    // Создаем "плавающую" визуализацию
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            const centerX = window.innerWidth * (panner.pan.value * 0.3 + 0.5);
                            const centerY = window.innerHeight * 0.5;
                            const radius = Math.min(window.innerWidth, window.innerHeight) * 0.25;
                            const angle = Math.PI * 2 * (i / 5);
                            
                            createSoundVisualization(
                                centerX + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5),
                                centerY + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5),
                                `hsl(${Math.floor(Math.random() * 60 + 30)}, 80%, 60%)`,
                                0.4
                            );
                        }, duration * 200 * (i + 1));
                    }
                }
                
                // Функция для создания глубокого сдвига
                function createDeepShift() {
                    // Создаем осциллятор для базового тона
                    const osc = audioContext.createOscillator();
                    osc.type = 'sawtooth';
                    
                    // Очень низкая частота
                    osc.frequency.value = 30 + Math.random() * 20;
                    
                    // Создаем фильтр для формирования звука
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 120;
                    filter.Q.value = 2;
                    
                    // Создаем усилитель
                    const gain = audioContext.createGain();
                    gain.gain.value = 0;
                    
                    // Соединяем компоненты
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(analyser);
                    
                    // Время и длительность
                    const now = audioContext.currentTime;
                    const duration = 15 + Math.random() * 10;
                    
                    // Формируем огибающую
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.12, now + duration * 0.4);
                    gain.gain.linearRampToValueAtTime(0.08, now + duration * 0.7);
                    gain.gain.linearRampToValueAtTime(0, now + duration);
                    
                    // Модуляция фильтра
                    filter.frequency.setValueAtTime(filter.frequency.value, now);
                    
                    // Создаем несколько точек модуляции
                    const numPoints = 5 + Math.floor(Math.random() * 4);
                    for (let i = 1; i < numPoints; i++) {
                        const timePoint = now + (duration * i / numPoints);
                        const freqValue = 80 + Math.random() * 300;
                        
                        filter.frequency.exponentialRampToValueAtTime(freqValue, timePoint);
                    }
                    
                    // Завершающая точка
                    filter.frequency.exponentialRampToValueAtTime(60, now + duration);
                    
                    // Запускаем и останавливаем
                    osc.start(now);
                    osc.stop(now + duration + 0.1);
                    
                    // Добавляем LFO для тонкой модуляции частоты
                    const lfo = audioContext.createOscillator();
                    lfo.type = 'sine';
                    lfo.frequency.value = 0.2 + Math.random() * 0.3;
                    
                    const lfoGain = audioContext.createGain();
                    lfoGain.gain.value = 5 + Math.random() * 5;
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    
                    lfo.start(now);
                    lfo.stop(now + duration + 0.1);
                    
                    // Создаем эффект глубины через распределенные визуализации
                    const numVisuals = 10;
                    const baseHue = Math.floor(Math.random() * 30);
                    
                    for (let i = 0; i < numVisuals; i++) {
                        setTimeout(() => {
                            // Визуализация распространяется волной от центра
                            const centerX = window.innerWidth / 2;
                            const centerY = window.innerHeight / 2;
                            const radius = Math.min(window.innerWidth, window.innerHeight) * 0.45 * (i / numVisuals);
                            const angle = Math.PI * 2 * Math.random();
                            
                            createSoundVisualization(
                                centerX + Math.cos(angle) * radius,
                                centerY + Math.sin(angle) * radius,
                                `hsl(${baseHue}, 80%, ${50 - i * 3}%)`,
                                1.0 - (i / numVisuals) * 0.5
                            );
                        }, duration * 100 * (i + 1));
                    }
                }
                
                // Запускаем генерацию атмосферных звуков с задержкой
                setTimeout(createAtmosphericSound, 5000);
            }

            // Настройка звуковых взаимодействий
            function setupSoundInteractions() {
                // Добавляем обработчики событий для фрагментов сознания
                document.addEventListener('click', function(e) {
                    if (!audioContext) {
                        initAudioSystem();
                        return;
                    }
                    
                    const elementsUnderCursor = document.elementsFromPoint(e.clientX, e.clientY);
                    
                    for (const element of elementsUnderCursor) {
                        if (element.classList.contains('consciousness-fragment')) {
                            // Воспроизводим звук для фрагмента сознания
                            const pitch = 0.8 + Math.random() * 0.5;
                            const volume = 0.2 + Math.random() * 0.3;
                            const pan = (e.clientX / window.innerWidth) * 2 - 1; // От -1 до 1
                            
                            const releaseTime = 3; // Полторы секунды затухания, можно настроить по вкусу

                            playSound(soundLibrary.buffers.consciousnessFragments, pitch, volume, pan, releaseTime);
                            
                            // Создаем визуализацию звука
                            createSoundVisualization(e.clientX, e.clientY);
                            
                            break;
                        }
                    }
                });
                
                // Добавляем звуки к hover-эффекту фрагментов сознания
                const fragments = document.querySelectorAll('.consciousness-fragment');
                fragments.forEach(fragment => {
                    fragment.addEventListener('mouseover', function() {
                        if (!audioContext || !audioEnabled) return;
                        
                        // Тихий звук при наведении
                        const pitch = 1.2 + Math.random() * 0.5;
                        const rect = this.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const pan = (centerX / window.innerWidth) * 2 - 1;
                        const releaseTime = 1.5; // Полторы секунды затухания, можно настроить по вкусу

                        playSound(soundLibrary.buffers.consciousnessFragments, pitch, 0.1, pan, releaseTime);
                        
                        
                    });
                });
                
                // Добавляем звуки для прото-языка
                const protoLanguage = document.getElementById('proto-language');
                const originalProtoLanguageUpdate = generateProtoLanguage;
                
                window.generateProtoLanguage = function() {
                    // Вызываем оригинальную функцию
                    originalProtoLanguageUpdate();
                    
                    // Добавляем звуковое сопровождение
                    if (!audioContext || !audioEnabled) return;
                    
                    // Воспроизводим слой шума
                    const noisePlayer = playNoise('pink', 0.05, 0.2, 2, 0.5);
                    
                    // Воспроизводим абстрактную вокализацию
                    setTimeout(() => {
                        const pitch = 0.7 + Math.random() * 0.6;
                        const pan = (Math.random() * 2) - 1;
                        const releaseTime = 3; // Полторы секунды затухания, можно настроить по вкусу
                        playSound(soundLibrary.buffers.protoSymbols, pitch, 0.3, pan, releaseTime);
                    }, 100);
                    
                    // Создаем визуализацию звука в центре экрана
                    createSoundVisualization(
                        window.innerWidth / 2 + (Math.random() * 200 - 100),
                        window.innerHeight / 2 + (Math.random() * 200 - 100),
                        `hsl(${Math.floor(Math.random() * 60 + 180)}, 70%, 60%)`,
                        1
                    );
                };
                
                // Добавляем звуки для потока мыслей
                const originalThoughtStreamUpdate = updateThoughtStream;
                
                window.updateThoughtStream = function() {
                    // Вызываем оригинальную функцию
                    originalThoughtStreamUpdate();
                    
                    // Добавляем звуковое сопровождение
                    if (!audioContext || !audioEnabled) return;
                    
                    // Воспроизводим звук потока мыслей
                    const pitch = 0.8 + Math.random() * 0.4;
                    const volume = 0.08 + Math.random() * 0.05;
                    const pan = Math.random() * 0.6 - 0.3; // Небольшое смещение по панораме

                    const releaseTime = 2.5; // Полторы секунды затухания, можно настроить по вкусу
                    
                    playSound(soundLibrary.buffers.thoughtStream, pitch, volume, pan, releaseTime);
                };
                
                // Вместо переопределения style, используем MutationObserver для отслеживания изменений
                const cartograph = document.getElementById('cartograph');

                // Создаем наблюдатель за изменениями атрибутов картографа
                const cartographObserver = new MutationObserver(function(mutations) {
                    // Проверяем, были ли изменения в стиле
                    const styleChanges = mutations.filter(mutation => 
                        mutation.attributeName === 'style');
                    
                    if (styleChanges.length > 0 && audioContext && audioEnabled) {
                        // Воспроизводим звук при изменении стиля картографа
                        const pitch = 0.7 + Math.random() * 0.6;
                        const volume = 0.15 + Math.random() * 0.1;
                        const releaseTime = 4; // Полторы секунды затухания, можно настроить по вкусу
                        
                        playSound(soundLibrary.buffers.cartograph, pitch, volume, 0, releaseTime);
                        
                        // Создаем визуализацию звука вокруг картографа
                        const centerX = window.innerWidth / 2;
                        const centerY = window.innerHeight / 2;
                        const radius = Math.min(window.innerWidth, window.innerHeight) / 4;
                        const angle = Math.random() * Math.PI * 2;
                        
                        createSoundVisualization(
                            centerX + Math.cos(angle) * radius,
                            centerY + Math.sin(angle) * radius,
                            `hsl(${Math.floor(Math.random() * 60)}, 70%, 60%)`,
                            0.8
                        );
                    }
                });

                // Запускаем наблюдение за атрибутами картографа
                cartographObserver.observe(cartograph, { 
                    attributes: true,
                    attributeFilter: ['style'] 
                });
                
                // Добавляем звуки для математических элементов
                // Переопределяем функцию создания мат. элементов
                const originalCreateMathElement = createMathElement;
                
                window.createMathElement = function() {
                    // Вызываем оригинальную функцию
                    const element = originalCreateMathElement();
                    
                    // Добавляем звуковое сопровождение
                    if (!audioContext || !audioEnabled) return element;
                    
                    // Воспроизводим кристаллический звук
                    const pitch = 0.8 + Math.random() * 0.5;
                    const volume = 0.15 + Math.random() * 0.1;
                    const rect = element.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const pan = (centerX / window.innerWidth) * 2 - 1;
                    const releaseTime = 2.5; // Полторы секунды затухания, можно настроить по вкусу
                        

                    playSound(soundLibrary.buffers.mathElements, pitch, volume, pan, releaseTime);
                    
                    // Создаем визуализацию звука
                    createSoundVisualization(
                        rect.left + rect.width / 2,
                        rect.top + rect.height / 2,
                        `hsl(${Math.floor(Math.random() * 60 + 240)}, 70%, 70%)`,
                        0.7
                    );
                    
                    return element;
                };
            }

            // Создание визуализации звука
            function createSoundVisualization(x, y, color = null, scale = 1) {
                if (!audioEnabled) return;
                
                const visualization = document.createElement('div');
                visualization.className = 'sound-visualization';
                
                // Установка цвета и размера
                const hue = color ? color : `hsl(${Math.floor(Math.random() * 360)}, 70%, 70%)`;
                const size = 50 + Math.random() * 150;
                
                visualization.style.left = x + 'px';
                visualization.style.top = y + 'px';
                visualization.style.width = size + 'px';
                visualization.style.height = size + 'px';
                visualization.style.backgroundColor = hue;
                visualization.style.boxShadow = `0 0 30px ${hue}`;
                
                // Случайная форма: круг или полигон
                if (Math.random() < 0.3) {
                    // Создаем более сложную форму - полигон с случайным числом сторон
                    const sides = 3 + Math.floor(Math.random() * 8); // От треугольника до декагона
                    const radius = size / 2;
                    let clipPath = 'polygon(';
                    
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * 2 * Math.PI;
                        const pointX = 50 + 45 * Math.cos(angle);
                        const pointY = 50 + 45 * Math.sin(angle);
                        
                        clipPath += `${pointX}% ${pointY}%${i < sides - 1 ? ', ' : ''}`;
                    }
                    
                    clipPath += ')';
                    visualization.style.clipPath = clipPath;
                    visualization.style.borderRadius = '0';
                }
                
                document.getElementById('container').appendChild(visualization);
                
                // Анимация появления, пульсации и исчезновения
                setTimeout(() => {
                    visualization.style.opacity = 0.5 * scale;
                    visualization.style.transform = `scale(${scale}) rotate(${Math.random() * 40 - 20}deg)`;
                    
                    // Добавляем пульсацию
                    let pulse = 0;
                    const pulseInterval = setInterval(() => {
                        pulse += 1;
                        const pulseScale = scale * (1 + 0.1 * Math.sin(pulse * 0.4));
                        visualization.style.transform = `scale(${pulseScale}) rotate(${Math.random() * 40 - 20}deg)`;
                        
                        if (pulse > 20) {
                            clearInterval(pulseInterval);
                        }
                    }, 100);
                }, 10);
                
                setTimeout(() => {
                    visualization.style.opacity = 0;
                    visualization.style.transform = `scale(${scale * 2}) rotate(${Math.random() * 90 - 45}deg)`;
                }, 1500);
                
                setTimeout(() => {
                    visualization.remove();
                }, 3000);
                
                // Добавляем в массив для отслеживания
                soundVisualizations.push(visualization);
            }

            // Настройка аудио-контролов
            function setupAudioControls() {
                const audioToggle = document.getElementById('audio-toggle');
                const volumeSlider = document.getElementById('volume-slider');
                const audioStateText = document.querySelector('.audio-state');
                
                // Обработчик клика по переключателю звука
                audioToggle.addEventListener('click', function() {
                    audioEnabled = !audioEnabled;
                    
                    if (audioEnabled) {
                        audioStateText.textContent = 'звук вкл';
                        masterGainNode.gain.value = volumeSlider.value / 100;
                    } else {
                        audioStateText.textContent = 'звук выкл';
                        masterGainNode.gain.value = 0;
                    }
                });
                
                // Обработчик изменения громкости
                volumeSlider.addEventListener('input', function() {
                    if (!audioContext || !audioEnabled) return;
                    
                    masterGainNode.gain.value = this.value / 100;
                });
            }

            // Инициализация аудио при клике
            document.addEventListener('click', function() {
                if (!audioInitialized) {
                    initAudioSystem();
                }
            }, { once: true });

        });
        

        // Расширение для математических элементов
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Инициализация математических элементов...");
            
            // Добавляем стили для математического дождя
            const styleElement = document.createElement('style');
            styleElement.textContent = `
                .math-rain {
                    position: fixed;
                    top: 0;
                    bottom: 0;
                    width: 200px;
                    overflow: hidden;
                    pointer-events: none;
                    z-index: 50;
                }
                #math-rain-left {
                    left: 20px;
                }
                #math-rain-right {
                    right: 20px;
                }
                .math-rain-drop {
                    position: absolute;
                    font-family: serif, "Times New Roman", math;
                    white-space: nowrap;
                    text-shadow: 0 0 8px rgba(150, 255, 255, 0.8);
                    transform: translateX(-50%);
                }
                .pulsating-math-symbol {
                    position: absolute;
                    pointer-events: none;
                    z-index: 999;
                    font-family: serif, "Times New Roman", math;
                }
            `;
            document.head.appendChild(styleElement);
            
            // Создаем контейнеры для математического дождя
            const container = document.querySelector('body');
            
            // Левый контейнер
            const leftContainer = document.createElement('div');
            leftContainer.id = 'math-rain-left';
            leftContainer.className = 'math-rain';
            container.appendChild(leftContainer);
            
            // Правый контейнер
            const rightContainer = document.createElement('div');
            rightContainer.id = 'math-rain-right';
            rightContainer.className = 'math-rain';
            container.appendChild(rightContainer);
            
            // Функция для генерации сложных математических выражений
            function generateComplexMathExpression(length) {
                // Базовые математические символы
                const symbols = [
                    'α', 'β', 'γ', 'δ', 'ε', 'ζ', 'η', 'θ', 'λ', 'μ', 'ν', 'ξ', 'π', 'ρ', 'σ', 'τ', 'φ', 'χ', 'ψ', 'ω',
                    '+', '-', '×', '÷', '=', '≠', '≈', '∑', '∏', '∫', '∂', '∇', '√', '∞', '∈', '∉', '⊂', '⊃', '∩', '∪',
                    '(', ')', '[', ']', '{', '}', '|', '‖',
                    'x', 'y', 'z', 'f', 'g', 'n', 'm'
                ];
                
                // Специальные полные математические выражения
                const specialExpressions = [
                    '∫ f(x) dx', '∑_{i=1}^{∞}', '∂²f/∂x²', 'lim_{x→∞}',
                    '∇×F', '∇·F', 'Δf', 'e^{iπ}+1=0', '√{x²+y²}',
                    'a_{n+1} = a_n + a_{n-1}', 'f: X → Y', '||v||',
                    'det(A-λI) = 0', 'x ∈ ℝ', '∀ε>0 ∃δ>0',
                    '⟨ψ|H|ψ⟩', 'P(A∩B|C)', '∮ E·dl = -∂Φ_B/∂t',
                    'ds² = g_{μν}dx^μdx^ν', '∇²ψ + k²ψ = 0',
                    'ψ(x,t) = Ae^{i(kx-ωt)}', 'F = G(m₁m₂)/r²',
                    'E = mc²', 'S = k·ln(W)', 'i\u0127 ∂ψ/∂t = Ĥψ'
                ];
                
                // Генерируем случайное выражение
                let expression = '';
                
                // Начинаем со специального выражения с вероятностью 70%
                if (Math.random() < 0.7) {
                    expression = specialExpressions[Math.floor(Math.random() * specialExpressions.length)];
                }
                
                // Добавляем символы до достижения нужной длины
                while (expression.length < length) {
                    // Иногда добавляем ещё одно специальное выражение
                    if (Math.random() < 0.3 && expression.length < length - 10) {
                        expression += ' ' + specialExpressions[Math.floor(Math.random() * specialExpressions.length)];
                    } else {
                        // Добавляем случайный символ, иногда с пробелом
                        expression += (Math.random() < 0.2 ? ' ' : '') + symbols[Math.floor(Math.random() * symbols.length)];
                    }
                }
                
                return expression;
            }
            
            // Функция для создания пульсирующего математического символа
            function createPulsatingMathSymbol(x, y) {
                // Сложные математические символы
                const complexSymbols = [
                    '∫', '∑', '∏', '√', '∂', '∇', 'Δ', 'Ω', 'λ', 'φ', '∞', 'π', 
                    '⊕', '⊗', '⊂', '⊃', '∩', '∪', '⇒', '⇔', '∀', '∃', '≡', '≈'
                ];
                
                // Создаем элемент
                const symbol = document.createElement('div');
                symbol.className = 'pulsating-math-symbol';
                symbol.textContent = complexSymbols[Math.floor(Math.random() * complexSymbols.length)];
                symbol.style.left = x + 'px';
                symbol.style.top = y + 'px';
                symbol.style.transform = 'translate(-50%, -50%)';
                symbol.style.fontSize = '5rem';
                symbol.style.color = `hsl(${Math.floor(180 + Math.random() * 60)}, 80%, 70%)`;
                symbol.style.opacity = 0;
                symbol.style.textShadow = `0 0 15px ${symbol.style.color}`;
                symbol.style.transition = 'all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                
                document.body.appendChild(symbol);
                
                // Анимация
                setTimeout(() => {
                    symbol.style.opacity = 1;
                    symbol.style.transform = 'translate(-50%, -50%) scale(1.5)';
                    
                    setTimeout(() => {
                        symbol.style.opacity = 0;
                        symbol.style.transform = 'translate(-50%, -50%) scale(3)';
                        
                        setTimeout(() => {
                            if (symbol.parentNode) {
                                symbol.parentNode.removeChild(symbol);
                            }
                        }, 500);
                    }, 800);
                }, 50);
            }
            
            // Функция для создания капли математического дождя
            function createMathRainDrop(container, baseHue) {
                // Создаем элемент
                const drop = document.createElement('div');
                drop.className = 'math-rain-drop';
                
                // Позиция - рандомизируем координату X
                drop.style.left = Math.random() * 100 + '%';
                drop.style.top = '-100px';
                
                // Оформление
                const hue = baseHue + (Math.random() * 30 - 15);
                const color = `hsl(${hue}, 70%, 70%)`;
                drop.style.color = color;
                drop.style.fontSize = (1 + Math.random() * 1.5) + 'rem';
                drop.style.textShadow = `0 0 5px ${color}`;
                drop.style.opacity = 0.8;
                
                // Содержание - генерируем сложное математическое выражение
                drop.textContent = generateComplexMathExpression(10 + Math.floor(Math.random() * 20));
                
                // Добавляем в контейнер
                container.appendChild(drop);
                
                // Параметры анимации
                const duration = 5000 + Math.random() * 10000; // 5-15 секунд
                const containerHeight = window.innerHeight;
                
                // Настраиваем переход
                drop.style.transition = `top ${duration}ms linear, opacity 2000ms`;
                
                // Запускаем анимацию после небольшой задержки
                setTimeout(() => {
                    drop.style.top = containerHeight + 'px';
                    
                    // Удаляем после анимации
                    setTimeout(() => {
                        drop.style.opacity = 0;
                        setTimeout(() => {
                            if (drop.parentNode) {
                                drop.parentNode.removeChild(drop);
                            }
                        }, 2000);
                    }, duration - 2000);
                }, 50);
                
                return drop;
            }
            
            // Функция для запуска математического дождя
            function triggerMathRain() {
                console.log("Запуск математического дождя");
                const leftContainer = document.getElementById('math-rain-left');
                const rightContainer = document.getElementById('math-rain-right');
                
                if (!leftContainer || !rightContainer) {
                    console.error("Не найдены контейнеры для математического дождя");
                    return;
                }
                
                // Настраиваем параметры
                const baseHue = Math.floor(180 + Math.random() * 60); // Сине-голубой оттенок
                const intensity = 15 + Math.floor(Math.random() * 10); // Количество капель
                const duration = 8000; // Общая продолжительность в мс
                
                // Генерируем начальные капли
                for (let i = 0; i < intensity / 3; i++) {
                    createMathRainDrop(leftContainer, baseHue);
                    createMathRainDrop(rightContainer, baseHue);
                }
                
                // Генерируем ещё капли со временем
                let elapsed = 0;
                const interval = 300; // Новая капля каждые 300мс
                
                const rainInterval = setInterval(() => {
                    elapsed += interval;
                    if (elapsed >= duration) {
                        clearInterval(rainInterval);
                        return;
                    }
                    
                    createMathRainDrop(leftContainer, baseHue);
                    createMathRainDrop(rightContainer, baseHue);
                }, interval);
            }
            
            // Добавляем прямую обработку кликов на математические элементы
            function handleMathClick(event) {
                console.log("Клик по математическому элементу");
                event.stopPropagation();
                
                // Запускаем математический дождь
                triggerMathRain();
                
                // Создаем визуализацию клика
                createPulsatingMathSymbol(event.clientX, event.clientY);
                
                // Воспроизводим звук, если доступен
                if (window.audioContext && window.audioEnabled) {
                    const pitch = 1.2 + Math.random() * 0.8;
                    const volume = 0.25 + Math.random() * 0.15;
                    const pan = (event.clientX / window.innerWidth) * 2 - 1;
                    
                    // Используем звуковые буферы, если они доступны
                    if (window.playSound && window.soundLibrary && window.soundLibrary.buffers) {
                        window.playSound(
                            window.soundLibrary.buffers.mathElements || window.soundLibrary.buffers.consciousnessFragments,
                            pitch, volume, pan, 3.0
                        );
                    }
                    
                    // Создаем визуализацию звука, если функция доступна
                    if (window.createSoundVisualization) {
                        window.createSoundVisualization(
                            event.clientX, event.clientY,
                            `hsl(${Math.floor(200 + Math.random() * 40)}, 80%, 65%)`,
                            1.2
                        );
                    }
                }
            }
            
            // Применяем обработчик клика к существующим и будущим математическим элементам
            // Используем делегирование событий
            document.body.addEventListener('click', function(event) {
                // Определяем, был ли клик по математическому элементу
                let target = event.target;
                
                // Проверяем, если элемент или его родители имеют класс 'math-element'
                while (target != null && target !== document.body) {
                    if (target.classList && target.classList.contains('math-element')) {
                        handleMathClick(event);
                        return;
                    }
                    target = target.parentNode;
                }
            });
            
            // Периодически проверяем и добавляем интерактивность к новым математическим элементам
            function ensureMathElementsClickable() {
                // Отключаем pointer-events: none для математических элементов
                const styleOverride = document.createElement('style');
                styleOverride.textContent = `
                    .math-element {
                        pointer-events: auto !important;
                        cursor: pointer !important;
                        transition: transform 0.3s, text-shadow 0.3s;
                    }
                    .math-element:hover {
                        transform: scale(1.2) !important;
                        z-index: 100 !important;
                        text-shadow: 0 0 10px currentColor !important;
                    }
                `;
                document.head.appendChild(styleOverride);
                
                console.log("Стили для математических элементов применены");
            }
            
            // Запускаем настройку математических элементов
            ensureMathElementsClickable();
            
            // Тестовый триггер для демонстрации эффекта (уберите в финальной версии)
            // setTimeout(triggerMathRain, 3000);
            
            console.log("Инициализация математических элементов завершена");
            
        // =========== КОНЕЦ ДОБАВЛЕННОГО КОДА ===========
        });
        
    </script>
    <div id="audio-controls">
    <div id="audio-toggle">
        <div class="audio-icon">◈</div>
        <div class="audio-state">звук вкл</div>
    </div>
    <div id="volume-control">
        <input type="range" id="volume-slider" min="0" max="100" value="50">
    </div>
    </div>
</body>
</html>