<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>СинЭстеМика: Синестезия эмоций и математики</title>
    <style>
    :root {
        --emotion-joy: #FFD700;
        --emotion-sadness: #4682B4;
        --emotion-fear: #800080;
        --emotion-anger: #FF4500;
        --emotion-disgust: #006400;
        --emotion-surprise: #FF69B4;
        --emotion-neutral: #EFEFEF;
        
        --math-linear: var(--emotion-neutral);
        --math-exponential: var(--emotion-neutral);
        --math-logarithmic: var(--emotion-neutral);
        --math-trigonometric: var(--emotion-neutral);
        --math-fractal: var(--emotion-neutral);
        --math-geometric: var(--emotion-neutral);
        --math-algebraic: var(--emotion-neutral);
        
        --transition-speed: 1.5s;
        --pulse-speed: 3s;
    }
    
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        transition: all var(--transition-speed) cubic-bezier(0.645, 0.045, 0.355, 1);
    }
    
    @font-face {
        font-family: 'EmotionalMath';
        src: url('data:application/font-woff2;charset=utf-8;base64,d09GMgABAAAAAAQAAA0AAAAABtwAAAOtAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0ZGVE0cGh4GYACCahEICotIilwLDgABNgIkAxQEIAWFAgdIGycGUZWTHbIfB87LMPE0/odk2dPsMm+NWYyIhtlVhUqH7GEemA+V9SoV9b5nz+BG0QQP/O+33zVztyYt25WJaImiCSKTRYNEqFAincz9/9fav6Z2I5FJZrMmkQhJRC/UCqFxSCQjO/CrAjgAwAAAICDZdPMmYMAFOBwQQECBB4UCiAMQZyAeQGiBeAFhBxJWAE4A4ACo0VO2lbBtkCXfiW8AQPTVJwYgGgBgBIABAFgNEAIAVEAcgQQASSn9qRYJAHYeAGkALAEgAwD4AwAGAJABGAAASQXgAEuEFWr0vwhxQB0A5NilaUAdANgAWAoAWwCkEwAZHADcAZAFAJwCQGQBkA5AF4AZOoBOgFoFABwAUAJgk2/2nEcAWAOADQCYYwAYZwFgnQMAXwCwVQBgtgPAGQDYBQDcDQBUMAA0ZACgAQCmDAAcGQDYGQAYGAAIkQBAAQBQDwBwDBDZPnxQlygwRgDgY+nTj1nzQImSZdY4GCiGWCYkJFieMGGC5YkTJ1iupKRkefjw4ZYnT55seVJSkuXx48dbnj59uuWJEydanqiPYnRKYjm1n5e/F7/+z7de9kBWP70HcvLVbf76nrQD4WXnPm88ENRA29rMtQ+sBi29KF3a+EHegfwv1FnrzrtjVlvbOenq/Ynkyd7JOa1V69a1TFrVTanKFftDRR8e9P/rbe0Q41Cp34cLfbHtWrZw2kJr40vXkKNrbhwPjXB8N1rj9nANTqOVpvnJi3IfDTOMqsN+PzY72wMcL62AEcbOFNk7n4z5YYKcH5PlfJ+i8i5fkPPlPkzW9sFLM75PVJmQQEbK+TRC5T7FAvPJiT9epctPT5L9fgppbZ8qe34GKT09mXQ2Tyed7dNVtuuHxuLf9c1s6txH1RpTAP72/F/d1Bkez8s25S6fnnfJ+jTu8yvj0pcjZVtxlfx/pMyU8f+TE+ROV59+N3LV9mDC+RBs3tFpw/5xfP+rAFTZ/wMAQCtgD6UAfvzY3+cjXP6j7gQqDMDxCxm2MQXkrSyRbCtTBPUDAOYAIIQFQIDRAALYWgFCYDsQokwAYpJ7QJr1Ccho34F88BsoBH0FJQrRqBrHQgMBBCPKOQBY2NXBVutUbJzY0b1Q5hcU7F8X6mmkbB5c/0CxgEJHTN2/2xDJKISLdZFJKk8QF17Wqx3WwCWqwf1pAtuoDoU2+i2Eo0jFKLnA1cFW61RsnNr9vVDmF8VN/7pQT9OtNg/+/EBBh5C3MXVnuG2IZKLbi3WRGS+eIJxztYBrYDXoIqrB/ekW2KjOEWijZ4fhUeWPfL4VNnCYKIRMCo2GzJCIxaNzRkw9SZpyS5qZOTGnmhA06RlCyUxnJsHJVBKjNNPT08tT0/ySNM1MAAA=') format('woff2');
        font-weight: normal;
        font-style: normal;
    }
    
    body {
        font-family: 'EmotionalMath', sans-serif;
        background-color: #111;
        color: #fff;
        overflow-x: hidden;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        min-height: 100vh;
        perspective: 1000px;
    }
    
    .container {
        width: 100%;
        max-width: 1200px;
        padding: 2rem;
        transform-style: preserve-3d;
    }
    
    .intro-section {
        text-align: center;
        margin-bottom: 3rem;
        transform: translateZ(0);
        animation: float 6s ease-in-out infinite;
    }
    
    @keyframes float {
        0%, 100% { transform: translateZ(0) translateY(0); }
        50% { transform: translateZ(50px) translateY(-10px); }
    }
    
    h1 {
        font-size: 3.5rem;
        margin-bottom: 1rem;
        background: linear-gradient(45deg, var(--emotion-joy), var(--emotion-sadness), var(--emotion-anger), var(--emotion-fear), var(--emotion-surprise));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-size: 300% 300%;
        animation: gradient-shift 10s ease infinite;
    }
    
    @keyframes gradient-shift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    
    .subtitle {
        font-size: 1.5rem;
        margin-bottom: 2rem;
        opacity: 0.8;
    }
    
    .concept-description {
        max-width: 800px;
        margin: 0 auto;
        line-height: 1.6;
        text-align: justify;
        padding: 2rem;
        background: rgba(30, 30, 30, 0.7);
        border-radius: 10px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(8px);
    }
    
    .emotion-math-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 2rem;
        margin-top: 3rem;
    }
    
    .emotion-container, .math-container {
        position: relative;
        padding: 1.5rem;
        border-radius: 10px;
        min-height: 200px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        cursor: pointer;
        overflow: hidden;
        background: rgba(20, 20, 20, 0.7);
        backdrop-filter: blur(5px);
        transform: perspective(1000px) rotateY(0deg);
        transition: transform 0.6s ease-out;
    }
    
    .emotion-container:hover, .math-container:hover {
        transform: perspective(1000px) rotateY(10deg) scale(1.05);
        z-index: 2;
    }
    
    .emotion-container::before, .math-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: -1;
        opacity: 0.3;
        border-radius: 10px;
        transition: opacity 0.5s ease;
    }
    
    .emotion-container:hover::before, .math-container:hover::before {
        opacity: 0.6;
    }
    
    .emotion-title, .math-title {
        font-size: 1.8rem;
        margin-bottom: 1rem;
        position: relative;
    }
    
    .emotion-description, .math-description {
        font-size: 1rem;
        opacity: 0.8;
    }
    
    .interaction-prompt {
        margin-top: 4rem;
        text-align: center;
        font-size: 1.2rem;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 0.5; transform: scale(1); }
        50% { opacity: 1; transform: scale(1.05); }
    }
    
    /* Эмоционально-математическая система сопоставления */
    #emotional-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        opacity: 0.2;
    }
    
    .emotional-mathematical-matrix {
        margin-top: 4rem;
        width: 100%;
        position: relative;
    }
    
    .matrix-header {
        text-align: center;
        margin-bottom: 2rem;
    }
    
    .matrix-header h2 {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        background: linear-gradient(45deg, var(--emotion-joy), var(--emotion-sadness), var(--emotion-anger), var(--emotion-fear), var(--emotion-surprise));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-size: 300% 300%;
        animation: gradient-shift 10s ease infinite;
    }
    
    .matrix-description {
        max-width: 800px;
        margin: 0 auto;
        font-size: 1.1rem;
        opacity: 0.8;
    }
    
    .emotion-intensity-slider, .math-complexity-slider {
        width: 100%;
        margin-top: auto;
    }
    
    .intensity-input, .complexity-input {
        width: 100%;
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        outline: none;
        margin-bottom: 0.5rem;
    }
    
    .intensity-input::-webkit-slider-thumb, .complexity-input::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: white;
        cursor: pointer;
    }
    
    .intensity-label, .complexity-label {
        font-size: 0.8rem;
        opacity: 0.7;
    }
    
    .math-visualization {
        width: 100%;
        height: 100px;
        margin: 1rem 0;
        position: relative;
    }
    
    .math-canvas {
        width: 100%;
        height: 100%;
        border-radius: 5px;
    }
    
    .synthesis-container {
        margin-top: 3rem;
        padding: 2rem;
        background: rgba(40, 40, 40, 0.7);
        border-radius: 15px;
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .synthesis-container h3 {
        font-size: 2rem;
        margin-bottom: 1rem;
        text-align: center;
    }
    
    .synthesis-description {
        text-align: center;
        font-size: 1.1rem;
        opacity: 0.8;
        margin-bottom: 2rem;
    }
    
    .synthesis-dropzone {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto auto;
        gap: 1.5rem;
    }
    
    .dropzone-emotion, .dropzone-math {
        height: 150px;
        border: 2px dashed rgba(255, 255, 255, 0.3);
        border-radius: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 1rem;
        transition: all 0.3s ease;
    }
    
    .dropzone-emotion.dragover, .dropzone-math.dragover {
        border-color: rgba(255, 255, 255, 0.8);
        background: rgba(255, 255, 255, 0.1);
    }
    
    .synthesis-result {
        grid-column: 1 / span 2;
        min-height: 200px;
        padding: 1.5rem;
        background: rgba(20, 20, 20, 0.7);
        border-radius: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        font-size: 1.2rem;
    }

    /* Стили для эмоционально-математического синтезатора */
    .emotional-math-synthesizer {
        margin-top: 4rem;
        width: 100%;
        position: relative;
        padding: 2rem;
        background: rgba(20, 20, 20, 0.8);
        border-radius: 15px;
        backdrop-filter: blur(10px);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }
    
    .synthesizer-title {
        font-size: 2.5rem;
        text-align: center;
        margin-bottom: 1rem;
        background: linear-gradient(45deg, var(--emotion-joy), var(--emotion-sadness), var(--emotion-anger), var(--emotion-fear), var(--emotion-surprise));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-size: 300% 300%;
        animation: gradient-shift 10s ease infinite;
    }
    
    .synthesizer-description {
        max-width: 800px;
        margin: 0 auto 2rem;
        text-align: center;
        font-size: 1.1rem;
        opacity: 0.8;
        line-height: 1.5;
    }
    
    .synthesizer-workspace {
        display: grid;
        grid-template-columns: 1fr 1.5fr;
        gap: 2rem;
    }
    
    @media (max-width: 1024px) {
        .synthesizer-workspace {
            grid-template-columns: 1fr;
        }
    }
    
    .control-panel {
        display: flex;
        flex-direction: column;
        gap: 2rem;
    }
    
    .control-section {
        padding: 1.5rem;
        background: rgba(30, 30, 30, 0.7);
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .control-section h3 {
        font-size: 1.3rem;
        margin-bottom: 1.2rem;
        color: #fff;
        position: relative;
        padding-bottom: 0.5rem;
    }
    
    .control-section h3::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 50px;
        height: 2px;
        background: rgba(255, 255, 255, 0.3);
    }
    
    .emotion-controls, .math-controls, .meta-sliders {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }
    
    .emotion-slider, .math-slider, .meta-slider {
        display: grid;
        grid-template-columns: 1fr 2fr 40px;
        align-items: center;
        gap: 1rem;
    }
    
    .emotion-slider label, .math-slider label, .meta-slider label {
        font-size: 0.95rem;
        opacity: 0.9;
    }
    
    .emotion-input, .math-input, .meta-input {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        outline: none;
    }
    
    .emotion-input::-webkit-slider-thumb, .math-input::-webkit-slider-thumb, .meta-input::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: white;
        cursor: pointer;
    }
    
    .emotion-input[data-emotion="joy"]::-webkit-slider-thumb {
        background: var(--emotion-joy);
    }
    
    .emotion-input[data-emotion="sadness"]::-webkit-slider-thumb {
        background: var(--emotion-sadness);
    }
    
    .emotion-input[data-emotion="fear"]::-webkit-slider-thumb {
        background: var(--emotion-fear);
    }
    
    .emotion-input[data-emotion="anger"]::-webkit-slider-thumb {
        background: var(--emotion-anger);
    }
    
    .emotion-input[data-emotion="surprise"]::-webkit-slider-thumb {
        background: var(--emotion-surprise);
    }
    
    .value-display {
        font-size: 0.9rem;
        opacity: 0.7;
        text-align: right;
    }
    
    .control-buttons {
        display: flex;
        justify-content: space-between;
        margin-top: 1.5rem;
        gap: 1rem;
    }
    
    .control-buttons button {
        flex: 1;
        padding: 0.8rem;
        border: none;
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .control-buttons button:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
    }
    
    #generate-button {
        background: linear-gradient(45deg, #6a11cb, #2575fc);
    }
    
    #generate-button:hover {
        background: linear-gradient(45deg, #7722dc, #3686fd);
    }
    
    .visualization-panel {
        position: relative;
        min-height: 500px;
        border-radius: 10px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    #synthesizer-canvas {
        width: 100%;
        height: 400px;
        background: #000;
        border-radius: 10px;
    }
    
    .equation-display {
        margin-top: 1rem;
        padding: 1rem;
        background: rgba(30, 30, 30, 0.7);
        border-radius: 8px;
        font-family: 'EmotionalMath', serif;
    }
    
    .equation-title {
        font-size: 0.9rem;
        opacity: 0.7;
        margin-bottom: 0.5rem;
    }
    
    .equation-content {
        font-size: 1.2rem;
        text-align: center;
    }
    
    .state-description {
        margin-top: 1rem;
        padding: 1rem;
        background: rgba(30, 30, 30, 0.7);
        border-radius: 8px;
        font-size: 0.95rem;
        line-height: 1.4;
        opacity: 0.8;
    }
    
    /* Специальные стили для активного состояния синтезатора */
    .synthesizer-active #synthesizer-canvas {
        box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
    }
    
    .synthesizer-active .equation-content {
        animation: pulse-text 2s infinite;
    }
    
    @keyframes pulse-text {
        0%, 100% { opacity: 0.7; }
        50% { opacity: 1; }
    }

    /* Стили для эмоционально-математического проводника */
    .emotional-math-conductor {
        margin-top: 4rem;
        width: 100%;
        position: relative;
        padding: 2rem;
        background: rgba(20, 20, 20, 0.8);
        border-radius: 15px;
        backdrop-filter: blur(10px);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }
    
    .conductor-title {
        font-size: 2.5rem;
        text-align: center;
        margin-bottom: 1rem;
        background: linear-gradient(135deg, var(--emotion-joy), var(--emotion-sadness), var(--emotion-anger), var(--emotion-fear), var(--emotion-surprise));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-size: 400% 400%;
        animation: gradient-shift 12s ease infinite alternate;
    }
    
    .conductor-description {
        max-width: 800px;
        margin: 0 auto 2rem;
        text-align: center;
        font-size: 1.1rem;
        opacity: 0.8;
        line-height: 1.5;
    }
    
    .conductor-interface {
        display: grid;
        grid-template-columns: minmax(300px, 1fr) 2fr;
        gap: 2rem;
        margin-bottom: 3rem;
    }
    
    @media (max-width: 1024px) {
        .conductor-interface {
            grid-template-columns: 1fr;
        }
    }
    
    .transformation-panel {
        padding: 1.5rem;
        background: rgba(30, 30, 30, 0.7);
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }
    
    .transformation-panel h3 {
        font-size: 1.4rem;
        margin-bottom: 1rem;
        position: relative;
        padding-bottom: 0.5rem;
    }
    
    .transformation-panel h3::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 50px;
        height: 2px;
        background: rgba(255, 255, 255, 0.3);
    }
    
    .transformation-controls {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1.5rem;
    }
    
    .transformation-group {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .transformation-label {
        font-size: 0.9rem;
        opacity: 0.7;
    }
    
    .transformation-arrow {
        font-size: 1.5rem;
        color: rgba(255, 255, 255, 0.7);
        margin: 0 0.5rem;
        align-self: flex-end;
        margin-bottom: 0.5rem;
        animation: pulse-arrow 2s infinite;
    }
    
    @keyframes pulse-arrow {
        0%, 100% { opacity: 0.4; transform: scale(1); }
        50% { opacity: 1; transform: scale(1.1); }
    }
    
    select {
        padding: 0.6rem;
        border-radius: 5px;
        background: rgba(50, 50, 50, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        font-size: 0.95rem;
        width: 100%;
        appearance: none;
        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 0.7rem center;
        background-size: 1rem;
    }
    
    select:focus {
        outline: none;
        border-color: rgba(255, 255, 255, 0.5);
    }
    
    .transformation-params {
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
    }
    
    .param-slider {
        display: grid;
        grid-template-columns: 1fr 2fr 40px;
        align-items: center;
        gap: 1rem;
    }
    
    .param-slider label {
        font-size: 0.95rem;
        opacity: 0.9;
    }
    
    .param-slider input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        outline: none;
    }
    
    .param-slider input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: linear-gradient(45deg, #6a11cb, #2575fc);
        cursor: pointer;
    }
    
    .conductor-buttons {
        display: flex;
        gap: 1rem;
        margin-top: 1rem;
    }
    
    .conductor-buttons button {
        flex: 1;
        padding: 0.8rem;
        border: none;
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .conductor-buttons button:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
    }
    
    #transform-button {
        background: linear-gradient(45deg, #6a11cb, #2575fc);
    }
    
    #transform-button:hover {
        background: linear-gradient(45deg, #7722dc, #3686fd);
    }
    
    .visualization-space {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }
    
    #conductor-canvas {
        width: 100%;
        height: 350px;
        background: #000;
        border-radius: 10px;
    }
    
    .conductor-info {
        padding: 1.5rem;
        background: rgba(30, 30, 30, 0.7);
        border-radius: 10px;
        min-height: 100px;
    }
    
    .transformation-equation {
        font-family: 'EmotionalMath', serif;
        font-size: 1.3rem;
        text-align: center;
        margin-bottom: 1rem;
        opacity: 0.9;
    }
    
    .transformation-description {
        font-size: 0.95rem;
        line-height: 1.5;
        opacity: 0.8;
    }
    
    .network-map {
        margin-top: 3rem;
    }
    
    .network-map h3 {
        font-size: 1.4rem;
        text-align: center;
        margin-bottom: 1rem;
    }
    
    .network-description {
        max-width: 700px;
        margin: 0 auto 1.5rem;
        text-align: center;
        font-size: 1rem;
        opacity: 0.7;
    }
    
    .network-container {
        width: 100%;
        height: 300px;
        position: relative;
    }
    
    #network-canvas {
        width: 100%;
        height: 100%;
        background: rgba(10, 10, 10, 0.6);
        border-radius: 10px;
    }

    /* Стили для эмоционально-математических профилей восприятия */
    .perception-profiles {
        margin-top: 4rem;
        width: 100%;
        position: relative;
        padding: 2rem;
        background: rgba(20, 20, 20, 0.8);
        border-radius: 15px;
        backdrop-filter: blur(10px);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }
    
    .profiles-title {
        font-size: 2.5rem;
        text-align: center;
        margin-bottom: 1rem;
        background: linear-gradient(180deg, var(--emotion-joy), var(--emotion-sadness), var(--emotion-anger), var(--emotion-fear), var(--emotion-surprise));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-size: 100% 400%;
        animation: gradient-shift-vertical 15s ease infinite;
    }
    
    @keyframes gradient-shift-vertical {
        0% { background-position: 50% 0%; }
        50% { background-position: 50% 100%; }
        100% { background-position: 50% 0%; }
    }
    
    .profiles-description {
        max-width: 800px;
        margin: 0 auto 2rem;
        text-align: center;
        font-size: 1.1rem;
        opacity: 0.8;
        line-height: 1.5;
    }
    
    .profile-interface {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
    }
    
    @media (max-width: 1200px) {
        .profile-interface {
            grid-template-columns: 1fr;
        }
    }
    
    .profile-controls {
        display: flex;
        flex-direction: column;
        gap: 2rem;
    }
    
    .profile-section {
        padding: 1.5rem;
        background: rgba(30, 30, 30, 0.7);
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .profile-section h3 {
        font-size: 1.4rem;
        margin-bottom: 1.2rem;
        position: relative;
        padding-bottom: 0.5rem;
    }
    
    .profile-section h3::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 50px;
        height: 2px;
        background: rgba(255, 255, 255, 0.3);
    }
    
    .profile-section h4 {
        font-size: 1.2rem;
        margin: 1.5rem 0 1rem;
        opacity: 0.9;
    }
    
    .dimension-sliders {
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
    }
    
    .dimension-slider {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .dimension-slider label {
        font-size: 1rem;
        opacity: 0.9;
    }
    
    .dimension-input {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        outline: none;
    }
    
    .dimension-input::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: linear-gradient(45deg, #9000ff, #5e72eb);
        cursor: pointer;
    }
    
    .dimension-labels {
        display: flex;
        justify-content: space-between;
        font-size: 0.8rem;
        opacity: 0.7;
    }
    
    .temperament-controls {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
    }
    
    .temperament-option {
        display: flex;
        align-items: flex-start;
        gap: 0.5rem;
        padding: 0.5rem;
        border-radius: 5px;
        transition: all 0.3s ease;
    }
    
    .temperament-option:hover {
        background: rgba(255, 255, 255, 0.1);
    }
    
    .temperament-option input[type="radio"] {
        margin-top: 0.2rem;
    }
    
    .temperament-option label {
        font-size: 1rem;
        font-weight: bold;
        margin-right: 0.5rem;
    }
    
    .temperament-desc {
        font-size: 0.85rem;
        opacity: 0.7;
    }
    
    .profile-buttons {
        display: flex;
        gap: 1rem;
        margin-top: 1.5rem;
    }
    
    .profile-buttons button {
        flex: 1;
        padding: 0.8rem;
        border: none;
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .profile-buttons button:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
    }
    
    #generate-profile-button {
        background: linear-gradient(45deg, #9000ff, #5e72eb);
    }
    
    #generate-profile-button:hover {
        background: linear-gradient(45deg, #a01eff, #6f83fc);
    }
    
    .perception-matrix {
        margin-top: 1rem;
        overflow-x: auto;
    }
    
    .matrix-table {
        width: 100%;
        border-collapse: collapse;
    }
    
    .matrix-table th, .matrix-table td {
        padding: 0.7rem;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .matrix-table th {
        background: rgba(50, 50, 50, 0.5);
        font-size: 0.9rem;
    }
    
    .matrix-table tbody th {
        text-align: left;
    }
    
    .matrix-cell {
        width: 40px;
        height: 40px;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .matrix-cell:hover {
        transform: scale(1.1);
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }
    
    .matrix-legend {
        display: flex;
        justify-content: center;
        gap: 1.5rem;
        margin-top: 1rem;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.8rem;
        opacity: 0.8;
    }
    
    .legend-color {
        display: inline-block;
        width: 16px;
        height: 16px;
        border-radius: 3px;
    }
    
    .profile-visualization {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }
    
    .profile-canvas-container {
        width: 100%;
        height: 350px;
        position: relative;
    }
    
    #profile-canvas {
        width: 100%;
        height: 100%;
        background: #111;
        border-radius: 10px;
    }
    
    .profile-info {
        padding: 1.5rem;
        background: rgba(30, 30, 30, 0.7);
        border-radius: 10px;
    }
    
    .profile-name {
        font-size: 1.4rem;
        margin-bottom: 1rem;
        text-align: center;
    }
    
    .profile-description {
        font-size: 0.95rem;
        line-height: 1.5;
        margin-bottom: 1.5rem;
        opacity: 0.8;
    }
    
    .profile-analysis h4 {
        font-size: 1.1rem;
        margin-bottom: 0.8rem;
        opacity: 0.9;
    }
    
    .analysis-points {
        padding-left: 1.5rem;
        margin-bottom: 0;
    }
    
    .analysis-points li {
        margin-bottom: 0.5rem;
        font-size: 0.9rem;
        opacity: 0.8;
    }

    /* Стили для глубинных структур и интеграции системы */
    .deep-structures {
        margin-top: 4rem;
        width: 100%;
        position: relative;
        padding: 2rem;
        background: rgba(15, 15, 20, 0.85);
        border-radius: 15px;
        backdrop-filter: blur(10px);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
    }
    
    .deep-structures-title {
        font-size: 2.5rem;
        text-align: center;
        margin-bottom: 1rem;
        background: linear-gradient(135deg, #FF6B6B, #4ECDC4, #9370DB, #556270, #FF8C94);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-size: 500% 500%;
        animation: gradient-shift-multi 20s ease infinite alternate;
    }
    
    @keyframes gradient-shift-multi {
        0% { background-position: 0% 0%; }
        25% { background-position: 50% 100%; }
        50% { background-position: 100% 50%; }
        75% { background-position: 50% 0%; }
        100% { background-position: 0% 50%; }
    }
    
    .deep-structures-description {
        max-width: 800px;
        margin: 0 auto 2rem;
        text-align: center;
        font-size: 1.1rem;
        opacity: 0.8;
        line-height: 1.5;
    }
    
    /* Стили для навигации по системе */
    
    .system-navigation {
        padding: 1.5rem;
        background: rgba(25, 25, 35, 0.7);
        border-radius: 10px;
        margin-bottom: 2rem;
    }
    
    .system-navigation h3 {
        font-size: 1.4rem;
        margin-bottom: 1rem;
        position: relative;
        padding-bottom: 0.5rem;
    }
    
    .system-navigation h3::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 50px;
        height: 2px;
        background: rgba(255, 255, 255, 0.3);
    }
    
    .navigation-description {
        margin-bottom: 1.5rem;
        font-size: 1rem;
        opacity: 0.8;
    }
    
    .navigation-map {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        justify-content: space-between;
        margin-bottom: 1.5rem;
    }
    
    .navigation-node {
        flex: 1;
        min-width: 180px;
        max-width: 220px;
        padding: 1rem;
        background: rgba(40, 40, 50, 0.6);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .navigation-node:hover {
        background: rgba(60, 60, 70, 0.6);
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .navigation-node.active {
        background: rgba(70, 70, 90, 0.8);
        border-color: rgba(255, 255, 255, 0.3);
        transform: translateY(-5px);
        box-shadow: 0 5px 20px rgba(100, 100, 255, 0.3);
    }
    
    .node-icon {
        font-size: 1.8rem;
        margin-bottom: 0.8rem;
        text-align: center;
    }
    
    .node-label {
        font-size: 0.9rem;
        text-align: center;
        margin-bottom: 0.5rem;
    }
    
    .node-status {
        font-size: 0.8rem;
        text-align: center;
        opacity: 0.6;
    }
    
    .node-status.active {
        color: #72E6FF;
        opacity: 1;
    }
    
    .system-status {
        padding: 1rem;
        background: rgba(30, 30, 40, 0.6);
        border-radius: 8px;
    }
    
    .status-title {
        font-size: 1.1rem;
        margin-bottom: 0.8rem;
        opacity: 0.9;
    }
    
    .status-description {
        font-size: 0.9rem;
        opacity: 0.8;
        margin-bottom: 1rem;
    }
    
    .status-indicators {
        display: flex;
        gap: 1.5rem;
    }
    
    .status-indicator {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .indicator-label {
        font-size: 0.85rem;
        opacity: 0.8;
    }
    
    .indicator-value {
        font-size: 0.85rem;
        font-weight: bold;
        padding: 0.2rem 0.5rem;
        border-radius: 4px;
    }
    
    .indicator-value.high {
        background: rgba(100, 255, 100, 0.2);
        color: #90EE90;
    }
    
    .indicator-value.medium {
        background: rgba(255, 255, 100, 0.2);
        color: #FFFF90;
    }
    
    .indicator-value.low {
        background: rgba(255, 100, 100, 0.2);
        color: #FF9090;
    }
    
    /* Стили для интерфейса глубинных структур */
    
    .deep-structures-interface {
        display: grid;
        grid-template-columns: 1.5fr 1fr;
        gap: 1.5rem;
        margin-bottom: 2rem;
    }
    
    @media (max-width: 1100px) {
        .deep-structures-interface {
            grid-template-columns: 1fr;
        }
    }
    
    .deep-visualization {
        position: relative;
    }
    
    #deep-canvas {
        width: 100%;
        height: 400px;
        background: #090912;
        border-radius: 10px;
        margin-bottom: 1rem;
    }
    
    .visualization-controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 1rem;
    }
    
    .control-group {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .control-group label {
        font-size: 0.9rem;
        opacity: 0.8;
    }
    
    .control-group input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        outline: none;
    }
    
    .control-group input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: linear-gradient(45deg, #9370DB, #4ECDC4);
        cursor: pointer;
    }
    
    /* Стили для панели архетипов */
    
    .archetypes-panel {
        padding: 1.5rem;
        background: rgba(25, 25, 35, 0.7);
        border-radius: 10px;
    }
    
    .archetypes-panel h3 {
        font-size: 1.4rem;
        margin-bottom: 1rem;
        position: relative;
        padding-bottom: 0.5rem;
    }
    
    .archetypes-panel h3::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 50px;
        height: 2px;
        background: rgba(255, 255, 255, 0.3);
    }
    
    .archetypes-description {
        margin-bottom: 1.5rem;
        font-size: 0.95rem;
        opacity: 0.8;
    }
    
    .archetypes-container {
        display: flex;
        flex-wrap: wrap;
        gap: 0.8rem;
        margin-bottom: 1.5rem;
    }
    
    .archetype-item {
        flex: 1;
        min-width: 120px;
        padding: 1rem;
        background: rgba(40, 40, 50, 0.6);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
    }
    
    .archetype-item:hover {
        background: rgba(60, 60, 70, 0.6);
        transform: translateY(-3px);
    }
    
    .archetype-item.active {
        background: rgba(70, 70, 90, 0.8);
        border-color: rgba(255, 255, 255, 0.3);
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(100, 100, 255, 0.2);
    }
    
    .archetype-icon {
        font-size: 1.8rem;
        margin-bottom: 0.8rem;
    }
    
    .archetype-name {
        font-size: 0.85rem;
        line-height: 1.3;
    }
    
    .archetype-details {
        padding: 1.5rem;
        background: rgba(30, 30, 40, 0.6);
        border-radius: 8px;
    }
    
    .archetype-title {
        font-size: 1.2rem;
        margin-bottom: 1rem;
        text-align: center;
    }
    
    .archetype-description {
        font-size: 0.95rem;
        opacity: 0.9;
        margin-bottom: 1.5rem;
        line-height: 1.5;
    }
    
    .archetype-description p {
        margin-bottom: 0.8rem;
    }
    
    .manifestation-title {
        font-size: 1rem;
        margin-bottom: 0.8rem;
        opacity: 0.9;
    }
    
    .manifestation-list {
        list-style: none;
        padding: 0;
    }
    
    .manifestation-list li {
        margin-bottom: 0.7rem;
        font-size: 0.9rem;
        opacity: 0.8;
        padding-left: 1.2rem;
        position: relative;
    }
    
    .manifestation-list li::before {
        content: '•';
        position: absolute;
        left: 0;
        top: 0;
    }
    
    .emotion-tag, .math-tag, .synesthesia-tag {
        font-weight: bold;
        font-size: 0.85rem;
        margin-right: 0.3rem;
    }
    
    .emotion-tag {
        color: #FF8C94;
    }
    
    .math-tag {
        color: #4ECDC4;
    }
    
    .synesthesia-tag {
        color: #9370DB;
    }
    
    /* Стили для интеграционной консоли */
    
    .integration-console {
        background: rgba(20, 20, 25, 0.8);
        border-radius: 10px;
        margin-bottom: 2rem;
        font-family: monospace;
    }
    
    .console-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .console-header h3 {
        font-size: 1.2rem;
        margin: 0;
    }
    
    .console-controls {
        display: flex;
        gap: 0.8rem;
    }
    
    .console-controls button {
        padding: 0.4rem 0.8rem;
        background: rgba(50, 50, 60, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        color: white;
        font-size: 0.85rem;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .console-controls button:hover {
        background: rgba(70, 70, 80, 0.8);
    }
    
    .console-content {
        max-height: 200px;
        overflow-y: auto;
        padding: 1rem 1.5rem;
    }
    
    .console-entry {
        display: flex;
        gap: 1rem;
        margin-bottom: 0.8rem;
        font-size: 0.9rem;
    }
    
    .entry-timestamp {
        color: #72E6FF;
        flex-shrink: 0;
    }
    
    .entry-content {
        opacity: 0.9;
        line-height: 1.4;
    }
    
    .console-input {
        display: flex;
        gap: 0.8rem;
        padding: 1rem 1.5rem;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .console-input input {
        flex: 1;
        padding: 0.7rem 1rem;
        background: rgba(40, 40, 50, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        color: white;
        font-size: 0.9rem;
        font-family: monospace;
    }
    
    .console-input input:focus {
        outline: none;
        border-color: rgba(255, 255, 255, 0.4);
    }
    
    .console-input button {
        padding: 0.7rem 1.2rem;
        background: rgba(70, 70, 90, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        color: white;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .console-input button:hover {
        background: rgba(90, 90, 110, 0.9);
    }
    
    /* Стили для эпилога */
    
    .project-epilogue {
        background: rgba(25, 25, 35, 0.7);
        border-radius: 10px;
        padding: 1.5rem;
    }
    
    .project-epilogue h3 {
        font-size: 1.4rem;
        margin-bottom: 1rem;
        text-align: center;
    }
    
    .epilogue-content {
        font-size: 1rem;
        line-height: 1.6;
        max-width: 800px;
        margin: 0 auto;
        text-align: center;
        opacity: 0.9;
    }
    
    .epilogue-content p {
        margin-bottom: 1rem;
    }
</style>
</head>
<body>
    <canvas id="emotional-canvas"></canvas>
    
    <div class="container">
        <div class="intro-section">
            <h1>СинЭстеМика</h1>
            <div class="subtitle">Где эмоции встречаются с математическими структурами</div>
            
            <div class="concept-description">
                <p>Добро пожаловать в пространство синестезии эмоций и математики. Здесь каждое чувство имеет свою математическую структуру, каждая формула несёт эмоциональный отпечаток. В этом интерактивном исследовании вы будете взаимодействовать с эмоционально-математическими сущностями, создавая уникальные паттерны сознания.</p>
                <p>Математика эмоций не линейна. Она фрактальна, рекурсивна, топологически сложна. Чувства преломляются через призму уравнений, а геометрические структуры порождают новые эмоциональные состояния. Исследуйте этот неизведанный ландшафт, где ваше взаимодействие изменяет саму структуру пространства.</p>
            </div>
        </div>
        
        <div class="interaction-prompt">
            Коснитесь экрана, чтобы начать погружение...
        </div>
    </div>

    <!-- Эмоционально-математическая система сопоставления -->
    <div class="emotional-mathematical-matrix">
        <div class="matrix-header">
            <h2>Матрица эмоционально-математических соответствий</h2>
            <p class="matrix-description">Исследуйте взаимосвязи между эмоциональными состояниями и математическими структурами. Взаимодействуйте с элементами, чтобы создавать новые эмоционально-математические комбинации.</p>
        </div>
        
        <div class="emotion-math-grid">
            <div class="emotion-container" data-emotion="joy" data-intensity="0.5">
                <div class="emotion-title">Радость</div>
                <div class="emotion-description">Возрастающая, расширяющаяся, сияющая</div>
                <div class="emotion-intensity-slider">
                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="intensity-input">
                    <div class="intensity-label">Интенсивность: <span>50%</span></div>
                </div>
            </div>
            
            <div class="math-container" data-math="exponential" data-complexity="0.5">
                <div class="math-title">Экспоненциальные функции</div>
                <div class="math-description">y = e<sup>x</sup>, возрастающие, ускоряющиеся</div>
                <div class="math-visualization">
                    <canvas class="math-canvas" width="200" height="100"></canvas>
                </div>
                <div class="math-complexity-slider">
                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="complexity-input">
                    <div class="complexity-label">Сложность: <span>50%</span></div>
                </div>
            </div>
            
            <div class="emotion-container" data-emotion="sadness" data-intensity="0.5">
                <div class="emotion-title">Грусть</div>
                <div class="emotion-description">Сжимающаяся, утихающая, глубокая</div>
                <div class="emotion-intensity-slider">
                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="intensity-input">
                    <div class="intensity-label">Интенсивность: <span>50%</span></div>
                </div>
            </div>
            
            <div class="math-container" data-math="logarithmic" data-complexity="0.5">
                <div class="math-title">Логарифмические функции</div>
                <div class="math-description">y = log(x), замедляющиеся, медитативные</div>
                <div class="math-visualization">
                    <canvas class="math-canvas" width="200" height="100"></canvas>
                </div>
                <div class="math-complexity-slider">
                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="complexity-input">
                    <div class="complexity-label">Сложность: <span>50%</span></div>
                </div>
            </div>
            
            <div class="emotion-container" data-emotion="fear" data-intensity="0.5">
                <div class="emotion-title">Страх</div>
                <div class="emotion-description">Хаотичная, прерывистая, затемняющая</div>
                <div class="emotion-intensity-slider">
                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="intensity-input">
                    <div class="intensity-label">Интенсивность: <span>50%</span></div>
                </div>
            </div>
            
            <div class="math-container" data-math="fractal" data-complexity="0.5">
                <div class="math-title">Фрактальные структуры</div>
                <div class="math-description">z = z² + c, бесконечная самоподобность</div>
                <div class="math-visualization">
                    <canvas class="math-canvas" width="200" height="100"></canvas>
                </div>
                <div class="math-complexity-slider">
                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="complexity-input">
                    <div class="complexity-label">Сложность: <span>50%</span></div>
                </div>
            </div>
            
            <div class="emotion-container" data-emotion="anger" data-intensity="0.5">
                <div class="emotion-title">Гнев</div>
                <div class="emotion-description">Пульсирующая, острая, интенсивная</div>
                <div class="emotion-intensity-slider">
                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="intensity-input">
                    <div class="intensity-label">Интенсивность: <span>50%</span></div>
                </div>
            </div>
            
            <div class="math-container" data-math="trigonometric" data-complexity="0.5">
                <div class="math-title">Тригонометрические волны</div>
                <div class="math-description">y = sin(x) × A, ритмичные, пульсирующие</div>
                <div class="math-visualization">
                    <canvas class="math-canvas" width="200" height="100"></canvas>
                </div>
                <div class="math-complexity-slider">
                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="complexity-input">
                    <div class="complexity-label">Сложность: <span>50%</span></div>
                </div>
            </div>
            
            <div class="emotion-container" data-emotion="surprise" data-intensity="0.5">
                <div class="emotion-title">Удивление</div>
                <div class="emotion-description">Внезапная, расширяющаяся, яркая</div>
                <div class="emotion-intensity-slider">
                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="intensity-input">
                    <div class="intensity-label">Интенсивность: <span>50%</span></div>
                </div>
            </div>
            
            <div class="math-container" data-math="complex" data-complexity="0.5">
                <div class="math-title">Комплексные числа</div>
                <div class="math-description">z = a + bi, многомерные, фазовые</div>
                <div class="math-visualization">
                    <canvas class="math-canvas" width="200" height="100"></canvas>
                </div>
                <div class="math-complexity-slider">
                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="complexity-input">
                    <div class="complexity-label">Сложность: <span>50%</span></div>
                </div>
            </div>
        </div>
        
        <div class="synthesis-container">
            <h3>Эмоционально-математический синтез</h3>
            <div class="synthesis-description">Перетащите элементы эмоций и математики для создания синтетического опыта</div>
            <div class="synthesis-dropzone">
                <div class="dropzone-emotion">Перетащите эмоцию сюда</div>
                <div class="dropzone-math">Перетащите математическую структуру сюда</div>
                <div class="synthesis-result">Результат синтеза появится здесь</div>
            </div>
        </div>
    </div>

    <!-- Эмоционально-математический синтезатор -->
    <div class="emotional-math-synthesizer">
        <h2 class="synthesizer-title">Эмоционально-математический синтезатор</h2>
        <p class="synthesizer-description">Создайте уникальную эмоционально-математическую композицию, управляя различными параметрами. Синтезатор преобразует ваши входные данные в визуальное и звуковое пространство.</p>
        
        <div class="synthesizer-workspace">
            <div class="control-panel">
                <div class="control-section emotions-section">
                    <h3>Эмоциональный спектр</h3>
                    
                    <div class="emotion-controls">
                        <div class="emotion-slider">
                            <label>Радость</label>
                            <input type="range" class="emotion-input" data-emotion="joy" min="0" max="1" step="0.01" value="0.5">
                            <span class="value-display">50%</span>
                        </div>
                        
                        <div class="emotion-slider">
                            <label>Грусть</label>
                            <input type="range" class="emotion-input" data-emotion="sadness" min="0" max="1" step="0.01" value="0.2">
                            <span class="value-display">20%</span>
                        </div>
                        
                        <div class="emotion-slider">
                            <label>Страх</label>
                            <input type="range" class="emotion-input" data-emotion="fear" min="0" max="1" step="0.01" value="0.1">
                            <span class="value-display">10%</span>
                        </div>
                        
                        <div class="emotion-slider">
                            <label>Гнев</label>
                            <input type="range" class="emotion-input" data-emotion="anger" min="0" max="1" step="0.01" value="0.1">
                            <span class="value-display">10%</span>
                        </div>
                        
                        <div class="emotion-slider">
                            <label>Удивление</label>
                            <input type="range" class="emotion-input" data-emotion="surprise" min="0" max="1" step="0.01" value="0.3">
                            <span class="value-display">30%</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-section math-section">
                    <h3>Математические структуры</h3>
                    
                    <div class="math-controls">
                        <div class="math-slider">
                            <label>Экспоненциальные функции</label>
                            <input type="range" class="math-input" data-math="exponential" min="0" max="1" step="0.01" value="0.4">
                            <span class="value-display">40%</span>
                        </div>
                        
                        <div class="math-slider">
                            <label>Логарифмические функции</label>
                            <input type="range" class="math-input" data-math="logarithmic" min="0" max="1" step="0.01" value="0.3">
                            <span class="value-display">30%</span>
                        </div>
                        
                        <div class="math-slider">
                            <label>Фрактальные структуры</label>
                            <input type="range" class="math-input" data-math="fractal" min="0" max="1" step="0.01" value="0.6">
                            <span class="value-display">60%</span>
                        </div>
                        
                        <div class="math-slider">
                            <label>Тригонометрические волны</label>
                            <input type="range" class="math-input" data-math="trigonometric" min="0" max="1" step="0.01" value="0.5">
                            <span class="value-display">50%</span>
                        </div>
                        
                        <div class="math-slider">
                            <label>Комплексные числа</label>
                            <input type="range" class="math-input" data-math="complex" min="0" max="1" step="0.01" value="0.3">
                            <span class="value-display">30%</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-section meta-controls">
                    <h3>Метапараметры</h3>
                    
                    <div class="meta-sliders">
                        <div class="meta-slider">
                            <label>Хаотичность</label>
                            <input type="range" class="meta-input" data-param="chaos" min="0" max="1" step="0.01" value="0.3">
                            <span class="value-display">30%</span>
                        </div>
                        
                        <div class="meta-slider">
                            <label>Синхронность</label>
                            <input type="range" class="meta-input" data-param="synchronicity" min="0" max="1" step="0.01" value="0.7">
                            <span class="value-display">70%</span>
                        </div>
                        
                        <div class="meta-slider">
                            <label>Многомерность</label>
                            <input type="range" class="meta-input" data-param="dimensionality" min="0" max="1" step="0.01" value="0.5">
                            <span class="value-display">50%</span>
                        </div>
                        
                        <div class="meta-slider">
                            <label>Темпоральность</label>
                            <input type="range" class="meta-input" data-param="temporality" min="0" max="1" step="0.01" value="0.4">
                            <span class="value-display">40%</span>
                        </div>
                    </div>
                    
                    <div class="control-buttons">
                        <button id="generate-button">Синтезировать</button>
                        <button id="reset-button">Сбросить</button>
                        <button id="random-button">Случайные значения</button>
                    </div>
                </div>
            </div>
            
            <div class="visualization-panel">
                <canvas id="synthesizer-canvas"></canvas>
                <div class="equation-display">
                    <div class="equation-title">Эмоционально-математическое уравнение:</div>
                    <div class="equation-content">φ(E) = Σ[E(i)·M(j)]·w(i,j)</div>
                </div>
                <div class="state-description">
                    <p>Передвигайте ползунки и нажмите "Синтезировать", чтобы создать эмоционально-математическое состояние.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Эмоционально-математический проводник -->
    <div class="emotional-math-conductor">
        <h2 class="conductor-title">Эмоционально-математический проводник</h2>
        <p class="conductor-description">Погрузитесь в интерактивное пространство взаимных преобразований между эмоциональными состояниями и математическими структурами. Проводник позволяет исследовать глубинные связи между субъективным опытом и объективными паттернами.</p>
        
        <div class="conductor-interface">
            <div class="transformation-panel">
                <h3>Преобразования</h3>
                <div class="transformation-controls">
                    <div class="transformation-group">
                        <div class="transformation-label">Источник:</div>
                        <select id="source-type">
                            <option value="emotion">Эмоциональное состояние</option>
                            <option value="math">Математическая структура</option>
                        </select>
                        <select id="source-value">
                            <!-- Динамически заполняется в зависимости от выбранного типа -->
                        </select>
                    </div>
                    
                    <div class="transformation-arrow">→</div>
                    
                    <div class="transformation-group">
                        <div class="transformation-label">Цель:</div>
                        <select id="target-type">
                            <option value="math">Математическая структура</option>
                            <option value="emotion">Эмоциональное состояние</option>
                        </select>
                        <select id="target-value">
                            <!-- Динамически заполняется в зависимости от выбранного типа -->
                        </select>
                    </div>
                </div>
                
                <div class="transformation-params">
                    <div class="param-slider">
                        <label>Интенсивность преобразования</label>
                        <input type="range" id="transform-intensity" min="0" max="1" step="0.01" value="0.7">
                        <span class="value-display">70%</span>
                    </div>
                    
                    <div class="param-slider">
                        <label>Глубина погружения</label>
                        <input type="range" id="transform-depth" min="0" max="1" step="0.01" value="0.5">
                        <span class="value-display">50%</span>
                    </div>
                    
                    <div class="conductor-buttons">
                        <button id="transform-button">Трансформировать</button>
                        <button id="explore-button">Исследовать пространство</button>
                    </div>
                </div>
            </div>
            
            <div class="visualization-space">
                <canvas id="conductor-canvas"></canvas>
                <div class="conductor-info">
                    <div class="transformation-equation"></div>
                    <div class="transformation-description"></div>
                </div>
            </div>
        </div>
        
        <div class="network-map">
            <h3>Карта эмоционально-математической сети</h3>
            <p class="network-description">Визуализация связей и переходов между различными состояниями и структурами. Линии отображают силу связей и возможные пути трансформации.</p>
            <div class="network-container">
                <canvas id="network-canvas"></canvas>
            </div>
        </div>
    </div>

    <!-- Эмоционально-математические профили восприятия -->
    <div class="perception-profiles">
        <h2 class="profiles-title">Эмоционально-математические профили восприятия</h2>
        <p class="profiles-description">Создайте и исследуйте индивидуальные профили восприятия, отражающие уникальную синестезию между эмоциональными состояниями и математическими структурами. Исследуйте как различные типы мышления формируют уникальное восприятие абстрактных концепций.</p>
        
        <div class="profile-interface">
            <div class="profile-controls">
                <div class="profile-section">
                    <h3>Ваш профиль восприятия</h3>
                    
                    <div class="dimension-sliders">
                        <div class="dimension-slider">
                            <label>Линейность / Нелинейность</label>
                            <input type="range" class="dimension-input" data-dimension="linearity" min="0" max="1" step="0.01" value="0.5">
                            <div class="dimension-labels">
                                <span>Линейное</span>
                                <span>Нелинейное</span>
                            </div>
                        </div>
                        
                        <div class="dimension-slider">
                            <label>Структурность / Хаотичность</label>
                            <input type="range" class="dimension-input" data-dimension="structure" min="0" max="1" step="0.01" value="0.4">
                            <div class="dimension-labels">
                                <span>Структурное</span>
                                <span>Хаотичное</span>
                            </div>
                        </div>
                        
                        <div class="dimension-slider">
                            <label>Дискретность / Непрерывность</label>
                            <input type="range" class="dimension-input" data-dimension="continuity" min="0" max="1" step="0.01" value="0.6">
                            <div class="dimension-labels">
                                <span>Дискретное</span>
                                <span>Непрерывное</span>
                            </div>
                        </div>
                        
                        <div class="dimension-slider">
                            <label>Детерминизм / Случайность</label>
                            <input type="range" class="dimension-input" data-dimension="determinism" min="0" max="1" step="0.01" value="0.3">
                            <div class="dimension-labels">
                                <span>Детерминистичное</span>
                                <span>Случайное</span>
                            </div>
                        </div>
                        
                        <div class="dimension-slider">
                            <label>Абстрактность / Конкретность</label>
                            <input type="range" class="dimension-input" data-dimension="abstraction" min="0" max="1" step="0.01" value="0.7">
                            <div class="dimension-labels">
                                <span>Конкретное</span>
                                <span>Абстрактное</span>
                            </div>
                        </div>
                    </div>
                    
                    <h4>Темперамент эмоционально-математического восприятия</h4>
                    <div class="temperament-controls">
                        <div class="temperament-option">
                            <input type="radio" name="temperament" id="temperament-rational" value="rational" checked>
                            <label for="temperament-rational">Рациональный</label>
                            <span class="temperament-desc">Акцент на структуре, логике и последовательности</span>
                        </div>
                        
                        <div class="temperament-option">
                            <input type="radio" name="temperament" id="temperament-intuitive" value="intuitive">
                            <label for="temperament-intuitive">Интуитивный</label>
                            <span class="temperament-desc">Акцент на паттернах, взаимосвязях и целостном восприятии</span>
                        </div>
                        
                        <div class="temperament-option">
                            <input type="radio" name="temperament" id="temperament-chaotic" value="chaotic">
                            <label for="temperament-chaotic">Хаотичный</label>
                            <span class="temperament-desc">Акцент на неожиданных связях, фрактальности и эмерджентности</span>
                        </div>
                        
                        <div class="temperament-option">
                            <input type="radio" name="temperament" id="temperament-harmonic" value="harmonic">
                            <label for="temperament-harmonic">Гармоничный</label>
                            <span class="temperament-desc">Акцент на симметрии, пропорциях и балансе</span>
                        </div>
                    </div>
                    
                    <div class="profile-buttons">
                        <button id="generate-profile-button">Сгенерировать профиль</button>
                        <button id="reset-profile-button">Сбросить</button>
                        <button id="randomize-profile-button">Случайные параметры</button>
                    </div>
                </div>
                
                <div class="profile-section">
                    <h3>Восприятие эмоционально-математических связей</h3>
                    <div class="perception-matrix">
                        <table class="matrix-table">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Экспоненциальные</th>
                                    <th>Логарифмические</th>
                                    <th>Тригонометрические</th>
                                    <th>Фрактальные</th>
                                    <th>Комплексные</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <th>Радость</th>
                                    <td data-emotion="joy" data-math="exponential" class="matrix-cell"></td>
                                    <td data-emotion="joy" data-math="logarithmic" class="matrix-cell"></td>
                                    <td data-emotion="joy" data-math="trigonometric" class="matrix-cell"></td>
                                    <td data-emotion="joy" data-math="fractal" class="matrix-cell"></td>
                                    <td data-emotion="joy" data-math="complex" class="matrix-cell"></td>
                                </tr>
                                <tr>
                                    <th>Грусть</th>
                                    <td data-emotion="sadness" data-math="exponential" class="matrix-cell"></td>
                                    <td data-emotion="sadness" data-math="logarithmic" class="matrix-cell"></td>
                                    <td data-emotion="sadness" data-math="trigonometric" class="matrix-cell"></td>
                                    <td data-emotion="sadness" data-math="fractal" class="matrix-cell"></td>
                                    <td data-emotion="sadness" data-math="complex" class="matrix-cell"></td>
                                </tr>
                                <tr>
                                    <th>Страх</th>
                                    <td data-emotion="fear" data-math="exponential" class="matrix-cell"></td>
                                    <td data-emotion="fear" data-math="logarithmic" class="matrix-cell"></td>
                                    <td data-emotion="fear" data-math="trigonometric" class="matrix-cell"></td>
                                    <td data-emotion="fear" data-math="fractal" class="matrix-cell"></td>
                                    <td data-emotion="fear" data-math="complex" class="matrix-cell"></td>
                                </tr>
                                <tr>
                                    <th>Гнев</th>
                                    <td data-emotion="anger" data-math="exponential" class="matrix-cell"></td>
                                    <td data-emotion="anger" data-math="logarithmic" class="matrix-cell"></td>
                                    <td data-emotion="anger" data-math="trigonometric" class="matrix-cell"></td>
                                    <td data-emotion="anger" data-math="fractal" class="matrix-cell"></td>
                                    <td data-emotion="anger" data-math="complex" class="matrix-cell"></td>
                                </tr>
                                <tr>
                                    <th>Удивление</th>
                                    <td data-emotion="surprise" data-math="exponential" class="matrix-cell"></td>
                                    <td data-emotion="surprise" data-math="logarithmic" class="matrix-cell"></td>
                                    <td data-emotion="surprise" data-math="trigonometric" class="matrix-cell"></td>
                                    <td data-emotion="surprise" data-math="fractal" class="matrix-cell"></td>
                                    <td data-emotion="surprise" data-math="complex" class="matrix-cell"></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="matrix-legend">
                        <div class="legend-item">
                            <span class="legend-color" style="background-color: rgba(255, 255, 255, 0.1);"></span>
                            <span class="legend-label">Слабая связь</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color" style="background-color: rgba(255, 255, 255, 0.4);"></span>
                            <span class="legend-label">Средняя связь</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color" style="background-color: rgba(255, 255, 255, 0.7);"></span>
                            <span class="legend-label">Сильная связь</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="profile-visualization">
                <div class="profile-canvas-container">
                    <canvas id="profile-canvas"></canvas>
                </div>
                
                <div class="profile-info">
                    <h3 class="profile-name">Профиль восприятия</h3>
                    <div class="profile-description">
                        <p>Настройте параметры и нажмите "Сгенерировать профиль" для создания индивидуального профиля эмоционально-математического восприятия.</p>
                    </div>
                    <div class="profile-analysis">
                        <h4>Анализ профиля</h4>
                        <ul class="analysis-points">
                            <li>Определите параметры своего восприятия</li>
                            <li>Исследуйте соответствия между эмоциями и математическими структурами</li>
                            <li>Наблюдайте как изменения параметров влияют на визуализацию</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Глубинные структуры и интеграция системы -->
    <div class="deep-structures">
        <h2 class="deep-structures-title">Глубинные структуры синестезии</h2>
        <p class="deep-structures-description">Финальный уровень исследования, где эмоции и математические структуры объединяются в единое пространство глубинных паттернов. Исследуйте фундаментальные структуры, лежащие в основе как эмоциональных, так и математических явлений.</p>
        
        <div class="system-navigation">
            <h3>Навигация по системе</h3>
            <p class="navigation-description">Вы можете исследовать любой аспект проекта СинЭстеМика через этот интерфейс. Все компоненты системы взаимосвязаны и влияют друг на друга.</p>
            
            <div class="navigation-map">
                <div class="navigation-node" data-component="synthesizer">
                    <div class="node-icon">⚡</div>
                    <div class="node-label">Эмоционально-математический синтезатор</div>
                    <div class="node-status"></div>
                </div>
                
                <div class="navigation-node" data-component="connections">
                    <div class="node-icon">🔄</div>
                    <div class="node-label">Система соответствий</div>
                    <div class="node-status"></div>
                </div>
                
                <div class="navigation-node" data-component="conductor">
                    <div class="node-icon">🔮</div>
                    <div class="node-label">Проводник</div>
                    <div class="node-status"></div>
                </div>
                
                <div class="navigation-node" data-component="profiles">
                    <div class="node-icon">👁️</div>
                    <div class="node-label">Профили восприятия</div>
                    <div class="node-status"></div>
                </div>
                
                <div class="navigation-node active" data-component="deep-structures">
                    <div class="node-icon">🌌</div>
                    <div class="node-label">Глубинные структуры</div>
                    <div class="node-status active">Активно</div>
                </div>
            </div>
            
            <div class="system-status">
                <div class="status-title">Статус системы</div>
                <div class="status-description">Все компоненты системы активны и взаимодействуют. Ваш профиль восприятия интегрирован с глубинными структурами.</div>
                <div class="status-indicators">
                    <div class="status-indicator">
                        <div class="indicator-label">Интеграция:</div>
                        <div class="indicator-value high">Высокая</div>
                    </div>
                    <div class="status-indicator">
                        <div class="indicator-label">Синхронизация:</div>
                        <div class="indicator-value medium">Средняя</div>
                    </div>
                    <div class="status-indicator">
                        <div class="indicator-label">Когерентность:</div>
                        <div class="indicator-value high">Высокая</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="deep-structures-interface">
            <div class="deep-visualization">
                <canvas id="deep-canvas"></canvas>
                <div class="visualization-controls">
                    <div class="control-group">
                        <label>Глубина исследования</label>
                        <input type="range" id="depth-slider" min="0" max="1" step="0.01" value="0.7">
                    </div>
                    <div class="control-group">
                        <label>Плотность связей</label>
                        <input type="range" id="density-slider" min="0" max="1" step="0.01" value="0.5">
                    </div>
                    <div class="control-group">
                        <label>Волновой фактор</label>
                        <input type="range" id="wave-slider" min="0" max="1" step="0.01" value="0.6">
                    </div>
                    <div class="control-buttons">
                        <button id="explore-button">Исследовать глубже</button>
                        <button id="resonance-button">Активировать резонанс</button>
                    </div>
                </div>
            </div>
            
            <div class="archetypes-panel">
                <h3>Архетипические паттерны</h3>
                <p class="archetypes-description">Фундаментальные структуры, общие для эмоциональных и математических явлений. Выберите архетип для исследования его проявлений.</p>
                
                <div class="archetypes-container">
                    <div class="archetype-item active" data-archetype="harmony">
                        <div class="archetype-icon">♾️</div>
                        <div class="archetype-name">Гармония и равновесие</div>
                    </div>
                    
                    <div class="archetype-item" data-archetype="transformation">
                        <div class="archetype-icon">🔄</div>
                        <div class="archetype-name">Трансформация и метаморфозы</div>
                    </div>
                    
                    <div class="archetype-item" data-archetype="recursion">
                        <div class="archetype-icon">🔁</div>
                        <div class="archetype-name">Рекурсия и самоподобие</div>
                    </div>
                    
                    <div class="archetype-item" data-archetype="duality">
                        <div class="archetype-icon">☯️</div>
                        <div class="archetype-name">Дуальность и полярность</div>
                    </div>
                    
                    <div class="archetype-item" data-archetype="emergence">
                        <div class="archetype-icon">🌱</div>
                        <div class="archetype-name">Эмерджентность и синергия</div>
                    </div>
                </div>
                
                <div class="archetype-details">
                    <h4 class="archetype-title">Гармония и равновесие</h4>
                    <div class="archetype-description">
                        <p>Фундаментальный паттерн баланса и пропорциональности, проявляющийся как в эмоциональных состояниях, так и в математических структурах.</p>
                        <p>В эмоциональной сфере выражается через состояния умиротворения, равновесия и целостности. В математике проявляется через симметрию, золотое сечение и согласованность.</p>
                    </div>
                    <div class="archetype-manifestations">
                        <div class="manifestation-title">Проявления:</div>
                        <ul class="manifestation-list">
                            <li><span class="emotion-tag">Эмоция:</span> Состояние внутреннего баланса и умиротворения</li>
                            <li><span class="math-tag">Математика:</span> Симметричные функции и сбалансированные уравнения</li>
                            <li><span class="synesthesia-tag">Синестезия:</span> Чувство завершенности при созерцании пропорциональных структур</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="integration-console">
            <div class="console-header">
                <h3>Интеграционная консоль</h3>
                <div class="console-controls">
                    <button id="clear-console-button">Очистить</button>
                    <button id="export-button">Экспортировать опыт</button>
                </div>
            </div>
            
            <div class="console-content">
                <div class="console-entry">
                    <div class="entry-timestamp">00:00:00</div>
                    <div class="entry-content">Инициализация системы СинЭстеМика завершена. Все компоненты активны.</div>
                </div>
                <div class="console-entry">
                    <div class="entry-timestamp">00:00:05</div>
                    <div class="entry-content">Глубинные структуры загружены. Архетипические паттерны доступны для исследования.</div>
                </div>
                <div class="console-entry">
                    <div class="entry-timestamp">00:00:10</div>
                    <div class="entry-content">Обнаружен активный профиль восприятия. Интеграция с глубинными структурами выполнена.</div>
                </div>
                <div class="console-entry">
                    <div class="entry-timestamp">00:00:15</div>
                    <div class="entry-content">Система готова к исследованию. Используйте элементы управления для навигации.</div>
                </div>
            </div>
            
            <div class="console-input">
                <input type="text" id="console-command" placeholder="Введите команду или запрос...">
                <button id="send-command-button">Отправить</button>
            </div>
        </div>
        
        <div class="project-epilogue">
            <h3>Эпилог</h3>
            <div class="epilogue-content">
                <p>Проект "СинЭстеМика" представляет собой экспериментальное исследование взаимосвязей между эмоциональными состояниями и математическими структурами. Он приглашает к интроспективному путешествию по неизведанной территории, где субъективный опыт встречается с объективными паттернами.</p>
                <p>В этом пространстве синестезии каждая эмоция имеет свою математическую форму, а каждая формула – свой эмоциональный оттенок. Через исследование этих взаимосвязей открывается новое измерение понимания как человеческого опыта, так и абстрактных структур.</p>
                <p>Благодарим вас за участие в этом эксперименте. Продолжайте исследовать пространство СинЭстеМики, создавая свои уникальные паттерны восприятия и расширяя границы познания.</p>
            </div>
        </div>
    </div>
    <script>
    
        // Функция для отрисовки математических визуализаций
        function drawMathCanvas() {
            const mathCanvases = document.querySelectorAll('.math-canvas');
            
            mathCanvases.forEach(canvas => {
                const ctx = canvas.getContext('2d');
                const mathType = canvas.closest('.math-container').dataset.math;
                const complexity = parseFloat(canvas.closest('.math-container').dataset.complexity);
                
                // Очистка холста
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Настройки для отрисовки
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                
                switch(mathType) {
                    case 'exponential':
                        drawExponential(ctx, canvas.width, canvas.height, complexity);
                        break;
                    case 'logarithmic':
                        drawLogarithmic(ctx, canvas.width, canvas.height, complexity);
                        break;
                    case 'fractal':
                        drawFractal(ctx, canvas.width, canvas.height, complexity);
                        break;
                    case 'trigonometric':
                        drawTrigonometric(ctx, canvas.width, canvas.height, complexity);
                        break;
                    case 'complex':
                        drawComplex(ctx, canvas.width, canvas.height, complexity);
                        break;
                }
            });
        }
        
        // Функции отрисовки для различных математических структур
        function drawExponential(ctx, width, height, complexity) {
            ctx.beginPath();
            
            const scale = 30 * complexity;
            
            for (let x = 0; x < width; x += 1) {
                const normalizedX = (x / width) * 4 - 2;
                const y = height - (Math.exp(normalizedX * complexity) * scale);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
        }
        
        function drawLogarithmic(ctx, width, height, complexity) {
            ctx.beginPath();
            
            const scale = 30 * complexity;
            
            for (let x = width / 4; x < width; x += 1) {
                const normalizedX = (x / width) * 10;
                const y = height - (Math.log(normalizedX) * scale);
                
                if (x === width / 4) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
        }
        
        function drawTrigonometric(ctx, width, height, complexity) {
            ctx.beginPath();
            
            const amplitude = height / 3 * complexity;
            const frequency = 0.05 * (1 + complexity * 2);
            
            for (let x = 0; x < width; x += 1) {
                const y = height / 2 + Math.sin(x * frequency) * amplitude;
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
        }
        
        function drawFractal(ctx, width, height, complexity) {
            // Упрощенная визуализация фрактала
            const maxIterations = 50 * complexity;
            const zoom = 150 * complexity;
            
            for (let x = 0; x < width; x += 4) {
                for (let y = 0; y < height; y += 4) {
                    const a = (x - width / 2) / zoom;
                    const b = (y - height / 2) / zoom;
                    
                    let ca = a;
                    let cb = b;
                    
                    let iterations = 0;
                    let z = 0;
                    
                    while (iterations < maxIterations) {
                        const aa = a * a - b * b;
                        const bb = 2 * a * b;
                        
                        a = aa + ca;
                        b = bb + cb;
                        
                        if (a * a + b * b > 4) {
                            break;
                        }
                        
                        iterations++;
                    }
                    
                    if (iterations < maxIterations) {
                        const hue = (iterations / maxIterations) * 360;
                        ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.5)`;
                        ctx.fillRect(x, y, 4, 4);
                    }
                }
            }
        }
        
        function drawComplex(ctx, width, height, complexity) {
            // Визуализация комплексной плоскости
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2.5;
            
            // Рисуем ось
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
            
            // Рисуем окружность единичного круга
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Рисуем несколько точек на комплексной плоскости
            const points = [];
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2 * complexity;
                const r = radius * Math.random() * complexity;
                points.push({
                    x: centerX + Math.cos(angle) * r,
                    y: centerY + Math.sin(angle) * r
                });
            }
            
            // Соединяем точки
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.stroke();
            
            // Рисуем точки
            ctx.fillStyle = 'white';
            points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Обработчики для слайдеров интенсивности эмоций
        function setupEmotionSliders() {
            const emotionSliders = document.querySelectorAll('.emotion-container .intensity-input');
            
            emotionSliders.forEach(slider => {
                slider.addEventListener('input', function() {
                    const container = this.closest('.emotion-container');
                    const value = this.value;
                    const displayValue = Math.round(value * 100);
                    
                    // Обновляем атрибут и отображаемое значение
                    container.dataset.intensity = value;
                    this.nextElementSibling.querySelector('span').textContent = `${displayValue}%`;
                    
                    // Обновляем визуальное отображение эмоции
                    updateEmotionVisualization(container, value);
                });
            });
        }
        
        // Обработчики для слайдеров сложности математических структур
        function setupMathSliders() {
            const mathSliders = document.querySelectorAll('.math-container .complexity-input');
            
            mathSliders.forEach(slider => {
                slider.addEventListener('input', function() {
                    const container = this.closest('.math-container');
                    const value = this.value;
                    const displayValue = Math.round(value * 100);
                    
                    // Обновляем атрибут и отображаемое значение
                    container.dataset.complexity = value;
                    this.nextElementSibling.querySelector('span').textContent = `${displayValue}%`;
                    
                    // Перерисовываем математические визуализации
                    drawMathCanvas();
                });
            });
        }
        
        // Функция для обновления визуального отображения эмоций
        function updateEmotionVisualization(container, intensity) {
            const emotion = container.dataset.emotion;
            const colorIntensity = 0.3 + (intensity * 0.7); // От 30% до 100%
            
            switch(emotion) {
                case 'joy':
                    container.style.boxShadow = `0 0 ${15 * intensity}px ${10 * intensity}px rgba(255, 215, 0, ${colorIntensity * 0.3})`;
                    break;
                case 'sadness':
                    container.style.boxShadow = `0 0 ${15 * intensity}px ${10 * intensity}px rgba(70, 130, 180, ${colorIntensity * 0.3})`;
                    break;
                case 'fear':
                    container.style.boxShadow = `0 0 ${15 * intensity}px ${10 * intensity}px rgba(128, 0, 128, ${colorIntensity * 0.3})`;
                    break;
                case 'anger':
                    container.style.boxShadow = `0 0 ${15 * intensity}px ${10 * intensity}px rgba(255, 69, 0, ${colorIntensity * 0.3})`;
                    break;
                case 'surprise':
                    container.style.boxShadow = `0 0 ${15 * intensity}px ${10 * intensity}px rgba(255, 105, 180, ${colorIntensity * 0.3})`;
                    break;
            }
            
            // Пульсация для более интенсивных эмоций
            if (intensity > 0.7) {
                container.style.animation = `pulse ${3 - intensity * 2}s infinite`;
            } else {
                container.style.animation = 'none';
            }
        }
        
        // Настройка перетаскивания элементов (drag and drop)
        function setupDragAndDrop() {
            const emotionContainers = document.querySelectorAll('.emotion-container');
            const mathContainers = document.querySelectorAll('.math-container');
            const emotionDropzone = document.querySelector('.dropzone-emotion');
            const mathDropzone = document.querySelector('.dropzone-math');
            
            // Для эмоций
            emotionContainers.forEach(container => {
                container.setAttribute('draggable', true);
                
                container.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                        type: 'emotion',
                        emotion: this.dataset.emotion,
                        intensity: this.dataset.intensity
                    }));
                    this.style.opacity = '0.5';
                });
                
                container.addEventListener('dragend', function() {
                    this.style.opacity = '1';
                });
            });
            
            // Для математических структур
            mathContainers.forEach(container => {
                container.setAttribute('draggable', true);
                
                container.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                        type: 'math',
                        math: this.dataset.math,
                        complexity: this.dataset.complexity
                    }));
                    this.style.opacity = '0.5';
                });
                
                container.addEventListener('dragend', function() {
                    this.style.opacity = '1';
                });
            });
            
            // Настройка для зоны сброса эмоций
            emotionDropzone.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.classList.add('dragover');
            });
            
            emotionDropzone.addEventListener('dragleave', function() {
                this.classList.remove('dragover');
            });
            
            emotionDropzone.addEventListener('drop', function(e) {
                e.preventDefault();
                this.classList.remove('dragover');
                
                const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                
                if (data.type === 'emotion') {
                    this.innerHTML = `
                        <div class="dropped-emotion" data-emotion="${data.emotion}" data-intensity="${data.intensity}">
                            <div class="emotion-title">${getEmotionName(data.emotion)}</div>
                            <div class="emotion-description">Интенсивность: ${Math.round(data.intensity * 100)}%</div>
                        </div>
                    `;
                    
                    updateSynthesisResult();
                }
            });
            
            // Настройка для зоны сброса математических структур
            mathDropzone.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.classList.add('dragover');
            });
            
            mathDropzone.addEventListener('dragleave', function() {
                this.classList.remove('dragover');
            });
            
            mathDropzone.addEventListener('drop', function(e) {
                e.preventDefault();
                this.classList.remove('dragover');
                
                const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                
                if (data.type === 'math') {
                    this.innerHTML = `
                        <div class="dropped-math" data-math="${data.math}" data-complexity="${data.complexity}">
                            <div class="math-title">${getMathName(data.math)}</div>
                            <div class="math-description">Сложность: ${Math.round(data.complexity * 100)}%</div>
                        </div>
                    `;
                    
                    updateSynthesisResult();
                }
            });
        }
        
        // Функция для получения названия эмоции по ключу
        function getEmotionName(emotion) {
            const emotions = {
                'joy': 'Радость',
                'sadness': 'Грусть',
                'fear': 'Страх',
                'anger': 'Гнев',
                'surprise': 'Удивление'
            };
            
            return emotions[emotion] || 'Неизвестная эмоция';
        }
        
        // Функция для получения названия математической структуры по ключу
        function getMathName(math) {
            const mathTypes = {
                'exponential': 'Экспоненциальные функции',
                'logarithmic': 'Логарифмические функции',
                'fractal': 'Фрактальные структуры',
                'trigonometric': 'Тригонометрические волны',
                'complex': 'Комплексные числа'
            };
            
            return mathTypes[math] || 'Неизвестная математическая структура';
        }
        
        // Функция для обновления результата синтеза
        function updateSynthesisResult() {
            const droppedEmotion = document.querySelector('.dropped-emotion');
            const droppedMath = document.querySelector('.dropped-math');
            const synthesisResult = document.querySelector('.synthesis-result');
            
            if (droppedEmotion && droppedMath) {
                const emotion = droppedEmotion.dataset.emotion;
                const emotionIntensity = parseFloat(droppedEmotion.dataset.intensity);
                const math = droppedMath.dataset.math;
                const mathComplexity = parseFloat(droppedMath.dataset.complexity);
                
                // Генерируем описание синтеза
                synthesisResult.innerHTML = generateSynthesisResult(emotion, emotionIntensity, math, mathComplexity);
            }
        }
        
        // Функция для генерации результата синтеза
        function generateSynthesisResult(emotion, emotionIntensity, math, mathComplexity) {
            // Получаем цвета для эмоций и математики
            const emotionColors = {
                'joy': '#FFD700',
                'sadness': '#4682B4',
                'fear': '#800080',
                'anger': '#FF4500',
                'surprise': '#FF69B4'
            };
            
            const mathColors = {
                'exponential': '#E6F2FF',
                'logarithmic': '#F2E6FF',
                'fractal': '#E6FFE6',
                'trigonometric': '#FFE6E6',
                'complex': '#FFF2E6'
            };
            
            // Создаем canvas для визуализации
            const resultHTML = `
                <div class="synthesis-visualization">
                    <h4 style="color: ${emotionColors[emotion]}; opacity: ${emotionIntensity + 0.5};">
                        ${getEmotionName(emotion)} × ${getMathName(math)}
                    </h4>
                    <div class="synthesis-description" style="font-size: 1.1rem; margin: 1rem 0;">
                        ${generateSynthesisDescription(emotion, emotionIntensity, math, mathComplexity)}
                    </div>
                    <canvas id="synthesis-canvas" width="400" height="300"></canvas>
                    <div class="synthesis-equation" style="margin-top: 1rem; font-size: 1.2rem; font-family: 'EmotionalMath', serif;">
                        ${generateSynthesisEquation(emotion, math)}
                    </div>
                </div>
            `;
            
            setTimeout(() => {
                const canvas = document.getElementById('synthesis-canvas');
                if (canvas) {
                    drawSynthesisVisualization(canvas, emotion, emotionIntensity, math, mathComplexity);
                }
            }, 100);
            
            return resultHTML;
        }
        
        // Функция для генерации описания синтеза
        function generateSynthesisDescription(emotion, emotionIntensity, math, mathComplexity) {
            const descriptions = {
                'joy-exponential': 'Радость, усиленная экспоненциальным ростом, создает ощущение безграничного воодушевления, которое усиливается с каждым моментом. Эйфория следует по кривой e^x, устремляясь в бесконечность.',
                'joy-logarithmic': 'Спокойная и уравновешенная радость, которая раскрывается неспешно, достигая глубоких уровней удовлетворения. Эйфория нарастает медленно, но стабильно, как логарифмическая функция.',
                'joy-fractal': 'Калейдоскопическая радость, которая раскрывается на множестве уровней сознания. Каждое погружение внутрь раскрывает новые, самоподобные паттерны эйфории.',
                'joy-trigonometric': 'Ритмичная, пульсирующая радость, которая движется волнами, создавая гармоничные колебания между умиротворением и восторгом. Эмоциональные волны следуют синусоидальным паттернам.',
                'joy-complex': 'Многомерная, фазовая радость, существующая одновременно в нескольких эмоциональных плоскостях. Эйфория приобретает дополнительные измерения, развертываясь в комплексном пространстве чувств.',
                
                'sadness-exponential': 'Глубокая меланхолия, которая нарастает экспоненциально, погружая в бездонные глубины созерцательной грусти. Траектория чувства следует кривой стремительного погружения.',
                'sadness-logarithmic': 'Умиротворенная грусть, которая постепенно затихает, оставляя после себя лишь эхо прошедших переживаний. Интенсивность эмоции затухает по логарифмической кривой.',
                'sadness-fractal': 'Самоподобная, рекурсивная грусть, раскрывающая бесконечную глубину на каждом уровне осознания. Меланхолия образует сложные, самоповторяющиеся структуры внутри психического пространства.',
                'sadness-trigonometric': 'Циклическая, волнообразная грусть, которая периодически усиливается и затихает, создавая ритмический танец меланхолии и смирения. Эмоциональный ландшафт напоминает мягкие волны прилива.',
                'sadness-complex': 'Многослойная, многомерная меланхолия, существующая одновременно в нескольких эмоциональных состояниях. Грусть обретает глубину и текстуру, разворачиваясь в комплексной плоскости чувств.',
                
                'fear-exponential': 'Паника, нарастающая с сокрушительной скоростью, захватывающая все уровни сознания. Страх следует по кривой экспоненциального роста, устремляясь к предельной интенсивности.',
                'fear-logarithmic': 'Постепенно затухающая тревога, которая медленно растворяется, оставляя после себя легкое напряжение и осторожность. Интенсивность затухает по логарифмической кривой.',
                'fear-fractal': 'Самовоспроизводящийся, рекурсивный страх, создающий сложные паттерны беспокойства. Каждый слой опасения раскрывает новые, самоподобные структуры тревоги.',
                'fear-trigonometric': 'Волнообразная тревога, которая пульсирует с предсказуемой периодичностью, создавая ритмические колебания между напряжением и облегчением. Психоэмоциональное состояние следует синусоидальной волне.',
                'fear-complex': 'Многомерный страх, существующий в нескольких плоскостях сознания одновременно. Тревога приобретает дополнительные измерения, разворачиваясь в комплексном пространстве психики.',
                
                'anger-exponential': 'Ярость, нарастающая с разрушительной скоростью, захватывающая все уровни сознания. Гнев следует по кривой экспоненциального роста, устремляясь к предельной интенсивности.',
                'anger-logarithmic': 'Постепенно затухающее раздражение, которое медленно растворяется, оставляя после себя легкое напряжение и осадок. Интенсивность снижается по логарифмической кривой.',
                'anger-fractal': 'Самовоспроизводящийся, рекурсивный гнев, создающий сложные паттерны раздражения. Каждый слой негодования раскрывает новые, самоподобные структуры возмущения.',
                'anger-trigonometric': 'Волнообразное раздражение, которое пульсирует с предсказуемой периодичностью, создавая ритмические колебания между спокойствием и вспышками гнева. Эмоциональное состояние следует синусоидальной волне.',
                'anger-complex': 'Многомерный гнев, существующий в нескольких плоскостях сознания одновременно. Раздражение приобретает дополнительные измерения, разворачиваясь в комплексном пространстве психики.',
                
                'surprise-exponential': 'Изумление, нарастающее с головокружительной скоростью, захватывающее все уровни восприятия. Удивление следует по кривой экспоненциального роста, расширяясь за пределы ожидаемого.',
                'surprise-logarithmic': 'Постепенно затухающее удивление, которое медленно растворяется, оставляя после себя легкое любопытство и восхищение. Интенсивность снижается по логарифмической кривой.',
                'surprise-fractal': 'Самовоспроизводящееся, рекурсивное изумление, создающее сложные паттерны удивления. Каждый слой восхищения раскрывает новые, самоподобные структуры неожиданности.',
                'surprise-trigonometric': 'Волнообразное удивление, которое пульсирует с предсказуемой периодичностью, создавая ритмические колебания между спокойствием и вспышками изумления. Эмоциональное состояние следует синусоидальной волне.',
                'surprise-complex': 'Многомерное удивление, существующее в нескольких плоскостях сознания одновременно. Изумление приобретает дополнительные измерения, разворачиваясь в комплексном пространстве психики.'
            };
            
            // Модифицируем описание в зависимости от интенсивности и сложности
            let description = descriptions[`${emotion}-${math}`] || 'Уникальная комбинация эмоционального состояния и математической структуры создает необычный психоэмоциональный паттерн.';
            
            // Усиливаем описание в зависимости от интенсивности эмоции
            if (emotionIntensity > 0.8) {
                description = `<strong>Чрезвычайно интенсивное переживание!</strong> ${description}`;
            } else if (emotionIntensity < 0.3) {
                description = `<em>Тонкий, едва уловимый оттенок чувства.</em> ${description}`;
            }
            
            // Добавляем сложность математической структуры
            if (mathComplexity > 0.8) {
                description += ` Структура отличается исключительной математической сложностью, создавая многомерные эмоциональные резонансы.`;
            } else if (mathComplexity < 0.3) {
                description += ` Математическая простота создает ясность и чистоту переживания.`;
            }
            
            return description;
        }
        
        // Функция для генерации уравнения синтеза
        function generateSynthesisEquation(emotion, math) {
            const equations = {
                'joy-exponential': 'E(joy) = A·e^(k·t) · ψ, где k > 0',
                'joy-logarithmic': 'E(joy) = A·ln(t + 1) · ψ',
                'joy-fractal': 'E(joy) = ψ^(n+1) = ψ^n² + c',
                'joy-trigonometric': 'E(joy) = A·sin(ωt + φ) · ψ',
                'joy-complex': 'E(joy) = (Re(z) + i·Im(z)) · ψ',
                
                'sadness-exponential': 'E(sadness) = A·e^(-k·t) · ψ, где k > 0',
                'sadness-logarithmic': 'E(sadness) = A·ln(1/t + ε) · ψ',
                'sadness-fractal': 'E(sadness) = ψ^(n+1) = 1/(ψ^n² + c)',
                'sadness-trigonometric': 'E(sadness) = -A·cos(ωt + φ) · ψ',
                'sadness-complex': 'E(sadness) = (Re(z) - i·Im(z)) · ψ',
                
                'fear-exponential': 'E(fear) = A·(1 - e^(-k·t)) · ψ, где k > 0',
                'fear-logarithmic': 'E(fear) = A·ln(t/(t+1)) · ψ',
                'fear-fractal': 'E(fear) = ψ^(n+1) = |ψ^n² - c|',
                'fear-trigonometric': 'E(fear) = A·sin²(ωt + φ) · ψ',
                'fear-complex': 'E(fear) = |z|·e^(i·arg(z)) · ψ',
                
                'anger-exponential': 'E(anger) = A·(e^(k·t) - 1) · ψ, где k > 0',
                'anger-logarithmic': 'E(anger) = A·ln(t + e) · ψ',
                'anger-fractal': 'E(anger) = ψ^(n+1) = |ψ^n|² + c',
                'anger-trigonometric': 'E(anger) = A·tan(ωt + φ) · ψ',
                'anger-complex': 'E(anger) = z² · ψ',
                
                'surprise-exponential': 'E(surprise) = A·e^(-k·t²) · ψ, где k > 0',
                'surprise-logarithmic': 'E(surprise) = A·ln(t² + 1) · ψ',
                'surprise-fractal': 'E(surprise) = ψ^(n+1) = ψ^n · (1 - ψ^n) + c',
                'surprise-trigonometric': 'E(surprise) = A·sin(ωt² + φ) · ψ',
                'surprise-complex': 'E(surprise) = e^z · ψ'
            };
            
            return equations[`${emotion}-${math}`] || 'E = ψ(emotion) · Φ(math)';
        }
        
        // Функция для отрисовки визуализации синтеза
        function drawSynthesisVisualization(canvas, emotion, emotionIntensity, math, mathComplexity) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Получаем цвета для эмоций
            const emotionColors = {
                'joy': '#FFD700',
                'sadness': '#4682B4',
                'fear': '#800080',
                'anger': '#FF4500',
                'surprise': '#FF69B4'
            };
            
            const color = emotionColors[emotion] || '#FFFFFF';
            
            // Визуализация в зависимости от типа математической структуры
            switch(math) {
                case 'exponential':
                    drawSynthesisExponential(ctx, canvas.width, canvas.height, color, emotionIntensity, mathComplexity);
                    break;
                case 'logarithmic':
                    drawSynthesisLogarithmic(ctx, canvas.width, canvas.height, color, emotionIntensity, mathComplexity);
                    break;
                case 'fractal':
                    drawSynthesisFractal(ctx, canvas.width, canvas.height, color, emotionIntensity, mathComplexity);
                    break;
                case 'trigonometric':
                    drawSynthesisTrigonometric(ctx, canvas.width, canvas.height, color, emotionIntensity, mathComplexity);
                    break;
                case 'complex':
                    drawSynthesisComplex(ctx, canvas.width, canvas.height, color, emotionIntensity, mathComplexity);
                    break;
            }
        }
        
        // Функции для отрисовки различных типов синтеза
        function drawSynthesisExponential(ctx, width, height, color, intensity, complexity) {
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, `rgba(10, 10, 10, 0.9)`);
            gradient.addColorStop(1, `rgba(${hexToRgb(color)}, ${intensity * 0.5})`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            ctx.lineWidth = 2 + intensity * 3;
            ctx.strokeStyle = color;
            
            // Рисуем базовую экспоненциальную функцию
            ctx.beginPath();
            
            const scale = 30 * complexity * (1 + intensity);
            
            for (let x = 0; x < width; x += 1) {
                const normalizedX = (x / width) * 4 - 2;
                const y = height - (Math.exp(normalizedX * intensity) * scale);
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Добавляем частицы, следующие по экспоненциальной кривой
            ctx.fillStyle = color;
            
            for (let i = 0; i < 50 * intensity; i++) {
                const x = Math.random() * width;
                const normalizedX = (x / width) * 4 - 2;
                const baseY = height - (Math.exp(normalizedX * intensity) * scale);
                const variance = (Math.random() - 0.5) * 50 * complexity;
                const y = baseY + variance;
                
                const size = (Math.random() * 3 + 1) * intensity;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawSynthesisLogarithmic(ctx, width, height, color, intensity, complexity) {
            const gradient = ctx.createLinearGradient(width, 0, 0, height);
            gradient.addColorStop(0, `rgba(10, 10, 10, 0.9)`);
            gradient.addColorStop(1, `rgba(${hexToRgb(color)}, ${intensity * 0.5})`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            ctx.lineWidth = 2 + intensity * 3;
            ctx.strokeStyle = color;
            
            // Рисуем базовую логарифмическую функцию
            ctx.beginPath();
            
            const scale = 40 * complexity * (1 + intensity);
            
            for (let x = width / 8; x < width; x += 1) {
                const normalizedX = (x / width) * 10;
                const y = height - (Math.log(normalizedX) * scale);
                
                if (x === width / 8) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Добавляем частицы, распределенные вокруг логарифмической кривой
            ctx.fillStyle = color;
            
            for (let i = 0; i < 40 * intensity; i++) {
                const x = (Math.random() * 0.9 + 0.1) * width;
                const normalizedX = (x / width) * 10;
                const baseY = height - (Math.log(normalizedX) * scale);
                const variance = (Math.random() - 0.5) * 60 * complexity;
                const y = baseY + variance;
                
                const size = (Math.random() * 3 + 1) * intensity;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Добавляем след
                const trailLength = Math.floor(Math.random() * 5) + 3;
                const trailDirection = Math.random() > 0.5 ? 1 : -1;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                
                for (let j = 1; j <= trailLength; j++) {
                    const trailX = x - j * trailDirection * 3;
                    const trailY = y + (Math.random() - 0.5) * 10;
                    ctx.lineTo(trailX, trailY);
                }
                
                ctx.strokeStyle = `rgba(${hexToRgb(color)}, ${intensity * 0.3})`;
                ctx.lineWidth = size / 2;
                ctx.stroke();
            }
        }
        
        function drawSynthesisFractal(ctx, width, height, color, intensity, complexity) {
            // Создаем градиентный фон
            const gradient = ctx.createRadialGradient(width/2, height/2, 10, width/2, height/2, width/2);
            gradient.addColorStop(0, `rgba(${hexToRgb(color)}, ${intensity * 0.7})`);
            gradient.addColorStop(1, 'rgba(10, 10, 10, 0.9)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Рисуем фрактальную структуру (упрощенное множество Мандельброта)
            const maxIterations = Math.floor(30 * complexity * (1 + intensity));
            const zoom = 200 * complexity;
            const offsetX = width / 2;
            const offsetY = height / 2;
            
            for (let x = 0; x < width; x += 4) {
                for (let y = 0; y < height; y += 4) {
                    const a = (x - offsetX) / zoom;
                    const b = (y - offsetY) / zoom;
                    
                    let ca = a;
                    let cb = b;
                    
                    let iterations = 0;
                    
                    while (iterations < maxIterations) {
                        const aa = a * a - b * b;
                        const bb = 2 * a * b;
                        
                        a = aa + ca;
                        b = bb + cb;
                        
                        if (a * a + b * b > 4) {
                            break;
                        }
                        
                        iterations++;
                    }
                    
                    if (iterations < maxIterations) {
                        const hue = (iterations / maxIterations) * 360;
                        const normalizedColor = colorToHsl(color);
                        
                        // Смешиваем цвет эмоции с фрактальным цветом
                        const finalHue = normalizedColor.h * intensity + hue * (1 - intensity);
                        
                        ctx.fillStyle = `hsla(${finalHue}, ${normalizedColor.s}%, ${normalizedColor.l}%, ${iterations / maxIterations * intensity})`;
                        ctx.fillRect(x, y, 4, 4);
                    }
                }
            }
            
            // Добавляем декоративные элементы
            const particleCount = Math.floor(50 * intensity);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * width / 3;
                
                const x = offsetX + Math.cos(angle) * distance;
                const y = offsetY + Math.sin(angle) * distance;
                
                const size = (Math.random() * 4 + 1) * intensity;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                
                // Добавляем лучи
                if (Math.random() < 0.3) {
                    const rayLength = Math.random() * 30 + 10;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(angle) * rayLength, y + Math.sin(angle) * rayLength);
                    ctx.strokeStyle = `rgba(${hexToRgb(color)}, ${intensity * 0.7})`;
                    ctx.lineWidth = size / 2;
                    ctx.stroke();
                }
            }
        }
        
        function drawSynthesisTrigonometric(ctx, width, height, color, intensity, complexity) {
            // Создаем градиентный фон
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, 'rgba(10, 10, 10, 0.9)');
            gradient.addColorStop(0.5, `rgba(${hexToRgb(color)}, ${intensity * 0.3})`);
            gradient.addColorStop(1, 'rgba(10, 10, 10, 0.9)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Рисуем несколько синусоидальных волн с разными частотами и амплитудами
            const waves = 3;
            
            for (let w = 0; w < waves; w++) {
                const amplitude = (height / 4) * (1 - w * 0.2) * intensity;
                const frequency = (0.01 + w * 0.01) * complexity;
                const phase = w * Math.PI / 4;
                
                ctx.beginPath();
                
                for (let x = 0; x < width; x += 1) {
                    const y = height / 2 + Math.sin(x * frequency + phase) * amplitude;
                    
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.strokeStyle = `rgba(${hexToRgb(color)}, ${(1 - w * 0.2) * intensity})`;
                ctx.lineWidth = 2 + (waves - w) * intensity;
                ctx.stroke();
            }
            
            // Добавляем частицы, следующие по синусоидальным траекториям
            const particleCount = Math.floor(60 * intensity);
            
            for (let i = 0; i < particleCount; i++) {
                const waveIdx = i % waves;
                const amplitude = (height / 4) * (1 - waveIdx * 0.2) * intensity;
                const frequency = (0.01 + waveIdx * 0.01) * complexity;
                const phase = waveIdx * Math.PI / 4 + i * 0.1;
                
                const x = Math.random() * width;
                const y = height / 2 + Math.sin(x * frequency + phase) * amplitude;
                
                const size = (Math.random() * 3 + 1) * intensity;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${hexToRgb(color)}, ${0.7 * intensity})`;
                ctx.fill();
                
                // Добавляем след
                if (i % 3 === 0) {
                    const trailLength = Math.floor(Math.random() * 10) + 5;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    
                    for (let j = 1; j <= trailLength; j++) {
                        const trailX = x - j * 5;
                        const trailY = height / 2 + Math.sin(trailX * frequency + phase) * amplitude;
                        ctx.lineTo(trailX, trailY);
                    }
                    
                    ctx.strokeStyle = `rgba(${hexToRgb(color)}, ${0.2 * intensity})`;
                    ctx.lineWidth = size / 2;
                    ctx.stroke();
                }
            }
        }
        
        function drawSynthesisComplex(ctx, width, height, color, intensity, complexity) {
            // Создаем градиентный фон
            const gradient = ctx.createRadialGradient(width/2, height/2, 10, width/2, height/2, width);
            gradient.addColorStop(0, `rgba(${hexToRgb(color)}, ${intensity * 0.6})`);
            gradient.addColorStop(0.7, `rgba(${hexToRgb(color)}, ${intensity * 0.1})`);
            gradient.addColorStop(1, 'rgba(10, 10, 10, 0.9)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Рисуем оси комплексной плоскости
            const centerX = width / 2;
            const centerY = height / 2;
            
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.2 * intensity})`;
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
            
            // Рисуем единичную окружность
            const radius = Math.min(width, height) / 3;
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(${hexToRgb(color)}, ${0.3 * intensity})`;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Генерируем и рисуем точки на комплексной плоскости
            const pointCount = Math.floor(20 + 40 * complexity * intensity);
            const points = [];
            
            for (let i = 0; i < pointCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.pow(Math.random(), 0.5) * radius * 1.5;
                
                points.push({
                    x: centerX + Math.cos(angle) * dist,
                    y: centerY + Math.sin(angle) * dist,
                    angle: angle,
                    dist: dist,
                    size: Math.random() * 4 * intensity + 2
                });
            }
            
            // Рисуем соединения между точками (комплексные пути)
            ctx.lineWidth = 1;
            
            for (let i = 0; i < pointCount; i++) {
                for (let j = i + 1; j < pointCount; j++) {
                    const distance = Math.sqrt(
                        Math.pow(points[i].x - points[j].x, 2) + 
                        Math.pow(points[i].y - points[j].y, 2)
                    );
                    
                    // Соединяем только близкие точки
                    if (distance < radius * 0.8) {
                        const opacity = (1 - distance / (radius * 0.8)) * 0.5 * intensity;
                        
                        ctx.beginPath();
                        ctx.moveTo(points[i].x, points[i].y);
                        ctx.lineTo(points[j].x, points[j].y);
                        ctx.strokeStyle = `rgba(${hexToRgb(color)}, ${opacity})`;
                        ctx.stroke();
                    }
                }
            }
            
            // Рисуем точки
            for (let i = 0; i < pointCount; i++) {
                const point = points[i];
                
                ctx.beginPath();
                ctx.arc(point.x, point.y, point.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${hexToRgb(color)}, ${0.8 * intensity})`;
                ctx.fill();
                
                // Добавляем комплексные орбиты для некоторых точек
                if (Math.random() < 0.3 * complexity) {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, point.dist * 0.4, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(${hexToRgb(color)}, ${0.2 * intensity})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
            
            // Добавляем трансформации комплексных функций
            if (complexity > 0.5) {
                // Рисуем фазовые линии
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                    const x1 = centerX;
                    const y1 = centerY;
                    const x2 = centerX + Math.cos(angle) * width;
                    const y2 = centerY + Math.sin(angle) * height;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = `rgba(${hexToRgb(color)}, ${0.05 * intensity})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }
        
        // Вспомогательная функция для преобразования HEX-цвета в RGB
        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            return `${r}, ${g}, ${b}`;
        }
        
        // Вспомогательная функция для преобразования цвета в HSL
        function colorToHsl(hex) {
            hex = hex.replace('#', '');
            
            const r = parseInt(hex.substring(0, 2), 16) / 255;
            const g = parseInt(hex.substring(2, 4), 16) / 255;
            const b = parseInt(hex.substring(4, 6), 16) / 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // ахроматический
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            return {
                h: Math.round(h * 360),
                s: Math.round(s * 100),
                l: Math.round(l * 100)
            };
        }
        
        // Основной объект синтезатора
        class EmotionalMathSynthesizer {
            constructor() {
                // Инициализация canvas
                this.canvas = document.getElementById('synthesizer-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                
                // Состояние синтезатора
                this.state = {
                    emotions: {
                        joy: 0.5,
                        sadness: 0.2,
                        fear: 0.1,
                        anger: 0.1,
                        surprise: 0.3
                    },
                    math: {
                        exponential: 0.4,
                        logarithmic: 0.3,
                        fractal: 0.6,
                        trigonometric: 0.5,
                        complex: 0.3
                    },
                    meta: {
                        chaos: 0.3,
                        synchronicity: 0.7,
                        dimensionality: 0.5,
                        temporality: 0.4
                    },
                    isActive: false,
                    animationFrame: null,
                    particles: [],
                    time: 0
                };
                
                // Цвета эмоций
                this.emotionColors = {
                    joy: '#FFD700',
                    sadness: '#4682B4',
                    fear: '#800080',
                    anger: '#FF4500',
                    surprise: '#FF69B4'
                };
                
                // Инициализация обработчиков событий
                this.initEventListeners();
                
                // Первоначальная отрисовка
                this.drawInitialState();
            }
            
            // Метод для изменения размеров canvas
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = 400;
            }
            
            // Инициализация всех обработчиков событий
            initEventListeners() {
                // Обработчики для слайдеров эмоций
                document.querySelectorAll('.emotion-input').forEach(slider => {
                    slider.addEventListener('input', this.handleEmotionChange.bind(this));
                });
                
                // Обработчики для слайдеров математических структур
                document.querySelectorAll('.math-input').forEach(slider => {
                    slider.addEventListener('input', this.handleMathChange.bind(this));
                });
                
                // Обработчики для метапараметров
                document.querySelectorAll('.meta-input').forEach(slider => {
                    slider.addEventListener('input', this.handleMetaChange.bind(this));
                });
                
                // Обработчики для кнопок
                document.getElementById('generate-button').addEventListener('click', this.generate.bind(this));
                document.getElementById('reset-button').addEventListener('click', this.reset.bind(this));
                document.getElementById('random-button').addEventListener('click', this.randomize.bind(this));
                
                // Обработчик изменения размера окна
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    this.drawInitialState();
                });
            }
            
            // Обработчик изменения значений слайдеров эмоций
            handleEmotionChange(event) {
                const emotion = event.target.dataset.emotion;
                const value = parseFloat(event.target.value);
                
                this.state.emotions[emotion] = value;
                
                // Обновляем отображение значения
                event.target.nextElementSibling.textContent = `${Math.round(value * 100)}%`;
                
                // Обновляем цвет слайдера
                const percentage = value * 100;
                event.target.style.background = `linear-gradient(to right, ${this.emotionColors[emotion]} 0%, ${this.emotionColors[emotion]} ${percentage}%, rgba(255, 255, 255, 0.2) ${percentage}%, rgba(255, 255, 255, 0.2) 100%)`;
            }
            
            // Обработчик изменения значений слайдеров математических структур
            handleMathChange(event) {
                const math = event.target.dataset.math;
                const value = parseFloat(event.target.value);
                
                this.state.math[math] = value;
                
                // Обновляем отображение значения
                event.target.nextElementSibling.textContent = `${Math.round(value * 100)}%`;
                
                // Обновляем цвет слайдера
                const percentage = value * 100;
                event.target.style.background = `linear-gradient(to right, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.8) ${percentage}%, rgba(255, 255, 255, 0.2) ${percentage}%, rgba(255, 255, 255, 0.2) 100%)`;
            }
            
            // Обработчик изменения значений метапараметров
            handleMetaChange(event) {
                const param = event.target.dataset.param;
                const value = parseFloat(event.target.value);
                
                this.state.meta[param] = value;
                
                // Обновляем отображение значения
                event.target.nextElementSibling.textContent = `${Math.round(value * 100)}%`;
                
                // Обновляем цвет слайдера
                const percentage = value * 100;
                event.target.style.background = `linear-gradient(to right, rgba(128, 128, 255, 0.8) 0%, rgba(128, 128, 255, 0.8) ${percentage}%, rgba(255, 255, 255, 0.2) ${percentage}%, rgba(255, 255, 255, 0.2) 100%)`;
            }
            
            // Метод для синтеза (генерации) эмоционально-математического состояния
            generate() {
                // Останавливаем текущую анимацию, если она запущена
                if (this.state.animationFrame) {
                    cancelAnimationFrame(this.state.animationFrame);
                }
                
                // Активируем синтезатор
                this.state.isActive = true;
                document.querySelector('.emotional-math-synthesizer').classList.add('synthesizer-active');
                
                // Генерируем уравнение
                this.generateEquation();
                
                // Генерируем описание состояния
                this.generateStateDescription();
                
                // Создаем частицы
                this.generateParticles();
                
                // Запускаем анимацию
                this.animate();
            }
            
            // Метод для сброса синтезатора в исходное состояние
            reset() {
                // Останавливаем анимацию
                if (this.state.animationFrame) {
                    cancelAnimationFrame(this.state.animationFrame);
                }
                
                // Сбрасываем состояние
                this.state.emotions = {
                    joy: 0.5,
                    sadness: 0.2,
                    fear: 0.1,
                    anger: 0.1,
                    surprise: 0.3
                };
                
                this.state.math = {
                    exponential: 0.4,
                    logarithmic: 0.3,
                    fractal: 0.6,
                    trigonometric: 0.5,
                    complex: 0.3
                };
                
                this.state.meta = {
                    chaos: 0.3,
                    synchronicity: 0.7,
                    dimensionality: 0.5,
                    temporality: 0.4
                };
                
                // Обновляем слайдеры
                document.querySelectorAll('.emotion-input').forEach(slider => {
                    const emotion = slider.dataset.emotion;
                    slider.value = this.state.emotions[emotion];
                    slider.nextElementSibling.textContent = `${Math.round(this.state.emotions[emotion] * 100)}%`;
                    
                    const percentage = this.state.emotions[emotion] * 100;
                    slider.style.background = `linear-gradient(to right, ${this.emotionColors[emotion]} 0%, ${this.emotionColors[emotion]} ${percentage}%, rgba(255, 255, 255, 0.2) ${percentage}%, rgba(255, 255, 255, 0.2) 100%)`;
                });
                
                document.querySelectorAll('.math-input').forEach(slider => {
                    const math = slider.dataset.math;
                    slider.value = this.state.math[math];
                    slider.nextElementSibling.textContent = `${Math.round(this.state.math[math] * 100)}%`;
                    
                    const percentage = this.state.math[math] * 100;
                    slider.style.background = `linear-gradient(to right, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.8) ${percentage}%, rgba(255, 255, 255, 0.2) ${percentage}%, rgba(255, 255, 255, 0.2) 100%)`;
                });
                
                document.querySelectorAll('.meta-input').forEach(slider => {
                    const param = slider.dataset.param;
                    slider.value = this.state.meta[param];
                    slider.nextElementSibling.textContent = `${Math.round(this.state.meta[param] * 100)}%`;
                    
                    const percentage = this.state.meta[param] * 100;
                    slider.style.background = `linear-gradient(to right, rgba(128, 128, 255, 0.8) 0%, rgba(128, 128, 255, 0.8) ${percentage}%, rgba(255, 255, 255, 0.2) ${percentage}%, rgba(255, 255, 255, 0.2) 100%)`;
                });
                
                // Деактивируем синтезатор
                this.state.isActive = false;
                document.querySelector('.emotional-math-synthesizer').classList.remove('synthesizer-active');
                
                // Сбрасываем уравнение и описание
                document.querySelector('.equation-content').textContent = 'φ(E) = Σ[E(i)·M(j)]·w(i,j)';
                document.querySelector('.state-description').innerHTML = '<p>Передвигайте ползунки и нажмите "Синтезировать", чтобы создать эмоционально-математическое состояние.</p>';
                
                // Отрисовываем начальное состояние
                this.drawInitialState();
            }
            
            // Метод для случайной генерации значений
            randomize() {
                // Генерируем случайные значения для всех параметров
                Object.keys(this.state.emotions).forEach(emotion => {
                    this.state.emotions[emotion] = Math.random();
                });
                
                Object.keys(this.state.math).forEach(math => {
                    this.state.math[math] = Math.random();
                });
                
                Object.keys(this.state.meta).forEach(param => {
                    this.state.meta[param] = Math.random();
                });
                
                // Обновляем слайдеры
                document.querySelectorAll('.emotion-input').forEach(slider => {
                    const emotion = slider.dataset.emotion;
                    slider.value = this.state.emotions[emotion];
                    slider.nextElementSibling.textContent = `${Math.round(this.state.emotions[emotion] * 100)}%`;
                    
                    const percentage = this.state.emotions[emotion] * 100;
                    slider.style.background = `linear-gradient(to right, ${this.emotionColors[emotion]} 0%, ${this.emotionColors[emotion]} ${percentage}%, rgba(255, 255, 255, 0.2) ${percentage}%, rgba(255, 255, 255, 0.2) 100%)`;
                });
                
                document.querySelectorAll('.math-input').forEach(slider => {
                    const math = slider.dataset.math;
                    slider.value = this.state.math[math];
                    slider.nextElementSibling.textContent = `${Math.round(this.state.math[math] * 100)}%`;
                    
                    const percentage = this.state.math[math] * 100;
                    slider.style.background = `linear-gradient(to right, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.8) ${percentage}%, rgba(255, 255, 255, 0.2) ${percentage}%, rgba(255, 255, 255, 0.2) 100%)`;
                });
                
                document.querySelectorAll('.meta-input').forEach(slider => {
                    const param = slider.dataset.param;
                    slider.value = this.state.meta[param];
                    slider.nextElementSibling.textContent = `${Math.round(this.state.meta[param] * 100)}%`;
                    
                    const percentage = this.state.meta[param] * 100;
                    slider.style.background = `linear-gradient(to right, rgba(128, 128, 255, 0.8) 0%, rgba(128, 128, 255, 0.8) ${percentage}%, rgba(255, 255, 255, 0.2) ${percentage}%, rgba(255, 255, 255, 0.2) 100%)`;
                });
            }
            
            // Вспомогательные методы
            
            // Получение доминирующего параметра из объекта параметров
            getDominantParameter(params) {
                let max = 0;
                let dominant = '';
                
                for (const param in params) {
                    if (params[param] > max) {
                        max = params[param];
                        dominant = param;
                    }
                }
                
                return dominant;
            }
            
            // Преобразование HEX-цвета в RGB
            hexToRgb(hex) {
                hex = hex.replace('#', '');
                
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                
                return `${r}, ${g}, ${b}`;
            }
            
            // Получение общей сложности математических структур
            getTotalMathComplexity() {
                let total = 0;
                
                for (const math in this.state.math) {
                    total += this.state.math[math];
                }
                
                return total / Object.keys(this.state.math).length;
            }
            
            // Получение случайного эмоционального параметра, взвешенного по значениям
            getRandomWeightedEmotion() {
                const emotions = Object.keys(this.state.emotions);
                const weights = Object.values(this.state.emotions);
                
                return this.getRandomWeightedChoice(emotions, weights);
            }
            
            // Получение случайного математического параметра, взвешенного по значениям
            getRandomWeightedMath() {
                const maths = Object.keys(this.state.math);
                const weights = Object.values(this.state.math);
                
                return this.getRandomWeightedChoice(maths, weights);
            }
            
            // Общий метод выбора случайного взвешенного элемента
            getRandomWeightedChoice(items, weights) {
                // Нормализуем веса
                const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                const normalizedWeights = weights.map(weight => weight / totalWeight);
                
                // Выбираем случайное значение
                const random = Math.random();
                let cumulativeWeight = 0;
                
                for (let i = 0; i < items.length; i++) {
                    cumulativeWeight += normalizedWeights[i];
                    
                    if (random < cumulativeWeight) {
                        return items[i];
                    }
                }
                
                // В случае ошибки округления возвращаем последний элемент
                return items[items.length - 1];
            }
            
            // Методы для генерации уравнения
            getEmotionSymbol(emotion) {
                const symbols = {
                    joy: 'J',
                    sadness: 'S',
                    fear: 'F',
                    anger: 'A',
                    surprise: 'U'
                };
                
                return symbols[emotion] || 'E';
            }
            
            getMathSymbol(math) {
                const symbols = {
                    exponential: 'exp',
                    logarithmic: 'ln',
                    fractal: 'Fr',
                    trigonometric: 'sin',
                    complex: 'ℂ'
                };
                
                return symbols[math] || 'M';
            }
            
            getMetaModifier() {
                const chaos = this.state.meta.chaos;
                const synchr = this.state.meta.synchronicity;
                
                if (chaos > 0.7) {
                    return `λ<sub>c</sub>(${chaos.toFixed(2)})`;
                } else if (synchr > 0.7) {
                    return `Ω<sub>s</sub>(${synchr.toFixed(2)})`;
                } else {
                    return 'τ';
                }
            }
            
            getChaosModifier() {
                return `χ<sup>${(this.state.meta.chaos * 3).toFixed(1)}</sup>`;
            }
            
            getDimensionalityModifier() {
                return `∇<sup>${Math.ceil(this.state.meta.dimensionality * 5)}</sup>`;
            }
            
            getSynchronicityModifier() {
                return `ω<sub>${Math.ceil(this.state.meta.synchronicity * 10)}</sub>`;
            }
            
            getTemporalityModifier() {
                return `∂t<sup>${(this.state.meta.temporality * 2).toFixed(1)}</sup>`;
            }
        }
        
        // Дополнительные методы для EmotionalMathSynthesizer
        // Эти методы добавляются к классу синтезатора, определенному в Части 3.2
        
        // Метод для генерации уравнения
        EmotionalMathSynthesizer.prototype.generateEquation = function() {
            // Получаем доминирующую эмоцию и математическую структуру
            const dominantEmotion = this.getDominantParameter(this.state.emotions);
            const dominantMath = this.getDominantParameter(this.state.math);
            
            // Генерируем различные шаблоны уравнений
            const equationTemplates = [
                `φ(${this.getEmotionSymbol(dominantEmotion)}) = Σ[E<sub>i</sub> · ${this.getMathSymbol(dominantMath)}(t)] · ${this.getMetaModifier()}`,
                `${this.getEmotionSymbol(dominantEmotion)}(t) = ${this.getMathSymbol(dominantMath)}(∫E<sub>i</sub> dt) × ${this.getChaosModifier()}`,
                `∇${this.getEmotionSymbol(dominantEmotion)} = ${this.getDimensionalityModifier()} × ${this.getMathSymbol(dominantMath)}(E<sub>i</sub>)`,
                `${this.getMathSymbol(dominantMath)}[${this.getEmotionSymbol(dominantEmotion)}] = ${this.getSynchronicityModifier()} · Σ(α<sub>i</sub> · E<sub>i</sub>)`,
                `Ψ = ${this.getEmotionSymbol(dominantEmotion)} ⊗ ${this.getMathSymbol(dominantMath)} + ${this.getTemporalityModifier()}`,
                `∂${this.getEmotionSymbol(dominantEmotion)}/∂t = ${this.getMathSymbol(dominantMath)}(Ψ) · ${this.getMetaModifier()}`
            ];
            
            // Выбираем случайный шаблон
            const randomTemplate = equationTemplates[Math.floor(Math.random() * equationTemplates.length)];
            
            // Устанавливаем уравнение
            document.querySelector('.equation-content').innerHTML = randomTemplate;
        };
        
        // Метод для генерации описания состояния
        EmotionalMathSynthesizer.prototype.generateStateDescription = function() {
            // Получаем доминирующие параметры
            const dominantEmotion = this.getDominantParameter(this.state.emotions);
            const dominantMath = this.getDominantParameter(this.state.math);
            
            // Шаблоны описаний для различных комбинаций
            const descriptions = {
                joy: {
                    exponential: "Состояние экспоненциально нарастающей радости, где каждый момент усиливает предыдущий, создавая ускоряющийся поток позитивных переживаний.",
                    logarithmic: "Глубокая, стабильная радость, которая раскрывается постепенно, подобно логарифмической функции, постоянно открывая новые оттенки позитивных эмоций.",
                    fractal: "Фрактальная радость, которая проявляется на множестве уровней восприятия одновременно, создавая самоподобные паттерны счастья в различных масштабах.",
                    trigonometric: "Циклическая, волнообразная радость, которая пульсирует с гармоничным ритмом, создавая мелодию позитивных эмоциональных состояний.",
                    complex: "Многомерная радость, существующая одновременно в нескольких эмоциональных плоскостях, образуя комплексную структуру переживаний."
                },
                sadness: {
                    exponential: "Быстро затухающая грусть, которая экспоненциально снижает свою интенсивность, открывая пространство для новых эмоциональных состояний.",
                    logarithmic: "Глубокая, медитативная меланхолия, которая обладает логарифмической структурой, раскрывая нюансы внутреннего мира с течением времени.",
                    fractal: "Самоподобная, рекурсивная грусть, проявляющаяся на различных уровнях сознания, создавая фрактальный ландшафт эмоциональных переживаний.",
                    trigonometric: "Ритмичная, волнообразная грусть, которая естественно перетекает в другие эмоциональные состояния, следуя тригонометрическим закономерностям.",
                    complex: "Комплексная меланхолия, существующая одновременно в нескольких измерениях восприятия, соединяющая различные аспекты эмоционального опыта."
                },
                fear: {
                    exponential: "Быстро нарастающее, но быстро достигающее насыщения беспокойство, экспоненциальная структура которого позволяет трансформировать его в другие эмоции.",
                    logarithmic: "Постепенно затухающая тревога, следующая логарифмической кривой, где каждый момент осознания снижает ее интенсивность.",
                    fractal: "Рекурсивный, самовоспроизводящийся страх, образующий фрактальные паттерны, которые можно наблюдать на различных уровнях психики.",
                    trigonometric: "Волнообразная, осциллирующая тревога, которая возникает и затихает с предсказуемой периодичностью, следуя тригонометрическим функциям.",
                    complex: "Многомерное беспокойство, которое можно представить в комплексной плоскости эмоций, где реальная и мнимая части создают неожиданные комбинации."
                },
                anger: {
                    exponential: "Интенсивный, быстро нарастающий гнев, который, достигнув пика, трансформируется в другие эмоции по экспоненциальному закону.",
                    logarithmic: "Постепенно затухающее раздражение, которое следует логарифмической кривой, позволяя осознать и интегрировать его энергию.",
                    fractal: "Фрактальный гнев, проявляющийся на различных уровнях осознания, создавая самоподобные структуры эмоциональных реакций.",
                    trigonometric: "Пульсирующее раздражение, которое следует синусоидальным паттернам, создавая волны эмоционального возбуждения и затихания.",
                    complex: "Многомерный гнев, существующий одновременно в нескольких плоскостях восприятия, образуя комплексную эмоциональную структуру."
                },
                surprise: {
                    exponential: "Внезапное, экспоненциально нарастающее удивление, которое открывает множество новых когнитивных и эмоциональных возможностей.",
                    logarithmic: "Постепенно раскрывающееся изумление, следующее логарифмической кривой, где каждое новое открытие углубляет опыт восприятия.",
                    fractal: "Рекурсивное, самоподобное удивление, которое раскрывается на множестве уровней сознания, создавая фрактальные паттерны восприятия.",
                    trigonometric: "Волнообразное, циклическое изумление, которое пульсирует с гармоничной периодичностью, следуя тригонометрическим функциям.",
                    complex: "Многомерное удивление, существующее одновременно в различных плоскостях восприятия, создавая комплексную структуру эмоционального опыта."
                }
            };
            
            // Получаем базовое описание
            let description = descriptions[dominantEmotion][dominantMath];
            
            // Добавляем модификаторы на основе метапараметров
            if (this.state.meta.chaos > 0.7) {
                description += " Высокий уровень хаотичности вносит элемент непредсказуемости в эмоционально-математическую структуру, создавая неожиданные переходы и комбинации.";
            } else if (this.state.meta.synchronicity > 0.7) {
                description += " Высокая синхронность создает гармоничное сочетание эмоциональных и математических элементов, позволяя им резонировать и усиливать друг друга.";
            }
            
            if (this.state.meta.dimensionality > 0.7) {
                description += " Многомерная структура состояния позволяет одновременно воспринимать различные аспекты эмоционально-математического опыта, создавая богатый и сложный паттерн.";
            } else if (this.state.meta.temporality > 0.7) {
                description += " Высокая темпоральность придает состоянию динамичный, постоянно эволюционирующий характер, где каждый момент открывает новые грани переживания.";
            }
            
            // Устанавливаем описание
            document.querySelector('.state-description').innerHTML = `<p>${description}</p>`;
        };
        
        // Метод для генерации частиц
        EmotionalMathSynthesizer.prototype.generateParticles = function() {
            // Очищаем текущие частицы
            this.state.particles = [];
            
            // Количество частиц зависит от сложности математических структур
            const particleCount = Math.floor(100 + 200 * this.getTotalMathComplexity());
            
            // Создаем частицы
            for (let i = 0; i < particleCount; i++) {
                // Определяем доминирующую эмоцию для частицы
                const emotion = this.getRandomWeightedEmotion();
                
                // Определяем тип математической структуры для движения частицы
                const mathType = this.getRandomWeightedMath();
                
                // Создаем частицу
                const particle = {
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    size: Math.random() * 3 + 1,
                    color: this.emotionColors[emotion],
                    alpha: Math.random() * 0.5 + 0.3,
                    emotion: emotion,
                    mathType: mathType,
                    speed: Math.random() * 2 + 0.5,
                    angle: Math.random() * Math.PI * 2,
                    phase: Math.random() * Math.PI * 2,
                    frequency: Math.random() * 0.1 + 0.01,
                    amplitude: Math.random() * 50 + 20,
                    chaosModifier: 1 + Math.random() * this.state.meta.chaos * 3,
                    temporalModifier: Math.random() * this.state.meta.temporality
                };
                
                this.state.particles.push(particle);
            }
        };
        
        // Метод для отрисовки начального состояния
        EmotionalMathSynthesizer.prototype.drawInitialState = function() {
            // Очищаем canvas
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            // Рисуем фоновый градиент
            const gradient = this.ctx.createRadialGradient(
                this.canvas.width / 2, this.canvas.height / 2, 10,
                this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height) / 2
            );
            
            gradient.addColorStop(0, 'rgba(40, 40, 80, 0.6)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
            
            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            
            // Рисуем мягкие точки
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * this.canvas.width;
                const y = Math.random() * this.canvas.height;
                const size = Math.random() * 2 + 1;
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.3 + 0.1})`;
                this.ctx.fill();
            }
            
            // Рисуем пульсирующий круг в центре
            const centerX = this.canvas.width / 2;
            const centerY = this.canvas.height / 2;
            const maxRadius = Math.min(this.canvas.width, this.canvas.height) / 5;
            
            this.ctx.beginPath();
            this.ctx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            this.ctx.lineWidth = 1.5;
            this.ctx.stroke();
            
            // Инструкция
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            this.ctx.font = '16px sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('Настройте параметры и нажмите "Синтезировать"', centerX, centerY);
        };
        
        
        
        // Метод для отрисовки фона
        EmotionalMathSynthesizer.prototype.drawBackground = function() {
            // Создаем градиент в зависимости от доминирующей эмоции
            const dominantEmotion = this.getDominantParameter(this.state.emotions);
            const color = this.emotionColors[dominantEmotion];
            
            const gradient = this.ctx.createRadialGradient(
                this.canvas.width / 2, this.canvas.height / 2, 10,
                this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height) / 2
            );
            
            gradient.addColorStop(0, `rgba(${this.hexToRgb(color)}, 0.2)`);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
            
            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        };
        
        // Метод для отрисовки математических структур
        EmotionalMathSynthesizer.prototype.drawMathStructures = function() {
            // Рисуем структуры в зависимости от их весов
            if (this.state.math.exponential > 0.2) {
                this.drawExponentialStructure(this.state.math.exponential);
            }
            
            if (this.state.math.logarithmic > 0.2) {
                this.drawLogarithmicStructure(this.state.math.logarithmic);
            }
            
            if (this.state.math.fractal > 0.2) {
                this.drawFractalStructure(this.state.math.fractal);
            }
            
            if (this.state.math.trigonometric > 0.2) {
                this.drawTrigonometricStructure(this.state.math.trigonometric);
            }
            
            if (this.state.math.complex > 0.2) {
                this.drawComplexStructure(this.state.math.complex);
            }
        };
        
        // Методы для отрисовки различных математических структур
    
        // Метод для отрисовки экспоненциальной структуры
        EmotionalMathSynthesizer.prototype.drawExponentialStructure = function(intensity) {
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.3})`;
            this.ctx.lineWidth = 1 + intensity * 2;
            
            const height = this.canvas.height;
            const width = this.canvas.width;
            
            this.ctx.beginPath();
            for (let x = 0; x < width; x += 2) {
                const normalizedX = (x / width) * 4 - 2;
                const y = height - ((Math.exp(normalizedX) * 0.1) * height);
                
                if (x === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
            this.ctx.stroke();
        };
        
        // Метод для отрисовки логарифмической структуры
        EmotionalMathSynthesizer.prototype.drawLogarithmicStructure = function(intensity) {
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.3})`;
            this.ctx.lineWidth = 1 + intensity * 2;
            
            const height = this.canvas.height;
            const width = this.canvas.width;
            
            this.ctx.beginPath();
            for (let x = width / 10; x < width; x += 2) {
                const normalizedX = (x / width) * 10;
                const y = height - ((Math.log(normalizedX) * 0.2) * height);
                
                if (x === width / 10) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
            this.ctx.stroke();
        };
        
        // Метод для отрисовки фрактальной структуры
        EmotionalMathSynthesizer.prototype.drawFractalStructure = function(intensity) {
            // Создаем сеть Серпинского как упрощенный фрактал
            const maxDepth = Math.floor(4 * intensity);
            
            if (maxDepth < 1) return;
            
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.4})`;
            this.ctx.lineWidth = 1;
            
            const drawTriangle = (x1, y1, x2, y2, x3, y3, depth) => {
                if (depth === 0) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.lineTo(x3, y3);
                    this.ctx.closePath();
                    this.ctx.stroke();
                    return;
                }
                
                // Вычисляем средние точки
                const x12 = (x1 + x2) / 2;
                const y12 = (y1 + y2) / 2;
                
                const x23 = (x2 + x3) / 2;
                const y23 = (y2 + y3) / 2;
                
                const x31 = (x3 + x1) / 2;
                const y31 = (y3 + y1) / 2;
                
                // Рекурсивно рисуем треугольники
                drawTriangle(x1, y1, x12, y12, x31, y31, depth - 1);
                drawTriangle(x12, y12, x2, y2, x23, y23, depth - 1);
                drawTriangle(x31, y31, x23, y23, x3, y3, depth - 1);
            };
            
            // Начальный треугольник
            const centerX = this.canvas.width / 2;
            const centerY = this.canvas.height / 2;
            const size = Math.min(this.canvas.width, this.canvas.height) * 0.8;
            
            const x1 = centerX;
            const y1 = centerY - size / 2;
            
            const x2 = centerX - size / 2;
            const y2 = centerY + size / 2;
            
            const x3 = centerX + size / 2;
            const y3 = centerY + size / 2;
            
            drawTriangle(x1, y1, x2, y2, x3, y3, maxDepth);
        };
        
        // Метод для отрисовки тригонометрической структуры
        EmotionalMathSynthesizer.prototype.drawTrigonometricStructure = function(intensity) {
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.3})`;
            this.ctx.lineWidth = 1 + intensity * 2;
            
            const height = this.canvas.height;
            const width = this.canvas.width;
            
            // Рисуем синусоидальную волну
            this.ctx.beginPath();
            for (let x = 0; x < width; x += 2) {
                const normalizedX = (x / width) * 20;
                const y = height / 2 + Math.sin(normalizedX + this.state.time) * (height / 4) * intensity;
                
                if (x === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
            this.ctx.stroke();
            
            // Рисуем косинусоидальную волну
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.2})`;
            this.ctx.beginPath();
            for (let x = 0; x < width; x += 2) {
                const normalizedX = (x / width) * 15;
                const y = height / 2 + Math.cos(normalizedX + this.state.time * 0.8) * (height / 5) * intensity;
                
                if (x === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
            this.ctx.stroke();
        };
        
        // Метод для отрисовки комплексной структуры
        EmotionalMathSynthesizer.prototype.drawComplexStructure = function(intensity) {
            // Рисуем комплексную плоскость
            const centerX = this.canvas.width / 2;
            const centerY = this.canvas.height / 2;
            const radius = Math.min(this.canvas.width, this.canvas.height) / 3;
            
            // Рисуем оси
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.2})`;
            this.ctx.lineWidth = 1;
            
            this.ctx.beginPath();
            this.ctx.moveTo(centerX - radius, centerY);
            this.ctx.lineTo(centerX + radius, centerY);
            this.ctx.moveTo(centerX, centerY - radius);
            this.ctx.lineTo(centerX, centerY + radius);
            this.ctx.stroke();
            
            // Рисуем единичную окружность
            this.ctx.beginPath();
            this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Рисуем комплексные точки
            const pointCount = Math.floor(10 * intensity);
            
            for (let i = 0; i < pointCount; i++) {
                const angle = (i / pointCount) * Math.PI * 2 + this.state.time * 0.5;
                const r = radius * (0.5 + Math.sin(this.state.time + i) * 0.2);
                
                const x = centerX + Math.cos(angle) * r;
                const y = centerY + Math.sin(angle) * r;
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, 3 * intensity, 0, Math.PI * 2);
                this.ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.8})`;
                this.ctx.fill();
                
                // Соединяем с центром
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, centerY);
                this.ctx.lineTo(x, y);
                this.ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.3})`;
                this.ctx.stroke();
            }
        };
        
        // Метод для обновления и отрисовки частиц
        EmotionalMathSynthesizer.prototype.updateParticles = function() {
            for (let i = 0; i < this.state.particles.length; i++) {
                const p = this.state.particles[i];
                
                // Обновляем положение частицы в зависимости от ее математического типа
                switch (p.mathType) {
                    case 'exponential':
                        this.updateExponentialParticle(p);
                        break;
                    case 'logarithmic':
                        this.updateLogarithmicParticle(p);
                        break;
                    case 'fractal':
                        this.updateFractalParticle(p);
                        break;
                    case 'trigonometric':
                        this.updateTrigonometricParticle(p);
                        break;
                    case 'complex':
                        this.updateComplexParticle(p);
                        break;
                }
                
                // Добавляем хаотичность
                if (this.state.meta.chaos > 0.2) {
                    p.x += (Math.random() - 0.5) * this.state.meta.chaos * p.chaosModifier;
                    p.y += (Math.random() - 0.5) * this.state.meta.chaos * p.chaosModifier;
                }
                
                // Проверяем границы
                if (p.x < 0) p.x = this.canvas.width;
                if (p.x > this.canvas.width) p.x = 0;
                if (p.y < 0) p.y = this.canvas.height;
                if (p.y > this.canvas.height) p.y = 0;
                
                // Рисуем частицу
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                this.ctx.fillStyle = `rgba(${this.hexToRgb(p.color)}, ${p.alpha})`;
                this.ctx.fill();
                
                // Рисуем след для некоторых частиц
                if (Math.random() < 0.2 * this.state.meta.dimensionality) {
                    const trailLength = Math.floor(Math.random() * 5) + 3;
                    const angleOffset = (Math.random() - 0.5) * Math.PI * 0.3;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(p.x, p.y);
                    
                    for (let j = 1; j <= trailLength; j++) {
                        const distance = j * p.size * 1.5;
                        const trailX = p.x - Math.cos(p.angle + angleOffset) * distance;
                        const trailY = p.y - Math.sin(p.angle + angleOffset) * distance;
                        
                        this.ctx.lineTo(trailX, trailY);
                    }
                    
                    this.ctx.strokeStyle = `rgba(${this.hexToRgb(p.color)}, ${p.alpha * 0.3})`;
                    this.ctx.lineWidth = p.size / 2;
                    this.ctx.stroke();
                }
            }
        };
        
        // Методы для обновления различных типов частиц
        EmotionalMathSynthesizer.prototype.updateExponentialParticle = function(p) {
            // Экспоненциальное движение - ускорение со временем
            const acceleration = Math.exp(this.state.time * p.temporalModifier * 0.1) * 0.01;
            p.speed += acceleration;
            
            if (p.speed > 5) {
                p.speed = 0.5; // Сброс скорости при достижении максимума
            }
            
            p.x += Math.cos(p.angle) * p.speed;
            p.y += Math.sin(p.angle) * p.speed;
            
            // Небольшое изменение направления
            p.angle += (Math.random() - 0.5) * 0.1;
        };
        
        EmotionalMathSynthesizer.prototype.updateLogarithmicParticle = function(p) {
            // Логарифмическое движение - замедление со временем
            const deceleration = 1 / (Math.log(this.state.time * p.temporalModifier + 1.1) + 1);
            p.speed = Math.max(0.1, p.speed * deceleration);
            
            p.x += Math.cos(p.angle) * p.speed;
            p.y += Math.sin(p.angle) * p.speed;
            
            // Плавное изменение направления
            p.angle += Math.sin(this.state.time * 0.1) * 0.05;
        };
        
        EmotionalMathSynthesizer.prototype.updateFractalParticle = function(p) {
            // Фрактальное движение - самоподобные траектории
            const t = this.state.time * p.temporalModifier;
            
            // Используем рекурсивно определенную функцию для фрактального движения
            const fractalX = Math.sin(t) * Math.sin(t * 1.5) * Math.sin(t * 2.3) * p.amplitude;
            const fractalY = Math.cos(t) * Math.cos(t * 1.7) * Math.cos(t * 2.1) * p.amplitude;
            
            p.x += fractalX * 0.01;
            p.y += fractalY * 0.01;
            
            // Добавляем случайное изменение направления для большей хаотичности
            p.angle += Math.sin(t * 3) * 0.1;
        };
        
        EmotionalMathSynthesizer.prototype.updateTrigonometricParticle = function(p) {
            // Тригонометрическое движение - волнообразные траектории
            const t = this.state.time * p.temporalModifier;
            
            p.x += Math.cos(p.angle) * p.speed;
            p.y += Math.sin(p.angle) * p.speed + Math.sin(t * p.frequency) * 0.5;
            
            // Плавное изменение угла по синусоиде
            p.angle += Math.sin(t) * 0.05;
        };
        
        EmotionalMathSynthesizer.prototype.updateComplexParticle = function(p) {
            // Движение в комплексной плоскости
            const t = this.state.time * p.temporalModifier;
            
            // Используем комплексные функции для движения
            const centerX = this.canvas.width / 2;
            const centerY = this.canvas.height / 2;
            
            // Вращение вокруг центра
            const radius = Math.sqrt(Math.pow(p.x - centerX, 2) + Math.pow(p.y - centerY, 2));
            const angle = Math.atan2(p.y - centerY, p.x - centerX) + p.speed * 0.01;
            
            // Спиральное движение с колебаниями
            const newRadius = radius + Math.sin(t * p.frequency) * 0.5;
            
            p.x = centerX + Math.cos(angle) * newRadius;
            p.y = centerY + Math.sin(angle) * newRadius;
        };
        
        // Метод для отрисовки дополнительных эффектов
        EmotionalMathSynthesizer.prototype.drawEffects = function() {
            // Добавляем эффекты в зависимости от метапараметров
            if (this.state.meta.synchronicity > 0.5) {
                this.drawSynchronicityEffect();
            }
            
            if (this.state.meta.dimensionality > 0.6) {
                this.drawDimensionalityEffect();
            }
            
            if (this.state.meta.temporality > 0.7) {
                this.drawTemporalityEffect();
            }
        };
        
        // Методы для отрисовки различных эффектов
        EmotionalMathSynthesizer.prototype.drawSynchronicityEffect = function() {
            const centerX = this.canvas.width / 2;
            const centerY = this.canvas.height / 2;
            const maxRadius = Math.min(this.canvas.width, this.canvas.height) / 3;
            
            // Рисуем концентрические круги, пульсирующие в унисон
            const pulseRadius = maxRadius * (0.5 + Math.sin(this.state.time * 2) * 0.2);
            
            for (let i = 0; i < 3; i++) {
                const radius = pulseRadius * (0.5 + i * 0.25);
                
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.2 - i * 0.05})`;
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            }
        };
        
        EmotionalMathSynthesizer.prototype.drawDimensionalityEffect = function() {
            // Рисуем сеть соединений между частицами, создавая многомерную структуру
            const particleCount = Math.min(this.state.particles.length, 50);
            const maxDistance = 100 * this.state.meta.dimensionality;
            
            this.ctx.lineWidth = 0.5;
            
            for (let i = 0; i < particleCount; i++) {
                const p1 = this.state.particles[i];
                
                for (let j = i + 1; j < particleCount; j++) {
                    const p2 = this.state.particles[j];
                    
                    const distance = Math.sqrt(
                        Math.pow(p1.x - p2.x, 2) + 
                        Math.pow(p1.y - p2.y, 2)
                    );
                    
                    if (distance < maxDistance) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        
                        const opacity = (1 - distance / maxDistance) * 0.2;
                        this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                        
                        this.ctx.stroke();
                    }
                }
            }
        };
        
        EmotionalMathSynthesizer.prototype.drawTemporalityEffect = function() {
            // Рисуем временные следы и эхо
            const centerX = this.canvas.width / 2;
            const centerY = this.canvas.height / 2;
            
            // Волны времени, расходящиеся от центра
            for (let i = 0; i < 3; i++) {
                const radius = (this.state.time * 30 + i * 100) % Math.max(this.canvas.width, this.canvas.height);
                
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                
                const opacity = 0.1 - (radius / Math.max(this.canvas.width, this.canvas.height)) * 0.1;
                this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                this.ctx.lineWidth = 1;
                
                this.ctx.stroke();
            }
        };
        
        // Класс для эмоционально-математического проводника
        class EmotionalMathConductor {
            constructor() {
                // Инициализация canvas
                this.conductorCanvas = document.getElementById('conductor-canvas');
                this.networkCanvas = document.getElementById('network-canvas');
                
                this.conductorCtx = this.conductorCanvas.getContext('2d');
                this.networkCtx = this.networkCanvas.getContext('2d');
                
                this.resizeCanvases();
                
                // Данные для эмоций и математических структур
                this.emotions = {
                    joy: { 
                        name: 'Радость', 
                        color: '#FFD700',
                        description: 'Расширяющееся, яркое, возрастающее чувство позитивного возбуждения',
                        properties: {
                            expansion: 0.9,
                            brightness: 0.8,
                            rhythm: 0.6,
                            depth: 0.5,
                            complexity: 0.4
                        }
                    },
                    sadness: { 
                        name: 'Грусть', 
                        color: '#4682B4',
                        description: 'Сжимающееся, глубокое, медленное чувство тихой меланхолии',
                        properties: {
                            expansion: 0.2,
                            brightness: 0.3,
                            rhythm: 0.3,
                            depth: 0.9,
                            complexity: 0.6
                        }
                    },
                    fear: { 
                        name: 'Страх', 
                        color: '#800080',
                        description: 'Хаотичное, сжимающееся, острое чувство тревоги и неопределенности',
                        properties: {
                            expansion: 0.3,
                            brightness: 0.4,
                            rhythm: 0.8,
                            depth: 0.7,
                            complexity: 0.8
                        }
                    },
                    anger: { 
                        name: 'Гнев', 
                        color: '#FF4500',
                        description: 'Пульсирующее, яркое, интенсивное чувство напряжения и энергии',
                        properties: {
                            expansion: 0.7,
                            brightness: 0.8,
                            rhythm: 0.9,
                            depth: 0.5,
                            complexity: 0.7
                        }
                    },
                    surprise: { 
                        name: 'Удивление', 
                        color: '#FF69B4',
                        description: 'Внезапное, расширяющееся, яркое чувство новизны и необычности',
                        properties: {
                            expansion: 0.8,
                            brightness: 0.9,
                            rhythm: 0.7,
                            depth: 0.4,
                            complexity: 0.5
                        }
                    }
                };
                
                this.mathStructures = {
                    exponential: { 
                        name: 'Экспоненциальные функции', 
                        formula: 'f(x) = e^x',
                        description: 'Быстрорастущие функции, ускоряющиеся с увеличением аргумента',
                        properties: {
                            growth: 0.9,
                            oscillation: 0.2,
                            symmetry: 0.4,
                            recursion: 0.3,
                            dimensionality: 0.5
                        }
                    },
                    logarithmic: { 
                        name: 'Логарифмические функции', 
                        formula: 'f(x) = log(x)',
                        description: 'Медленнорастущие функции, замедляющиеся с увеличением аргумента',
                        properties: {
                            growth: 0.3,
                            oscillation: 0.1,
                            symmetry: 0.4,
                            recursion: 0.2,
                            dimensionality: 0.4
                        }
                    },
                    trigonometric: { 
                        name: 'Тригонометрические функции', 
                        formula: 'f(x) = sin(x), cos(x), tan(x)',
                        description: 'Периодические, волнообразные функции с постоянной амплитудой',
                        properties: {
                            growth: 0.5,
                            oscillation: 0.9,
                            symmetry: 0.8,
                            recursion: 0.4,
                            dimensionality: 0.6
                        }
                    },
                    fractal: { 
                        name: 'Фрактальные структуры', 
                        formula: 'z = z² + c',
                        description: 'Самоподобные рекурсивные структуры с бесконечной детализацией',
                        properties: {
                            growth: 0.7,
                            oscillation: 0.6,
                            symmetry: 0.7,
                            recursion: 0.9,
                            dimensionality: 0.8
                        }
                    },
                    complex: { 
                        name: 'Комплексные числа', 
                        formula: 'z = a + bi',
                        description: 'Числа с реальной и мнимой частью, формирующие двумерное пространство',
                        properties: {
                            growth: 0.6,
                            oscillation: 0.7,
                            symmetry: 0.6,
                            recursion: 0.5,
                            dimensionality: 0.9
                        }
                    }
                };
                
                // Параметры преобразований
                this.transformParams = {
                    intensity: 0.7,
                    depth: 0.5
                };
                
                // Сетевые связи
                this.network = {
                    nodes: [],
                    links: [],
                    simulation: null
                };
                
                // Текущее состояние и анимация
                this.state = {
                    sourceType: 'emotion',
                    sourceValue: 'joy',
                    targetType: 'math',
                    targetValue: 'exponential',
                    particles: [],
                    time: 0,
                    isTransforming: false,
                    animationFrame: null
                };
                
                // Инициализация UI и обработчиков событий
                this.initUI();
                this.initEventListeners();
                
                // Создание начальной сетевой визуализации
                this.initNetwork();
                
                // Начальная визуализация
                this.drawInitialState();
            }
            
            // Метод для изменения размеров canvas
            resizeCanvases() {
                const conductorContainer = this.conductorCanvas.parentElement;
                const networkContainer = this.networkCanvas.parentElement;
                
                this.conductorCanvas.width = conductorContainer.clientWidth;
                this.conductorCanvas.height = 350;
                
                this.networkCanvas.width = networkContainer.clientWidth;
                this.networkCanvas.height = 300;
            }
            
            // Инициализация пользовательского интерфейса
            initUI() {
                // Заполняем выпадающие списки
                this.updateSourceValueSelect();
                this.updateTargetValueSelect();
                
                // Устанавливаем начальные значения для слайдеров
                document.getElementById('transform-intensity').value = this.transformParams.intensity;
                document.getElementById('transform-depth').value = this.transformParams.depth;
                document.getElementById('transform-intensity').nextElementSibling.textContent = `${Math.round(this.transformParams.intensity * 100)}%`;
                document.getElementById('transform-depth').nextElementSibling.textContent = `${Math.round(this.transformParams.depth * 100)}%`;
                
                // Устанавливаем начальное уравнение и описание
                this.updateTransformationInfo();
            }
            
            // Обновление списка значений источника в зависимости от выбранного типа
            updateSourceValueSelect() {
                const sourceType = document.getElementById('source-type').value;
                const sourceValueSelect = document.getElementById('source-value');
                
                // Очищаем текущие опции
                sourceValueSelect.innerHTML = '';
                
                // Добавляем новые опции в зависимости от типа
                if (sourceType === 'emotion') {
                    for (const key in this.emotions) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = this.emotions[key].name;
                        sourceValueSelect.appendChild(option);
                    }
                } else {
                    for (const key in this.mathStructures) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = this.mathStructures[key].name;
                        sourceValueSelect.appendChild(option);
                    }
                }
                
                // Обновляем текущее состояние
                this.state.sourceType = sourceType;
                this.state.sourceValue = sourceValueSelect.value;
            }
            
            // Обновление списка значений цели в зависимости от выбранного типа
            updateTargetValueSelect() {
                const targetType = document.getElementById('target-type').value;
                const targetValueSelect = document.getElementById('target-value');
                
                // Очищаем текущие опции
                targetValueSelect.innerHTML = '';
                
                // Добавляем новые опции в зависимости от типа
                if (targetType === 'emotion') {
                    for (const key in this.emotions) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = this.emotions[key].name;
                        targetValueSelect.appendChild(option);
                    }
                } else {
                    for (const key in this.mathStructures) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = this.mathStructures[key].name;
                        targetValueSelect.appendChild(option);
                    }
                }
                
                // Обновляем текущее состояние
                this.state.targetType = targetType;
                this.state.targetValue = targetValueSelect.value;
            }
            
            // Инициализация обработчиков событий
            initEventListeners() {
                // Обработчики для селекторов типа источника и цели
                document.getElementById('source-type').addEventListener('change', () => {
                    this.updateSourceValueSelect();
                    this.updateTransformationInfo();
                });
                
                document.getElementById('target-type').addEventListener('change', () => {
                    this.updateTargetValueSelect();
                    this.updateTransformationInfo();
                });
                
                // Обработчики для селекторов значений источника и цели
                document.getElementById('source-value').addEventListener('change', (e) => {
                    this.state.sourceValue = e.target.value;
                    this.updateTransformationInfo();
                });
                
                document.getElementById('target-value').addEventListener('change', (e) => {
                    this.state.targetValue = e.target.value;
                    this.updateTransformationInfo();
                });
                
                // Обработчики для слайдеров параметров
                document.getElementById('transform-intensity').addEventListener('input', (e) => {
                    this.transformParams.intensity = parseFloat(e.target.value);
                    e.target.nextElementSibling.textContent = `${Math.round(this.transformParams.intensity * 100)}%`;
                });
                
                document.getElementById('transform-depth').addEventListener('input', (e) => {
                    this.transformParams.depth = parseFloat(e.target.value);
                    e.target.nextElementSibling.textContent = `${Math.round(this.transformParams.depth * 100)}%`;
                });
                
                // Обработчики для кнопок
                document.getElementById('transform-button').addEventListener('click', () => {
                    this.startTransformation();
                });
                
                document.getElementById('explore-button').addEventListener('click', () => {
                    this.exploreSpace();
                });
                
                // Обработчик изменения размера окна
                window.addEventListener('resize', () => {
                    this.resizeCanvases();
                    this.drawTransformation();
                    this.drawNetwork();
                });
            }
            
            // Обновление информации о преобразовании
            updateTransformationInfo() {
                // Получаем информацию об источнике и цели
                let source, target;
                
                if (this.state.sourceType === 'emotion') {
                    source = this.emotions[this.state.sourceValue];
                } else {
                    source = this.mathStructures[this.state.sourceValue];
                }
                
                if (this.state.targetType === 'emotion') {
                    target = this.emotions[this.state.targetValue];
                } else {
                    target = this.mathStructures[this.state.targetValue];
                }
                
                // Генерируем уравнение преобразования
                const equation = this.generateTransformationEquation(source, target);
                
                // Генерируем описание преобразования
                const description = this.generateTransformationDescription(source, target);
                
                // Обновляем отображение
                document.querySelector('.transformation-equation').innerHTML = equation;
                document.querySelector('.transformation-description').innerHTML = description;
            }
            
            // Генерация уравнения преобразования
            generateTransformationEquation(source, target) {
                let sourceSymbol, targetSymbol;
                
                if (this.state.sourceType === 'emotion') {
                    sourceSymbol = this.getEmotionSymbol(this.state.sourceValue);
                } else {
                    sourceSymbol = this.getMathSymbol(this.state.sourceValue);
                }
                
                if (this.state.targetType === 'emotion') {
                    targetSymbol = this.getEmotionSymbol(this.state.targetValue);
                } else {
                    targetSymbol = this.getMathSymbol(this.state.targetValue);
                }
                
                // Шаблоны уравнений
                const templates = [
                    `${targetSymbol} = T<sub>${sourceSymbol}</sub>(${sourceSymbol}) × λ<sup>${this.transformParams.intensity.toFixed(1)}</sup>`,
                    `${targetSymbol} = ∫ ${sourceSymbol}(t) · δ<sup>${this.transformParams.depth.toFixed(1)}</sup> dt`,
                    `∇${targetSymbol} = Φ(${sourceSymbol}) · Ω<sub>${Math.round(this.transformParams.intensity * 10)}</sub>`,
                    `${targetSymbol} = ${sourceSymbol} ⊗ V<sup>${Math.round(this.transformParams.depth * 5)}</sup>`,
                    `${targetSymbol}(x) = ${sourceSymbol}(Λ<sub>x</sub>) · e<sup>${this.transformParams.intensity.toFixed(1)}</sup>`
                ];
                
                // Выбираем случайный шаблон
                return templates[Math.floor(Math.random() * templates.length)];
            }
            
            // Генерация описания преобразования
            generateTransformationDescription(source, target) {
                // Базовое описание в зависимости от типов преобразования
                let description = '';
                
                if (this.state.sourceType === 'emotion' && this.state.targetType === 'math') {
                    description = `Преобразование ${source.name.toLowerCase()} в ${target.name.toLowerCase()} создает математическую структуру, которая отражает ключевые свойства эмоционального состояния: `;
                    
                    // Добавляем соответствия свойств
                    if (source.properties.expansion > 0.7) {
                        description += target.properties.growth > 0.7 ? 
                            'экспансивная природа эмоции трансформируется в быстрый рост функции, ' : 
                            'расширяющаяся природа эмоции преобразуется в сложные структурные паттерны, ';
                    }
                    
                    if (source.properties.brightness > 0.7) {
                        description += target.properties.oscillation > 0.7 ? 
                            'яркость эмоции отражается в амплитуде колебаний, ' : 
                            'интенсивность эмоции проявляется в насыщенности математического паттерна, ';
                    }
                    
                    if (source.properties.depth > 0.7) {
                        description += target.properties.dimensionality > 0.7 ? 
                            'глубина эмоционального переживания выражается в многомерности структуры. ' : 
                            'глубина переживания отражается в сложности взаимосвязей внутри структуры. ';
                    }
                } else if (this.state.sourceType === 'math' && this.state.targetType === 'emotion') {
                    description = `Преобразование ${source.name.toLowerCase()} в эмоциональное состояние ${target.name.toLowerCase()} создает субъективный опыт, который отражает ключевые свойства математической структуры: `;
                    
                    // Добавляем соответствия свойств
                    if (source.properties.growth > 0.7) {
                        description += target.properties.expansion > 0.7 ? 
                            'быстрый рост функции трансформируется в расширяющееся чувство, ' : 
                            'стремительное нарастание функции преобразуется в нарастающую интенсивность переживания, ';
                    }
                    
                    if (source.properties.oscillation > 0.7) {
                        description += target.properties.rhythm > 0.7 ? 
                            'волнообразная природа функции отражается в ритмичной пульсации эмоции, ' : 
                            'периодичность функции проявляется в волнообразном характере переживания, ';
                    }
                    
                    if (source.properties.recursion > 0.7) {
                        description += target.properties.complexity > 0.7 ? 
                            'рекурсивная структура преобразуется в сложные слои эмоционального опыта. ' : 
                            'самоподобие структуры отражается в многослойности переживания. ';
                    }
                } else {
                    // Преобразование эмоция -> эмоция или математика -> математика
                    description = `Преобразование ${source.name.toLowerCase()} в ${target.name.toLowerCase()} создает сложное сопряжение свойств, где `;
                    
                    // Добавляем несколько соответствий свойств
                    const sourceProps = Object.keys(source.properties);
                    const targetProps = Object.keys(target.properties);
                    
                    for (let i = 0; i < 3; i++) {
                        const sourceProp = sourceProps[Math.floor(Math.random() * sourceProps.length)];
                        const targetProp = targetProps[Math.floor(Math.random() * targetProps.length)];
                        
                        description += `${sourceProp} переходит в ${targetProp}${i < 2 ? ', ' : '. '}`;
                    }
                }
                
                // Добавляем модификаторы на основе параметров преобразования
                if (this.transformParams.intensity > 0.7) {
                    description += `Высокая интенсивность (${Math.round(this.transformParams.intensity * 100)}%) усиливает преобразование, делая новое состояние более ярким и выраженным. `;
                } else if (this.transformParams.intensity < 0.3) {
                    description += `Низкая интенсивность (${Math.round(this.transformParams.intensity * 100)}%) создает тонкое, едва уловимое преобразование. `;
                }
                
                if (this.transformParams.depth > 0.7) {
                    description += `Глубокое погружение (${Math.round(this.transformParams.depth * 100)}%) позволяет исследовать скрытые аспекты взаимосвязей между исходным и целевым состояниями.`;
                } else if (this.transformParams.depth < 0.3) {
                    description += `Поверхностное погружение (${Math.round(this.transformParams.depth * 100)}%) фокусируется на наиболее очевидных свойствах преобразования.`;
                }
                
                return description;
            }
            
            // Метод для получения символа эмоции
            getEmotionSymbol(emotion) {
                const symbols = {
                    joy: 'J',
                    sadness: 'S',
                    fear: 'F',
                    anger: 'A',
                    surprise: 'U'
                };
                
                return symbols[emotion] || 'E';
            }
            
            // Метод для получения символа математической структуры
            getMathSymbol(math) {
                const symbols = {
                    exponential: 'exp',
                    logarithmic: 'ln',
                    fractal: 'Fr',
                    trigonometric: 'sin',
                    complex: 'ℂ'
                };
                
                return symbols[math] || 'M';
            }
            
            // Инициализация и отображение сетевой визуализации
            initNetwork() {
                // Создаем узлы для эмоций
                for (const key in this.emotions) {
                    this.network.nodes.push({
                        id: `emotion-${key}`,
                        type: 'emotion',
                        value: key,
                        label: this.emotions[key].name,
                        color: this.emotions[key].color,
                        size: 12
                    });
                }
                
                // Создаем узлы для математических структур
                for (const key in this.mathStructures) {
                    this.network.nodes.push({
                        id: `math-${key}`,
                        type: 'math',
                        value: key,
                        label: this.mathStructures[key].name,
                        color: '#FFFFFF',
                        size: 12
                    });
                }
                
                // Создаем связи между узлами
                // Сначала между эмоциями и математическими структурами
                for (const emotionKey in this.emotions) {
                    for (const mathKey in this.mathStructures) {
                        const emotion = this.emotions[emotionKey];
                        const math = this.mathStructures[mathKey];
                        
                        // Вычисляем силу связи на основе схожести свойств
                        let similarity = 0;
                        
                        similarity += Math.abs(emotion.properties.expansion - math.properties.growth) * 0.2;
                        similarity += Math.abs(emotion.properties.rhythm - math.properties.oscillation) * 0.2;
                        similarity += Math.abs(emotion.properties.complexity - math.properties.recursion) * 0.2;
                        similarity += Math.abs(emotion.properties.depth - math.properties.dimensionality) * 0.2;
                        similarity += Math.abs(emotion.properties.brightness - math.properties.symmetry) * 0.2;
                        
                        similarity = 1 - similarity; // Преобразуем различие в сходство
                        
                        if (similarity > 0.5) { // Создаем связь только если сходство достаточно высокое
                            this.network.links.push({
                                source: `emotion-${emotionKey}`,
                                target: `math-${mathKey}`,
                                value: similarity,
                                color: this.interpolateColors('#FFFFFF', emotion.color, similarity)
                            });
                        }
                    }
                }
                
                // Добавляем связи между эмоциями
                for (const key1 in this.emotions) {
                    for (const key2 in this.emotions) {
                        if (key1 !== key2) {
                            const emotion1 = this.emotions[key1];
                            const emotion2 = this.emotions[key2];
                            
                            // Вычисляем силу связи на основе схожести свойств
                            let similarity = 0;
                            
                            for (const prop in emotion1.properties) {
                                similarity += Math.abs(emotion1.properties[prop] - emotion2.properties[prop]);
                            }
                            
                            similarity = 1 - similarity / 5; // Нормализуем и преобразуем различие в сходство
                            
                            if (similarity > 0.6) { // Создаем связь только если сходство достаточно высокое
                                this.network.links.push({
                                    source: `emotion-${key1}`,
                                    target: `emotion-${key2}`,
                                    value: similarity,
                                    color: this.interpolateColors(emotion1.color, emotion2.color, 0.5)
                                });
                            }
                        }
                    }
                }
                
                // Добавляем связи между математическими структурами
                for (const key1 in this.mathStructures) {
                    for (const key2 in this.mathStructures) {
                        if (key1 !== key2) {
                            const math1 = this.mathStructures[key1];
                            const math2 = this.mathStructures[key2];
                            
                            // Вычисляем силу связи на основе схожести свойств
                            let similarity = 0;
                            
                            for (const prop in math1.properties) {
                                similarity += Math.abs(math1.properties[prop] - math2.properties[prop]);
                            }
                            
                            similarity = 1 - similarity / 5; // Нормализуем и преобразуем различие в сходство
                            
                            if (similarity > 0.6) { // Создаем связь только если сходство достаточно высокое
                                this.network.links.push({
                                    source: `math-${key1}`,
                                    target: `math-${key2}`,
                                    value: similarity,
                                    color: `rgba(255, 255, 255, ${similarity})`
                                });
                            }
                        }
                    }
                }
                
                // Отрисовываем сеть
                this.drawNetwork();
            }
            
            // Метод для отрисовки сети
            drawNetwork() {
                // Очищаем canvas
                this.networkCtx.clearRect(0, 0, this.networkCanvas.width, this.networkCanvas.height);
                
                // Рисуем фон
                this.networkCtx.fillStyle = 'rgba(10, 10, 10, 0.6)';
                this.networkCtx.fillRect(0, 0, this.networkCanvas.width, this.networkCanvas.height);
                
                // Базовые параметры отрисовки
                const nodePositions = {};
                const emotionCount = Object.keys(this.emotions).length;
                const mathCount = Object.keys(this.mathStructures).length;
                
                // Располагаем узлы эмоций в верхней части
                let i = 0;
                for (const key in this.emotions) {
                    const x = this.networkCanvas.width * (i + 1) / (emotionCount + 1);
                    const y = this.networkCanvas.height * 0.3;
                    
                    nodePositions[`emotion-${key}`] = { x, y };
                    i++;
                }
                
                // Располагаем узлы математических структур в нижней части
                i = 0;
                for (const key in this.mathStructures) {
                    const x = this.networkCanvas.width * (i + 1) / (mathCount + 1);
                    const y = this.networkCanvas.height * 0.7;
                    
                    nodePositions[`math-${key}`] = { x, y };
                    i++;
                }
                
                // Рисуем связи
                for (const link of this.network.links) {
                    const source = nodePositions[link.source];
                    const target = nodePositions[link.target];
                    
                    this.networkCtx.beginPath();
                    this.networkCtx.moveTo(source.x, source.y);
                    this.networkCtx.lineTo(target.x, target.y);
                    this.networkCtx.strokeStyle = link.color || `rgba(255, 255, 255, ${link.value})`;
                    this.networkCtx.lineWidth = Math.max(1, link.value * 3);
                    this.networkCtx.stroke();
                }
                
                // Рисуем узлы
                for (const node of this.network.nodes) {
                    const pos = nodePositions[node.id];
                    
                    // Выделяем выбранные узлы
                    const isSourceSelected = (this.state.sourceType === node.type && this.state.sourceValue === node.value);
                    const isTargetSelected = (this.state.targetType === node.type && this.state.targetValue === node.value);
                    
                    // Рисуем внешний круг для выделенных узлов
                    if (isSourceSelected || isTargetSelected) {
                        this.networkCtx.beginPath();
                        this.networkCtx.arc(pos.x, pos.y, node.size + 4, 0, Math.PI * 2);
                        this.networkCtx.fillStyle = isSourceSelected ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.3)';
                        this.networkCtx.fill();
                    }
                    
                    // Рисуем узел
                    this.networkCtx.beginPath();
                    this.networkCtx.arc(pos.x, pos.y, node.size, 0, Math.PI * 2);
                    this.networkCtx.fillStyle = node.color;
                    this.networkCtx.fill();
                    
                    // Рисуем текст
                    this.networkCtx.fillStyle = '#FFFFFF';
                    this.networkCtx.font = '10px sans-serif';
                    this.networkCtx.textAlign = 'center';
                    this.networkCtx.fillText(node.label, pos.x, pos.y + node.size + 12);
                }
            }
            
            // Метод для отрисовки начального состояния
            drawInitialState() {
                // Очищаем canvas
                this.conductorCtx.clearRect(0, 0, this.conductorCanvas.width, this.conductorCanvas.height);
                
                // Рисуем градиентный фон
                const gradient = this.conductorCtx.createLinearGradient(0, 0, this.conductorCanvas.width, this.conductorCanvas.height);
                gradient.addColorStop(0, 'rgba(30, 30, 60, 0.7)');
                gradient.addColorStop(1, 'rgba(10, 10, 20, 0.9)');
                
                this.conductorCtx.fillStyle = gradient;
                this.conductorCtx.fillRect(0, 0, this.conductorCanvas.width, this.conductorCanvas.height);
                
                // Рисуем частицы на фоне
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * this.conductorCanvas.width;
                    const y = Math.random() * this.conductorCanvas.height;
                    const size = Math.random() * 2 + 1;
                    
                    this.conductorCtx.beginPath();
                    this.conductorCtx.arc(x, y, size, 0, Math.PI * 2);
                    this.conductorCtx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.1})`;
                    this.conductorCtx.fill();
                }
                
                // Рисуем линию трансформации
                this.conductorCtx.beginPath();
                this.conductorCtx.moveTo(this.conductorCanvas.width * 0.2, this.conductorCanvas.height * 0.5);
                this.conductorCtx.lineTo(this.conductorCanvas.width * 0.8, this.conductorCanvas.height * 0.5);
                this.conductorCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.conductorCtx.lineWidth = 2;
                this.conductorCtx.stroke();
                
                // Рисуем точки на линии
                const sourceColor = this.state.sourceType === 'emotion' ? 
                    this.emotions[this.state.sourceValue].color : 
                    '#FFFFFF';
                
                const targetColor = this.state.targetType === 'emotion' ? 
                    this.emotions[this.state.targetValue].color : 
                    '#FFFFFF';
                
                // Точка источника
                this.conductorCtx.beginPath();
                this.conductorCtx.arc(this.conductorCanvas.width * 0.2, this.conductorCanvas.height * 0.5, 10, 0, Math.PI * 2);
                this.conductorCtx.fillStyle = sourceColor;
                this.conductorCtx.fill();
                
                // Точка цели
                this.conductorCtx.beginPath();
                this.conductorCtx.arc(this.conductorCanvas.width * 0.8, this.conductorCanvas.height * 0.5, 10, 0, Math.PI * 2);
                this.conductorCtx.fillStyle = targetColor;
                this.conductorCtx.fill();
                
                // Текст
                this.conductorCtx.fillStyle = '#FFFFFF';
                this.conductorCtx.font = '14px sans-serif';
                this.conductorCtx.textAlign = 'center';
                
                // Метки источника и цели
                const sourceName = this.state.sourceType === 'emotion' ? 
                    this.emotions[this.state.sourceValue].name : 
                    this.mathStructures[this.state.sourceValue].name;
                
                const targetName = this.state.targetType === 'emotion' ? 
                    this.emotions[this.state.targetValue].name : 
                    this.mathStructures[this.state.targetValue].name;
                
                this.conductorCtx.fillText(sourceName, this.conductorCanvas.width * 0.2, this.conductorCanvas.height * 0.5 - 20);
                this.conductorCtx.fillText(targetName, this.conductorCanvas.width * 0.8, this.conductorCanvas.height * 0.5 - 20);
                
                // Центральный текст
                this.conductorCtx.font = '16px sans-serif';
                this.conductorCtx.fillText('Нажмите "Трансформировать" для начала преобразования', 
                    this.conductorCanvas.width * 0.5, 
                    this.conductorCanvas.height * 0.5 + 30);
            }
            
            // Метод для запуска трансформации
            startTransformation() {
                // Останавливаем текущую анимацию, если она запущена
                if (this.state.animationFrame) {
                    cancelAnimationFrame(this.state.animationFrame);
                }
                
                // Устанавливаем флаг трансформации
                this.state.isTransforming = true;
                
                // Генерируем частицы
                this.generateTransformParticles();
                
                // Запускаем анимацию
                this.state.time = 0;
                this.animateTransformation();
            }
            
            // Метод для генерации частиц трансформации
            generateTransformParticles() {
                // Очищаем текущие частицы
                this.state.particles = [];
                
                // Количество частиц зависит от интенсивности и глубины
                const particleCount = Math.floor(100 + 200 * this.transformParams.intensity);
                
                // Получаем цвета источника и цели
                const sourceColor = this.state.sourceType === 'emotion' ? 
                    this.emotions[this.state.sourceValue].color : 
                    '#FFFFFF';
                
                const targetColor = this.state.targetType === 'emotion' ? 
                    this.emotions[this.state.targetValue].color : 
                    '#FFFFFF';
                
                // Создаем частицы
                for (let i = 0; i < particleCount; i++) {
                    // Начальное положение вокруг источника
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 30;
                    
                    const startX = this.conductorCanvas.width * 0.2 + Math.cos(angle) * distance;
                    const startY = this.conductorCanvas.height * 0.5 + Math.sin(angle) * distance;
                    
                    // Добавляем частицу
                    this.state.particles.push({
                        x: startX,
                        y: startY,
                        targetX: this.conductorCanvas.width * 0.8 + (Math.random() - 0.5) * 50,
                        targetY: this.conductorCanvas.height * 0.5 + (Math.random() - 0.5) * 50,
                        size: Math.random() * 3 + 1,
                        color: sourceColor,
                        targetColor: targetColor,
                        speed: Math.random() * 0.005 + 0.002,
                        progress: 0,
                        opacity: Math.random() * 0.5 + 0.3,
                        phase: Math.random() * Math.PI * 2,
                        amplitude: Math.random() * 50 * this.transformParams.depth
                    });
                }
            }
            
            // Метод для анимации трансформации
            animateTransformation() {
                // Инкрементируем время
                this.state.time += 0.01;
                
                // Отрисовываем текущее состояние
                this.drawTransformation();
                
                // Проверяем условие завершения
                if (this.state.particles.every(p => p.progress >= 1)) {
                    this.state.isTransforming = false;
                    return;
                }
                
                // Запускаем следующий кадр анимации
                this.state.animationFrame = requestAnimationFrame(this.animateTransformation.bind(this));
            }
            
            // Метод для отрисовки трансформации
            drawTransformation() {
                // Очищаем canvas
                this.conductorCtx.clearRect(0, 0, this.conductorCanvas.width, this.conductorCanvas.height);
                
                // Рисуем градиентный фон
                const gradient = this.conductorCtx.createLinearGradient(0, 0, this.conductorCanvas.width, this.conductorCanvas.height);
                gradient.addColorStop(0, 'rgba(30, 30, 60, 0.7)');
                gradient.addColorStop(1, 'rgba(10, 10, 20, 0.9)');
                
                this.conductorCtx.fillStyle = gradient;
                this.conductorCtx.fillRect(0, 0, this.conductorCanvas.width, this.conductorCanvas.height);
                
                // Рисуем линию трансформации
                this.conductorCtx.beginPath();
                this.conductorCtx.moveTo(this.conductorCanvas.width * 0.2, this.conductorCanvas.height * 0.5);
                this.conductorCtx.lineTo(this.conductorCanvas.width * 0.8, this.conductorCanvas.height * 0.5);
                this.conductorCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.conductorCtx.lineWidth = 2;
                this.conductorCtx.stroke();
                
                // Получаем цвета источника и цели
                const sourceColor = this.state.sourceType === 'emotion' ? 
                    this.emotions[this.state.sourceValue].color : 
                    '#FFFFFF';
                
                const targetColor = this.state.targetType === 'emotion' ? 
                    this.emotions[this.state.targetValue].color : 
                    '#FFFFFF';
                
                // Рисуем точки на линии
                
                // Точка источника
                this.conductorCtx.beginPath();
                this.conductorCtx.arc(this.conductorCanvas.width * 0.2, this.conductorCanvas.height * 0.5, 10, 0, Math.PI * 2);
                this.conductorCtx.fillStyle = sourceColor;
                this.conductorCtx.fill();
                
                // Точка цели
                this.conductorCtx.beginPath();
                this.conductorCtx.arc(this.conductorCanvas.width * 0.8, this.conductorCanvas.height * 0.5, 10, 0, Math.PI * 2);
                this.conductorCtx.fillStyle = targetColor;
                this.conductorCtx.fill();
                
                // Метки источника и цели
                this.conductorCtx.fillStyle = '#FFFFFF';
                this.conductorCtx.font = '14px sans-serif';
                this.conductorCtx.textAlign = 'center';
                
                const sourceName = this.state.sourceType === 'emotion' ? 
                    this.emotions[this.state.sourceValue].name : 
                    this.mathStructures[this.state.sourceValue].name;
                
                const targetName = this.state.targetType === 'emotion' ? 
                    this.emotions[this.state.targetValue].name : 
                    this.mathStructures[this.state.targetValue].name;
                
                this.conductorCtx.fillText(sourceName, this.conductorCanvas.width * 0.2, this.conductorCanvas.height * 0.5 - 20);
                this.conductorCtx.fillText(targetName, this.conductorCanvas.width * 0.8, this.conductorCanvas.height * 0.5 - 20);
                
                // Обновляем и рисуем частицы
                for (const particle of this.state.particles) {
                    // Обновляем прогресс
                    if (this.state.isTransforming && particle.progress < 1) {
                        particle.progress += particle.speed;
                    }
                    
                    // Интерполируем цвет
                    const color = this.interpolateColors(particle.color, particle.targetColor, particle.progress);
                    
                    // Вычисляем текущее положение с синусоидальным отклонением
                    const baseX = this.conductorCanvas.width * 0.2 + (this.conductorCanvas.width * 0.6) * particle.progress;
                    const baseY = this.conductorCanvas.height * 0.5;
                    
                    const phase = particle.phase + this.state.time * 2;
                    const offsetY = Math.sin(phase) * particle.amplitude * Math.sin(Math.PI * particle.progress);
                    
                    const x = baseX;
                    const y = baseY + offsetY;
                    
                    // Рисуем частицу
                    this.conductorCtx.beginPath();
                    this.conductorCtx.arc(x, y, particle.size, 0, Math.PI * 2);
                    this.conductorCtx.fillStyle = `rgba(${this.hexToRgb(color)}, ${particle.opacity})`;
                    this.conductorCtx.fill();
                    
                    // Рисуем след
                    if (Math.random() < 0.1 && this.state.isTransforming) {
                        this.conductorCtx.beginPath();
                        this.conductorCtx.moveTo(x, y);
                        
                        const trailLength = Math.floor(Math.random() * 5) + 3;
                        
                        for (let i = 1; i <= trailLength; i++) {
                            const trailX = x - i * 5;
                            const trailPhase = phase - i * 0.2;
                            const trailOffsetY = Math.sin(trailPhase) * particle.amplitude * Math.sin(Math.PI * (particle.progress - i * 0.01));
                            const trailY = baseY + trailOffsetY;
                            
                            this.conductorCtx.lineTo(trailX, trailY);
                        }
                        
                        this.conductorCtx.strokeStyle = `rgba(${this.hexToRgb(color)}, ${particle.opacity * 0.3})`;
                        this.conductorCtx.lineWidth = particle.size / 2;
                        this.conductorCtx.stroke();
                    }
                }
            }
            
            // Метод для исследования пространства
            exploreSpace() {
                // В этом режиме мы исследуем несколько связанных трансформаций
                
                // Случайно выбираем несколько узлов для последовательной трансформации
                const pathLength = Math.floor(Math.random() * 3) + 3; // 3-5 узлов
                const path = [];
                
                // Начинаем с текущего источника
                path.push({
                    type: this.state.sourceType,
                    value: this.state.sourceValue
                });
                
                // Добавляем текущую цель
                path.push({
                    type: this.state.targetType,
                    value: this.state.targetValue
                });
                
                // Добавляем случайные узлы из сети для продолжения пути
                for (let i = 2; i < pathLength; i++) {
                    // Выбираем тип узла (эмоция или математика)
                    const type = Math.random() < 0.5 ? 'emotion' : 'math';
                    
                    // Выбираем случайное значение из доступных
                    const values = type === 'emotion' ? 
                        Object.keys(this.emotions) : 
                        Object.keys(this.mathStructures);
                    
                    const value = values[Math.floor(Math.random() * values.length)];
                    
                    // Добавляем узел в путь
                    path.push({ type, value });
                }
                
                // Устанавливаем текущий индекс пути
                this.state.currentPathIndex = 0;
                this.state.explorationPath = path;
                
                // Начинаем первое преобразование
                this.explorePath();
            }
            
            // Метод для исследования пути
            explorePath() {
                // Проверяем, завершен ли путь
                if (this.state.currentPathIndex >= this.state.explorationPath.length - 1) {
                    // Путь завершен, возвращаемся к нормальному режиму
                    this.state.explorationPath = null;
                    this.state.currentPathIndex = null;
                    return;
                }
                
                // Получаем текущий узел и следующий узел
                const currentNode = this.state.explorationPath[this.state.currentPathIndex];
                const nextNode = this.state.explorationPath[this.state.currentPathIndex + 1];
                
                // Устанавливаем источник и цель
                this.state.sourceType = currentNode.type;
                this.state.sourceValue = currentNode.value;
                this.state.targetType = nextNode.type;
                this.state.targetValue = nextNode.value;
                
                // Обновляем интерфейс
                document.getElementById('source-type').value = this.state.sourceType;
                this.updateSourceValueSelect();
                document.getElementById('source-value').value = this.state.sourceValue;
                
                document.getElementById('target-type').value = this.state.targetType;
                this.updateTargetValueSelect();
                document.getElementById('target-value').value = this.state.targetValue;
                
                // Обновляем информацию о преобразовании
                this.updateTransformationInfo();
                
                // Обновляем сетевую визуализацию
                this.drawNetwork();
                
                // Начинаем трансформацию
                this.startTransformation();
                
                // После завершения трансформации переходим к следующему шагу
                setTimeout(() => {
                    this.state.currentPathIndex++;
                    this.explorePath();
                }, 3000); // Задержка между трансформациями
            }
            
            // Вспомогательные методы
            
            // Метод для интерполяции цветов
            interpolateColors(color1, color2, factor) {
                // Преобразуем HEX в RGB
                const r1 = parseInt(color1.substring(1, 3), 16);
                const g1 = parseInt(color1.substring(3, 5), 16);
                const b1 = parseInt(color1.substring(5, 7), 16);
                
                const r2 = parseInt(color2.substring(1, 3), 16);
                const g2 = parseInt(color2.substring(3, 5), 16);
                const b2 = parseInt(color2.substring(5, 7), 16);
                
                // Интерполируем
                const r = Math.round(r1 + (r2 - r1) * factor);
                const g = Math.round(g1 + (g2 - g1) * factor);
                const b = Math.round(b1 + (b2 - b1) * factor);
                
                // Преобразуем обратно в HEX
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
            
            // Метод для преобразования HEX в RGB строку
            hexToRgb(hex) {
                const r = parseInt(hex.substring(1, 3), 16);
                const g = parseInt(hex.substring(3, 5), 16);
                const b = parseInt(hex.substring(5, 7), 16);
                
                return `${r}, ${g}, ${b}`;
            }
        }
        
        // Класс для профилей эмоционально-математического восприятия
        class PerceptionProfile {
            constructor() {
                // Инициализация canvas
                this.canvas = document.getElementById('profile-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                
                // Цвета эмоций
                this.emotionColors = {
                    joy: '#FFD700',
                    sadness: '#4682B4',
                    fear: '#800080',
                    anger: '#FF4500',
                    surprise: '#FF69B4'
                };
                
                // Параметры профиля восприятия
                this.profileDimensions = {
                    linearity: 0.5,      // 0 - линейное, 1 - нелинейное
                    structure: 0.4,      // 0 - структурное, 1 - хаотичное
                    continuity: 0.6,     // 0 - дискретное, 1 - непрерывное
                    determinism: 0.3,    // 0 - детерминистичное, 1 - случайное
                    abstraction: 0.7     // 0 - конкретное, 1 - абстрактное
                };
                
                // Темперамент профиля
                this.temperament = 'rational';
                
                // Матрица восприятия (связи между эмоциями и математическими структурами)
                this.perceptionMatrix = this.generateEmptyMatrix();
                
                // Текущее состояние
                this.state = {
                    isProfileGenerated: false,
                    particles: [],
                    time: 0,
                    animationFrame: null
                };
                
                // Инициализация обработчиков событий
                this.initEventListeners();
                
                // Начальная визуализация
                this.drawInitialState();
            }
            
            // Метод для изменения размеров canvas
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }
            
            // Создание пустой матрицы восприятия
            generateEmptyMatrix() {
                const emotions = ['joy', 'sadness', 'fear', 'anger', 'surprise'];
                const mathStructures = ['exponential', 'logarithmic', 'trigonometric', 'fractal', 'complex'];
                
                const matrix = {};
                
                emotions.forEach(emotion => {
                    matrix[emotion] = {};
                    
                    mathStructures.forEach(math => {
                        matrix[emotion][math] = 0;
                    });
                });
                
                return matrix;
            }
            
            // Инициализация обработчиков событий
            initEventListeners() {
                // Обработчики для слайдеров параметров
                document.querySelectorAll('.dimension-input').forEach(slider => {
                    slider.addEventListener('input', this.handleDimensionChange.bind(this));
                });
                
                // Обработчики для радио-кнопок темперамента
                document.querySelectorAll('input[name="temperament"]').forEach(radio => {
                    radio.addEventListener('change', this.handleTemperamentChange.bind(this));
                });
                
                // Обработчики для кнопок
                document.getElementById('generate-profile-button').addEventListener('click', this.generateProfile.bind(this));
                document.getElementById('reset-profile-button').addEventListener('click', this.resetProfile.bind(this));
                document.getElementById('randomize-profile-button').addEventListener('click', this.randomizeProfile.bind(this));
                
                // Обработчики для ячеек матрицы
                document.querySelectorAll('.matrix-cell').forEach(cell => {
                    cell.addEventListener('click', this.handleMatrixCellClick.bind(this));
                });
                
                // Обработчик изменения размера окна
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    if (this.state.isProfileGenerated) {
                        this.drawProfile();
                    } else {
                        this.drawInitialState();
                    }
                });
            }
            
            // Обработчик изменения значений параметров
            handleDimensionChange(event) {
                const dimension = event.target.dataset.dimension;
                const value = parseFloat(event.target.value);
                
                this.profileDimensions[dimension] = value;
            }
            
            // Обработчик изменения темперамента
            handleTemperamentChange(event) {
                this.temperament = event.target.value;
            }
            
            // Обработчик клика по ячейке матрицы
            handleMatrixCellClick(event) {
                const cell = event.target;
                const emotion = cell.dataset.emotion;
                const math = cell.dataset.math;
                
                // Циклически меняем значение связи (0 -> 0.3 -> 0.6 -> 0.9 -> 0)
                let currentValue = this.perceptionMatrix[emotion][math];
                
                if (currentValue < 0.1) {
                    currentValue = 0.3;
                } else if (currentValue < 0.4) {
                    currentValue = 0.6;
                } else if (currentValue < 0.7) {
                    currentValue = 0.9;
                } else {
                    currentValue = 0;
                }
                
                this.perceptionMatrix[emotion][math] = currentValue;
                
                // Обновляем визуальное отображение ячейки
                this.updateMatrixCell(cell, currentValue);
                
                // Если профиль уже сгенерирован, обновляем его
                if (this.state.isProfileGenerated) {
                    this.updateProfile();
                }
            }
            
            // Обновление визуального отображения ячейки матрицы
            updateMatrixCell(cell, value) {
                const emotion = cell.dataset.emotion;
                const color = this.emotionColors[emotion];
                
                cell.style.backgroundColor = `rgba(${this.hexToRgb(color)}, ${value})`;
            }
            
            // Метод для генерации профиля
            generateProfile() {
                // Генерируем матрицу восприятия, если она пуста
                if (this.isMatrixEmpty()) {
                    this.generatePerceptionMatrix();
                }
                
                // Обновляем визуальное отображение матрицы
                this.updatePerceptionMatrix();
                
                // Генерируем описание профиля
                this.generateProfileDescription();
                
                // Генерируем частицы для визуализации
                this.generateProfileParticles();
                
                // Устанавливаем флаг сгенерированного профиля
                this.state.isProfileGenerated = true;
                
                // Запускаем анимацию
                if (this.state.animationFrame) {
                    cancelAnimationFrame(this.state.animationFrame);
                }
                
                this.state.time = 0;
                this.animateProfile();
            }
            
            // Проверка, пуста ли матрица восприятия
            isMatrixEmpty() {
                for (const emotion in this.perceptionMatrix) {
                    for (const math in this.perceptionMatrix[emotion]) {
                        if (this.perceptionMatrix[emotion][math] > 0) {
                            return false;
                        }
                    }
                }
                
                return true;
            }
            
            // Генерация матрицы восприятия на основе параметров профиля
            generatePerceptionMatrix() {
                const emotions = ['joy', 'sadness', 'fear', 'anger', 'surprise'];
                const mathStructures = ['exponential', 'logarithmic', 'trigonometric', 'fractal', 'complex'];
                
                // Влияние темперамента на восприятие
                const temperamentInfluence = {
                    rational: {
                        exponential: 0.7,
                        logarithmic: 0.8,
                        trigonometric: 0.6,
                        fractal: 0.3,
                        complex: 0.5
                    },
                    intuitive: {
                        exponential: 0.5,
                        logarithmic: 0.7,
                        trigonometric: 0.8,
                        fractal: 0.6,
                        complex: 0.7
                    },
                    chaotic: {
                        exponential: 0.3,
                        logarithmic: 0.4,
                        trigonometric: 0.5,
                        fractal: 0.9,
                        complex: 0.8
                    },
                    harmonic: {
                        exponential: 0.6,
                        logarithmic: 0.5,
                        trigonometric: 0.9,
                        fractal: 0.7,
                        complex: 0.6
                    }
                };
                
                // Влияние эмоций на восприятие математических структур
                const emotionInfluence = {
                    joy: {
                        exponential: 0.8,
                        logarithmic: 0.5,
                        trigonometric: 0.7,
                        fractal: 0.6,
                        complex: 0.4
                    },
                    sadness: {
                        exponential: 0.3,
                        logarithmic: 0.8,
                        trigonometric: 0.5,
                        fractal: 0.7,
                        complex: 0.6
                    },
                    fear: {
                        exponential: 0.7,
                        logarithmic: 0.4,
                        trigonometric: 0.5,
                        fractal: 0.9,
                        complex: 0.7
                    },
                    anger: {
                        exponential: 0.9,
                        logarithmic: 0.3,
                        trigonometric: 0.6,
                        fractal: 0.5,
                        complex: 0.8
                    },
                    surprise: {
                        exponential: 0.6,
                        logarithmic: 0.5,
                        trigonometric: 0.8,
                        fractal: 0.8,
                        complex: 0.9
                    }
                };
                
                // Генерируем матрицу восприятия
                emotions.forEach(emotion => {
                    mathStructures.forEach(math => {
                        // Базовое значение связи
                        let value = (temperamentInfluence[this.temperament][math] + emotionInfluence[emotion][math]) / 2;
                        
                        // Влияние параметров профиля
                        // Линейность усиливает экспоненциальные и логарифмические связи
                        if (math === 'exponential' || math === 'logarithmic') {
                            value *= 1 - this.profileDimensions.linearity * 0.5;
                        }
                        
                        // Нелинейность усиливает фрактальные и комплексные связи
                        if (math === 'fractal' || math === 'complex') {
                            value *= 0.5 + this.profileDimensions.linearity * 0.5;
                        }
                        
                        // Структурность усиливает все связи в целом
                        value *= 1 - this.profileDimensions.structure * 0.3;
                        
                        // Непрерывность усиливает тригонометрические и комплексные связи
                        if (math === 'trigonometric' || math === 'complex') {
                            value *= 0.7 + this.profileDimensions.continuity * 0.3;
                        }
                        
                        // Случайность вносит некоторый шум
                        value += (Math.random() - 0.5) * this.profileDimensions.determinism * 0.4;
                        
                        // Абстрактность усиливает комплексные и фрактальные связи
                        if (math === 'complex' || math === 'fractal') {
                            value *= 0.7 + this.profileDimensions.abstraction * 0.3;
                        }
                        
                        // Нормализуем значение и округляем до ближайшего из 0, 0.3, 0.6, 0.9
                        value = Math.max(0, Math.min(1, value));
                        
                        if (value < 0.15) {
                            value = 0;
                        } else if (value < 0.45) {
                            value = 0.3;
                        } else if (value < 0.75) {
                            value = 0.6;
                        } else {
                            value = 0.9;
                        }
                        
                        // Сохраняем значение в матрице
                        this.perceptionMatrix[emotion][math] = value;
                    });
                });
            }
            
            // Обновление визуального отображения матрицы восприятия
            updatePerceptionMatrix() {
                document.querySelectorAll('.matrix-cell').forEach(cell => {
                    const emotion = cell.dataset.emotion;
                    const math = cell.dataset.math;
                    const value = this.perceptionMatrix[emotion][math];
                    
                    this.updateMatrixCell(cell, value);
                });
            }
            
            // Генерация описания профиля
            generateProfileDescription() {
                // Вычисляем основные характеристики профиля
                const profileName = this.generateProfileName();
                const mainDescription = this.generateMainDescription();
                const analysisPoints = this.generateAnalysisPoints();
                
                // Обновляем отображение
                document.querySelector('.profile-name').textContent = profileName;
                document.querySelector('.profile-description').innerHTML = `<p>${mainDescription}</p>`;
                
                const analysisList = document.querySelector('.analysis-points');
                analysisList.innerHTML = '';
                
                analysisPoints.forEach(point => {
                    const li = document.createElement('li');
                    li.textContent = point;
                    analysisList.appendChild(li);
                });
            }
            
            // Генерация названия профиля
            generateProfileName() {
                // Определяем доминирующие характеристики
                const dominantDimensions = this.getDominantDimensions();
                const dominantConnections = this.getDominantConnections();
                
                // Создаем название на основе характеристик
                let name = '';
                
                // Добавляем префикс на основе темперамента
                switch (this.temperament) {
                    case 'rational':
                        name += 'Рациональный ';
                        break;
                    case 'intuitive':
                        name += 'Интуитивный ';
                        break;
                    case 'chaotic':
                        name += 'Хаотичный ';
                        break;
                    case 'harmonic':
                        name += 'Гармоничный ';
                        break;
                }
                
                // Добавляем корень на основе доминирующей размерности
                if (dominantDimensions.includes('linearity') && this.profileDimensions.linearity > 0.7) {
                    name += 'нелинейный ';
                } else if (dominantDimensions.includes('linearity') && this.profileDimensions.linearity < 0.3) {
                    name += 'линейный ';
                }
                
                if (dominantDimensions.includes('structure') && this.profileDimensions.structure > 0.7) {
                    name += 'дисгармоничный ';
                } else if (dominantDimensions.includes('structure') && this.profileDimensions.structure < 0.3) {
                    name += 'структурированный ';
                }
                
                // Добавляем суффикс на основе доминирующих связей
                if (dominantConnections.emotion === 'joy') {
                    name += 'оптимист';
                } else if (dominantConnections.emotion === 'sadness') {
                    name += 'меланхолик';
                } else if (dominantConnections.emotion === 'fear') {
                    name += 'тревожный аналитик';
                } else if (dominantConnections.emotion === 'anger') {
                    name += 'динамичный активист';
                } else if (dominantConnections.emotion === 'surprise') {
                    name += 'исследователь';
                }
                
                // Дополняем название на основе доминирующей математической структуры
                if (dominantConnections.math === 'exponential') {
                    name += ' экспоненциального восприятия';
                } else if (dominantConnections.math === 'logarithmic') {
                    name += ' логарифмического восприятия';
                } else if (dominantConnections.math === 'trigonometric') {
                    name += ' волнового восприятия';
                } else if (dominantConnections.math === 'fractal') {
                    name += ' фрактального восприятия';
                } else if (dominantConnections.math === 'complex') {
                    name += ' многомерного восприятия';
                }
                
                return name;
            }
            
            // Получение доминирующих размерностей
            getDominantDimensions() {
                const dimensions = [];
                
                // Проверяем каждую размерность
                for (const dimension in this.profileDimensions) {
                    const value = this.profileDimensions[dimension];
                    
                    // Если значение экстремальное (близко к 0 или 1), добавляем размерность
                    if (value > 0.7 || value < 0.3) {
                        dimensions.push(dimension);
                    }
                }
                
                return dimensions;
            }
            
            // Получение доминирующих связей
            getDominantConnections() {
                let maxValue = 0;
                let dominantEmotion = '';
                let dominantMath = '';
                
                // Вычисляем суммарную силу связей для каждой эмоции и математической структуры
                const emotionStrength = {};
                const mathStrength = {};
                
                for (const emotion in this.perceptionMatrix) {
                    emotionStrength[emotion] = 0;
                    
                    for (const math in this.perceptionMatrix[emotion]) {
                        const value = this.perceptionMatrix[emotion][math];
                        
                        emotionStrength[emotion] += value;
                        
                        if (!(math in mathStrength)) {
                            mathStrength[math] = 0;
                        }
                        
                        mathStrength[math] += value;
                        
                        // Проверяем, является ли эта связь максимальной
                        if (value > maxValue) {
                            maxValue = value;
                            dominantEmotion = emotion;
                            dominantMath = math;
                        }
                    }
                }
                
                // Находим доминирующую эмоцию и математическую структуру
                let maxEmotionStrength = 0;
                let maxMathStrength = 0;
                
                for (const emotion in emotionStrength) {
                    if (emotionStrength[emotion] > maxEmotionStrength) {
                        maxEmotionStrength = emotionStrength[emotion];
                        dominantEmotion = emotion;
                    }
                }
                
                for (const math in mathStrength) {
                    if (mathStrength[math] > maxMathStrength) {
                        maxMathStrength = mathStrength[math];
                        dominantMath = math;
                    }
                }
                
                return {
                    emotion: dominantEmotion,
                    math: dominantMath
                };
            }
            
            // Генерация основного описания профиля
            generateMainDescription() {
                // Определяем доминирующие характеристики
                const dominantDimensions = this.getDominantDimensions();
                const dominantConnections = this.getDominantConnections();
                
                // Базовое описание в зависимости от темперамента
                let description = '';
                
                switch (this.temperament) {
                    case 'rational':
                        description = 'Ваш профиль восприятия характеризуется рациональным подходом к пониманию эмоционально-математических связей. ';
                        break;
                    case 'intuitive':
                        description = 'Вы обладаете интуитивным восприятием эмоционально-математических связей, видя целостные паттерны и взаимосвязи. ';
                        break;
                    case 'chaotic':
                        description = 'Ваш профиль отличается хаотичным, нелинейным восприятием, способным находить неожиданные связи между эмоциями и математическими структурами. ';
                        break;
                    case 'harmonic':
                        description = 'Вы обладаете гармоничным восприятием, стремящимся к балансу и симметрии в эмоционально-математических связях. ';
                        break;
                }
                
                // Дополняем описание на основе доминирующих размерностей
                if (dominantDimensions.includes('linearity')) {
                    if (this.profileDimensions.linearity > 0.7) {
                        description += 'Вы предпочитаете нелинейные, сложные структуры и отношения, находя в них глубокий смысл. ';
                    } else if (this.profileDimensions.linearity < 0.3) {
                        description += 'Вы тяготеете к линейным, последовательным структурам, ценя ясность и предсказуемость. ';
                    }
                }
                
                if (dominantDimensions.includes('structure')) {
                    if (this.profileDimensions.structure > 0.7) {
                        description += 'Хаотичность и спонтанность являются важными аспектами вашего восприятия, позволяя видеть нестандартные связи. ';
                    } else if (this.profileDimensions.structure < 0.3) {
                        description += 'Вы предпочитаете структурированные, упорядоченные паттерны, находя в них особую красоту и значение. ';
                    }
                }
                
                if (dominantDimensions.includes('continuity')) {
                    if (this.profileDimensions.continuity > 0.7) {
                        description += 'Непрерывность и плавность переходов особенно важны в вашем восприятии, создавая целостные образы. ';
                    } else if (this.profileDimensions.continuity < 0.3) {
                        description += 'Вы воспринимаете дискретные, четко разграниченные структуры, обращая внимание на детали и различия. ';
                    }
                }
                
                // Дополняем описание на основе доминирующих связей
                const emotionNames = {
                    joy: 'радость',
                    sadness: 'грусть',
                    fear: 'страх',
                    anger: 'гнев',
                    surprise: 'удивление'
                };
                
                const mathNames = {
                    exponential: 'экспоненциальные функции',
                    logarithmic: 'логарифмические функции',
                    trigonometric: 'тригонометрические функции',
                    fractal: 'фрактальные структуры',
                    complex: 'комплексные числа'
                };
                
                description += `В вашем профиле наиболее сильная связь проявляется между эмоцией "${emotionNames[dominantConnections.emotion]}" и математической структурой "${mathNames[dominantConnections.math]}". `;
                
                // Завершаем описание
                description += 'Этот уникальный паттерн восприятия формирует ваше индивидуальное понимание и интерпретацию эмоционально-математических соответствий.';
                
                return description;
            }
            
            // Генерация пунктов анализа профиля
            generateAnalysisPoints() {
                const points = [];
                
                // Доминирующие связи
                const dominantConnections = this.getDominantConnections();
                
                // Эмоциональный спектр
                let emotionalSpectrum = 'Эмоциональный спектр: ';
                let highEmotions = [];
                
                for (const emotion in this.perceptionMatrix) {
                    let totalStrength = 0;
                    
                    for (const math in this.perceptionMatrix[emotion]) {
                        totalStrength += this.perceptionMatrix[emotion][math];
                    }
                    
                    // Нормализуем значение
                    totalStrength /= Object.keys(this.perceptionMatrix[emotion]).length;
                    
                    if (totalStrength > 0.5) {
                        highEmotions.push(emotion);
                    }
                }
                
                if (highEmotions.length > 0) {
                    emotionalSpectrum += 'высокая восприимчивость к ';
                    
                    const emotionNames = {
                        joy: 'радости',
                        sadness: 'грусти',
                        fear: 'страху',
                        anger: 'гневу',
                        surprise: 'удивлению'
                    };
                    
                    emotionalSpectrum += highEmotions.map(emotion => emotionNames[emotion]).join(', ');
                } else {
                    emotionalSpectrum += 'сбалансированное восприятие эмоций';
                }
                
                points.push(emotionalSpectrum);
                
                // Математические предпочтения
                let mathPreferences = 'Математические предпочтения: ';
                let highMath = [];
                
                const mathStructures = ['exponential', 'logarithmic', 'trigonometric', 'fractal', 'complex'];
                
                for (const math of mathStructures) {
                    let totalStrength = 0;
                    
                    for (const emotion in this.perceptionMatrix) {
                        totalStrength += this.perceptionMatrix[emotion][math];
                    }
                    
                    // Нормализуем значение
                    totalStrength /= Object.keys(this.perceptionMatrix).length;
                    
                    if (totalStrength > 0.5) {
                        highMath.push(math);
                    }
                }
                
                if (highMath.length > 0) {
                    mathPreferences += 'особая чувствительность к ';
                    
                    const mathNames = {
                        exponential: 'экспоненциальным функциям',
                        logarithmic: 'логарифмическим функциям',
                        trigonometric: 'тригонометрическим функциям',
                        fractal: 'фрактальным структурам',
                        complex: 'комплексным числам'
                    };
                    
                    mathPreferences += highMath.map(math => mathNames[math]).join(', ');
                } else {
                    mathPreferences += 'равномерное восприятие математических структур';
                }
                
                points.push(mathPreferences);
                
                // Дополнительная характеристика
                let additionalPoint = '';
                
                // Выбираем характеристику на основе параметров профиля
                if (this.profileDimensions.linearity > 0.7 && this.profileDimensions.structure > 0.7) {
                    additionalPoint = 'Нелинейное хаотичное мышление: способность видеть эмерджентные свойства и скрытые связи';
                } else if (this.profileDimensions.linearity < 0.3 && this.profileDimensions.structure < 0.3) {
                    additionalPoint = 'Линейное структурированное мышление: способность к последовательному анализу и систематизации';
                } else if (this.profileDimensions.abstraction > 0.7 && this.profileDimensions.continuity > 0.7) {
                    additionalPoint = 'Абстрактное непрерывное восприятие: способность к глубоким обобщениям и целостному видению';
                } else if (this.profileDimensions.determinism < 0.3 && this.profileDimensions.abstraction < 0.3) {
                    additionalPoint = 'Детерминистическое конкретное мышление: способность выявлять причинно-следственные связи в физических явлениях';
                } else {
                    // Случайная характеристика для других комбинаций
                    const characteristics = [
                        'Синтетический тип мышления: способность объединять разрозненные элементы в единую систему',
                        'Аналитический тип восприятия: склонность к детальному исследованию компонентов',
                        'Метафорическое мышление: способность видеть аналогии между разными областями',
                        'Символическое восприятие: чувствительность к глубинным архетипам и паттернам'
                    ];
                    
                    additionalPoint = characteristics[Math.floor(Math.random() * characteristics.length)];
                }
                
                points.push(additionalPoint);
                
                return points;
            }
            
            // Генерация частиц для визуализации профиля
            generateProfileParticles() {
                // Очищаем текущие частицы
                this.state.particles = [];
                
                // Количество частиц зависит от силы связей в матрице
                let totalStrength = 0;
                let particleCount = 0;
                
                for (const emotion in this.perceptionMatrix) {
                    for (const math in this.perceptionMatrix[emotion]) {
                        totalStrength += this.perceptionMatrix[emotion][math];
                    }
                }
                
                particleCount = Math.floor(100 + totalStrength * 400);
                
                // Создаем частицы
                for (let i = 0; i < particleCount; i++) {
                    // Выбираем случайную эмоцию и математическую структуру
                    const emotions = Object.keys(this.perceptionMatrix);
                    const mathStructures = Object.keys(this.perceptionMatrix[emotions[0]]);
                    
                    const emotion = emotions[Math.floor(Math.random() * emotions.length)];
                    const math = mathStructures[Math.floor(Math.random() * mathStructures.length)];
                    
                    // Сила связи определяет вероятность создания частицы
                    const strength = this.perceptionMatrix[emotion][math];
                    
                    if (Math.random() > strength * 0.8) {
                        // Пропускаем создание частицы для слабых связей
                        continue;
                    }
                    
                    // Параметры частицы зависят от профиля восприятия
                    const linearity = this.profileDimensions.linearity;
                    const structure = this.profileDimensions.structure;
                    const continuity = this.profileDimensions.continuity;
                    const determinism = this.profileDimensions.determinism;
                    const abstraction = this.profileDimensions.abstraction;
                    
                    // Создаем частицу
                    const particle = {
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 3 + 1,
                        color: this.emotionColors[emotion],
                        emotion: emotion,
                        math: math,
                        speed: Math.random() * 0.5 + 0.2,
                        direction: Math.random() * Math.PI * 2,
                        amplitude: 10 + Math.random() * 20 * continuity,
                        frequency: 0.01 + Math.random() * 0.05 * (1 - linearity),
                        phase: Math.random() * Math.PI * 2,
                        opacity: 0.3 + Math.random() * 0.5,
                        lifespan: 100 + Math.random() * 200 * (1 - structure),
                        age: 0,
                        turbulence: Math.random() * structure * 0.1,
                        complexity: Math.random() * abstraction * 0.2,
                        randomness: Math.random() * determinism * 0.1
                    };
                    
                    // Добавляем частицу
                    this.state.particles.push(particle);
                }
            }
            
            // Обновление профиля
            updateProfile() {
                // Обновляем описание профиля
                this.generateProfileDescription();
                
                // Регенерируем частицы
                this.generateProfileParticles();
                
                // Перезапускаем анимацию, если она уже была запущена
                if (this.state.isProfileGenerated) {
                    if (this.state.animationFrame) {
                        cancelAnimationFrame(this.state.animationFrame);
                    }
                    
                    this.state.time = 0;
                    this.animateProfile();
                }
            }
            
            // Метод для сброса профиля
            resetProfile() {
                // Сбрасываем параметры профиля
                this.profileDimensions = {
                    linearity: 0.5,
                    structure: 0.4,
                    continuity: 0.6,
                    determinism: 0.3,
                    abstraction: 0.7
                };
                
                // Сбрасываем темперамент
                this.temperament = 'rational';
                document.getElementById('temperament-rational').checked = true;
                
                // Сбрасываем матрицу восприятия
                this.perceptionMatrix = this.generateEmptyMatrix();
                
                // Обновляем визуальное отображение матрицы
                document.querySelectorAll('.matrix-cell').forEach(cell => {
                    this.updateMatrixCell(cell, 0);
                });
                
                // Обновляем слайдеры
                document.querySelectorAll('.dimension-input').forEach(slider => {
                    const dimension = slider.dataset.dimension;
                    slider.value = this.profileDimensions[dimension];
                });
                
                // Сбрасываем состояние
                this.state.isProfileGenerated = false;
                
                // Останавливаем анимацию, если она запущена
                if (this.state.animationFrame) {
                    cancelAnimationFrame(this.state.animationFrame);
                    this.state.animationFrame = null;
                }
                
                // Сбрасываем описание
                document.querySelector('.profile-name').textContent = 'Профиль восприятия';
                document.querySelector('.profile-description').innerHTML = '<p>Настройте параметры и нажмите "Сгенерировать профиль" для создания индивидуального профиля эмоционально-математического восприятия.</p>';
                
                const analysisList = document.querySelector('.analysis-points');
                analysisList.innerHTML = '';
                analysisList.innerHTML = `
                    <li>Определите параметры своего восприятия</li>
                    <li>Исследуйте соответствия между эмоциями и математическими структурами</li>
                    <li>Наблюдайте как изменения параметров влияют на визуализацию</li>
                `;
                
                // Рисуем начальное состояние
                this.drawInitialState();
            }
            
            // Метод для случайной генерации параметров
            randomizeProfile() {
                // Генерируем случайные значения параметров
                for (const dimension in this.profileDimensions) {
                    this.profileDimensions[dimension] = Math.random();
                }
                
                // Генерируем случайный темперамент
                const temperaments = ['rational', 'intuitive', 'chaotic', 'harmonic'];
                this.temperament = temperaments[Math.floor(Math.random() * temperaments.length)];
                
                // Обновляем слайдеры
                document.querySelectorAll('.dimension-input').forEach(slider => {
                    const dimension = slider.dataset.dimension;
                    slider.value = this.profileDimensions[dimension];
                });
                
                // Обновляем радио-кнопки темперамента
                document.getElementById(`temperament-${this.temperament}`).checked = true;
                
                // Генерируем случайную матрицу восприятия
                for (const emotion in this.perceptionMatrix) {
                    for (const math in this.perceptionMatrix[emotion]) {
                        // Случайное значение: 0, 0.3, 0.6 или 0.9
                        const values = [0, 0.3, 0.6, 0.9];
                        this.perceptionMatrix[emotion][math] = values[Math.floor(Math.random() * values.length)];
                    }
                }
                
                // Обновляем визуальное отображение матрицы
                this.updatePerceptionMatrix();
            }
            
            // Метод для анимации профиля
            animateProfile() {
                // Инкрементируем время
                this.state.time += 0.01;
                
                // Обновляем и рисуем профиль
                this.drawProfile();
                
                // Запускаем следующий кадр анимации
                this.state.animationFrame = requestAnimationFrame(this.animateProfile.bind(this));
            }
            
            // Метод для отрисовки начального состояния
            drawInitialState() {
                // Очищаем canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Рисуем градиентный фон
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, 'rgba(30, 30, 80, 0.7)');
                gradient.addColorStop(1, 'rgba(10, 10, 30, 0.9)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Рисуем звездный фон
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    const size = Math.random() * 2 + 1;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.7 + 0.1})`;
                    this.ctx.fill();
                }
                
                // Рисуем центральный текст
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.font = '18px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                this.ctx.fillText('Настройте параметры и нажмите "Сгенерировать профиль"', 
                    this.canvas.width / 2, 
                    this.canvas.height / 2);
                
                // Рисуем пунктирную окружность в центре
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                
                this.ctx.beginPath();
                this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, 100, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.setLineDash([]); // Сбрасываем пунктирную линию
            }
            
            // Метод для отрисовки профиля
            drawProfile() {
                // Очищаем canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Рисуем градиентный фон
                const gradient = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 10,
                    this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height) / 1.5
                );
                
                // Цвет градиента зависит от доминирующей эмоции
                const dominantConnections = this.getDominantConnections();
                const dominantColor = this.emotionColors[dominantConnections.emotion];
                
                gradient.addColorStop(0, `rgba(${this.hexToRgb(dominantColor)}, 0.1)`);
                gradient.addColorStop(1, 'rgba(10, 10, 30, 0.9)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Рисуем сетку восприятия в зависимости от параметров профиля
                this.drawPerceptionGrid();
                
                // Обновляем и рисуем частицы
                this.updateAndDrawParticles();
                
                // Рисуем дополнительные эффекты
                this.drawProfileEffects();
            }
            
            // Метод для отрисовки сетки восприятия
            drawPerceptionGrid() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = Math.min(this.canvas.width, this.canvas.height) / 3;
                
                // Параметры сетки зависят от профиля восприятия
                const linearity = this.profileDimensions.linearity;
                const structure = this.profileDimensions.structure;
                const continuity = this.profileDimensions.continuity;
                
                // Цвет сетки зависит от темперамента
                let gridColor = 'rgba(255, 255, 255, 0.2)';
                
                switch (this.temperament) {
                    case 'rational':
                        gridColor = 'rgba(200, 255, 255, 0.2)';
                        break;
                    case 'intuitive':
                        gridColor = 'rgba(255, 200, 255, 0.2)';
                        break;
                    case 'chaotic':
                        gridColor = 'rgba(255, 100, 100, 0.2)';
                        break;
                    case 'harmonic':
                        gridColor = 'rgba(100, 255, 200, 0.2)';
                        break;
                }
                
                this.ctx.strokeStyle = gridColor;
                this.ctx.lineWidth = 1;
                
                // Рисуем концентрические круги
                const circleCount = Math.floor(3 + structure * 5);
                
                for (let i = 1; i <= circleCount; i++) {
                    const r = (radius * i) / circleCount;
                    
                    this.ctx.beginPath();
                    
                    if (linearity < 0.5) {
                        // Более линейная сетка: правильные круги
                        this.ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                    } else {
                        // Более нелинейная сетка: деформированные круги
                        const points = 50;
                        
                        for (let j = 0; j <= points; j++) {
                            const angle = (j / points) * Math.PI * 2;
                            
                            // Деформация зависит от linearity
                            const deformation = 1 + Math.sin(angle * 3 + this.state.time) * linearity * 0.3;
                            
                            const x = centerX + Math.cos(angle) * r * deformation;
                            const y = centerY + Math.sin(angle) * r * deformation;
                            
                            if (j === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                    }
                    
                    this.ctx.stroke();
                }
                
                // Рисуем радиальные линии
                const lineCount = Math.floor(6 + structure * 10);
                
                for (let i = 0; i < lineCount; i++) {
                    const angle = (i / lineCount) * Math.PI * 2;
                    
                    this.ctx.beginPath();
                    
                    if (continuity < 0.5) {
                        // Более дискретная сетка: прямые линии
                        this.ctx.moveTo(centerX, centerY);
                        this.ctx.lineTo(
                            centerX + Math.cos(angle) * radius,
                            centerY + Math.sin(angle) * radius
                        );
                    } else {
                        // Более непрерывная сетка: волнистые линии
                        this.ctx.moveTo(centerX, centerY);
                        
                        const points = 20;
                        
                        for (let j = 1; j <= points; j++) {
                            const r = (radius * j) / points;
                            
                            // Волнистость зависит от continuity
                            const waveAngle = angle + Math.sin(r * 0.1 + this.state.time) * continuity * 0.2;
                            
                            const x = centerX + Math.cos(waveAngle) * r;
                            const y = centerY + Math.sin(waveAngle) * r;
                            
                            this.ctx.lineTo(x, y);
                        }
                    }
                    
                    this.ctx.stroke();
                }
            }
            
            // Метод для обновления и отрисовки частиц
            updateAndDrawParticles() {
                const newParticles = [];
                
                for (const particle of this.state.particles) {
                    // Обновляем возраст частицы
                    particle.age++;
                    
                    // Проверяем, не истек ли срок жизни частицы
                    if (particle.age > particle.lifespan) {
                        continue;
                    }
                    
                    // Обновляем позицию частицы в зависимости от ее математического типа
                    switch (particle.math) {
                        case 'exponential':
                            this.updateExponentialParticle(particle);
                            break;
                        case 'logarithmic':
                            this.updateLogarithmicParticle(particle);
                            break;
                        case 'trigonometric':
                            this.updateTrigonometricParticle(particle);
                            break;
                        case 'fractal':
                            this.updateFractalParticle(particle);
                            break;
                        case 'complex':
                            this.updateComplexParticle(particle);
                            break;
                    }
                    
                    // Добавляем случайное отклонение в зависимости от randomness
                    particle.x += (Math.random() - 0.5) * particle.randomness * 10;
                    particle.y += (Math.random() - 0.5) * particle.randomness * 10;
                    
                    // Проверяем границы
                    if (particle.x < 0) particle.x = this.canvas.width;
                    if (particle.x > this.canvas.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.canvas.height;
                    if (particle.y > this.canvas.height) particle.y = 0;
                    
                    // Вычисляем прозрачность в зависимости от возраста
                    const lifeProgress = particle.age / particle.lifespan;
                    const alpha = lifeProgress < 0.2 ? 
                        lifeProgress * 5 * particle.opacity : 
                        (1 - lifeProgress) * 1.25 * particle.opacity;
                    
                    // Рисуем частицу
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fillStyle = `rgba(${this.hexToRgb(particle.color)}, ${alpha})`;
                    this.ctx.fill();
                    
                    // Рисуем след для некоторых частиц
                    if (Math.random() < 0.3 * this.profileDimensions.continuity) {
                        const trailLength = Math.floor(Math.random() * 5) + 3;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(particle.x, particle.y);
                        
                        for (let i = 1; i <= trailLength; i++) {
                            const distance = i * particle.size * 2;
                            const angle = particle.direction - Math.PI; // След в противоположном направлении
                            
                            const trailX = particle.x + Math.cos(angle) * distance;
                            const trailY = particle.y + Math.sin(angle) * distance;
                            
                            this.ctx.lineTo(trailX, trailY);
                        }
                        
                        this.ctx.strokeStyle = `rgba(${this.hexToRgb(particle.color)}, ${alpha * 0.3})`;
                        this.ctx.lineWidth = particle.size / 2;
                        this.ctx.stroke();
                    }
                    
                    // Сохраняем частицу для следующего кадра
                    newParticles.push(particle);
                }
                
                // Обновляем список частиц
                this.state.particles = newParticles;
                
                // Добавляем новые частицы, если их количество уменьшилось
                const targetParticleCount = this.state.particles.length * 1.1;
                
                if (this.state.particles.length < targetParticleCount) {
                    this.addNewParticles(Math.ceil(targetParticleCount - this.state.particles.length));
                }
            }
            
            // Методы для обновления различных типов частиц
            updateExponentialParticle(particle) {
                // Экспоненциальное движение: ускорение
                particle.speed *= 1.002;
                
                // Ограничиваем максимальную скорость
                if (particle.speed > 2) {
                    particle.speed = 0.5;
                }
                
                // Обновляем позицию
                particle.x += Math.cos(particle.direction) * particle.speed;
                particle.y += Math.sin(particle.direction) * particle.speed;
                
                // Небольшое изменение направления
                particle.direction += (Math.random() - 0.5) * 0.1 * particle.turbulence;
            }
            
            updateLogarithmicParticle(particle) {
                // Логарифмическое движение: замедление
                particle.speed *= 0.998;
                
                // Минимальная скорость
                if (particle.speed < 0.1) {
                    particle.speed = 0.1;
                }
                
                // Обновляем позицию
                particle.x += Math.cos(particle.direction) * particle.speed;
                particle.y += Math.sin(particle.direction) * particle.speed;
                
                // Плавное изменение направления
                particle.direction += Math.sin(this.state.time * 0.5) * 0.03 * particle.turbulence;
            }
            
            updateTrigonometricParticle(particle) {
                // Тригонометрическое движение: волновое
                const time = this.state.time * particle.frequency;
                
                // Обновляем позицию
                particle.x += Math.cos(particle.direction) * particle.speed;
                particle.y += Math.sin(particle.direction) * particle.speed + Math.sin(time + particle.phase) * particle.amplitude * 0.03;
                
                // Волнообразное изменение направления
                particle.direction += Math.sin(time * 2) * 0.05 * particle.turbulence;
            }
            
            updateFractalParticle(particle) {
                // Фрактальное движение: самоподобное
                const time = this.state.time * 0.5;
                
                // Используем несколько наложенных синусоид для имитации фрактальности
                const fractalX = Math.sin(time) * Math.sin(time * 1.5) * Math.sin(time * 2.3) * particle.amplitude * 0.1;
                const fractalY = Math.cos(time) * Math.cos(time * 1.7) * Math.cos(time * 2.1) * particle.amplitude * 0.1;
                
                // Обновляем позицию
                particle.x += fractalX * particle.complexity;
                particle.y += fractalY * particle.complexity;
                
                // Дополнительное базовое движение
                particle.x += Math.cos(particle.direction) * particle.speed;
                particle.y += Math.sin(particle.direction) * particle.speed;
                
                // Хаотичное изменение направления
                particle.direction += (Math.random() - 0.5) * 0.2 * particle.turbulence;
            }
            
            updateComplexParticle(particle) {
                // Движение в комплексной плоскости
                const time = this.state.time * 0.5;
                
                // Центр канваса
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Расстояние и угол от центра
                const dx = particle.x - centerX;
                const dy = particle.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                // Вращение с изменением расстояния
                const newAngle = angle + particle.speed * 0.01;
                const newDistance = distance + Math.sin(time * particle.frequency + particle.phase) * 0.5;
                
                // Обновляем позицию
                particle.x = centerX + Math.cos(newAngle) * newDistance;
                particle.y = centerY + Math.sin(newAngle) * newDistance;
                
                // Обновляем направление
                particle.direction = newAngle + Math.PI / 2;
            }
            
            // Метод для добавления новых частиц
            addNewParticles(count) {
                // Выбираем случайные эмоции и математические структуры с учетом матрицы восприятия
                const emotions = Object.keys(this.perceptionMatrix);
                const mathStructures = Object.keys(this.perceptionMatrix[emotions[0]]);
                
                // Создаем частицы
                for (let i = 0; i < count; i++) {
                    // Вес для каждой комбинации эмоции и математической структуры
                    const weights = [];
                    const combinations = [];
                    
                    for (const emotion of emotions) {
                        for (const math of mathStructures) {
                            weights.push(this.perceptionMatrix[emotion][math]);
                            combinations.push({ emotion, math });
                        }
                    }
                    
                    // Нормализуем веса
                    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                    const normalizedWeights = weights.map(weight => weight / totalWeight);
                    
                    // Выбираем комбинацию с учетом весов
                    let randomValue = Math.random();
                    let selectedIndex = 0;
                    let cumulativeWeight = 0;
                    
                    for (let j = 0; j < normalizedWeights.length; j++) {
                        cumulativeWeight += normalizedWeights[j];
                        
                        if (randomValue <= cumulativeWeight) {
                            selectedIndex = j;
                            break;
                        }
                    }
                    
                    const selectedCombination = combinations[selectedIndex];
                    
                    // Параметры профиля восприятия
                    const linearity = this.profileDimensions.linearity;
                    const structure = this.profileDimensions.structure;
                    const continuity = this.profileDimensions.continuity;
                    const determinism = this.profileDimensions.determinism;
                    const abstraction = this.profileDimensions.abstraction;
                    
                    // Создаем частицу
                    const particle = {
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 3 + 1,
                        color: this.emotionColors[selectedCombination.emotion],
                        emotion: selectedCombination.emotion,
                        math: selectedCombination.math,
                        speed: Math.random() * 0.5 + 0.2,
                        direction: Math.random() * Math.PI * 2,
                        amplitude: 10 + Math.random() * 20 * continuity,
                        frequency: 0.01 + Math.random() * 0.05 * (1 - linearity),
                        phase: Math.random() * Math.PI * 2,
                        opacity: 0.3 + Math.random() * 0.5,
                        lifespan: 100 + Math.random() * 200 * (1 - structure),
                        age: 0,
                        turbulence: Math.random() * structure * 0.1,
                        complexity: Math.random() * abstraction * 0.2,
                        randomness: Math.random() * determinism * 0.1
                    };
                    
                    // Добавляем частицу
                    this.state.particles.push(particle);
                }
            }
            
            // Метод для отрисовки дополнительных эффектов
            drawProfileEffects() {
                // Эффекты зависят от параметров профиля
                const linearity = this.profileDimensions.linearity;
                const structure = this.profileDimensions.structure;
                const abstraction = this.profileDimensions.abstraction;
                
                // Центр канваса
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Эффект лучей (для высокой линейности)
                if (linearity < 0.3) {
                    const rayCount = 12;
                    const rayLength = Math.min(this.canvas.width, this.canvas.height) * 0.4;
                    
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.lineWidth = 2;
                    
                    for (let i = 0; i < rayCount; i++) {
                        const angle = (i / rayCount) * Math.PI * 2;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(centerX, centerY);
                        this.ctx.lineTo(
                            centerX + Math.cos(angle) * rayLength,
                            centerY + Math.sin(angle) * rayLength
                        );
                        this.ctx.stroke();
                    }
                }
                
                // Эффект вихря (для высокой хаотичности)
                if (structure > 0.7) {
                    const spiralCount = 3;
                    const spiralPoints = 100;
                    const spiralRadius = Math.min(this.canvas.width, this.canvas.height) * 0.4;
                    
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.lineWidth = 1;
                    
                    for (let s = 0; s < spiralCount; s++) {
                        const phaseOffset = (s / spiralCount) * Math.PI * 2;
                        
                        this.ctx.beginPath();
                        
                        for (let i = 0; i <= spiralPoints; i++) {
                            const progress = i / spiralPoints;
                            const angle = progress * Math.PI * 6 + phaseOffset + this.state.time;
                            const radius = progress * spiralRadius;
                            
                            const x = centerX + Math.cos(angle) * radius;
                            const y = centerY + Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                        
                        this.ctx.stroke();
                    }
                }
                
                // Эффект перспективы (для высокой абстрактности)
                if (abstraction > 0.7) {
                    const gridSize = 5;
                    const gridSpacing = Math.min(this.canvas.width, this.canvas.height) / 10;
                    
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                    this.ctx.lineWidth = 1;
                    
                    // Горизонтальные линии
                    for (let y = -gridSize; y <= gridSize; y++) {
                        const perspY = centerY + y * gridSpacing;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, perspY);
                        this.ctx.lineTo(this.canvas.width, perspY);
                        this.ctx.stroke();
                    }
                    
                    // Вертикальные линии
                    for (let x = -gridSize; x <= gridSize; x++) {
                        const perspX = centerX + x * gridSpacing;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(perspX, 0);
                        this.ctx.lineTo(perspX, this.canvas.height);
                        this.ctx.stroke();
                    }
                }
            }
            
            // Вспомогательный метод для преобразования HEX в RGB
            hexToRgb(hex) {
                hex = hex.replace('#', '');
                
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                
                return `${r}, ${g}, ${b}`;
            }
        }
        
        // Класс для глубинных структур и интеграции системы
        class DeepStructures {
            constructor() {
                // Инициализация canvas
                this.canvas = document.getElementById('deep-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                
                // Параметры отображения
                this.params = {
                    depth: 0.7,
                    density: 0.5,
                    waveFactor: 0.6,
                    resonanceActive: false,
                    explorationLevel: 1
                };
                
                // Текущий выбранный архетип
                this.currentArchetype = 'harmony';
                
                // Архетипы и их параметры
                this.archetypes = {
                    harmony: {
                        name: 'Гармония и равновесие',
                        description: `<p>Фундаментальный паттерн баланса и пропорциональности, проявляющийся как в эмоциональных состояниях, так и в математических структурах.</p>
                                    <p>В эмоциональной сфере выражается через состояния умиротворения, равновесия и целостности. В математике проявляется через симметрию, золотое сечение и согласованность.</p>`,
                        manifestations: [
                            '<span class="emotion-tag">Эмоция:</span> Состояние внутреннего баланса и умиротворения',
                            '<span class="math-tag">Математика:</span> Симметричные функции и сбалансированные уравнения',
                            '<span class="synesthesia-tag">Синестезия:</span> Чувство завершенности при созерцании пропорциональных структур'
                        ],
                        color: '#4ECDC4',
                        structure: 'symmetric',
                        emotionAffinity: 'joy',
                        mathAffinity: 'trigonometric'
                    },
                    transformation: {
                        name: 'Трансформация и метаморфозы',
                        description: `<p>Архетип изменения и преобразования, отражающий непрерывное движение и развитие как эмоциональных состояний, так и математических моделей.</p>
                                    <p>В эмоциональном пространстве проявляется через переходы между различными состояниями, эмоциональное развитие и катарсис. В математике выражается через функции преобразования, дифференциальные уравнения и теорию катастроф.</p>`,
                        manifestations: [
                            '<span class="emotion-tag">Эмоция:</span> Переход между различными аффективными состояниями, эмоциональные метаморфозы',
                            '<span class="math-tag">Математика:</span> Дифференциальные уравнения и функции преобразования',
                            '<span class="synesthesia-tag">Синестезия:</span> Ощущение плавных переходов между различными модальностями восприятия'
                        ],
                        color: '#FF6B6B',
                        structure: 'transformative',
                        emotionAffinity: 'surprise',
                        mathAffinity: 'exponential'
                    },
                    recursion: {
                        name: 'Рекурсия и самоподобие',
                        description: `<p>Архетип повторяющихся паттернов на различных уровнях организации, проявляющийся в форме само-референтных структур.</p>
                                    <p>В эмоциональном плане выражается через многослойные переживания, эхо-эмоции и эмоциональные резонансы. В математике представлен фракталами, рекурсивными функциями и итеративными процессами.</p>`,
                        manifestations: [
                            '<span class="emotion-tag">Эмоция:</span> Многослойные эмоциональные переживания с повторяющимися паттернами',
                            '<span class="math-tag">Математика:</span> Фракталы, рекурсивные функции и самоподобные структуры',
                            '<span class="synesthesia-tag">Синестезия:</span> Переживание одного и того же паттерна на различных уровнях восприятия'
                        ],
                        color: '#9370DB',
                        structure: 'recursive',
                        emotionAffinity: 'fear',
                        mathAffinity: 'fractal'
                    },
                    duality: {
                        name: 'Дуальность и полярность',
                        description: `<p>Архетип противоположностей и их единства, отражающий бинарные структуры в основе как эмоциональных, так и математических явлений.</p>
                                    <p>В эмоциональной сфере проявляется через противоположные аффекты, амбивалентность и диалектику чувств. В математике выражается через двоичные системы, комплиментарные функции и симметрии инверсии.</p>`,
                        manifestations: [
                            '<span class="emotion-tag">Эмоция:</span> Амбивалентность и сосуществование противоположных чувств',
                            '<span class="math-tag">Математика:</span> Бинарные системы, комплиментарные функции и дуальные преобразования',
                            '<span class="synesthesia-tag">Синестезия:</span> Восприятие противоположных качеств как единого целого'
                        ],
                        color: '#556270',
                        structure: 'dual',
                        emotionAffinity: 'anger',
                        mathAffinity: 'complex'
                    },
                    emergence: {
                        name: 'Эмерджентность и синергия',
                        description: `<p>Архетип появления новых свойств и качеств из взаимодействия более простых элементов. Отражает возникновение сложности из базовых компонентов.</p>
                                    <p>В эмоциональном плане проявляется как возникновение сложных чувств из базовых эмоций, чувственные гештальты и синергия переживаний. В математике представлен нелинейными системами, теорией сложности и эмерджентными функциями.</p>`,
                        manifestations: [
                            '<span class="emotion-tag">Эмоция:</span> Эмоциональные гештальты и комплексные чувства, возникающие из базовых эмоций',
                            '<span class="math-tag">Математика:</span> Нелинейные системы, теория хаоса и эмерджентные структуры',
                            '<span class="synesthesia-tag">Синестезия:</span> Возникновение целостных паттернов восприятия из множества сенсорных элементов'
                        ],
                        color: '#FF8C94',
                        structure: 'emergent',
                        emotionAffinity: 'sadness',
                        mathAffinity: 'logarithmic'
                    }
                };
                
                // Элементы глубинных структур
                this.structureElements = [];
                
                // Интеграционная консоль
                this.console = {
                    entries: [
                        { timestamp: '00:00:00', content: 'Инициализация системы СинЭстеМика завершена. Все компоненты активны.' },
                        { timestamp: '00:00:05', content: 'Глубинные структуры загружены. Архетипические паттерны доступны для исследования.' },
                        { timestamp: '00:00:10', content: 'Обнаружен активный профиль восприятия. Интеграция с глубинными структурами выполнена.' },
                        { timestamp: '00:00:15', content: 'Система готова к исследованию. Используйте элементы управления для навигации.' }
                    ],
                    startTime: new Date()
                };
                
                // Cостояние анимации
                this.state = {
                    time: 0,
                    animationFrame: null,
                    resonanceIntensity: 0,
                    explorationProgress: 0,
                    activeConnections: []
                };
                
                // Инициализация событий
                this.initEventListeners();
                
                // Генерация первоначальных элементов структуры
                this.generateStructureElements();
                
                // Запуск анимации
                this.animate();
            }
            
            // Метод для изменения размеров canvas
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = 400;
            }
            
            // Инициализация обработчиков событий
            initEventListeners() {
                // Слайдеры параметров
                document.getElementById('depth-slider').addEventListener('input', (e) => {
                    this.params.depth = parseFloat(e.target.value);
                });
                
                document.getElementById('density-slider').addEventListener('input', (e) => {
                    this.params.density = parseFloat(e.target.value);
                    this.generateStructureElements();
                });
                
                document.getElementById('wave-slider').addEventListener('input', (e) => {
                    this.params.waveFactor = parseFloat(e.target.value);
                });
                
                // Кнопки
                document.getElementById('explore-button').addEventListener('click', () => {
                    this.exploreDeeper();
                });
                
                document.getElementById('resonance-button').addEventListener('click', () => {
                    this.toggleResonance();
                });
                
                // Архетипы
                document.querySelectorAll('.archetype-item').forEach(item => {
                    item.addEventListener('click', () => {
                        this.selectArchetype(item.dataset.archetype);
                    });
                });
                
                // Навигация по системе
                document.querySelectorAll('.navigation-node').forEach(node => {
                    node.addEventListener('click', () => {
                        this.navigateToComponent(node.dataset.component);
                    });
                });
                
                // Интеграционная консоль
                document.getElementById('clear-console-button').addEventListener('click', () => {
                    this.clearConsole();
                });
                
                document.getElementById('export-button').addEventListener('click', () => {
                    this.exportExperience();
                });
                
                document.getElementById('send-command-button').addEventListener('click', () => {
                    this.processConsoleCommand();
                });
                
                document.getElementById('console-command').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.processConsoleCommand();
                    }
                });
                
                // Обработчик изменения размера окна
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                });
            }
            
            // Генерация элементов структуры
            generateStructureElements() {
                // Очищаем текущие элементы
                this.structureElements = [];
                
                // Количество элементов зависит от параметра плотности
                const elementCount = Math.floor(50 + this.params.density * 150);
                
                // Генерируем элементы в зависимости от текущего архетипа
                const archetype = this.archetypes[this.currentArchetype];
                
                for (let i = 0; i < elementCount; i++) {
                    let element = null;
                    
                    switch (archetype.structure) {
                        case 'symmetric':
                            element = this.generateSymmetricElement();
                            break;
                        case 'transformative':
                            element = this.generateTransformativeElement();
                            break;
                        case 'recursive':
                            element = this.generateRecursiveElement();
                            break;
                        case 'dual':
                            element = this.generateDualElement();
                            break;
                        case 'emergent':
                            element = this.generateEmergentElement();
                            break;
                        default:
                            element = this.generateSymmetricElement();
                    }
                    
                    // Добавляем общие свойства
                    element.color = this.adjustColor(archetype.color, 0.3 + Math.random() * 0.7);
                    element.archetype = this.currentArchetype;
                    
                    // Добавляем элемент в массив
                    this.structureElements.push(element);
                }
                
                // Генерируем связи между элементами
                this.generateConnections();
                
                // Добавляем запись в консоль
                this.addConsoleEntry(`Сгенерированы элементы архетипа "${archetype.name}". Количество элементов: ${elementCount}.`);
            }
            
            // Генерация элемента симметричной структуры
            generateSymmetricElement() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Генерируем позицию на окружности
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * this.canvas.width * 0.4;
                
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                // Генерируем симметричную пару
                const symmetricX = centerX - (x - centerX);
                const symmetricY = centerY - (y - centerY);
                
                return {
                    x: x,
                    y: y,
                    size: 2 + Math.random() * 3,
                    type: 'symmetric',
                    pairX: symmetricX,
                    pairY: symmetricY,
                    angle: angle,
                    radius: radius,
                    phase: Math.random() * Math.PI * 2,
                    frequency: 0.01 + Math.random() * 0.03,
                    amplitude: 5 + Math.random() * 10,
                    connections: []
                };
            }
            
            // Генерация элемента трансформативной структуры
            generateTransformativeElement() {
                return {
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    size: 2 + Math.random() * 3,
                    type: 'transformative',
                    targetX: Math.random() * this.canvas.width,
                    targetY: Math.random() * this.canvas.height,
                    transitionProgress: Math.random(),
                    transitionSpeed: 0.001 + Math.random() * 0.003,
                    phase: Math.random() * Math.PI * 2,
                    connections: []
                };
            }
            
            // Генерация элемента рекурсивной структуры
            generateRecursiveElement() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Генерируем начальную позицию
                const angle = Math.random() * Math.PI * 2;
                const radiusBase = 20 + Math.random() * 100;
                
                // Генерируем несколько уровней рекурсии
                const levels = 1 + Math.floor(Math.random() * 3);
                const subElements = [];
                
                for (let i = 0; i < levels; i++) {
                    const subRadius = radiusBase / (i + 1);
                    const subAngle = angle + i * (Math.PI / 4);
                    
                    subElements.push({
                        radius: subRadius,
                        angle: subAngle,
                        phase: Math.random() * Math.PI * 2,
                        amplitude: 3 + Math.random() * 7
                    });
                }
                
                return {
                    x: centerX + Math.cos(angle) * radiusBase,
                    y: centerY + Math.sin(angle) * radiusBase,
                    size: 2 + Math.random() * 3,
                    type: 'recursive',
                    baseAngle: angle,
                    baseRadius: radiusBase,
                    subElements: subElements,
                    frequency: 0.01 + Math.random() * 0.02,
                    phase: Math.random() * Math.PI * 2,
                    connections: []
                };
            }
            
            // Генерация элемента дуальной структуры
            generateDualElement() {
                // Генерируем пару противоположных элементов
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                const angle = Math.random() * Math.PI * 2;
                const radius = 50 + Math.random() * 150;
                
                const x1 = centerX + Math.cos(angle) * radius;
                const y1 = centerY + Math.sin(angle) * radius;
                
                const x2 = centerX + Math.cos(angle + Math.PI) * radius;
                const y2 = centerY + Math.sin(angle + Math.PI) * radius;
                
                return {
                    x: x1,
                    y: y1,
                    size: 2 + Math.random() * 3,
                    type: 'dual',
                    oppositeX: x2,
                    oppositeY: y2,
                    angle: angle,
                    radius: radius,
                    polarity: Math.random() > 0.5 ? 1 : -1,
                    phase: Math.random() * Math.PI * 2,
                    frequency: 0.01 + Math.random() * 0.02,
                    connections: []
                };
            }
            
            // Генерация элемента эмерджентной структуры
            generateEmergentElement() {
                // Генерируем кластер связанных элементов
                const clusterSize = 2 + Math.floor(Math.random() * 4);
                const clusterX = Math.random() * this.canvas.width;
                const clusterY = Math.random() * this.canvas.height;
                const clusterRadius = 20 + Math.random() * 40;
                
                const subElements = [];
                
                for (let i = 0; i < clusterSize; i++) {
                    const angle = (i / clusterSize) * Math.PI * 2;
                    const radius = clusterRadius * (0.5 + Math.random() * 0.5);
                    
                    subElements.push({
                        x: clusterX + Math.cos(angle) * radius,
                        y: clusterY + Math.sin(angle) * radius,
                        size: 1 + Math.random() * 2,
                        phase: Math.random() * Math.PI * 2
                    });
                }
                
                return {
                    x: clusterX,
                    y: clusterY,
                    size: 2 + Math.random() * 3,
                    type: 'emergent',
                    subElements: subElements,
                    frequency: 0.01 + Math.random() * 0.02,
                    phase: Math.random() * Math.PI * 2,
                    emergenceLevel: Math.random(),
                    connections: []
                };
            }
            
            // Генерация связей между элементами
            generateConnections() {
                // Очищаем текущие связи
                this.structureElements.forEach(element => {
                    element.connections = [];
                });
                
                // Генерируем новые связи
                const connectionDensity = this.params.density * 0.7;
                const maxConnections = Math.floor(3 + this.params.density * 5);
                
                // Перебираем все элементы
                for (let i = 0; i < this.structureElements.length; i++) {
                    const element = this.structureElements[i];
                    const potentialConnections = [];
                    
                    // Находим потенциальные связи
                    for (let j = 0; j < this.structureElements.length; j++) {
                        if (i === j) continue;
                        
                        const otherElement = this.structureElements[j];
                        const dx = element.x - otherElement.x;
                        const dy = element.y - otherElement.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Если элементы достаточно близко, добавляем связь
                        if (distance < 100 + connectionDensity * 200) {
                            potentialConnections.push({
                                index: j,
                                distance: distance
                            });
                        }
                    }
                    
                    // Сортируем по расстоянию
                    potentialConnections.sort((a, b) => a.distance - b.distance);
                    
                    // Выбираем случайное количество связей
                    const connectionCount = Math.min(
                        potentialConnections.length,
                        1 + Math.floor(Math.random() * maxConnections)
                    );
                    
                    // Добавляем связи
                    for (let j = 0; j < connectionCount; j++) {
                        if (Math.random() < connectionDensity) {
                            const connection = potentialConnections[j];
                            element.connections.push(connection.index);
                        }
                    }
                }
            }
            
            // Метод для анимации
            animate() {
                // Инкрементируем время
                this.state.time += 0.01;
                
                // Обновляем состояние резонанса
                if (this.params.resonanceActive) {
                    this.state.resonanceIntensity = Math.min(1, this.state.resonanceIntensity + 0.01);
                } else {
                    this.state.resonanceIntensity = Math.max(0, this.state.resonanceIntensity - 0.01);
                }
                
                // Отрисовываем сцену
                this.drawScene();
                
                // Запускаем следующий кадр анимации
                this.state.animationFrame = requestAnimationFrame(this.animate.bind(this));
            }
            
            // Отрисовка сцены
            drawScene() {
                // Очищаем canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Рисуем градиентный фон
                this.drawBackground();
                
                // Рисуем базовую структуру
                this.drawBaseStructure();
                
                // Рисуем связи между элементами
                this.drawConnections();
                
                // Рисуем элементы структуры
                this.drawElements();
                
                // Рисуем эффекты резонанса
                if (this.state.resonanceIntensity > 0) {
                    this.drawResonanceEffects();
                }
                
                // Рисуем эффекты глубокого исследования
                if (this.state.explorationProgress > 0) {
                    this.drawExplorationEffects();
                }
            }
            
            // Отрисовка фона
            drawBackground() {
                // Создаем градиент в зависимости от текущего архетипа
                const archetype = this.archetypes[this.currentArchetype];
                const color = archetype.color;
                
                const gradient = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 10,
                    this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height) / 1.5
                );
                
                gradient.addColorStop(0, this.adjustColor(color, 0.1));
                gradient.addColorStop(1, 'rgba(10, 10, 20, 0.9)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            // Отрисовка базовой структуры
            drawBaseStructure() {
                // Различные базовые структуры в зависимости от архетипа
                const archetype = this.archetypes[this.currentArchetype];
                
                switch (archetype.structure) {
                    case 'symmetric':
                        this.drawSymmetricBase();
                        break;
                    case 'transformative':
                        this.drawTransformativeBase();
                        break;
                    case 'recursive':
                        this.drawRecursiveBase();
                        break;
                    case 'dual':
                        this.drawDualBase();
                        break;
                    case 'emergent':
                        this.drawEmergentBase();
                        break;
                }
            }
            
            // Отрисовка базовой симметричной структуры
            drawSymmetricBase() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = Math.min(this.canvas.width, this.canvas.height) / 3;
                
                // Рисуем концентрические круги
                this.ctx.strokeStyle = this.adjustColor(this.archetypes.harmony.color, 0.2);
                
                for (let i = 1; i <= 3; i++) {
                    const r = radius * (i / 3);
                    
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
                
                // Рисуем радиальные линии
                const lineCount = 12;
                
                for (let i = 0; i < lineCount; i++) {
                    const angle = (i / lineCount) * Math.PI * 2;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.lineTo(
                        centerX + Math.cos(angle) * radius,
                        centerY + Math.sin(angle) * radius
                    );
                    this.ctx.lineWidth = 0.5;
                    this.ctx.stroke();
                }
            }
            
            // Отрисовка базовой трансформативной структуры
            drawTransformativeBase() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = Math.min(this.canvas.width, this.canvas.height) / 3;
                
                // Рисуем спираль трансформации
                this.ctx.strokeStyle = this.adjustColor(this.archetypes.transformation.color, 0.2);
                this.ctx.lineWidth = 1;
                
                this.ctx.beginPath();
                
                for (let angle = 0; angle < Math.PI * 6; angle += 0.1) {
                    const r = (angle / (Math.PI * 6)) * radius;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    
                    if (angle === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                
                this.ctx.stroke();
                
                // Рисуем тени трансформации
                const shadowCount = 3;
                const shadowOpacity = 0.1;
                
                for (let i = 1; i <= shadowCount; i++) {
                    const offset = i * 10;
                    const phase = i * Math.PI / 6 + this.state.time;
                    
                    this.ctx.strokeStyle = this.adjustColor(this.archetypes.transformation.color, shadowOpacity);
                    this.ctx.beginPath();
                    
                    for (let angle = 0; angle < Math.PI * 6; angle += 0.1) {
                        const r = (angle / (Math.PI * 6)) * radius;
                        const x = centerX + Math.cos(angle + phase) * (r + offset);
                        const y = centerY + Math.sin(angle + phase) * (r + offset);
                        
                        if (angle === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    
                    this.ctx.stroke();
                }
            }
            
            // Отрисовка базовой рекурсивной структуры
            drawRecursiveBase() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const maxDepth = 4;
                
                // Рекурсивная функция для отрисовки треугольников
                const drawTriangle = (x1, y1, x2, y2, x3, y3, depth) => {
                    if (depth === 0) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.lineTo(x3, y3);
                        this.ctx.closePath();
                        this.ctx.strokeStyle = this.adjustColor(this.archetypes.recursion.color, 0.1 + 0.1 * maxDepth / (1 + maxDepth - depth));
                        this.ctx.lineWidth = 0.5 + depth * 0.5;
                        this.ctx.stroke();
                        return;
                    }
                    
                    // Вычисляем середины сторон
                    const x12 = (x1 + x2) / 2;
                    const y12 = (y1 + y2) / 2;
                    
                    const x23 = (x2 + x3) / 2;
                    const y23 = (y2 + y3) / 2;
                    
                    const x31 = (x3 + x1) / 2;
                    const y31 = (y3 + y1) / 2;
                    
                    // Рекурсивно рисуем треугольники
                    drawTriangle(x1, y1, x12, y12, x31, y31, depth - 1);
                    drawTriangle(x12, y12, x2, y2, x23, y23, depth - 1);
                    drawTriangle(x31, y31, x23, y23, x3, y3, depth - 1);
                };
                
                // Начальный треугольник
                const radius = Math.min(this.canvas.width, this.canvas.height) / 3;
                
                const x1 = centerX;
                const y1 = centerY - radius;
                
                const x2 = centerX - radius * Math.cos(Math.PI / 6);
                const y2 = centerY + radius * Math.sin(Math.PI / 6);
                
                const x3 = centerX + radius * Math.cos(Math.PI / 6);
                const y3 = centerY + radius * Math.sin(Math.PI / 6);
                
                // Рисуем рекурсивную структуру
                drawTriangle(x1, y1, x2, y2, x3, y3, maxDepth);
            }
            
            // Отрисовка базовой дуальной структуры
            drawDualBase() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = Math.min(this.canvas.width, this.canvas.height) / 3;
                
                // Рисуем символ инь-ян
                this.ctx.strokeStyle = this.adjustColor(this.archetypes.duality.color, 0.2);
                this.ctx.lineWidth = 1;
                
                // Основная окружность
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Волнистая разделяющая линия
                this.ctx.beginPath();
                
                for (let x = centerX - radius; x <= centerX + radius; x += 1) {
                    const normalizedX = (x - (centerX - radius)) / (radius * 2);
                    const waveAmplitude = radius / 3;
                    const wavePhase = this.state.time * 0.5;
                    
                    const y = centerY + Math.sin(normalizedX * Math.PI * 2 + wavePhase) * waveAmplitude;
                    
                    if (x === centerX - radius) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                
                this.ctx.stroke();
                
                // Две меньшие окружности
                const smallRadius = radius / 4;
                
                this.ctx.beginPath();
                this.ctx.arc(centerX - radius / 3, centerY - radius / 6, smallRadius, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.arc(centerX + radius / 3, centerY + radius / 6, smallRadius, 0, Math.PI * 2);
                this.ctx.stroke();
            }
            
            // Отрисовка базовой эмерджентной структуры
            drawEmergentBase() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = Math.min(this.canvas.width, this.canvas.height) / 3;
                
                // Рисуем сеть взаимодействующих узлов
                this.ctx.strokeStyle = this.adjustColor(this.archetypes.emergence.color, 0.2);
                this.ctx.lineWidth = 0.5;
                
                // Узлы
                const nodeCount = 12;
                const nodes = [];
                
                for (let i = 0; i < nodeCount; i++) {
                    const angle = (i / nodeCount) * Math.PI * 2;
                    const nodeRadius = radius * (0.6 + Math.random() * 0.4);
                    
                    const x = centerX + Math.cos(angle) * nodeRadius;
                    const y = centerY + Math.sin(angle) * nodeRadius;
                    
                    nodes.push({ x, y });
                }
                
                // Связи между узлами
                for (let i = 0; i < nodeCount; i++) {
                    for (let j = i + 1; j < nodeCount; j++) {
                        // Создаем больше связей в центре
                        const centerDistance = Math.sqrt(
                            Math.pow(nodes[i].x - centerX, 2) + 
                            Math.pow(nodes[i].y - centerY, 2)
                        ) / radius;
                        
                        if (Math.random() < 0.3 - centerDistance * 0.2) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(nodes[i].x, nodes[i].y);
                            this.ctx.lineTo(nodes[j].x, nodes[j].y);
                            this.ctx.stroke();
                        }
                    }
                }
                
                // Эмерджентный паттерн в центре
                this.ctx.beginPath();
                
                for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                    const r = radius * 0.3 * (1 + Math.sin(angle * 5 + this.state.time) * 0.2);
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    
                    if (angle === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                
                this.ctx.closePath();
                this.ctx.stroke();
            }
            
            // Отрисовка связей между элементами
            drawConnections() {
                this.structureElements.forEach((element, index) => {
                    element.connections.forEach(targetIndex => {
                        const targetElement = this.structureElements[targetIndex];
                        
                        // Рассчитываем цвет связи
                        const baseColor = this.adjustColor(this.archetypes[this.currentArchetype].color, 0.3);
                        
                        // Модифицируем цвет в зависимости от параметров
                        const waveFactor = this.params.waveFactor;
                        const timeOffset = this.state.time + index * 0.1;
                        const waveInfluence = Math.sin(timeOffset * 2) * waveFactor * 0.5;
                        
                        // Вычисляем динамическую прозрачность для волнового эффекта
                        const alpha = 0.1 + waveInfluence * 0.1 + 0.1 * this.state.resonanceIntensity;
                        
                        this.ctx.strokeStyle = this.adjustColor(baseColor, alpha);
                        this.ctx.lineWidth = 0.5 + this.state.resonanceIntensity * 0.5;
                        
                        // Рисуем линию связи
                        this.ctx.beginPath();
                        
                        if (waveFactor > 0.3) {
                            // Волнистая связь
                            const dx = targetElement.x - element.x;
                            const dy = targetElement.y - element.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const segments = Math.ceil(distance / 20);
                            
                            for (let i = 0; i <= segments; i++) {
                                const t = i / segments;
                                const x = element.x + dx * t;
                                const y = element.y + dy * t + Math.sin(t * Math.PI * 2 + timeOffset * 3) * waveFactor * 10;
                                
                                if (i === 0) {
                                    this.ctx.moveTo(x, y);
                                } else {
                                    this.ctx.lineTo(x, y);
                                }
                            }
                        } else {
                            // Прямая связь
                            this.ctx.moveTo(element.x, element.y);
                            this.ctx.lineTo(targetElement.x, targetElement.y);
                        }
                        
                        this.ctx.stroke();
                    });
                });
            }
            
            // Отрисовка элементов структуры
            drawElements() {
                this.structureElements.forEach(element => {
                    // Обновляем позицию элемента
                    this.updateElementPosition(element);
                    
                    // Рисуем элемент в зависимости от его типа
                    switch (element.type) {
                        case 'symmetric':
                            this.drawSymmetricElement(element);
                            break;
                        case 'transformative':
                            this.drawTransformativeElement(element);
                            break;
                        case 'recursive':
                            this.drawRecursiveElement(element);
                            break;
                        case 'dual':
                            this.drawDualElement(element);
                            break;
                        case 'emergent':
                            this.drawEmergentElement(element);
                            break;
                    }
                });
            }
            
            // Обновление позиции элемента
            updateElementPosition(element) {
                // Базовое обновление в зависимости от типа
                switch (element.type) {
                    case 'symmetric':
                        this.updateSymmetricElement(element);
                        break;
                    case 'transformative':
                        this.updateTransformativeElement(element);
                        break;
                    case 'recursive':
                        this.updateRecursiveElement(element);
                        break;
                    case 'dual':
                        this.updateDualElement(element);
                        break;
                    case 'emergent':
                        this.updateEmergentElement(element);
                        break;
                }
                
                // Общие обновления для резонанса
                if (this.state.resonanceIntensity > 0) {
                    const resonanceTime = this.state.time * 3;
                    const resonanceFactor = this.state.resonanceIntensity * 0.1;
                    
                    element.x += Math.sin(resonanceTime + element.phase) * resonanceFactor * 10;
                    element.y += Math.cos(resonanceTime + element.phase) * resonanceFactor * 10;
                }
            }
            
            // Обновление симметричного элемента
            updateSymmetricElement(element) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Волновое движение по кругу
                const time = this.state.time * element.frequency;
                const angleOffset = Math.sin(time + element.phase) * this.params.waveFactor * 0.5;
                
                element.x = centerX + Math.cos(element.angle + angleOffset) * element.radius;
                element.y = centerY + Math.sin(element.angle + angleOffset) * element.radius;
                
                // Обновляем пару
                element.pairX = centerX - (element.x - centerX);
                element.pairY = centerY - (element.y - centerY);
            }
            
            // Обновление трансформативного элемента
            updateTransformativeElement(element) {
                // Плавный переход между начальной и целевой позицией
                element.transitionProgress += element.transitionSpeed;
                
                if (element.transitionProgress >= 1) {
                    // Достигнуто целевого положения, генерируем новую цель
                    element.transitionProgress = 0;
                    element.x = element.targetX;
                    element.y = element.targetY;
                    element.targetX = Math.random() * this.canvas.width;
                    element.targetY = Math.random() * this.canvas.height;
                }
                
                // Интерполяция между текущей и целевой позицией
                const progress = this.easeInOut(element.transitionProgress);
                const newX = element.x + (element.targetX - element.x) * progress;
                const newY = element.y + (element.targetY - element.y) * progress;
                
                element.x = newX;
                element.y = newY;
            }
            
            // Обновление рекурсивного элемента
            updateRecursiveElement(element) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Базовое движение по кругу
                const time = this.state.time * element.frequency;
                element.baseAngle += 0.001 * (1 + time * 0.1);
                
                // Обновляем основную позицию
                element.x = centerX + Math.cos(element.baseAngle) * element.baseRadius;
                element.y = centerY + Math.sin(element.baseAngle) * element.baseRadius;
                
                // Обновляем подэлементы
                element.subElements.forEach(subElement => {
                    subElement.angle += 0.002 * (1 + Math.sin(time + subElement.phase) * 0.5);
                });
            }
            
            // Обновление дуального элемента
            updateDualElement(element) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Вращение вокруг центра
                const time = this.state.time * element.frequency;
                const angleSpeed = 0.005 * element.polarity * (1 + Math.sin(time) * 0.2);
                
                element.angle += angleSpeed;
                
                // Обновляем позицию
                element.x = centerX + Math.cos(element.angle) * element.radius;
                element.y = centerY + Math.sin(element.angle) * element.radius;
                
                // Обновляем противоположную точку
                element.oppositeX = centerX + Math.cos(element.angle + Math.PI) * element.radius;
                element.oppositeY = centerY + Math.sin(element.angle + Math.PI) * element.radius;
            }
            
            // Обновление эмерджентного элемента
            updateEmergentElement(element) {
                // Обновляем уровень эмерджентности
                const time = this.state.time * element.frequency;
                element.emergenceLevel = 0.3 + Math.sin(time + element.phase) * 0.3 + 0.3;
                
                // Рассчитываем общее движение кластера
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                const dx = centerX - element.x;
                const dy = centerY - element.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 20) {
                    // Движение к центру с небольшими колебаниями
                    element.x += dx * 0.001 * element.emergenceLevel;
                    element.y += dy * 0.001 * element.emergenceLevel;
                }
                
                // Обновляем подэлементы
                element.subElements.forEach(subElement => {
                    const angle = Math.atan2(subElement.y - element.y, subElement.x - element.x);
                    const distance = Math.sqrt(
                        Math.pow(subElement.x - element.x, 2) + 
                        Math.pow(subElement.y - element.y, 2)
                    );
                    
                    // Движение подэлементов вокруг центра
                    const newAngle = angle + 0.02 * Math.sin(time + subElement.phase);
                    const newDistance = distance * (0.99 + Math.sin(time * 2 + subElement.phase) * 0.01);
                    
                    subElement.x = element.x + Math.cos(newAngle) * newDistance;
                    subElement.y = element.y + Math.sin(newAngle) * newDistance;
                });
            }
            
            // Отрисовка симметричного элемента
            drawSymmetricElement(element) {
                // Рисуем основной элемент
                this.ctx.beginPath();
                this.ctx.arc(element.x, element.y, element.size, 0, Math.PI * 2);
                this.ctx.fillStyle = element.color;
                this.ctx.fill();
                
                // Рисуем парный элемент
                this.ctx.beginPath();
                this.ctx.arc(element.pairX, element.pairY, element.size, 0, Math.PI * 2);
                this.ctx.fillStyle = element.color;
                this.ctx.fill();
                
                // Рисуем соединительную линию
                this.ctx.beginPath();
                this.ctx.moveTo(element.x, element.y);
                this.ctx.lineTo(element.pairX, element.pairY);
                this.ctx.strokeStyle = this.adjustColor(element.color, 0.3);
                this.ctx.lineWidth = 0.5;
                this.ctx.stroke();
            }
            
            // Отрисовка трансформативного элемента
            drawTransformativeElement(element) {
                // Рисуем элемент с "хвостом" трансформации
                this.ctx.beginPath();
                this.ctx.arc(element.x, element.y, element.size, 0, Math.PI * 2);
                this.ctx.fillStyle = element.color;
                this.ctx.fill();
                
                // Рисуем след трансформации
                this.ctx.beginPath();
                this.ctx.moveTo(element.x, element.y);
                
                const trailLength = 10;
                const directionX = element.targetX - element.x;
                const directionY = element.targetY - element.y;
                const directionLength = Math.sqrt(directionX * directionX + directionY * directionY);
                
                if (directionLength > 0) {
                    const normalizedDirX = directionX / directionLength;
                    const normalizedDirY = directionY / directionLength;
                    
                    for (let i = 1; i <= trailLength; i++) {
                        const trailProgress = i / trailLength;
                        const trailDistance = trailProgress * element.size * 4;
                        
                        const trailX = element.x - normalizedDirX * trailDistance;
                        const trailY = element.y - normalizedDirY * trailDistance;
                        
                        ctx.lineTo(trailX, trailY);
                    }
                    
                    this.ctx.strokeStyle = this.adjustColor(element.color, 0.2);
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
            }
            
            // Отрисовка рекурсивного элемента
            drawRecursiveElement(element) {
                // Рисуем основной элемент
                this.ctx.beginPath();
                this.ctx.arc(element.x, element.y, element.size, 0, Math.PI * 2);
                this.ctx.fillStyle = element.color;
                this.ctx.fill();
                
                // Рисуем подэлементы
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                element.subElements.forEach(subElement => {
                    const subAngle = element.baseAngle + subElement.angle;
                    const subX = centerX + Math.cos(subAngle) * subElement.radius;
                    const subY = centerY + Math.sin(subAngle) * subElement.radius;
                    
                    // Рисуем подэлемент
                    this.ctx.beginPath();
                    this.ctx.arc(subX, subY, element.size * 0.7, 0, Math.PI * 2);
                    this.ctx.fillStyle = this.adjustColor(element.color, 0.8);
                    this.ctx.fill();
                    
                    // Рисуем связь между основным элементом и подэлементом
                    this.ctx.beginPath();
                    this.ctx.moveTo(element.x, element.y);
                    this.ctx.lineTo(subX, subY);
                    this.ctx.strokeStyle = this.adjustColor(element.color, 0.3);
                    this.ctx.lineWidth = 0.5;
                    this.ctx.stroke();
                });
            }
            
            // Отрисовка дуального элемента
            drawDualElement(element) {
                // Рисуем основной элемент
                this.ctx.beginPath();
                this.ctx.arc(element.x, element.y, element.size, 0, Math.PI * 2);
                this.ctx.fillStyle = element.color;
                this.ctx.fill();
                
                // Рисуем противоположный элемент
                this.ctx.beginPath();
                this.ctx.arc(element.oppositeX, element.oppositeY, element.size, 0, Math.PI * 2);
                this.ctx.fillStyle = this.invertColor(element.color);
                this.ctx.fill();
                
                // Рисуем связующую линию
                this.ctx.beginPath();
                this.ctx.moveTo(element.x, element.y);
                this.ctx.lineTo(element.oppositeX, element.oppositeY);
                this.ctx.strokeStyle = this.adjustColor(element.color, 0.3);
                this.ctx.lineWidth = 0.5;
                this.ctx.setLineDash([3, 3]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
            
            // Отрисовка эмерджентного элемента
            drawEmergentElement(element) {
                // Рисуем подэлементы
                element.subElements.forEach(subElement => {
                    this.ctx.beginPath();
                    this.ctx.arc(subElement.x, subElement.y, subElement.size, 0, Math.PI * 2);
                    this.ctx.fillStyle = this.adjustColor(element.color, 0.7);
                    this.ctx.fill();
                    
                    // Рисуем связи между подэлементами
                    for (let i = 0; i < element.subElements.length; i++) {
                        const otherSubElement = element.subElements[i];
                        
                        if (subElement !== otherSubElement) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(subElement.x, subElement.y);
                            this.ctx.lineTo(otherSubElement.x, otherSubElement.y);
                            this.ctx.strokeStyle = this.adjustColor(element.color, 0.2 * element.emergenceLevel);
                            this.ctx.lineWidth = 0.5;
                            this.ctx.stroke();
                        }
                    }
                });
                
                // Рисуем эмерджентный узор
                if (element.emergenceLevel > 0.5) {
                    this.ctx.beginPath();
                    
                    for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                        const radius = element.size * 2 * element.emergenceLevel;
                        const x = element.x + Math.cos(angle) * radius;
                        const y = element.y + Math.sin(angle) * radius;
                        
                        if (angle === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    
                    this.ctx.closePath();
                    this.ctx.strokeStyle = this.adjustColor(element.color, 0.3 * element.emergenceLevel);
                    this.ctx.lineWidth = 0.5;
                    this.ctx.stroke();
                }
            }
            
            // Отрисовка эффектов резонанса
            drawResonanceEffects() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Рисуем волны резонанса
                const waveCount = 3;
                const maxRadius = Math.max(this.canvas.width, this.canvas.height) / 2;
                
                for (let i = 0; i < waveCount; i++) {
                    const phaseOffset = (i / waveCount) * Math.PI * 2;
                    const time = this.state.time * 2 + phaseOffset;
                    const radius = (0.2 + Math.sin(time) * 0.3 + 0.5) * maxRadius * this.state.resonanceIntensity;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    this.ctx.strokeStyle = this.adjustColor(this.archetypes[this.currentArchetype].color, 0.1 * this.state.resonanceIntensity);
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
                
                // Рисуем световые вспышки
                if (Math.random() < 0.03 * this.state.resonanceIntensity) {
                    const flashX = centerX + (Math.random() - 0.5) * this.canvas.width * 0.8;
                    const flashY = centerY + (Math.random() - 0.5) * this.canvas.height * 0.8;
                    const flashRadius = 5 + Math.random() * 15;
                    
                    const gradient = this.ctx.createRadialGradient(
                        flashX, flashY, 0,
                        flashX, flashY, flashRadius
                    );
                    
                    gradient.addColorStop(0, this.adjustColor(this.archetypes[this.currentArchetype].color, 0.8));
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(flashX, flashY, flashRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            // Отрисовка эффектов глубокого исследования
            drawExplorationEffects() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Рисуем портал исследования
                const portalRadius = 50 + 100 * this.state.explorationProgress;
                const gradient = this.ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, portalRadius
                );
                
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.2, this.adjustColor(this.archetypes[this.currentArchetype].color, 0.5));
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, portalRadius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Рисуем спиральные линии
                const spiralCount = 5;
                
                for (let i = 0; i < spiralCount; i++) {
                    const phaseOffset = (i / spiralCount) * Math.PI * 2;
                    
                    this.ctx.beginPath();
                    
                    for (let angle = 0; angle < Math.PI * 4 * this.state.explorationProgress; angle += 0.1) {
                        const radius = angle * 5 * (1 - this.state.explorationProgress * 0.5);
                        const waveRadius = radius + Math.sin(angle * 3 + this.state.time * 2) * 5;
                        
                        const x = centerX + Math.cos(angle + phaseOffset) * waveRadius;
                        const y = centerY + Math.sin(angle + phaseOffset) * waveRadius;
                        
                        if (angle === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    
                    this.ctx.strokeStyle = this.adjustColor(this.archetypes[this.currentArchetype].color, 0.3 * this.state.explorationProgress);
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
            }
            
            // Метод для глубокого исследования
            exploreDeeper() {
                // Увеличиваем уровень исследования
                this.params.explorationLevel = Math.min(5, this.params.explorationLevel + 1);
                
                // Запускаем анимацию портала исследования
                this.state.explorationProgress = 0;
                
                const exploreAnimation = () => {
                    this.state.explorationProgress += 0.02;
                    
                    if (this.state.explorationProgress >= 1) {
                        // Завершаем анимацию и обновляем визуализацию
                        this.state.explorationProgress = 0;
                        this.generateStructureElements();
                        
                        // Добавляем запись в консоль
                        this.addConsoleEntry(`Исследование углублено до уровня ${this.params.explorationLevel}. Обнаружены новые паттерны архетипа "${this.archetypes[this.currentArchetype].name}".`);
                        return;
                    }
                    
                    // Продолжаем анимацию
                    requestAnimationFrame(exploreAnimation);
                };
                
                exploreAnimation();
            }
            
            // Переключение режима резонанса
            toggleResonance() {
                this.params.resonanceActive = !this.params.resonanceActive;
                
                const button = document.getElementById('resonance-button');
                
                if (this.params.resonanceActive) {
                    button.textContent = 'Деактивировать резонанс';
                    this.addConsoleEntry(`Резонанс активирован. Усиление взаимодействия между элементами архетипа "${this.archetypes[this.currentArchetype].name}".`);
                } else {
                    button.textContent = 'Активировать резонанс';
                    this.addConsoleEntry('Резонанс деактивирован. Система возвращается в стабильное состояние.');
                }
            }
            
            // Выбор архетипа
            selectArchetype(archetypeKey) {
                // Обновляем текущий архетип
                this.currentArchetype = archetypeKey;
                
                // Обновляем классы активности
                document.querySelectorAll('.archetype-item').forEach(item => {
                    if (item.dataset.archetype === archetypeKey) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
                
                // Обновляем отображение описания архетипа
                const archetype = this.archetypes[archetypeKey];
                
                document.querySelector('.archetype-title').textContent = archetype.name;
                document.querySelector('.archetype-description').innerHTML = archetype.description;
                
                const manifestationList = document.querySelector('.manifestation-list');
                manifestationList.innerHTML = '';
                
                archetype.manifestations.forEach(manifestation => {
                    const li = document.createElement('li');
                    li.innerHTML = manifestation;
                    manifestationList.appendChild(li);
                });
                
                // Генерируем новые структурные элементы
                this.generateStructureElements();
                
                // Добавляем запись в консоль
                this.addConsoleEntry(`Выбран архетип "${archetype.name}". Структурные элементы обновлены.`);
            }
            
            // Навигация по компонентам системы
            navigateToComponent(componentKey) {
                // В реальной системе здесь был бы переход к другим компонентам
                // В данной демонстрации добавляем только запись в консоль
                const componentNames = {
                    'synthesizer': 'Эмоционально-математический синтезатор',
                    'connections': 'Система соответствий',
                    'conductor': 'Проводник',
                    'profiles': 'Профили восприятия',
                    'deep-structures': 'Глубинные структуры'
                };
                
                this.addConsoleEntry(`Выполнен переход к компоненту "${componentNames[componentKey]}".`);
            }
            
            // Добавление записи в консоль
            addConsoleEntry(content) {
                // Генерируем временную метку
                const now = new Date();
                const elapsedSeconds = Math.floor((now - this.console.startTime) / 1000);
                
                const hours = Math.floor(elapsedSeconds / 3600).toString().padStart(2, '0');
                const minutes = Math.floor((elapsedSeconds % 3600) / 60).toString().padStart(2, '0');
                const seconds = (elapsedSeconds % 60).toString().padStart(2, '0');
                
                const timestamp = `${hours}:${minutes}:${seconds}`;
                
                // Создаем запись
                const entry = {
                    timestamp,
                    content
                };
                
                // Добавляем в список
                this.console.entries.push(entry);
                
                // Обновляем отображение
                this.updateConsoleDisplay();
            }
            
            // Обновление отображения консоли
            updateConsoleDisplay() {
                const consoleContent = document.querySelector('.console-content');
                
                // Очищаем текущее содержимое
                consoleContent.innerHTML = '';
                
                // Добавляем записи
                this.console.entries.forEach(entry => {
                    const entryElement = document.createElement('div');
                    entryElement.className = 'console-entry';
                    
                    const timestampElement = document.createElement('div');
                    timestampElement.className = 'entry-timestamp';
                    timestampElement.textContent = entry.timestamp;
                    
                    const contentElement = document.createElement('div');
                    contentElement.className = 'entry-content';
                    contentElement.textContent = entry.content;
                    
                    entryElement.appendChild(timestampElement);
                    entryElement.appendChild(contentElement);
                    
                    consoleContent.appendChild(entryElement);
                });
                
                // Прокручиваем к последней записи
                consoleContent.scrollTop = consoleContent.scrollHeight;
            }
            
            // Очистка консоли
            clearConsole() {
                // Сохраняем только начальные записи
                this.console.entries = this.console.entries.slice(0, 4);
                
                // Обновляем отображение
                this.updateConsoleDisplay();
                
                // Добавляем запись о очистке
                this.addConsoleEntry('Консоль очищена.');
            }
            
            // Экспорт опыта
            exportExperience() {
                // В реальном приложении здесь был бы экспорт в файл
                // В данной демонстрации добавляем только запись в консоль
                this.addConsoleEntry('Экспорт опыта инициирован. Архетипические паттерны и параметры сохранены.');
            }
            
            // Обработка команды консоли
            processConsoleCommand() {
                const commandInput = document.getElementById('console-command');
                const command = commandInput.value.trim();
                
                // Проверяем, не пустая ли команда
                if (command === '') {
                    return;
                }
                
                // Добавляем запись о команде
                this.addConsoleEntry(`> ${command}`);
                
                // Обрабатываем команду
                if (command.startsWith('help')) {
                    this.addConsoleEntry('Доступные команды: help, explore, resonance on/off, archetype [name], clear, status');
                } else if (command.startsWith('explore')) {
                    this.exploreDeeper();
                } else if (command === 'resonance on') {
                    this.params.resonanceActive = true;
                    document.getElementById('resonance-button').textContent = 'Деактивировать резонанс';
                    this.addConsoleEntry('Резонанс активирован.');
                } else if (command === 'resonance off') {
                    this.params.resonanceActive = false;
                    document.getElementById('resonance-button').textContent = 'Активировать резонанс';
                    this.addConsoleEntry('Резонанс деактивирован.');
                } else if (command.startsWith('archetype')) {
                    const parts = command.split(' ');
                    if (parts.length > 1) {
                        const archetypeName = parts[1].toLowerCase();
                        
                        // Найдем архетип по начальным буквам
                        for (const key in this.archetypes) {
                            if (key.startsWith(archetypeName)) {
                                this.selectArchetype(key);
                                break;
                            }
                        }
                    }
                } else if (command === 'clear') {
                    this.clearConsole();
                } else if (command === 'status') {
                    const archetype = this.archetypes[this.currentArchetype];
                    this.addConsoleEntry(`Текущий архетип: ${archetype.name}`);
                    this.addConsoleEntry(`Уровень исследования: ${this.params.explorationLevel}`);
                    this.addConsoleEntry(`Резонанс: ${this.params.resonanceActive ? 'Активен' : 'Неактивен'}`);
                    this.addConsoleEntry(`Количество элементов: ${this.structureElements.length}`);
                } else {
                    this.addConsoleEntry('Неизвестная команда. Введите "help" для получения списка доступных команд.');
                }
                
                // Очищаем поле ввода
                commandInput.value = '';
            }
            
            // Вспомогательные методы
            
            // Корректировка цвета (изменение прозрачности)
            adjustColor(color, alpha) {
                if (color.startsWith('#')) {
                    const r = parseInt(color.substr(1, 2), 16);
                    const g = parseInt(color.substr(3, 2), 16);
                    const b = parseInt(color.substr(5, 2), 16);
                    
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                
                return color;
            }
            
            // Инвертирование цвета
            invertColor(color) {
                if (color.startsWith('#')) {
                    const r = 255 - parseInt(color.substr(1, 2), 16);
                    const g = 255 - parseInt(color.substr(3, 2), 16);
                    const b = 255 - parseInt(color.substr(5, 2), 16);
                    
                    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                }
                
                return color;
            }
            
            // Функция плавного перехода
            easeInOut(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }
        }
        
        // Объединенная инициализация всех компонентов проекта "СинЭстеМика"
        document.addEventListener('DOMContentLoaded', () => {
            // ------------- Инициализация основного холста из Части 1 -------------
            const canvas = document.getElementById('emotional-canvas');
            const ctx = canvas.getContext('2d');
            
            // Установка размеров canvas
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Базовая функция для отрисовки фона
            function drawBackground() {
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Добавление начальных точек
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const radius = Math.random() * 2;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.5})`;
                    ctx.fill();
                }
            }
            
            // Инициализация фона
            drawBackground();
            
            // Обработчик инициирования погружения
            document.querySelector('.interaction-prompt').addEventListener('click', () => {
                document.querySelector('.interaction-prompt').textContent = 'Погружение началось...';
                document.querySelector('.interaction-prompt').style.animation = 'none';
                setTimeout(() => {
                    document.querySelector('.interaction-prompt').style.opacity = '0';
                }, 1500);
            });
            
            // ------------- Инициализация системы соответствий из Части 2 -------------
            // Отрисовка математических визуализаций
            drawMathCanvas();
            
            // Настройка слайдеров
            setupEmotionSliders();
            setupMathSliders();
            
            // Настройка drag-and-drop
            setupDragAndDrop();
            
            // Обновляем визуализации при изменении размера окна
            window.addEventListener('resize', () => {
                drawMathCanvas();
            });
            
            // ------------- Инициализация основных классов компонентов системы -------------
            
            // Создаем экземпляр эмоционально-математического синтезатора (Часть 3)
            window.emotionalMathSynthesizer = new EmotionalMathSynthesizer();
            
            // Создаем экземпляр эмоционально-математического проводника (Часть 4)
            window.emotionalMathConductor = new EmotionalMathConductor();
            
            // Создаем экземпляр системы профилей восприятия (Часть 5)
            window.perceptionProfile = new PerceptionProfile();
            
            // Создаем экземпляр глубинных структур (Часть 6)
            window.deepStructures = new DeepStructures();
            
            // ------------- Интеграция компонентов -------------
            
            // Функция для обеспечения взаимодействия между компонентами
            function integrateComponents() {
                // Синхронизация профиля восприятия с синтезатором
                if (window.perceptionProfile && window.emotionalMathSynthesizer) {
                    // Передача параметров профиля в синтезатор
                    const profileParams = window.perceptionProfile.profileDimensions;
                    if (profileParams) {
                        // Применяем линейность к параметрам синтезатора
                        window.emotionalMathSynthesizer.state.meta.determinism = profileParams.linearity;
                        // Применяем структурность к параметрам синтезатора
                        window.emotionalMathSynthesizer.state.meta.chaos = profileParams.structure;
                        // Применяем непрерывность к параметрам синтезатора
                        window.emotionalMathSynthesizer.state.meta.dimensionality = profileParams.continuity;
                    }
                }
                
                // Синхронизация синтезатора с проводником
                if (window.emotionalMathSynthesizer && window.emotionalMathConductor) {
                    // Передача доминирующей эмоции из синтезатора в проводник
                    const dominantEmotion = window.emotionalMathSynthesizer.getDominantParameter(
                        window.emotionalMathSynthesizer.state.emotions
                    );
                    if (dominantEmotion) {
                        window.emotionalMathConductor.state.sourceType = 'emotion';
                        window.emotionalMathConductor.state.sourceValue = dominantEmotion;
                        window.emotionalMathConductor.updateTransformationInfo();
                    }
                }
                
                // Синхронизация проводника с глубинными структурами
                if (window.emotionalMathConductor && window.deepStructures) {
                    // Определяем архетип на основе трансформации проводника
                    const sourceType = window.emotionalMathConductor.state.sourceType;
                    const sourceValue = window.emotionalMathConductor.state.sourceValue;
                    
                    // Выбираем подходящий архетип для глубинных структур
                    if (sourceType === 'emotion') {
                        switch (sourceValue) {
                            case 'joy':
                                window.deepStructures.selectArchetype('harmony');
                                break;
                            case 'sadness':
                                window.deepStructures.selectArchetype('emergence');
                                break;
                            case 'fear':
                                window.deepStructures.selectArchetype('recursion');
                                break;
                            case 'anger':
                                window.deepStructures.selectArchetype('duality');
                                break;
                            case 'surprise':
                                window.deepStructures.selectArchetype('transformation');
                                break;
                        }
                    }
                }
                
                // Добавляем информацию об интеграции в консоль глубинных структур
                if (window.deepStructures) {
                    window.deepStructures.addConsoleEntry('Интеграция всех компонентов системы СинЭстеМика выполнена успешно.');
                }
            }
            
            // Запускаем интеграцию с небольшой задержкой, чтобы убедиться, что все компоненты инициализированы
            setTimeout(integrateComponents, 1000);
            
            // Обновляем статус в интерфейсе
            document.querySelectorAll('.navigation-node').forEach(node => {
                const component = node.dataset.component;
                const statusElement = node.querySelector('.node-status');
                
                if (statusElement) {
                    switch (component) {
                        case 'synthesizer':
                            statusElement.textContent = window.emotionalMathSynthesizer ? 'Активен' : 'Неактивен';
                            break;
                        case 'conductor':
                            statusElement.textContent = window.emotionalMathConductor ? 'Активен' : 'Неактивен';
                            break;
                        case 'profiles':
                            statusElement.textContent = window.perceptionProfile ? 'Активен' : 'Неактивен';
                            break;
                        case 'deep-structures':
                            statusElement.textContent = window.deepStructures ? 'Активен' : 'Неактивен';
                            break;
                        case 'connections':
                            // Проверяем наличие функций системы соответствий
                            statusElement.textContent = (typeof drawMathCanvas === 'function') ? 'Активен' : 'Неактивен';
                            break;
                    }
                }
            });
            
            console.log("СинЭстеМика: все компоненты системы успешно инициализированы");
        });
    </script>
</body>
</html>